exports.id = 4374;
exports.ids = [4374];
exports.modules = {

/***/ 21809:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addLeadingZeros;
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = '0' + output;
  }
  return sign + output;
}
module.exports = exports.default;

/***/ }),

/***/ 38177:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = assign;
function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      ;
      target[property] = object[property];
    }
  }
  return target;
}
module.exports = exports.default;

/***/ }),

/***/ 50941:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = cloneObject;
var _index = _interopRequireDefault(__webpack_require__(38177));
function cloneObject(object) {
  return (0, _index.default)({}, object);
}
module.exports = exports.default;

/***/ }),

/***/ 67030:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(37703));
var _default = _index.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 30596:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getDefaultOptions = getDefaultOptions;
exports.setDefaultOptions = setDefaultOptions;
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}

/***/ }),

/***/ 14481:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(11566));
var _index2 = _interopRequireDefault(__webpack_require__(28022));
var _index3 = _interopRequireDefault(__webpack_require__(68783));
var _index4 = _interopRequireDefault(__webpack_require__(5957));
var _index5 = _interopRequireDefault(__webpack_require__(28465));
var _index6 = _interopRequireDefault(__webpack_require__(21809));
var _index7 = _interopRequireDefault(__webpack_require__(941));
var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B
      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ
      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }
    return _index7.default.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = (0, _index5.default)(date, options);
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

    // Two digit year
    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return (0, _index6.default)(twoDigitYear, 2);
    }

    // Ordinal number
    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    }

    // Padding
    return (0, _index6.default)(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = (0, _index3.default)(date);

    // Padding
    return (0, _index6.default)(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return (0, _index6.default)(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04
      case 'QQ':
        return (0, _index6.default)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4
      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...
      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04
      case 'qq':
        return (0, _index6.default)(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4
      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...
      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();
    switch (token) {
      case 'M':
      case 'MM':
        return _index7.default.M(date, token);
      // 1st, 2nd, ..., 12th
      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec
      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D
      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December
      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();
    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12
      case 'LL':
        return (0, _index6.default)(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec
      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D
      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December
      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = (0, _index4.default)(date, options);
    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }
    return (0, _index6.default)(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = (0, _index2.default)(date);
    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }
    return (0, _index6.default)(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }
    return _index7.default.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = (0, _index.default)(date);
    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }
    return (0, _index6.default)(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T
      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu
      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday
      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value
      case 'ee':
        return (0, _index6.default)(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });
      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T
      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu
      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday
      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value
      case 'cc':
        return (0, _index6.default)(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });
      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T
      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu
      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday
      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02
      case 'ii':
        return (0, _index6.default)(isoDayOfWeek, token.length);
      // 2nd
      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue
      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T
      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu
      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday
      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });
      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();
      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });
      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }
    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });
      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();
      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });
      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });
      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });
      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }
    return _index7.default.h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }
    return _index7.default.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;
    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }
    return (0, _index6.default)(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;
    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }
    return (0, _index6.default)(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }
    return _index7.default.m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }
    return _index7.default.s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return _index7.default.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return 'Z';
    }
    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);

      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);

      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long
      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long
      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return (0, _index6.default)(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return (0, _index6.default)(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
  var minutes = (0, _index6.default)(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var _default = formatters;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 941:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(21809));
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    var signedYear = date.getUTCFullYear();
    // Returns 1 for 1 BC (which is year 0 in JavaScript)
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0, _index.default)(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : (0, _index.default)(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return (0, _index.default)(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();
      case 'aaa':
        return dayPeriodEnumValue;
      case 'aaaaa':
        return dayPeriodEnumValue[0];
      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return (0, _index.default)(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return (0, _index.default)(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return (0, _index.default)(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return (0, _index.default)(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return (0, _index.default)(fractionalSeconds, token.length);
  }
};
var _default = formatters;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 74049:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });
    case 'PP':
      return formatLong.date({
        width: 'medium'
      });
    case 'PPP':
      return formatLong.date({
        width: 'long'
      });
    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};
var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });
    case 'pp':
      return formatLong.time({
        width: 'medium'
      });
    case 'ppp':
      return formatLong.time({
        width: 'long'
      });
    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;
    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;
    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;
    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }
  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var _default = longFormatters;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 10944:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getTimezoneOffsetInMilliseconds;
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 11566:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getUTCDayOfYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 28022:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getUTCISOWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(12246));
var _index3 = _interopRequireDefault(__webpack_require__(72399));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;
function getUTCISOWeek(dirtyDate) {
  (0, _index4.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var diff = (0, _index2.default)(date).getTime() - (0, _index3.default)(date).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 68783:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getUTCISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(12246));
function getUTCISOWeekYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 5957:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getUTCWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(97968));
var _index3 = _interopRequireDefault(__webpack_require__(35864));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  (0, _index4.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var diff = (0, _index2.default)(date, options).getTime() - (0, _index3.default)(date, options).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 28465:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getUTCWeekYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(97968));
var _index4 = _interopRequireDefault(__webpack_require__(50687));
var _index5 = __webpack_require__(30596);
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = (0, _index5.getDefaultOptions)();
  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 31374:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
exports.throwProtectedError = throwProtectedError;
var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

/***/ }),

/***/ 37716:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = requiredArgs;
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}
module.exports = exports.default;

/***/ }),

/***/ 43010:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getRoundingMethod = getRoundingMethod;
var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function trunc(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  } // Math.trunc is not supported by IE
};

var defaultRoundingMethod = 'trunc';
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}

/***/ }),

/***/ 65275:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setUTCDay;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = __webpack_require__(30596);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index2.default)(2, arguments);
  var defaultOptions = (0, _index4.getDefaultOptions)();
  var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = (0, _index.default)(dirtyDate);
  var day = (0, _index3.default)(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 18385:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setUTCISODay;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
function setUTCISODay(dirtyDate, dirtyDay) {
  (0, _index2.default)(2, arguments);
  var day = (0, _index3.default)(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = (0, _index.default)(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 6622:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setUTCISOWeek;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(28022));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  (0, _index4.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var isoWeek = (0, _index.default)(dirtyISOWeek);
  var diff = (0, _index3.default)(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 89369:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setUTCWeek;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(5957));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  (0, _index4.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var week = (0, _index.default)(dirtyWeek);
  var diff = (0, _index3.default)(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 12246:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfUTCISOWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
function startOfUTCISOWeek(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var weekStartsOn = 1;
  var date = (0, _index.default)(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 72399:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfUTCISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(68783));
var _index2 = _interopRequireDefault(__webpack_require__(12246));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
function startOfUTCISOWeekYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var year = (0, _index.default)(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = (0, _index2.default)(fourthOfJanuary);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 97968:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfUTCWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = __webpack_require__(30596);
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index2.default)(1, arguments);
  var defaultOptions = (0, _index4.getDefaultOptions)();
  var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = (0, _index.default)(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 35864:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfUTCWeekYear;
var _index = _interopRequireDefault(__webpack_require__(28465));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(97968));
var _index4 = _interopRequireDefault(__webpack_require__(50687));
var _index5 = __webpack_require__(30596);
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index2.default)(1, arguments);
  var defaultOptions = (0, _index5.getDefaultOptions)();
  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = (0, _index.default)(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = (0, _index3.default)(firstWeek, options);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 50687:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = toInteger;
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
module.exports = exports.default;

/***/ }),

/***/ 49639:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = add;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(83530));
var _index2 = _interopRequireDefault(__webpack_require__(86069));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var _index5 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name add
 * @category Common Helpers
 * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @description
 * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 *
 * | Key            | Description                        |
 * |----------------|------------------------------------|
 * | years          | Amount of years to be added        |
 * | months         | Amount of months to be added       |
 * | weeks          | Amount of weeks to be added        |
 * | days           | Amount of days to be added         |
 * | hours          | Amount of hours to be added        |
 * | minutes        | Amount of minutes to be added      |
 * | seconds        | Amount of seconds to be added      |
 *
 * All values default to 0
 *
 * @returns {Date} the new date with the seconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add the following duration to 1 September 2014, 10:19:50
 * const result = add(new Date(2014, 8, 1, 10, 19, 50), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30,
 * })
 * //=> Thu Jun 15 2017 15:29:20
 */
function add(dirtyDate, duration) {
  (0, _index4.default)(2, arguments);
  if (!duration || (0, _typeof2.default)(duration) !== 'object') return new Date(NaN);
  var years = duration.years ? (0, _index5.default)(duration.years) : 0;
  var months = duration.months ? (0, _index5.default)(duration.months) : 0;
  var weeks = duration.weeks ? (0, _index5.default)(duration.weeks) : 0;
  var days = duration.days ? (0, _index5.default)(duration.days) : 0;
  var hours = duration.hours ? (0, _index5.default)(duration.hours) : 0;
  var minutes = duration.minutes ? (0, _index5.default)(duration.minutes) : 0;
  var seconds = duration.seconds ? (0, _index5.default)(duration.seconds) : 0;

  // Add years and months
  var date = (0, _index3.default)(dirtyDate);
  var dateWithMonths = months || years ? (0, _index2.default)(date, months + years * 12) : date;

  // Add weeks and days
  var dateWithDays = days || weeks ? (0, _index.default)(dateWithMonths, days + weeks * 7) : dateWithMonths;

  // Add days, hours, minutes and seconds
  var minutesToAdd = minutes + hours * 60;
  var secondsToAdd = seconds + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1000;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}
module.exports = exports.default;

/***/ }),

/***/ 42975:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addBusinessDays;
var _index = _interopRequireDefault(__webpack_require__(31125));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var _index5 = _interopRequireDefault(__webpack_require__(43889));
var _index6 = _interopRequireDefault(__webpack_require__(85104));
/**
 * @name addBusinessDays
 * @category Day Helpers
 * @summary Add the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Add the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of business days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the business days added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 10 business days to 1 September 2014:
 * const result = addBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Sep 15 2014 00:00:00 (skipped weekend days)
 */
function addBusinessDays(dirtyDate, dirtyAmount) {
  (0, _index4.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var startedOnWeekend = (0, _index.default)(date);
  var amount = (0, _index3.default)(dirtyAmount);
  if (isNaN(amount)) return new Date(NaN);
  var hours = date.getHours();
  var sign = amount < 0 ? -1 : 1;
  var fullWeeks = (0, _index3.default)(amount / 5);
  date.setDate(date.getDate() + fullWeeks * 7);

  // Get remaining days not part of a full week
  var restDays = Math.abs(amount % 5);

  // Loops over remaining days
  while (restDays > 0) {
    date.setDate(date.getDate() + sign);
    if (!(0, _index.default)(date)) restDays -= 1;
  }

  // If the date is a weekend day and we reduce a dividable of
  // 5 from it, we land on a weekend date.
  // To counter this, we add days accordingly to land on the next business day
  if (startedOnWeekend && (0, _index.default)(date) && amount !== 0) {
    // If we're reducing days, we want to add days until we land on a weekday
    // If we're adding days we want to reduce days until we land on a weekday
    if ((0, _index6.default)(date)) date.setDate(date.getDate() + (sign < 0 ? 2 : -1));
    if ((0, _index5.default)(date)) date.setDate(date.getDate() + (sign < 0 ? 1 : -2));
  }

  // Restore hours to avoid DST lag
  date.setHours(hours);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 83530:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addDays;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */
function addDays(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var amount = (0, _index.default)(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 43462:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addHours;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(11098));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_HOUR = 3600000;

/**
 * @name addHours
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of hours to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the hours added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */
function addHours(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
module.exports = exports.default;

/***/ }),

/***/ 17006:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addISOWeekYears;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(6874));
var _index3 = _interopRequireDefault(__webpack_require__(75574));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Add the specified number of ISO week-numbering years to the given date.
 *
 * @description
 * Add the specified number of ISO week-numbering years to the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of ISO week-numbering years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the ISO week-numbering years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 ISO week-numbering years to 2 July 2010:
 * const result = addISOWeekYears(new Date(2010, 6, 2), 5)
 * //=> Fri Jun 26 2015 00:00:00
 */
function addISOWeekYears(dirtyDate, dirtyAmount) {
  (0, _index4.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index3.default)(dirtyDate, (0, _index2.default)(dirtyDate) + amount);
}
module.exports = exports.default;

/***/ }),

/***/ 11098:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */
function addMilliseconds(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var timestamp = (0, _index2.default)(dirtyDate).getTime();
  var amount = (0, _index.default)(dirtyAmount);
  return new Date(timestamp + amount);
}
module.exports = exports.default;

/***/ }),

/***/ 98958:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addMinutes;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(11098));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_MINUTE = 60000;

/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the minutes added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */
function addMinutes(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
module.exports = exports.default;

/***/ }),

/***/ 86069:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addMonths;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */
function addMonths(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var amount = (0, _index.default)(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }
  var dayOfMonth = date.getDate();

  // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 75633:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addQuarters;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(86069));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addQuarters
 * @category Quarter Helpers
 * @summary Add the specified number of year quarters to the given date.
 *
 * @description
 * Add the specified number of year quarters to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of quarters to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the quarters added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 1 quarter to 1 September 2014:
 * const result = addQuarters(new Date(2014, 8, 1), 1)
 * //=> Mon Dec 01 2014 00:00:00
 */
function addQuarters(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  var months = amount * 3;
  return (0, _index2.default)(dirtyDate, months);
}
module.exports = exports.default;

/***/ }),

/***/ 87344:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addSeconds;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(11098));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the seconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */
function addSeconds(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, amount * 1000);
}
module.exports = exports.default;

/***/ }),

/***/ 11237:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addWeeks;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(83530));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */
function addWeeks(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  var days = amount * 7;
  return (0, _index2.default)(dirtyDate, days);
}
module.exports = exports.default;

/***/ }),

/***/ 66291:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = addYears;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(86069));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */
function addYears(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, amount * 12);
}
module.exports = exports.default;

/***/ }),

/***/ 17814:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = areIntervalsOverlapping;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name areIntervalsOverlapping
 * @category Interval Helpers
 * @summary Is the given time interval overlapping with another time interval?
 *
 * @description
 * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping.
 *
 * @param {Interval} intervalLeft - the first interval to compare. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Interval} intervalRight - the second interval to compare. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Object} [options] - the object with options
 * @param {Boolean} [options.inclusive=false] - whether the comparison is inclusive or not
 * @returns {Boolean} whether the time intervals are overlapping
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // For overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> true
 *
 * @example
 * // For non-overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> false
 *
 * @example
 * // For adjacent time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }
 * )
 * //=> false
 *
 * @example
 * // Using the inclusive option:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }
 * )
 * //=> false
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },
 *   { inclusive: true }
 * )
 * //=> true
 */
function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
  (0, _index2.default)(2, arguments);
  var leftStartTime = (0, _index.default)(intervalLeft === null || intervalLeft === void 0 ? void 0 : intervalLeft.start).getTime();
  var leftEndTime = (0, _index.default)(intervalLeft === null || intervalLeft === void 0 ? void 0 : intervalLeft.end).getTime();
  var rightStartTime = (0, _index.default)(intervalRight === null || intervalRight === void 0 ? void 0 : intervalRight.start).getTime();
  var rightEndTime = (0, _index.default)(intervalRight === null || intervalRight === void 0 ? void 0 : intervalRight.end).getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
    throw new RangeError('Invalid interval');
  }
  if (options !== null && options !== void 0 && options.inclusive) {
    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;
  }
  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
}
module.exports = exports.default;

/***/ }),

/***/ 96050:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = clamp;
var _index = _interopRequireDefault(__webpack_require__(374));
var _index2 = _interopRequireDefault(__webpack_require__(32131));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name clamp
 * @category Interval Helpers
 * @summary Return a date bounded by the start and the end of the given interval
 *
 * @description
 * Clamps a date to the lower bound with the start of the interval and the upper
 * bound with the end of the interval.
 *
 * - When the date is less than the start of the interval, the start is returned.
 * - When the date is greater than the end of the interval, the end is returned.
 * - Otherwise the date is returned.
 *
 * @example
 * // What is Mar, 21, 2021 bounded to an interval starting at Mar, 22, 2021 and ending at Apr, 01, 2021
 * const result = clamp(new Date(2021, 2, 21), {
 *   start: new Date(2021, 2, 22),
 *   end: new Date(2021, 3, 1),
 * })
 * //=> Mon Mar 22 2021 00:00:00
 *
 * @param {Date | Number} date - the date to be bounded
 * @param {Interval} interval - the interval to bound to
 * @returns {Date} the date bounded by the start and the end of the interval
 * @throws {TypeError} 2 arguments required
 */
function clamp(date, _ref) {
  var start = _ref.start,
    end = _ref.end;
  (0, _index3.default)(2, arguments);
  return (0, _index2.default)([(0, _index.default)([date, start]), end]);
}
module.exports = exports.default;

/***/ }),

/***/ 48557:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = closestIndexTo;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name closestIndexTo
 * @category Common Helpers
 * @summary Return an index of the closest date from the array comparing to the given date.
 *
 * @description
 * Return an index of the closest date from the array comparing to the given date.
 *
 * @param {Date | Number} dateToCompare - the date to compare with
 * @param {Array<Date> | Array<number>} datesArray - the array to search
 * @returns {Number | undefined} an index of the date closest to the given date or undefined if no valid value is given
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Which date is closer to 6 September 2015?
 * const dateToCompare = new Date(2015, 8, 6)
 * const datesArray = [
 *   new Date(2015, 0, 1),
 *   new Date(2016, 0, 1),
 *   new Date(2017, 0, 1)
 * ]
 * const result = closestIndexTo(dateToCompare, datesArray)
 * //=> 1
 */
function closestIndexTo(dirtyDateToCompare, dirtyDatesArray) {
  (0, _index2.default)(2, arguments);
  var dateToCompare = (0, _index.default)(dirtyDateToCompare);
  if (isNaN(Number(dateToCompare))) return NaN;
  var timeToCompare = dateToCompare.getTime();
  var datesArray;
  // `dirtyDatesArray` is undefined or null
  if (dirtyDatesArray == null) {
    datesArray = [];

    // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method
  } else if (typeof dirtyDatesArray.forEach === 'function') {
    datesArray = dirtyDatesArray;

    // If `dirtyDatesArray` is Array-like Object, convert to Array. Otherwise, make it empty Array
  } else {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  }
  var result;
  var minDistance;
  datesArray.forEach(function (dirtyDate, index) {
    var currentDate = (0, _index.default)(dirtyDate);
    if (isNaN(Number(currentDate))) {
      result = NaN;
      minDistance = NaN;
      return;
    }
    var distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < Number(minDistance)) {
      result = index;
      minDistance = distance;
    }
  });
  return result;
}
module.exports = exports.default;

/***/ }),

/***/ 7215:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = closestTo;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name closestTo
 * @category Common Helpers
 * @summary Return a date from the array closest to the given date.
 *
 * @description
 * Return a date from the array closest to the given date.
 *
 * @param {Date | Number} dateToCompare - the date to compare with
 * @param {Array<Date> | Array<number>} datesArray - the array to search
 * @returns {Date | undefined} the date from the array closest to the given date or undefined if no valid value is given
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Which date is closer to 6 September 2015: 1 January 2000 or 1 January 2030?
 * const dateToCompare = new Date(2015, 8, 6)
 * const result = closestTo(dateToCompare, [
 *   new Date(2000, 0, 1),
 *   new Date(2030, 0, 1)
 * ])
 * //=> Tue Jan 01 2030 00:00:00
 */
function closestTo(dirtyDateToCompare, dirtyDatesArray) {
  (0, _index2.default)(2, arguments);
  var dateToCompare = (0, _index.default)(dirtyDateToCompare);
  if (isNaN(Number(dateToCompare))) return new Date(NaN);
  var timeToCompare = dateToCompare.getTime();
  var datesArray;
  // `dirtyDatesArray` is undefined or null
  if (dirtyDatesArray == null) {
    datesArray = [];

    // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method
  } else if (typeof dirtyDatesArray.forEach === 'function') {
    datesArray = dirtyDatesArray;

    // If `dirtyDatesArray` is Array-like Object, convert to Array. Otherwise, make it empty Array
  } else {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  }
  var result;
  var minDistance;
  datesArray.forEach(function (dirtyDate) {
    var currentDate = (0, _index.default)(dirtyDate);
    if (isNaN(Number(currentDate))) {
      result = new Date(NaN);
      minDistance = NaN;
      return;
    }
    var distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < Number(minDistance)) {
      result = currentDate;
      minDistance = distance;
    }
  });
  return result;
}
module.exports = exports.default;

/***/ }),

/***/ 74876:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = compareAsc;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 93711:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = compareDesc;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name compareDesc
 * @category Common Helpers
 * @summary Compare the two dates reverse chronologically and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return -1 if the first date is after the second,
 * 1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989 reverse chronologically:
 * const result = compareDesc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> 1
 *
 * @example
 * // Sort the array of dates in reverse chronological order:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareDesc)
 * //=> [
 * //   Sun Jul 02 1995 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Wed Feb 11 1987 00:00:00
 * // ]
 */
function compareDesc(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff > 0) {
    return -1;
  } else if (diff < 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 53372:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.secondsInYear = exports.secondsInWeek = exports.secondsInQuarter = exports.secondsInMonth = exports.secondsInMinute = exports.secondsInHour = exports.secondsInDay = exports.quartersInYear = exports.monthsInYear = exports.monthsInQuarter = exports.minutesInHour = exports.minTime = exports.millisecondsInSecond = exports.millisecondsInMinute = exports.millisecondsInHour = exports.maxTime = exports.daysInYear = exports.daysInWeek = void 0;
/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
var daysInWeek = 7;

/**
 * Days in 1 year
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * @name daysInYear
 * @constant
 * @type {number}
 * @default
 */
exports.daysInWeek = daysInWeek;
var daysInYear = 365.2425;

/**
 * Maximum allowed time.
 *
 * @name maxTime
 * @constant
 * @type {number}
 * @default
 */
exports.daysInYear = daysInYear;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;

/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */
exports.maxTime = maxTime;
var millisecondsInMinute = 60000;

/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */
exports.millisecondsInMinute = millisecondsInMinute;
var millisecondsInHour = 3600000;

/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */
exports.millisecondsInHour = millisecondsInHour;
var millisecondsInSecond = 1000;

/**
 * Minimum allowed time.
 *
 * @name minTime
 * @constant
 * @type {number}
 * @default
 */
exports.millisecondsInSecond = millisecondsInSecond;
var minTime = -maxTime;

/**
 * Minutes in 1 hour
 *
 * @name minutesInHour
 * @constant
 * @type {number}
 * @default
 */
exports.minTime = minTime;
var minutesInHour = 60;

/**
 * Months in 1 quarter
 *
 * @name monthsInQuarter
 * @constant
 * @type {number}
 * @default
 */
exports.minutesInHour = minutesInHour;
var monthsInQuarter = 3;

/**
 * Months in 1 year
 *
 * @name monthsInYear
 * @constant
 * @type {number}
 * @default
 */
exports.monthsInQuarter = monthsInQuarter;
var monthsInYear = 12;

/**
 * Quarters in 1 year
 *
 * @name quartersInYear
 * @constant
 * @type {number}
 * @default
 */
exports.monthsInYear = monthsInYear;
var quartersInYear = 4;

/**
 * Seconds in 1 hour
 *
 * @name secondsInHour
 * @constant
 * @type {number}
 * @default
 */
exports.quartersInYear = quartersInYear;
var secondsInHour = 3600;

/**
 * Seconds in 1 minute
 *
 * @name secondsInMinute
 * @constant
 * @type {number}
 * @default
 */
exports.secondsInHour = secondsInHour;
var secondsInMinute = 60;

/**
 * Seconds in 1 day
 *
 * @name secondsInDay
 * @constant
 * @type {number}
 * @default
 */
exports.secondsInMinute = secondsInMinute;
var secondsInDay = secondsInHour * 24;

/**
 * Seconds in 1 week
 *
 * @name secondsInWeek
 * @constant
 * @type {number}
 * @default
 */
exports.secondsInDay = secondsInDay;
var secondsInWeek = secondsInDay * 7;

/**
 * Seconds in 1 year
 *
 * @name secondsInYear
 * @constant
 * @type {number}
 * @default
 */
exports.secondsInWeek = secondsInWeek;
var secondsInYear = secondsInDay * daysInYear;

/**
 * Seconds in 1 month
 *
 * @name secondsInMonth
 * @constant
 * @type {number}
 * @default
 */
exports.secondsInYear = secondsInYear;
var secondsInMonth = secondsInYear / 12;

/**
 * Seconds in 1 quarter
 *
 * @name secondsInQuarter
 * @constant
 * @type {number}
 * @default
 */
exports.secondsInMonth = secondsInMonth;
var secondsInQuarter = secondsInMonth * 3;
exports.secondsInQuarter = secondsInQuarter;

/***/ }),

/***/ 17911:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = daysToWeeks;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name daysToWeeks
 * @category Conversion Helpers
 * @summary Convert days to weeks.
 *
 * @description
 * Convert a number of days to a full number of weeks.
 *
 * @param {number} days - number of days to be converted
 *
 * @returns {number} the number of days converted in weeks
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 14 days to weeks:
 * const result = daysToWeeks(14)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = daysToWeeks(13)
 * //=> 1
 */
function daysToWeeks(days) {
  (0, _index.default)(1, arguments);
  var weeks = days / _index2.daysInWeek;
  return Math.floor(weeks);
}
module.exports = exports.default;

/***/ }),

/***/ 36630:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInBusinessDays;
var _index = _interopRequireDefault(__webpack_require__(83530));
var _index2 = _interopRequireDefault(__webpack_require__(64618));
var _index3 = _interopRequireDefault(__webpack_require__(95795));
var _index4 = _interopRequireDefault(__webpack_require__(92401));
var _index5 = _interopRequireDefault(__webpack_require__(31125));
var _index6 = _interopRequireDefault(__webpack_require__(70107));
var _index7 = _interopRequireDefault(__webpack_require__(37716));
var _index8 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name differenceInBusinessDays
 * @category Day Helpers
 * @summary Get the number of business days between the given dates.
 *
 * @description
 * Get the number of business day periods between the given dates.
 * Business days being days that arent in the weekend.
 * Like `differenceInCalendarDays`, the function removes the times from
 * the dates before calculating the difference.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of business days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many business days are between
 * // 10 January 2014 and 20 July 2014?
 * const result = differenceInBusinessDays(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 0, 10)
 * )
 * //=> 136
 *
 * // How many business days are between
 * // 30 November 2021 and 1 November 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 30),
 *   new Date(2021, 10, 1)
 * )
 * //=> 21
 *
 * // How many business days are between
 * // 1 November 2021 and 1 December 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 11, 1)
 * )
 * //=> -22
 *
 * // How many business days are between
 * // 1 November 2021 and 1 November 2021 ?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 10, 1)
 * )
 * //=> 0
 */
function differenceInBusinessDays(dirtyDateLeft, dirtyDateRight) {
  (0, _index7.default)(2, arguments);
  var dateLeft = (0, _index6.default)(dirtyDateLeft);
  var dateRight = (0, _index6.default)(dirtyDateRight);
  if (!(0, _index4.default)(dateLeft) || !(0, _index4.default)(dateRight)) return NaN;
  var calendarDifference = (0, _index2.default)(dateLeft, dateRight);
  var sign = calendarDifference < 0 ? -1 : 1;
  var weeks = (0, _index8.default)(calendarDifference / 7);
  var result = weeks * 5;
  dateRight = (0, _index.default)(dateRight, weeks * 7);

  // the loop below will run at most 6 times to account for the remaining days that don't makeup a full week
  while (!(0, _index3.default)(dateLeft, dateRight)) {
    // sign is used to account for both negative and positive differences
    result += (0, _index5.default)(dateRight) ? 0 : sign;
    dateRight = (0, _index.default)(dateRight, sign);
  }
  return result === 0 ? 0 : result;
}
module.exports = exports.default;

/***/ }),

/***/ 64618:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarDays;
var _index = _interopRequireDefault(__webpack_require__(10944));
var _index2 = _interopRequireDefault(__webpack_require__(87597));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_DAY = 86400000;

/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  (0, _index3.default)(2, arguments);
  var startOfDayLeft = (0, _index2.default)(dirtyDateLeft);
  var startOfDayRight = (0, _index2.default)(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - (0, _index.default)(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - (0, _index.default)(startOfDayRight);

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}
module.exports = exports.default;

/***/ }),

/***/ 67507:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarISOWeekYears;
var _index = _interopRequireDefault(__webpack_require__(6874));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInCalendarISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of calendar ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of calendar ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar ISO week-numbering years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar ISO week-numbering years are 1 January 2010 and 1 January 2012?
 * const result = differenceInCalendarISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 2
 */
function differenceInCalendarISOWeekYears(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  return (0, _index.default)(dirtyDateLeft) - (0, _index.default)(dirtyDateRight);
}
module.exports = exports.default;

/***/ }),

/***/ 53428:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarISOWeeks;
var _index = _interopRequireDefault(__webpack_require__(10944));
var _index2 = _interopRequireDefault(__webpack_require__(38674));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;

/**
 * @name differenceInCalendarISOWeeks
 * @category ISO Week Helpers
 * @summary Get the number of calendar ISO weeks between the given dates.
 *
 * @description
 * Get the number of calendar ISO weeks between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar ISO weeks
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar ISO weeks are between 6 July 2014 and 21 July 2014?
 * const result = differenceInCalendarISOWeeks(
 *   new Date(2014, 6, 21),
 *   new Date(2014, 6, 6)
 * )
 * //=> 3
 */
function differenceInCalendarISOWeeks(dirtyDateLeft, dirtyDateRight) {
  (0, _index3.default)(2, arguments);
  var startOfISOWeekLeft = (0, _index2.default)(dirtyDateLeft);
  var startOfISOWeekRight = (0, _index2.default)(dirtyDateRight);
  var timestampLeft = startOfISOWeekLeft.getTime() - (0, _index.default)(startOfISOWeekLeft);
  var timestampRight = startOfISOWeekRight.getTime() - (0, _index.default)(startOfISOWeekRight);

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
}
module.exports = exports.default;

/***/ }),

/***/ 86223:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarMonths;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
module.exports = exports.default;

/***/ }),

/***/ 41222:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarQuarters;
var _index = _interopRequireDefault(__webpack_require__(59164));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInCalendarQuarters
 * @category Quarter Helpers
 * @summary Get the number of calendar quarters between the given dates.
 *
 * @description
 * Get the number of calendar quarters between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar quarters
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInCalendarQuarters(
 *   new Date(2014, 6, 2),
 *   new Date(2013, 11, 31)
 * )
 * //=> 3
 */
function differenceInCalendarQuarters(dirtyDateLeft, dirtyDateRight) {
  (0, _index3.default)(2, arguments);
  var dateLeft = (0, _index2.default)(dirtyDateLeft);
  var dateRight = (0, _index2.default)(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var quarterDiff = (0, _index.default)(dateLeft) - (0, _index.default)(dateRight);
  return yearDiff * 4 + quarterDiff;
}
module.exports = exports.default;

/***/ }),

/***/ 79279:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarWeeks;
var _index = _interopRequireDefault(__webpack_require__(11790));
var _index2 = _interopRequireDefault(__webpack_require__(10944));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;

/**
 * @name differenceInCalendarWeeks
 * @category Week Helpers
 * @summary Get the number of calendar weeks between the given dates.
 *
 * @description
 * Get the number of calendar weeks between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Number} the number of calendar weeks
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // How many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5)
 * )
 * //=> 3
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5),
 *   { weekStartsOn: 1 }
 * )
 * //=> 2
 */
function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, options) {
  (0, _index3.default)(2, arguments);
  var startOfWeekLeft = (0, _index.default)(dirtyDateLeft, options);
  var startOfWeekRight = (0, _index.default)(dirtyDateRight, options);
  var timestampLeft = startOfWeekLeft.getTime() - (0, _index2.default)(startOfWeekLeft);
  var timestampRight = startOfWeekRight.getTime() - (0, _index2.default)(startOfWeekRight);

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
}
module.exports = exports.default;

/***/ }),

/***/ 75921:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInCalendarYears;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInCalendarYears
 * @category Year Helpers
 * @summary Get the number of calendar years between the given dates.
 *
 * @description
 * Get the number of calendar years between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInCalendarYears(
 *   new Date(2015, 1, 11),
 *   new Date(2013, 11, 31)
 * )
 * //=> 2
 */
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
module.exports = exports.default;

/***/ }),

/***/ 93688:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInDays;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(64618));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
// Like `compareAsc` but uses local time not UTC, which is needed
// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.
function compareLocalAsc(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
    // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full days according to the local timezone
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * const result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
//=> 92
 */
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  (0, _index3.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var sign = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign * difference);

  // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value
  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastDayNotFull);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}
module.exports = exports.default;

/***/ }),

/***/ 23815:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInHours;
var _index = __webpack_require__(53372);
var _index2 = _interopRequireDefault(__webpack_require__(86213));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var _index4 = __webpack_require__(43010);
/**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of hours
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * const result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */
function differenceInHours(dateLeft, dateRight, options) {
  (0, _index3.default)(2, arguments);
  var diff = (0, _index2.default)(dateLeft, dateRight) / _index.millisecondsInHour;
  return (0, _index4.getRoundingMethod)(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
module.exports = exports.default;

/***/ }),

/***/ 45018:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInISOWeekYears;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(67507));
var _index3 = _interopRequireDefault(__webpack_require__(74876));
var _index4 = _interopRequireDefault(__webpack_require__(11144));
var _index5 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of full ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of full ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full ISO week-numbering years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full ISO week-numbering years are between 1 January 2010 and 1 January 2012?
 * const result = differenceInISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 1
 */
function differenceInISOWeekYears(dirtyDateLeft, dirtyDateRight) {
  (0, _index5.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var sign = (0, _index3.default)(dateLeft, dateRight);
  var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
  dateLeft = (0, _index4.default)(dateLeft, sign * difference);

  // Math.abs(diff in full ISO years - diff in calendar ISO years) === 1
  // if last calendar ISO year is not full
  // If so, result must be decreased by 1 in absolute value
  var isLastISOWeekYearNotFull = Number((0, _index3.default)(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastISOWeekYearNotFull);
  // Prevent negative zero
  return result === 0 ? 0 : result;
}
module.exports = exports.default;

/***/ }),

/***/ 86213:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of milliseconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * const result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */
function differenceInMilliseconds(dateLeft, dateRight) {
  (0, _index2.default)(2, arguments);
  return (0, _index.default)(dateLeft).getTime() - (0, _index.default)(dateRight).getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 98970:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInMinutes;
var _index = __webpack_require__(53372);
var _index2 = _interopRequireDefault(__webpack_require__(86213));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var _index4 = __webpack_require__(43010);
/**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of minutes
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * const result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are between 10:01:59 and 10:00:00
 * const result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */
function differenceInMinutes(dateLeft, dateRight, options) {
  (0, _index3.default)(2, arguments);
  var diff = (0, _index2.default)(dateLeft, dateRight) / _index.millisecondsInMinute;
  return (0, _index4.getRoundingMethod)(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
module.exports = exports.default;

/***/ }),

/***/ 63310:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInMonths;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(86223));
var _index3 = _interopRequireDefault(__webpack_require__(74876));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var _index5 = _interopRequireDefault(__webpack_require__(47072));
/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates using trunc as a default rounding method.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  (0, _index4.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var sign = (0, _index3.default)(dateLeft, dateRight);
  var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
  var result;

  // Check for the difference of less than month
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      // This will check if the date is end of Feb and assign a higher end of month date
      // to compare it with Jan
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign * difference);

    // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
    // If so, result must be decreased by 1 in absolute value
    var isLastMonthNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;

    // Check for cases of one full calendar month
    if ((0, _index5.default)((0, _index.default)(dirtyDateLeft)) && difference === 1 && (0, _index3.default)(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign * (difference - Number(isLastMonthNotFull));
  }

  // Prevent negative zero
  return result === 0 ? 0 : result;
}
module.exports = exports.default;

/***/ }),

/***/ 96778:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInQuarters;
var _index = _interopRequireDefault(__webpack_require__(63310));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = __webpack_require__(43010);
/**
 * @name differenceInQuarters
 * @category Quarter Helpers
 * @summary Get the number of quarters between the given dates.
 *
 * @description
 * Get the number of quarters between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of full quarters
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
 * //=> 2
 */
function differenceInQuarters(dateLeft, dateRight, options) {
  (0, _index2.default)(2, arguments);
  var diff = (0, _index.default)(dateLeft, dateRight) / 3;
  return (0, _index3.getRoundingMethod)(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
module.exports = exports.default;

/***/ }),

/***/ 6538:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInSeconds;
var _index = _interopRequireDefault(__webpack_require__(86213));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = __webpack_require__(43010);
/**
 * @name differenceInSeconds
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of seconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * const result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */
function differenceInSeconds(dateLeft, dateRight, options) {
  (0, _index2.default)(2, arguments);
  var diff = (0, _index.default)(dateLeft, dateRight) / 1000;
  return (0, _index3.getRoundingMethod)(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
module.exports = exports.default;

/***/ }),

/***/ 40816:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInWeeks;
var _index = _interopRequireDefault(__webpack_require__(93688));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = __webpack_require__(43010);
/**
 * @name differenceInWeeks
 * @category Week Helpers
 * @summary Get the number of full weeks between the given dates.
 *
 * @description
 * Get the number of full weeks between two dates. Fractional weeks are
 * truncated towards zero by default.
 *
 * One "full week" is the distance between a local time in one day to the same
 * local time 7 days earlier or later. A full week can sometimes be less than
 * or more than 7*24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 7*24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
 *
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of full weeks
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
 * //=> 2
 *
 * // How many full weeks are between
 * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 8 weeks (54 days),
 * // even if DST starts and the period has
 * // only 54*24-1 hours.
 * const result = differenceInWeeks(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 6)
 * )
 * //=> 8
 */
function differenceInWeeks(dateLeft, dateRight, options) {
  (0, _index2.default)(2, arguments);
  var diff = (0, _index.default)(dateLeft, dateRight) / 7;
  return (0, _index3.getRoundingMethod)(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
module.exports = exports.default;

/***/ }),

/***/ 15957:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = differenceInYears;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(75921));
var _index3 = _interopRequireDefault(__webpack_require__(74876));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name differenceInYears
 * @category Year Helpers
 * @summary Get the number of full years between the given dates.
 *
 * @description
 * Get the number of full years between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
 * //=> 1
 */
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  (0, _index4.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  var sign = (0, _index3.default)(dateLeft, dateRight);
  var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));

  // Set both dates to a valid leap year for accurate comparison when dealing
  // with leap days
  dateLeft.setFullYear(1584);
  dateRight.setFullYear(1584);

  // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
  // If so, result must be decreased by 1 in absolute value
  var isLastYearNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;
  var result = sign * (difference - Number(isLastYearNotFull));
  // Prevent negative zero
  return result === 0 ? 0 : result;
}
module.exports = exports.default;

/***/ }),

/***/ 20242:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachDayOfInterval;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachDayOfInterval
 * @category Interval Helpers
 * @summary Return the array of dates within the specified time interval.
 *
 * @description
 * Return the array of dates within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Object} [options] - an object with options.
 * @param {Number} [options.step=1] - the step to increment by. The value should be more than 1.
 * @returns {Date[]} the array with starts of days from the day of the interval start to the day of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.step` must be a number greater than 1
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each day between 6 October 2014 and 10 October 2014:
 * const result = eachDayOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 9, 10)
 * })
 * //=> [
 * //   Mon Oct 06 2014 00:00:00,
 * //   Tue Oct 07 2014 00:00:00,
 * //   Wed Oct 08 2014 00:00:00,
 * //   Thu Oct 09 2014 00:00:00,
 * //   Fri Oct 10 2014 00:00:00
 * // ]
 */
function eachDayOfInterval(dirtyInterval, options) {
  var _options$step;
  (0, _index2.default)(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = (0, _index.default)(interval.start);
  var endDate = (0, _index.default)(interval.end);
  var endTime = endDate.getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');
  while (currentDate.getTime() <= endTime) {
    dates.push((0, _index.default)(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}
module.exports = exports.default;

/***/ }),

/***/ 46607:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachHourOfInterval;
var _index = _interopRequireDefault(__webpack_require__(43462));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachHourOfInterval
 * @category Interval Helpers
 * @summary Return the array of hours within the specified time interval.
 *
 * @description
 * Return the array of hours within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Object} [options] - an object with options.
 * @param {Number} [options.step=1] - the step to increment by. The value should be more than 1.
 * @returns {Date[]} the array with starts of hours from the hour of the interval start to the hour of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.step` must be a number greater than 1
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each hour between 6 October 2014, 12:00 and 6 October 2014, 15:00
 * const result = eachHourOfInterval({
 *   start: new Date(2014, 9, 6, 12),
 *   end: new Date(2014, 9, 6, 15)
 * })
 * //=> [
 * //   Mon Oct 06 2014 12:00:00,
 * //   Mon Oct 06 2014 13:00:00,
 * //   Mon Oct 06 2014 14:00:00,
 * //   Mon Oct 06 2014 15:00:00
 * // ]
 */
function eachHourOfInterval(dirtyInterval, options) {
  var _options$step;
  (0, _index3.default)(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = (0, _index2.default)(interval.start);
  var endDate = (0, _index2.default)(interval.end);
  var startTime = startDate.getTime();
  var endTime = endDate.getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startTime <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setMinutes(0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');
  while (currentDate.getTime() <= endTime) {
    dates.push((0, _index2.default)(currentDate));
    currentDate = (0, _index.default)(currentDate, step);
  }
  return dates;
}
module.exports = exports.default;

/***/ }),

/***/ 52663:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachMinuteOfInterval;
var _index = _interopRequireDefault(__webpack_require__(98958));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(10515));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachMinuteOfInterval
 * @category Interval Helpers
 * @summary Return the array of minutes within the specified time interval.
 *
 * @description
 * Returns the array of minutes within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Object} [options] - an object with options.
 * @param {Number} [options.step=1] - the step to increment by. The step must be equal to or greater than 1
 * @throws {TypeError} 1 argument required
 * @returns {Date[]} the array with starts of minutes from the minute of the interval start to the minute of the interval end
 * @throws {RangeError} `options.step` must be a number equal to or greater than 1
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each minute between 14 October 2020, 13:00 and 14 October 2020, 13:03
 * const result = eachMinuteOfInterval({
 *   start: new Date(2014, 9, 14, 13),
 *   end: new Date(2014, 9, 14, 13, 3)
 * })
 * //=> [
 * //   Wed Oct 14 2014 13:00:00,
 * //   Wed Oct 14 2014 13:01:00,
 * //   Wed Oct 14 2014 13:02:00,
 * //   Wed Oct 14 2014 13:03:00
 * // ]
 */
function eachMinuteOfInterval(interval, options) {
  var _options$step;
  (0, _index4.default)(1, arguments);
  var startDate = (0, _index3.default)((0, _index2.default)(interval.start));
  var endDate = (0, _index2.default)(interval.end);
  var startTime = startDate.getTime();
  var endTime = endDate.getTime();
  if (startTime >= endTime) {
    throw new RangeError('Invalid interval');
  }
  var dates = [];
  var currentDate = startDate;
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number equal to or greater than 1');
  while (currentDate.getTime() <= endTime) {
    dates.push((0, _index2.default)(currentDate));
    currentDate = (0, _index.default)(currentDate, step);
  }
  return dates;
}
module.exports = exports.default;

/***/ }),

/***/ 81757:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachMonthOfInterval;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachMonthOfInterval
 * @category Interval Helpers
 * @summary Return the array of months within the specified time interval.
 *
 * @description
 * Return the array of months within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @returns {Date[]} the array with starts of months from the month of the interval start to the month of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each month between 6 February 2014 and 10 August 2014:
 * const result = eachMonthOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Sat Feb 01 2014 00:00:00,
 * //   Sat Mar 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Thu May 01 2014 00:00:00,
 * //   Sun Jun 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * //   Fri Aug 01 2014 00:00:00
 * // ]
 */
function eachMonthOfInterval(dirtyInterval) {
  (0, _index2.default)(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = (0, _index.default)(interval.start);
  var endDate = (0, _index.default)(interval.end);
  var endTime = endDate.getTime();
  var dates = [];

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setDate(1);
  while (currentDate.getTime() <= endTime) {
    dates.push((0, _index.default)(currentDate));
    currentDate.setMonth(currentDate.getMonth() + 1);
  }
  return dates;
}
module.exports = exports.default;

/***/ }),

/***/ 97144:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachQuarterOfInterval;
var _index = _interopRequireDefault(__webpack_require__(75633));
var _index2 = _interopRequireDefault(__webpack_require__(20183));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachQuarterOfInterval
 * @category Interval Helpers
 * @summary Return the array of quarters within the specified time interval.
 *
 * @description
 * Return the array of quarters within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @returns {Date[]} the array with starts of quarters from the quarter of the interval start to the quarter of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each quarter within interval 6 February 2014 - 10 August 2014:
 * const result = eachQuarterOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * // ]
 */
function eachQuarterOfInterval(dirtyInterval) {
  (0, _index4.default)(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = (0, _index3.default)(interval.start);
  var endDate = (0, _index3.default)(interval.end);
  var endTime = endDate.getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var startDateQuarter = (0, _index2.default)(startDate);
  var endDateQuarter = (0, _index2.default)(endDate);
  endTime = endDateQuarter.getTime();
  var quarters = [];
  var currentQuarter = startDateQuarter;
  while (currentQuarter.getTime() <= endTime) {
    quarters.push((0, _index3.default)(currentQuarter));
    currentQuarter = (0, _index.default)(currentQuarter, 1);
  }
  return quarters;
}
module.exports = exports.default;

/***/ }),

/***/ 14890:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachWeekOfInterval;
var _index = _interopRequireDefault(__webpack_require__(11237));
var _index2 = _interopRequireDefault(__webpack_require__(11790));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachWeekOfInterval
 * @category Interval Helpers
 * @summary Return the array of weeks within the specified time interval.
 *
 * @description
 * Return the array of weeks within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date[]} the array with starts of weeks from the week of the interval start to the week of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be 0, 1, ..., 6
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each week within interval 6 October 2014 - 23 November 2014:
 * const result = eachWeekOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 10, 23)
 * })
 * //=> [
 * //   Sun Oct 05 2014 00:00:00,
 * //   Sun Oct 12 2014 00:00:00,
 * //   Sun Oct 19 2014 00:00:00,
 * //   Sun Oct 26 2014 00:00:00,
 * //   Sun Nov 02 2014 00:00:00,
 * //   Sun Nov 09 2014 00:00:00,
 * //   Sun Nov 16 2014 00:00:00,
 * //   Sun Nov 23 2014 00:00:00
 * // ]
 */
function eachWeekOfInterval(dirtyInterval, options) {
  (0, _index4.default)(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = (0, _index3.default)(interval.start);
  var endDate = (0, _index3.default)(interval.end);
  var endTime = endDate.getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var startDateWeek = (0, _index2.default)(startDate, options);
  var endDateWeek = (0, _index2.default)(endDate, options);

  // Some timezones switch DST at midnight, making start of day unreliable in these timezones, 3pm is a safe bet
  startDateWeek.setHours(15);
  endDateWeek.setHours(15);
  endTime = endDateWeek.getTime();
  var weeks = [];
  var currentWeek = startDateWeek;
  while (currentWeek.getTime() <= endTime) {
    currentWeek.setHours(0);
    weeks.push((0, _index3.default)(currentWeek));
    currentWeek = (0, _index.default)(currentWeek, 1);
    currentWeek.setHours(15);
  }
  return weeks;
}
module.exports = exports.default;

/***/ }),

/***/ 59737:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachWeekendOfInterval;
var _index = _interopRequireDefault(__webpack_require__(20242));
var _index2 = _interopRequireDefault(__webpack_require__(43889));
var _index3 = _interopRequireDefault(__webpack_require__(31125));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachWeekendOfInterval
 * @category Interval Helpers
 * @summary List all the Saturdays and Sundays in the given date interval.
 *
 * @description
 * Get all the Saturdays and Sundays in the given date interval.
 *
 * @param {Interval} interval - the given interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @returns {Date[]} an array containing all the Saturdays and Sundays
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Lists all Saturdays and Sundays in the given date interval
 * const result = eachWeekendOfInterval({
 *   start: new Date(2018, 8, 17),
 *   end: new Date(2018, 8, 30)
 * })
 * //=> [
 * //   Sat Sep 22 2018 00:00:00,
 * //   Sun Sep 23 2018 00:00:00,
 * //   Sat Sep 29 2018 00:00:00,
 * //   Sun Sep 30 2018 00:00:00
 * // ]
 */
function eachWeekendOfInterval(interval) {
  (0, _index4.default)(1, arguments);
  var dateInterval = (0, _index.default)(interval);
  var weekends = [];
  var index = 0;
  while (index < dateInterval.length) {
    var date = dateInterval[index++];
    if ((0, _index3.default)(date)) {
      weekends.push(date);
      if ((0, _index2.default)(date)) index = index + 5;
    }
  }
  return weekends;
}
module.exports = exports.default;

/***/ }),

/***/ 72393:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachWeekendOfMonth;
var _index = _interopRequireDefault(__webpack_require__(59737));
var _index2 = _interopRequireDefault(__webpack_require__(63104));
var _index3 = _interopRequireDefault(__webpack_require__(74192));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachWeekendOfMonth
 * @category Month Helpers
 * @summary List all the Saturdays and Sundays in the given month.
 *
 * @description
 * Get all the Saturdays and Sundays in the given month.
 *
 * @param {Date|Number} date - the given month
 * @returns {Date[]} an array containing all the Saturdays and Sundays
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} The passed date is invalid
 *
 * @example
 * // Lists all Saturdays and Sundays in the given month
 * const result = eachWeekendOfMonth(new Date(2022, 1, 1))
 * //=> [
 * //   Sat Feb 05 2022 00:00:00,
 * //   Sun Feb 06 2022 00:00:00,
 * //   Sat Feb 12 2022 00:00:00,
 * //   Sun Feb 13 2022 00:00:00,
 * //   Sat Feb 19 2022 00:00:00,
 * //   Sun Feb 20 2022 00:00:00,
 * //   Sat Feb 26 2022 00:00:00,
 * //   Sun Feb 27 2022 00:00:00
 * // ]
 */
function eachWeekendOfMonth(dirtyDate) {
  (0, _index4.default)(1, arguments);
  var startDate = (0, _index2.default)(dirtyDate);
  if (isNaN(startDate.getTime())) throw new RangeError('The passed date is invalid');
  var endDate = (0, _index3.default)(dirtyDate);
  return (0, _index.default)({
    start: startDate,
    end: endDate
  });
}
module.exports = exports.default;

/***/ }),

/***/ 76893:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachWeekendOfYear;
var _index = _interopRequireDefault(__webpack_require__(59737));
var _index2 = _interopRequireDefault(__webpack_require__(356));
var _index3 = _interopRequireDefault(__webpack_require__(69280));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachWeekendOfYear
 * @category Year Helpers
 * @summary List all the Saturdays and Sundays in the year.
 *
 * @description
 * Get all the Saturdays and Sundays in the year.
 *
 * @param {Date|Number} date - the given year
 * @returns {Date[]} an array containing all the Saturdays and Sundays
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} The passed date is invalid
 *
 * @example
 * // Lists all Saturdays and Sundays in the year
 * const result = eachWeekendOfYear(new Date(2020, 1, 1))
 * //=> [
 * //   Sat Jan 03 2020 00:00:00,
 * //   Sun Jan 04 2020 00:00:00,
 * //   ...
 * //   Sun Dec 27 2020 00:00:00
 * // ]
 * ]
 */
function eachWeekendOfYear(dirtyDate) {
  (0, _index4.default)(1, arguments);
  var startDate = (0, _index3.default)(dirtyDate);
  var endDate = (0, _index2.default)(dirtyDate);
  return (0, _index.default)({
    start: startDate,
    end: endDate
  });
}
module.exports = exports.default;

/***/ }),

/***/ 3044:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = eachYearOfInterval;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name eachYearOfInterval
 * @category Interval Helpers
 * @summary Return the array of yearly timestamps within the specified time interval.
 *
 * @description
 * Return the array of yearly timestamps within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @returns {Date[]} the array with starts of yearly timestamps from the month of the interval start to the month of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each year between 6 February 2014 and 10 August 2017:
 * const result = eachYearOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2017, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Thu Jan 01 2015 00:00:00,
 * //   Fri Jan 01 2016 00:00:00,
 * //   Sun Jan 01 2017 00:00:00
 * // ]
 */
function eachYearOfInterval(dirtyInterval) {
  (0, _index2.default)(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = (0, _index.default)(interval.start);
  var endDate = (0, _index.default)(interval.end);
  var endTime = endDate.getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setMonth(0, 1);
  while (currentDate.getTime() <= endTime) {
    dates.push((0, _index.default)(currentDate));
    currentDate.setFullYear(currentDate.getFullYear() + 1);
  }
  return dates;
}
module.exports = exports.default;

/***/ }),

/***/ 62660:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfDay;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */
function endOfDay(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 27429:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfDecade;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfDecade
 * @category Decade Helpers
 * @summary Return the end of a decade for the given date.
 *
 * @description
 * Return the end of a decade for the given date.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a decade
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // The end of a decade for 12 May 1984 00:00:00:
 * const result = endOfDecade(new Date(1984, 4, 12, 00, 00, 00))
 * //=> Dec 31 1989 23:59:59.999
 */
function endOfDecade(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  var decade = 9 + Math.floor(year / 10) * 10;
  date.setFullYear(decade, 11, 31);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 47343:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfHour;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfHour
 * @category Hour Helpers
 * @summary Return the end of an hour for the given date.
 *
 * @description
 * Return the end of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of an hour
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of an hour for 2 September 2014 11:55:00:
 * const result = endOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:59:59.999
 */
function endOfHour(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setMinutes(59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 12284:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfISOWeek;
var _index = _interopRequireDefault(__webpack_require__(28626));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the end of an ISO week for the given date.
 *
 * @description
 * Return the end of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of an ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of an ISO week for 2 September 2014 11:55:00:
 * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfISOWeek(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, {
    weekStartsOn: 1
  });
}
module.exports = exports.default;

/***/ }),

/***/ 41330:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(6874));
var _index2 = _interopRequireDefault(__webpack_require__(38674));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the end of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the end of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of an ISO week-numbering year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of an ISO week-numbering year for 2 July 2005:
 * const result = endOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 23:59:59.999
 */
function endOfISOWeekYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var year = (0, _index.default)(dirtyDate);
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var date = (0, _index2.default)(fourthOfJanuaryOfNextYear);
  date.setMilliseconds(date.getMilliseconds() - 1);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 21064:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfMinute;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfMinute
 * @category Minute Helpers
 * @summary Return the end of a minute for the given date.
 *
 * @description
 * Return the end of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a minute
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a minute for 1 December 2014 22:15:45.400:
 * const result = endOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:59.999
 */
function endOfMinute(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setSeconds(59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 74192:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */
function endOfMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 56197:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfQuarter;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfQuarter
 * @category Quarter Helpers
 * @summary Return the end of a year quarter for the given date.
 *
 * @description
 * Return the end of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a quarter for 2 September 2014 11:55:00:
 * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */
function endOfQuarter(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date.setMonth(month, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 32664:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfSecond;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfSecond
 * @category Second Helpers
 * @summary Return the end of a second for the given date.
 *
 * @description
 * Return the end of a second for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a second
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a second for 1 December 2014 22:15:45.400:
 * const result = endOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.999
 */
function endOfSecond(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setMilliseconds(999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 4493:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfToday;
var _index = _interopRequireDefault(__webpack_require__(62660));
/**
 * @name endOfToday
 * @category Day Helpers
 * @summary Return the end of today.
 * @pure false
 *
 * @description
 * Return the end of today.
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the end of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfToday()
 * //=> Mon Oct 6 2014 23:59:59.999
 */
function endOfToday() {
  return (0, _index.default)(Date.now());
}
module.exports = exports.default;

/***/ }),

/***/ 41659:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfTomorrow;
/**
 * @name endOfTomorrow
 * @category Day Helpers
 * @summary Return the end of tomorrow.
 * @pure false
 *
 * @description
 * Return the end of tomorrow.
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `new Date()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the end of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfTomorrow()
 * //=> Tue Oct 7 2014 23:59:59.999
 */
function endOfTomorrow() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 28626:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfWeek;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the end of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index4.default)(1, arguments);
  var defaultOptions = (0, _index.getDefaultOptions)();
  var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = (0, _index2.default)(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 356:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */
function endOfYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 60390:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = endOfYesterday;
/**
 * @name endOfYesterday
 * @category Day Helpers
 * @summary Return the end of yesterday.
 * @pure false
 *
 * @description
 * Return the end of yesterday.
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `new Date()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the end of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfYesterday()
 * //=> Sun Oct 5 2014 23:59:59.999
 */
function endOfYesterday() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(23, 59, 59, 999);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 55076:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = format;
var _index = _interopRequireDefault(__webpack_require__(92401));
var _index2 = _interopRequireDefault(__webpack_require__(2665));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(14481));
var _index5 = _interopRequireDefault(__webpack_require__(74049));
var _index6 = _interopRequireDefault(__webpack_require__(10944));
var _index7 = __webpack_require__(31374);
var _index8 = _interopRequireDefault(__webpack_require__(50687));
var _index9 = _interopRequireDefault(__webpack_require__(37716));
var _index10 = __webpack_require__(30596);
var _index11 = _interopRequireDefault(__webpack_require__(67030));
// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  (0, _index9.default)(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = (0, _index10.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index11.default;
  var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }
  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }
  var originalDate = (0, _index3.default)(dirtyDate);
  if (!(0, _index.default)(originalDate)) {
    throw new RangeError('Invalid time value');
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
  var timezoneOffset = (0, _index6.default)(originalDate);
  var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = _index5.default[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = _index4.default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
        (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
        (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }
    return substring;
  }).join('');
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
module.exports = exports.default;

/***/ }),

/***/ 87280:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatDistance;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(74876));
var _index3 = _interopRequireDefault(__webpack_require__(63310));
var _index4 = _interopRequireDefault(__webpack_require__(6538));
var _index5 = _interopRequireDefault(__webpack_require__(67030));
var _index6 = _interopRequireDefault(__webpack_require__(70107));
var _index7 = _interopRequireDefault(__webpack_require__(50941));
var _index8 = _interopRequireDefault(__webpack_require__(38177));
var _index9 = _interopRequireDefault(__webpack_require__(10944));
var _index10 = _interopRequireDefault(__webpack_require__(37716));
var MINUTES_IN_DAY = 1440;
var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
var MINUTES_IN_MONTH = 43200;
var MINUTES_IN_TWO_MONTHS = 86400;

/**
 * @name formatDistance
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words.
 *
 * | Distance between dates                                            | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance between dates | Result               |
 * |------------------------|----------------------|
 * | 0 secs ... 5 secs      | less than 5 seconds  |
 * | 5 secs ... 10 secs     | less than 10 seconds |
 * | 10 secs ... 20 secs    | less than 20 seconds |
 * | 20 secs ... 40 secs    | half a minute        |
 * | 40 secs ... 60 secs    | less than a minute   |
 * | 60 secs ... 90 secs    | 1 minute             |
 *
 * @param {Date|Number} date - the date
 * @param {Date|Number} baseDate - the date to compare with
 * @param {Object} [options] - an object with options.
 * @param {Boolean} [options.includeSeconds=false] - distances less than a minute are more detailed
 * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the distance in words
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `baseDate` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00, including seconds?
 * const result = formatDistance(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0),
 *   { includeSeconds: true }
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> 'about 1 year ago'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> 'pli ol 1 jaro'
 */

function formatDistance(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale;
  (0, _index10.default)(2, arguments);
  var defaultOptions = (0, _index.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index5.default;
  if (!locale.formatDistance) {
    throw new RangeError('locale must contain formatDistance property');
  }
  var comparison = (0, _index2.default)(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError('Invalid time value');
  }
  var localizeOptions = (0, _index8.default)((0, _index7.default)(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison: comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = (0, _index6.default)(dirtyBaseDate);
    dateRight = (0, _index6.default)(dirtyDate);
  } else {
    dateLeft = (0, _index6.default)(dirtyDate);
    dateRight = (0, _index6.default)(dirtyBaseDate);
  }
  var seconds = (0, _index4.default)(dateRight, dateLeft);
  var offsetInSeconds = ((0, _index9.default)(dateRight) - (0, _index9.default)(dateLeft)) / 1000;
  var minutes = Math.round((seconds - offsetInSeconds) / 60);
  var months;

  // 0 up to 2 mins
  if (minutes < 2) {
    if (options !== null && options !== void 0 && options.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance('lessThanXSeconds', 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance('lessThanXSeconds', 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance('lessThanXSeconds', 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance('halfAMinute', 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance('lessThanXMinutes', 1, localizeOptions);
      } else {
        return locale.formatDistance('xMinutes', 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance('lessThanXMinutes', 1, localizeOptions);
      } else {
        return locale.formatDistance('xMinutes', minutes, localizeOptions);
      }
    }

    // 2 mins up to 0.75 hrs
  } else if (minutes < 45) {
    return locale.formatDistance('xMinutes', minutes, localizeOptions);

    // 0.75 hrs up to 1.5 hrs
  } else if (minutes < 90) {
    return locale.formatDistance('aboutXHours', 1, localizeOptions);

    // 1.5 hrs up to 24 hrs
  } else if (minutes < MINUTES_IN_DAY) {
    var hours = Math.round(minutes / 60);
    return locale.formatDistance('aboutXHours', hours, localizeOptions);

    // 1 day up to 1.75 days
  } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
    return locale.formatDistance('xDays', 1, localizeOptions);

    // 1.75 days up to 30 days
  } else if (minutes < MINUTES_IN_MONTH) {
    var days = Math.round(minutes / MINUTES_IN_DAY);
    return locale.formatDistance('xDays', days, localizeOptions);

    // 1 month up to 2 months
  } else if (minutes < MINUTES_IN_TWO_MONTHS) {
    months = Math.round(minutes / MINUTES_IN_MONTH);
    return locale.formatDistance('aboutXMonths', months, localizeOptions);
  }
  months = (0, _index3.default)(dateRight, dateLeft);

  // 2 months up to 12 months
  if (months < 12) {
    var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
    return locale.formatDistance('xMonths', nearestMonth, localizeOptions);

    // 1 year up to max Date
  } else {
    var monthsSinceStartOfYear = months % 12;
    var years = Math.floor(months / 12);

    // N years up to 1 years 3 months
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance('aboutXYears', years, localizeOptions);

      // N years 3 months up to N years 9 months
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance('overXYears', years, localizeOptions);

      // N years 9 months up to N year 12 months
    } else {
      return locale.formatDistance('almostXYears', years + 1, localizeOptions);
    }
  }
}
module.exports = exports.default;

/***/ }),

/***/ 69359:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatDistanceStrict;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(10944));
var _index3 = _interopRequireDefault(__webpack_require__(74876));
var _index4 = _interopRequireDefault(__webpack_require__(70107));
var _index5 = _interopRequireDefault(__webpack_require__(50941));
var _index6 = _interopRequireDefault(__webpack_require__(38177));
var _index7 = _interopRequireDefault(__webpack_require__(67030));
var _index8 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_MINUTE = 1000 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

/**
 * @name formatDistanceStrict
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @param {Date|Number} date - the date
 * @param {Date|Number} baseDate - the date to compare with
 * @param {Object} [options] - an object with options.
 * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
 * @param {'second'|'minute'|'hour'|'day'|'month'|'year'} [options.unit] - if specified, will force a unit
 * @param {'floor'|'ceil'|'round'} [options.roundingMethod='round'] - which way to round partial units
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the distance in words
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `baseDate` must not be Invalid Date
 * @throws {RangeError} `options.roundingMethod` must be 'floor', 'ceil' or 'round'
 * @throws {RangeError} `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
 * @throws {RangeError} `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00?
 * const result = formatDistanceStrict(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> '1 year ago'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, in minutes?
 * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
 *   unit: 'minute'
 * })
 * //=> '525600 minutes'
 *
 * @example
 * // What is the distance from 1 January 2015
 * // to 28 January 2015, in months, rounded up?
 * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> '1 jaro'
 */

function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale, _options$roundingMeth;
  (0, _index8.default)(2, arguments);
  var defaultOptions = (0, _index.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index7.default;
  if (!locale.formatDistance) {
    throw new RangeError('locale must contain localize.formatDistance property');
  }
  var comparison = (0, _index3.default)(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError('Invalid time value');
  }
  var localizeOptions = (0, _index6.default)((0, _index5.default)(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison: comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = (0, _index4.default)(dirtyBaseDate);
    dateRight = (0, _index4.default)(dirtyDate);
  } else {
    dateLeft = (0, _index4.default)(dirtyDate);
    dateRight = (0, _index4.default)(dirtyBaseDate);
  }
  var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : 'round');
  var roundingMethodFn;
  if (roundingMethod === 'floor') {
    roundingMethodFn = Math.floor;
  } else if (roundingMethod === 'ceil') {
    roundingMethodFn = Math.ceil;
  } else if (roundingMethod === 'round') {
    roundingMethodFn = Math.round;
  } else {
    throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
  }
  var milliseconds = dateRight.getTime() - dateLeft.getTime();
  var minutes = milliseconds / MILLISECONDS_IN_MINUTE;
  var timezoneOffset = (0, _index2.default)(dateRight) - (0, _index2.default)(dateLeft);

  // Use DST-normalized difference in minutes for years, months and days;
  // use regular difference in minutes for hours, minutes and seconds.
  var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE;
  var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
  var unit;
  if (!defaultUnit) {
    if (minutes < 1) {
      unit = 'second';
    } else if (minutes < 60) {
      unit = 'minute';
    } else if (minutes < MINUTES_IN_DAY) {
      unit = 'hour';
    } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
      unit = 'day';
    } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
      unit = 'month';
    } else {
      unit = 'year';
    }
  } else {
    unit = String(defaultUnit);
  }

  // 0 up to 60 seconds
  if (unit === 'second') {
    var seconds = roundingMethodFn(milliseconds / 1000);
    return locale.formatDistance('xSeconds', seconds, localizeOptions);

    // 1 up to 60 mins
  } else if (unit === 'minute') {
    var roundedMinutes = roundingMethodFn(minutes);
    return locale.formatDistance('xMinutes', roundedMinutes, localizeOptions);

    // 1 up to 24 hours
  } else if (unit === 'hour') {
    var hours = roundingMethodFn(minutes / 60);
    return locale.formatDistance('xHours', hours, localizeOptions);

    // 1 up to 30 days
  } else if (unit === 'day') {
    var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
    return locale.formatDistance('xDays', days, localizeOptions);

    // 1 up to 12 months
  } else if (unit === 'month') {
    var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
    return months === 12 && defaultUnit !== 'month' ? locale.formatDistance('xYears', 1, localizeOptions) : locale.formatDistance('xMonths', months, localizeOptions);

    // 1 year up to max Date
  } else if (unit === 'year') {
    var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
    return locale.formatDistance('xYears', years, localizeOptions);
  }
  throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
}
module.exports = exports.default;

/***/ }),

/***/ 46683:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatDistanceToNow;
var _index = _interopRequireDefault(__webpack_require__(87280));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name formatDistanceToNow
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given date and now in words.
 *
 * | Distance to now                                                   | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance to now     | Result               |
 * |---------------------|----------------------|
 * | 0 secs ... 5 secs   | less than 5 seconds  |
 * | 5 secs ... 10 secs  | less than 10 seconds |
 * | 10 secs ... 20 secs | less than 20 seconds |
 * | 20 secs ... 40 secs | half a minute        |
 * | 40 secs ... 60 secs | less than a minute   |
 * | 60 secs ... 90 secs | 1 minute             |
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - the object with options
 * @param {Boolean} [options.includeSeconds=false] - distances less than a minute are more detailed
 * @param {Boolean} [options.addSuffix=false] - result specifies if now is earlier or later than the passed date
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the distance in words
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNow(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNow(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   {includeSeconds: true}
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNow(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in about 1 year'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 August 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNow(
 *   new Date(2016, 7, 1),
 *   {locale: eoLocale}
 * )
 * //=> 'pli ol 1 jaro'
 */
function formatDistanceToNow(dirtyDate, options) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, Date.now(), options);
}
module.exports = exports.default;

/***/ }),

/***/ 33160:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatDistanceToNowStrict;
var _index = _interopRequireDefault(__webpack_require__(69359));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name formatDistanceToNowStrict
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
 * @param {'second'|'minute'|'hour'|'day'|'month'|'year'} [options.unit] - if specified, will force a unit
 * @param {'floor'|'ceil'|'round'} [options.roundingMethod='round'] - which way to round partial units
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the distance in words
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNowStrict(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNowStrict(
 *   new Date(2015, 0, 1, 0, 0, 15)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in 1 year'
 *
 * @example
 * // If today is 28 January 2015,
 * // what is the distance to 1 January 2015, in months, rounded up??
 * const result = formatDistanceToNowStrict(new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {locale: eoLocale}
 * )
 * //=> '1 jaro'
 */
function formatDistanceToNowStrict(dirtyDate, options) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, Date.now(), options);
}
module.exports = exports.default;

/***/ }),

/***/ 67208:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatDuration;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(67030));
var defaultFormat = ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds'];

/**
 * @name formatDuration
 * @category Common Helpers
 * @summary Formats a duration in human-readable format
 *
 * @description
 * Return human-readable duration string i.e. "9 months 2 days"
 *
 * @param {Duration} duration - the duration to format
 * @param {Object} [options] - an object with options.
 * @param {string[]} [options.format=['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds']] - the array of units to format
 * @param {boolean} [options.zero=false] - should zeros be included in the output?
 * @param {string} [options.delimiter=' '] - delimiter string
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {string} the formatted date string
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Format full duration
 * formatDuration({
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> '2 years 9 months 1 week 7 days 5 hours 9 minutes 30 seconds'
 *
 * @example
 * // Format partial duration
 * formatDuration({ months: 9, days: 2 })
 * //=> '9 months 2 days'
 *
 * @example
 * // Customize the format
 * formatDuration(
 *   {
 *     years: 2,
 *     months: 9,
 *     weeks: 1,
 *     days: 7,
 *     hours: 5,
 *     minutes: 9,
 *     seconds: 30
 *   },
 *   { format: ['months', 'weeks'] }
 * ) === '9 months 1 week'
 *
 * @example
 * // Customize the zeros presence
 * formatDuration({ years: 0, months: 9 })
 * //=> '9 months'
 * formatDuration({ years: 0, months: 9 }, { zero: true })
 * //=> '0 years 9 months'
 *
 * @example
 * // Customize the delimiter
 * formatDuration({ years: 2, months: 9, weeks: 3 }, { delimiter: ', ' })
 * //=> '2 years, 9 months, 3 weeks'
 */
function formatDuration(duration, options) {
  var _ref, _options$locale, _options$format, _options$zero, _options$delimiter;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }
  var defaultOptions = (0, _index.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index2.default;
  var format = (_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : defaultFormat;
  var zero = (_options$zero = options === null || options === void 0 ? void 0 : options.zero) !== null && _options$zero !== void 0 ? _options$zero : false;
  var delimiter = (_options$delimiter = options === null || options === void 0 ? void 0 : options.delimiter) !== null && _options$delimiter !== void 0 ? _options$delimiter : ' ';
  if (!locale.formatDistance) {
    return '';
  }
  var result = format.reduce(function (acc, unit) {
    var token = "x".concat(unit.replace(/(^.)/, function (m) {
      return m.toUpperCase();
    }));
    var value = duration[unit];
    if (typeof value === 'number' && (zero || duration[unit])) {
      return acc.concat(locale.formatDistance(token, value));
    }
    return acc;
  }, []).join(delimiter);
  return result;
}
module.exports = exports.default;

/***/ }),

/***/ 37002:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatISO;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(21809));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {'extended'|'basic'} [options.format='extended'] - if 'basic', hide delimiters between date and time values.
 * @param {'complete'|'date'|'time'} [options.representation='complete'] - format date, time with local time zone, or both.
 * @returns {String} the formatted date string (in local time zone)
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.format` must be 'extended' or 'basic'
 * @throws {RangeError} `options.representation` must be 'date', 'time' or 'complete'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */
function formatISO(date, options) {
  var _options$format, _options$representati;
  (0, _index3.default)(1, arguments);
  var originalDate = (0, _index.default)(date);
  if (isNaN(originalDate.getTime())) {
    throw new RangeError('Invalid time value');
  }
  var format = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : 'extended');
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : 'complete');
  if (format !== 'extended' && format !== 'basic') {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== 'date' && representation !== 'time' && representation !== 'complete') {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = '';
  var tzOffset = '';
  var dateDelimiter = format === 'extended' ? '-' : '';
  var timeDelimiter = format === 'extended' ? ':' : '';

  // Representation is either 'date' or 'complete'
  if (representation !== 'time') {
    var day = (0, _index2.default)(originalDate.getDate(), 2);
    var month = (0, _index2.default)(originalDate.getMonth() + 1, 2);
    var year = (0, _index2.default)(originalDate.getFullYear(), 4);

    // yyyyMMdd or yyyy-MM-dd.
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }

  // Representation is either 'time' or 'complete'
  if (representation !== 'date') {
    // Add the timezone.
    var offset = originalDate.getTimezoneOffset();
    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = (0, _index2.default)(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = (0, _index2.default)(absoluteOffset % 60, 2);
      // If less than 0, the sign is +, because it is ahead of time.
      var sign = offset < 0 ? '+' : '-';
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = 'Z';
    }
    var hour = (0, _index2.default)(originalDate.getHours(), 2);
    var minute = (0, _index2.default)(originalDate.getMinutes(), 2);
    var second = (0, _index2.default)(originalDate.getSeconds(), 2);

    // If there's also date, separate it with time with 'T'
    var separator = result === '' ? '' : 'T';

    // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.
    var time = [hour, minute, second].join(timeDelimiter);

    // HHmmss or HH:mm:ss.
    result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
  }
  return result;
}
module.exports = exports.default;

/***/ }),

/***/ 77665:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatISO9075;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(92401));
var _index3 = _interopRequireDefault(__webpack_require__(21809));
/**
 * @name formatISO9075
 * @category Common Helpers
 * @summary Format the date according to the ISO 9075 standard (https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_get-format).
 *
 * @description
 * Return the formatted date string in ISO 9075 format. Options may be passed to control the parts and notations of the date.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {'extended'|'basic'} [options.format='extended'] - if 'basic', hide delimiters between date and time values.
 * @param {'complete'|'date'|'time'} [options.representation='complete'] - format date, time, or both.
 * @returns {String} the formatted date string
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.format` must be 'extended' or 'basic'
 * @throws {RangeError} `options.representation` must be 'date', 'time' or 'complete'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18 19:00:52'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075, short format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918 190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, date only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, time only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52'
 */
function formatISO9075(dirtyDate, options) {
  var _options$format, _options$representati;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = (0, _index.default)(dirtyDate);
  if (!(0, _index2.default)(originalDate)) {
    throw new RangeError('Invalid time value');
  }
  var format = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : 'extended');
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : 'complete');
  if (format !== 'extended' && format !== 'basic') {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== 'date' && representation !== 'time' && representation !== 'complete') {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = '';
  var dateDelimiter = format === 'extended' ? '-' : '';
  var timeDelimiter = format === 'extended' ? ':' : '';

  // Representation is either 'date' or 'complete'
  if (representation !== 'time') {
    var day = (0, _index3.default)(originalDate.getDate(), 2);
    var month = (0, _index3.default)(originalDate.getMonth() + 1, 2);
    var year = (0, _index3.default)(originalDate.getFullYear(), 4);

    // yyyyMMdd or yyyy-MM-dd.
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }

  // Representation is either 'time' or 'complete'
  if (representation !== 'date') {
    var hour = (0, _index3.default)(originalDate.getHours(), 2);
    var minute = (0, _index3.default)(originalDate.getMinutes(), 2);
    var second = (0, _index3.default)(originalDate.getSeconds(), 2);

    // If there's also date, separate it with time with a space
    var separator = result === '' ? '' : ' ';

    // HHmmss or HH:mm:ss.
    result = "".concat(result).concat(separator).concat(hour).concat(timeDelimiter).concat(minute).concat(timeDelimiter).concat(second);
  }
  return result;
}
module.exports = exports.default;

/***/ }),

/***/ 29906:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatISODuration;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name formatISODuration
 * @category Common Helpers
 * @summary Format a duration object according as ISO 8601 duration string
 *
 * @description
 * Format a duration object according to the ISO 8601 duration standard (https://www.digi.com/resources/documentation/digidocs/90001437-13/reference/r_iso_8601_duration_format.htm)
 *
 * @param {Duration} duration - the duration to format
 *
 * @returns {String} The ISO 8601 duration string
 * @throws {TypeError} Requires 1 argument
 * @throws {Error} Argument must be an object
 *
 * @example
 * // Format the given duration as ISO 8601 string
 * const result = formatISODuration({
 *   years: 39,
 *   months: 2,
 *   days: 20,
 *   hours: 7,
 *   minutes: 5,
 *   seconds: 0
 * })
 * //=> 'P39Y2M20DT0H0M0S'
 */
function formatISODuration(duration) {
  (0, _index.default)(1, arguments);
  if ((0, _typeof2.default)(duration) !== 'object') throw new Error('Duration must be an object');
  var _duration$years = duration.years,
    years = _duration$years === void 0 ? 0 : _duration$years,
    _duration$months = duration.months,
    months = _duration$months === void 0 ? 0 : _duration$months,
    _duration$days = duration.days,
    days = _duration$days === void 0 ? 0 : _duration$days,
    _duration$hours = duration.hours,
    hours = _duration$hours === void 0 ? 0 : _duration$hours,
    _duration$minutes = duration.minutes,
    minutes = _duration$minutes === void 0 ? 0 : _duration$minutes,
    _duration$seconds = duration.seconds,
    seconds = _duration$seconds === void 0 ? 0 : _duration$seconds;
  return "P".concat(years, "Y").concat(months, "M").concat(days, "DT").concat(hours, "H").concat(minutes, "M").concat(seconds, "S");
}
module.exports = exports.default;

/***/ }),

/***/ 69697:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatRFC3339;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(92401));
var _index3 = _interopRequireDefault(__webpack_require__(21809));
var _index4 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name formatRFC3339
 * @category Common Helpers
 * @summary Format the date according to the RFC 3339 standard (https://tools.ietf.org/html/rfc3339#section-5.6).
 *
 * @description
 * Return the formatted date string in RFC 3339 format. Options may be passed to control the parts and notations of the date.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {0|1|2|3} [options.fractionDigits=0] - number of digits after the decimal point after seconds
 * @returns {String} the formatted date string
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.fractionDigits` must be between 0 and 3
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format:
 * const result = formatRFC3339(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format, 2 digits of second fraction:
 * const result = formatRFC3339(new Date(2019, 8, 18, 19, 0, 52, 234), { fractionDigits: 2 })
 * //=> '2019-09-18T19:00:52.23Z'
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format, 3 digits of second fraction
 * const result = formatRFC3339(new Date(2019, 8, 18, 19, 0, 52, 234), { fractionDigits: 3 })
 * //=> '2019-09-18T19:00:52.234Z'
 */
function formatRFC3339(dirtyDate, options) {
  var _options$fractionDigi;
  if (arguments.length < 1) {
    throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = (0, _index.default)(dirtyDate);
  if (!(0, _index2.default)(originalDate)) {
    throw new RangeError('Invalid time value');
  }
  var fractionDigits = Number((_options$fractionDigi = options === null || options === void 0 ? void 0 : options.fractionDigits) !== null && _options$fractionDigi !== void 0 ? _options$fractionDigi : 0);

  // Test if fractionDigits is between 0 and 3 _and_ is not NaN
  if (!(fractionDigits >= 0 && fractionDigits <= 3)) {
    throw new RangeError('fractionDigits must be between 0 and 3 inclusively');
  }
  var day = (0, _index3.default)(originalDate.getDate(), 2);
  var month = (0, _index3.default)(originalDate.getMonth() + 1, 2);
  var year = originalDate.getFullYear();
  var hour = (0, _index3.default)(originalDate.getHours(), 2);
  var minute = (0, _index3.default)(originalDate.getMinutes(), 2);
  var second = (0, _index3.default)(originalDate.getSeconds(), 2);
  var fractionalSecond = '';
  if (fractionDigits > 0) {
    var milliseconds = originalDate.getMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, fractionDigits - 3));
    fractionalSecond = '.' + (0, _index3.default)(fractionalSeconds, fractionDigits);
  }
  var offset = '';
  var tzOffset = originalDate.getTimezoneOffset();
  if (tzOffset !== 0) {
    var absoluteOffset = Math.abs(tzOffset);
    var hourOffset = (0, _index3.default)((0, _index4.default)(absoluteOffset / 60), 2);
    var minuteOffset = (0, _index3.default)(absoluteOffset % 60, 2);
    // If less than 0, the sign is +, because it is ahead of time.
    var sign = tzOffset < 0 ? '+' : '-';
    offset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
  } else {
    offset = 'Z';
  }
  return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond).concat(offset);
}
module.exports = exports.default;

/***/ }),

/***/ 67840:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatRFC7231;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(92401));
var _index3 = _interopRequireDefault(__webpack_require__(21809));
var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

/**
 * @name formatRFC7231
 * @category Common Helpers
 * @summary Format the date according to the RFC 7231 standard (https://tools.ietf.org/html/rfc7231#section-7.1.1.1).
 *
 * @description
 * Return the formatted date string in RFC 7231 format.
 * The result will always be in UTC timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {String} the formatted date string
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 7231 format:
 * const result = formatRFC7231(new Date(2019, 8, 18, 19, 0, 52))
 * //=> 'Wed, 18 Sep 2019 19:00:52 GMT'
 */
function formatRFC7231(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = (0, _index.default)(dirtyDate);
  if (!(0, _index2.default)(originalDate)) {
    throw new RangeError('Invalid time value');
  }
  var dayName = days[originalDate.getUTCDay()];
  var dayOfMonth = (0, _index3.default)(originalDate.getUTCDate(), 2);
  var monthName = months[originalDate.getUTCMonth()];
  var year = originalDate.getUTCFullYear();
  var hour = (0, _index3.default)(originalDate.getUTCHours(), 2);
  var minute = (0, _index3.default)(originalDate.getUTCMinutes(), 2);
  var second = (0, _index3.default)(originalDate.getUTCSeconds(), 2);

  // Result variables.
  return "".concat(dayName, ", ").concat(dayOfMonth, " ").concat(monthName, " ").concat(year, " ").concat(hour, ":").concat(minute, ":").concat(second, " GMT");
}
module.exports = exports.default;

/***/ }),

/***/ 73613:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = formatRelative;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(64618));
var _index3 = _interopRequireDefault(__webpack_require__(55076));
var _index4 = _interopRequireDefault(__webpack_require__(67030));
var _index5 = _interopRequireDefault(__webpack_require__(2665));
var _index6 = _interopRequireDefault(__webpack_require__(70107));
var _index7 = _interopRequireDefault(__webpack_require__(10944));
var _index8 = _interopRequireDefault(__webpack_require__(37716));
var _index9 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name formatRelative
 * @category Common Helpers
 * @summary Represent the date in words relative to the given base date.
 *
 * @description
 * Represent the date in words relative to the given base date.
 *
 * | Distance to the base date | Result                    |
 * |---------------------------|---------------------------|
 * | Previous 6 days           | last Sunday at 04:30 AM   |
 * | Last day                  | yesterday at 04:30 AM     |
 * | Same day                  | today at 04:30 AM         |
 * | Next day                  | tomorrow at 04:30 AM      |
 * | Next 6 days               | Sunday at 04:30 AM        |
 * | Other                     | 12/31/2017                |
 *
 * @param {Date|Number} date - the date to format
 * @param {Date|Number} baseDate - the date to compare with
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {String} the date in words
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `baseDate` must not be Invalid Date
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.locale` must contain `formatRelative` property
 *
 * @example
 * // Represent the date of 6 days ago in words relative to the given base date. In this example, today is Wednesday
 * const result = formatRelative(addDays(new Date(), -6), new Date())
 * //=> "last Thursday at 12:45 AM"
 */
function formatRelative(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$weekStartsOn, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2;
  (0, _index8.default)(2, arguments);
  var date = (0, _index6.default)(dirtyDate);
  var baseDate = (0, _index6.default)(dirtyBaseDate);
  var defaultOptions = (0, _index.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index4.default;
  var weekStartsOn = (0, _index9.default)((_ref2 = (_ref3 = (_ref4 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }
  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }
  if (!locale.formatRelative) {
    throw new RangeError('locale must contain formatRelative property');
  }
  var diff = (0, _index2.default)(date, baseDate);
  if (isNaN(diff)) {
    throw new RangeError('Invalid time value');
  }
  var token;
  if (diff < -6) {
    token = 'other';
  } else if (diff < -1) {
    token = 'lastWeek';
  } else if (diff < 0) {
    token = 'yesterday';
  } else if (diff < 1) {
    token = 'today';
  } else if (diff < 2) {
    token = 'tomorrow';
  } else if (diff < 7) {
    token = 'nextWeek';
  } else {
    token = 'other';
  }
  var utcDate = (0, _index5.default)(date, (0, _index7.default)(date));
  var utcBaseDate = (0, _index5.default)(baseDate, (0, _index7.default)(baseDate));
  var formatStr = locale.formatRelative(token, utcDate, utcBaseDate, {
    locale: locale,
    weekStartsOn: weekStartsOn
  });
  return (0, _index3.default)(date, formatStr, {
    locale: locale,
    weekStartsOn: weekStartsOn
  });
}
module.exports = exports.default;

/***/ }),

/***/ 43804:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = fromUnixTime;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(50687));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name fromUnixTime
 * @category Timestamp Helpers
 * @summary Create a date from a Unix timestamp.
 *
 * @description
 * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
 *
 * @param {Number} unixTime - the given Unix timestamp (in seconds)
 * @returns {Date} the date
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Create the date 29 February 2012 11:45:05:
 * const result = fromUnixTime(1330515905)
 * //=> Wed Feb 29 2012 11:45:05
 */
function fromUnixTime(dirtyUnixTime) {
  (0, _index3.default)(1, arguments);
  var unixTime = (0, _index2.default)(dirtyUnixTime);
  return (0, _index.default)(unixTime * 1000);
}
module.exports = exports.default;

/***/ }),

/***/ 36471:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDate;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the day of month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * const result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */
function getDate(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}
module.exports = exports.default;

/***/ }),

/***/ 48461:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDay;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */
function getDay(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var day = date.getDay();
  return day;
}
module.exports = exports.default;

/***/ }),

/***/ 9374:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDayOfYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(69280));
var _index3 = _interopRequireDefault(__webpack_require__(64618));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getDayOfYear
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the day of year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * const result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear(dirtyDate) {
  (0, _index4.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var diff = (0, _index3.default)(date, (0, _index2.default)(date));
  var dayOfYear = diff + 1;
  return dayOfYear;
}
module.exports = exports.default;

/***/ }),

/***/ 54223:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDaysInMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */
function getDaysInMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
module.exports = exports.default;

/***/ }),

/***/ 74418:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDaysInYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(75501));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getDaysInYear
 * @category Year Helpers
 * @summary Get the number of days in a year of the given date.
 *
 * @description
 * Get the number of days in a year of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in 2012?
 * const result = getDaysInYear(new Date(2012, 0, 1))
 * //=> 366
 */
function getDaysInYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  if (String(new Date(date)) === 'Invalid Date') {
    return NaN;
  }
  return (0, _index2.default)(date) ? 366 : 365;
}
module.exports = exports.default;

/***/ }),

/***/ 60219:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDecade;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getDecade
 * @category Decade Helpers
 * @summary Get the decade of the given date.
 *
 * @description
 * Get the decade of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the year of decade
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which decade belongs 27 November 1942?
 * const result = getDecade(new Date(1942, 10, 27))
 * //=> 1940
 */
function getDecade(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  var decade = Math.floor(year / 10) * 10;
  return decade;
}
module.exports = exports.default;

/***/ }),

/***/ 34269:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getDefaultOptions;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(38177));
/**
 * @name getDefaultOptions
 * @category Common Helpers
 * @summary Get default options.
 * @pure false
 *
 * @description
 * Returns an object that contains defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * You can change these with [setDefaultOptions]{@link https://date-fns.org/docs/setDefaultOptions}.
 *
 * @returns {Object} default options
 *
 * @example
 * const result = getDefaultOptions()
 * //=> {}
 *
 * @example
 * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
 * const result = getDefaultOptions()
 * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
 */
function getDefaultOptions() {
  return (0, _index2.default)({}, (0, _index.getDefaultOptions)());
}
module.exports = exports.default;

/***/ }),

/***/ 60026:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getHours;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * const result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */
function getHours(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var hours = date.getHours();
  return hours;
}
module.exports = exports.default;

/***/ }),

/***/ 91655:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getISODay;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getISODay
 * @category Weekday Helpers
 * @summary Get the day of the ISO week of the given date.
 *
 * @description
 * Get the day of the ISO week of the given date,
 * which is 7 for Sunday, 1 for Monday etc.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the day of ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the ISO week is 26 February 2012?
 * const result = getISODay(new Date(2012, 1, 26))
 * //=> 7
 */
function getISODay(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var day = date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}
module.exports = exports.default;

/***/ }),

/***/ 54343:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getISOWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(38674));
var _index3 = _interopRequireDefault(__webpack_require__(4407));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;

/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek(dirtyDate) {
  (0, _index4.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var diff = (0, _index2.default)(date).getTime() - (0, _index3.default)(date).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 6874:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(38674));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the ISO week-numbering year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOWeekYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = (0, _index2.default)(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = (0, _index2.default)(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 87569:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getISOWeeksInYear;
var _index = _interopRequireDefault(__webpack_require__(4407));
var _index2 = _interopRequireDefault(__webpack_require__(11237));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;

/**
 * @name getISOWeeksInYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * @description
 * Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of ISO weeks in a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many weeks are in ISO week-numbering year 2015?
 * const result = getISOWeeksInYear(new Date(2015, 1, 11))
 * //=> 53
 */
function getISOWeeksInYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var thisYear = (0, _index.default)(dirtyDate);
  var nextYear = (0, _index.default)((0, _index2.default)(thisYear, 60));
  var diff = nextYear.valueOf() - thisYear.valueOf();
  // Round the number of weeks to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK);
}
module.exports = exports.default;

/***/ }),

/***/ 66600:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getMilliseconds
 * @category Millisecond Helpers
 * @summary Get the milliseconds of the given date.
 *
 * @description
 * Get the milliseconds of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the milliseconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the milliseconds of 29 February 2012 11:45:05.123:
 * const result = getMilliseconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 123
 */
function getMilliseconds(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var milliseconds = date.getMilliseconds();
  return milliseconds;
}
module.exports = exports.default;

/***/ }),

/***/ 11802:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getMinutes;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */
function getMinutes(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}
module.exports = exports.default;

/***/ }),

/***/ 63983:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which month is 29 February 2012?
 * const result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */
function getMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var month = date.getMonth();
  return month;
}
module.exports = exports.default;

/***/ }),

/***/ 20039:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getOverlappingDaysInIntervals;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1000;

/**
 * @name getOverlappingDaysInIntervals
 * @category Interval Helpers
 * @summary Get the number of days that overlap in two time intervals
 *
 * @description
 * Get the number of days that overlap in two time intervals
 *
 * @param {Interval} intervalLeft - the first interval to compare. See [Interval]{@link docs/Interval}
 * @param {Interval} intervalRight - the second interval to compare. See [Interval]{@link docs/Interval}
 * @returns {Number} the number of days that overlap in two time intervals
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // For overlapping time intervals adds 1 for each started overlapping day:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> 3
 *
 * @example
 * // For non-overlapping time intervals returns 0:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> 0
 */

function getOverlappingDaysInIntervals(dirtyIntervalLeft, dirtyIntervalRight) {
  (0, _index2.default)(2, arguments);
  var intervalLeft = dirtyIntervalLeft || {};
  var intervalRight = dirtyIntervalRight || {};
  var leftStartTime = (0, _index.default)(intervalLeft.start).getTime();
  var leftEndTime = (0, _index.default)(intervalLeft.end).getTime();
  var rightStartTime = (0, _index.default)(intervalRight.start).getTime();
  var rightEndTime = (0, _index.default)(intervalRight.end).getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
    throw new RangeError('Invalid interval');
  }
  var isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
  if (!isOverlapping) {
    return 0;
  }
  var overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime;
  var overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime;
  var differenceInMs = overlapEndDate - overlapStartDate;
  return Math.ceil(differenceInMs / MILLISECONDS_IN_DAY);
}
module.exports = exports.default;

/***/ }),

/***/ 59164:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getQuarter;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getQuarter
 * @category Quarter Helpers
 * @summary Get the year quarter of the given date.
 *
 * @description
 * Get the year quarter of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which quarter is 2 July 2014?
 * const result = getQuarter(new Date(2014, 6, 2))
 * //=> 3
 */
function getQuarter(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}
module.exports = exports.default;

/***/ }),

/***/ 10648:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getSeconds;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */
function getSeconds(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
module.exports = exports.default;

/***/ }),

/***/ 2018:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getTime;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getTime
 * @category Timestamp Helpers
 * @summary Get the milliseconds timestamp of the given date.
 *
 * @description
 * Get the milliseconds timestamp of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the timestamp
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05.123:
 * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 1330515905123
 */
function getTime(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}
module.exports = exports.default;

/***/ }),

/***/ 2761:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getUnixTime;
var _index = _interopRequireDefault(__webpack_require__(2018));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getUnixTime
 * @category Timestamp Helpers
 * @summary Get the seconds timestamp of the given date.
 *
 * @description
 * Get the seconds timestamp of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the timestamp
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05 CET:
 * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 1330512305
 */
function getUnixTime(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return Math.floor((0, _index.default)(dirtyDate) / 1000);
}
module.exports = exports.default;

/***/ }),

/***/ 81507:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getWeek;
var _index = _interopRequireDefault(__webpack_require__(11790));
var _index2 = _interopRequireDefault(__webpack_require__(70669));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var MILLISECONDS_IN_WEEK = 604800000;

/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(dirtyDate, options) {
  (0, _index4.default)(1, arguments);
  var date = (0, _index3.default)(dirtyDate);
  var diff = (0, _index.default)(date, options).getTime() - (0, _index2.default)(date, options).getTime();

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 95322:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getWeekOfMonth;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(36471));
var _index3 = _interopRequireDefault(__webpack_require__(48461));
var _index4 = _interopRequireDefault(__webpack_require__(63104));
var _index5 = _interopRequireDefault(__webpack_require__(37716));
var _index6 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name getWeekOfMonth
 * @category Week Helpers
 * @summary Get the week of the month of the given date.
 *
 * @description
 * Get the week of the month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Number} the week of month
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6 inclusively
 *
 * @example
 * // Which week of the month is 9 November 2017?
 * const result = getWeekOfMonth(new Date(2017, 10, 9))
 * //=> 2
 */
function getWeekOfMonth(date, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index5.default)(1, arguments);
  var defaultOptions = (0, _index.getDefaultOptions)();
  var weekStartsOn = (0, _index6.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var currentDayOfMonth = (0, _index2.default)(date);
  if (isNaN(currentDayOfMonth)) return NaN;
  var startWeekDay = (0, _index3.default)((0, _index4.default)(date));
  var lastDayOfFirstWeek = weekStartsOn - startWeekDay;
  if (lastDayOfFirstWeek <= 0) lastDayOfFirstWeek += 7;
  var remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
  return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 36878:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getWeekYear;
var _index = _interopRequireDefault(__webpack_require__(11790));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var _index5 = __webpack_require__(30596);
/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the local week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */
function getWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index4.default)(1, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var year = date.getFullYear();
  var defaultOptions = (0, _index5.getDefaultOptions)();
  var firstWeekContainsDate = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = (0, _index.default)(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = (0, _index.default)(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
module.exports = exports.default;

/***/ }),

/***/ 63030:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getWeeksInMonth;
var _index = _interopRequireDefault(__webpack_require__(79279));
var _index2 = _interopRequireDefault(__webpack_require__(8305));
var _index3 = _interopRequireDefault(__webpack_require__(63104));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getWeeksInMonth
 * @category Week Helpers
 * @summary Get the number of calendar weeks a month spans.
 *
 * @description
 * Get the number of calendar weeks the month in the given date spans.
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Number} the number of calendar weeks
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // How many calendar weeks does February 2015 span?
 * const result = getWeeksInMonth(new Date(2015, 1, 8))
 * //=> 4
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks does July 2017 span?
 * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })
 * //=> 6
 */
function getWeeksInMonth(date, options) {
  (0, _index4.default)(1, arguments);
  return (0, _index.default)((0, _index2.default)(date), (0, _index3.default)(date), options) + 1;
}
module.exports = exports.default;

/***/ }),

/***/ 69401:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which year is 2 July 2014?
 * const result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */
function getYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getFullYear();
}
module.exports = exports.default;

/***/ }),

/***/ 53100:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = hoursToMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name hoursToMilliseconds
 * @category  Conversion Helpers
 * @summary Convert hours to milliseconds.
 *
 * @description
 * Convert a number of hours to a full number of milliseconds.
 *
 * @param {number} hours - number of hours to be converted
 *
 * @returns {number} the number of hours converted to milliseconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 hours to milliseconds:
 * const result = hoursToMilliseconds(2)
 * //=> 7200000
 */
function hoursToMilliseconds(hours) {
  (0, _index.default)(1, arguments);
  return Math.floor(hours * _index2.millisecondsInHour);
}
module.exports = exports.default;

/***/ }),

/***/ 71495:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = hoursToMinutes;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name hoursToMinutes
 * @category Conversion Helpers
 * @summary Convert hours to minutes.
 *
 * @description
 * Convert a number of hours to a full number of minutes.
 *
 * @param {number} hours - number of hours to be converted
 *
 * @returns {number} the number of hours converted in minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 hours to minutes:
 * const result = hoursToMinutes(2)
 * //=> 120
 */
function hoursToMinutes(hours) {
  (0, _index.default)(1, arguments);
  return Math.floor(hours * _index2.minutesInHour);
}
module.exports = exports.default;

/***/ }),

/***/ 45469:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = hoursToSeconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name hoursToSeconds
 * @category Conversion Helpers
 * @summary Convert hours to seconds.
 *
 * @description
 * Convert a number of hours to a full number of seconds.
 *
 * @param {number} hours - number of hours to be converted
 *
 * @returns {number} the number of hours converted in seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 hours to seconds:
 * const result = hoursToSeconds(2)
 * //=> 7200
 */
function hoursToSeconds(hours) {
  (0, _index.default)(1, arguments);
  return Math.floor(hours * _index2.secondsInHour);
}
module.exports = exports.default;

/***/ }),

/***/ 66609:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _exportNames = {
  add: true,
  addBusinessDays: true,
  addDays: true,
  addHours: true,
  addISOWeekYears: true,
  addMilliseconds: true,
  addMinutes: true,
  addMonths: true,
  addQuarters: true,
  addSeconds: true,
  addWeeks: true,
  addYears: true,
  areIntervalsOverlapping: true,
  clamp: true,
  closestIndexTo: true,
  closestTo: true,
  compareAsc: true,
  compareDesc: true,
  daysToWeeks: true,
  differenceInBusinessDays: true,
  differenceInCalendarDays: true,
  differenceInCalendarISOWeekYears: true,
  differenceInCalendarISOWeeks: true,
  differenceInCalendarMonths: true,
  differenceInCalendarQuarters: true,
  differenceInCalendarWeeks: true,
  differenceInCalendarYears: true,
  differenceInDays: true,
  differenceInHours: true,
  differenceInISOWeekYears: true,
  differenceInMilliseconds: true,
  differenceInMinutes: true,
  differenceInMonths: true,
  differenceInQuarters: true,
  differenceInSeconds: true,
  differenceInWeeks: true,
  differenceInYears: true,
  eachDayOfInterval: true,
  eachHourOfInterval: true,
  eachMinuteOfInterval: true,
  eachMonthOfInterval: true,
  eachQuarterOfInterval: true,
  eachWeekOfInterval: true,
  eachWeekendOfInterval: true,
  eachWeekendOfMonth: true,
  eachWeekendOfYear: true,
  eachYearOfInterval: true,
  endOfDay: true,
  endOfDecade: true,
  endOfHour: true,
  endOfISOWeek: true,
  endOfISOWeekYear: true,
  endOfMinute: true,
  endOfMonth: true,
  endOfQuarter: true,
  endOfSecond: true,
  endOfToday: true,
  endOfTomorrow: true,
  endOfWeek: true,
  endOfYear: true,
  endOfYesterday: true,
  format: true,
  formatDistance: true,
  formatDistanceStrict: true,
  formatDistanceToNow: true,
  formatDistanceToNowStrict: true,
  formatDuration: true,
  formatISO: true,
  formatISO9075: true,
  formatISODuration: true,
  formatRFC3339: true,
  formatRFC7231: true,
  formatRelative: true,
  fromUnixTime: true,
  getDate: true,
  getDay: true,
  getDayOfYear: true,
  getDaysInMonth: true,
  getDaysInYear: true,
  getDecade: true,
  getDefaultOptions: true,
  getHours: true,
  getISODay: true,
  getISOWeek: true,
  getISOWeekYear: true,
  getISOWeeksInYear: true,
  getMilliseconds: true,
  getMinutes: true,
  getMonth: true,
  getOverlappingDaysInIntervals: true,
  getQuarter: true,
  getSeconds: true,
  getTime: true,
  getUnixTime: true,
  getWeek: true,
  getWeekOfMonth: true,
  getWeekYear: true,
  getWeeksInMonth: true,
  getYear: true,
  hoursToMilliseconds: true,
  hoursToMinutes: true,
  hoursToSeconds: true,
  intervalToDuration: true,
  intlFormat: true,
  intlFormatDistance: true,
  isAfter: true,
  isBefore: true,
  isDate: true,
  isEqual: true,
  isExists: true,
  isFirstDayOfMonth: true,
  isFriday: true,
  isFuture: true,
  isLastDayOfMonth: true,
  isLeapYear: true,
  isMatch: true,
  isMonday: true,
  isPast: true,
  isSameDay: true,
  isSameHour: true,
  isSameISOWeek: true,
  isSameISOWeekYear: true,
  isSameMinute: true,
  isSameMonth: true,
  isSameQuarter: true,
  isSameSecond: true,
  isSameWeek: true,
  isSameYear: true,
  isSaturday: true,
  isSunday: true,
  isThisHour: true,
  isThisISOWeek: true,
  isThisMinute: true,
  isThisMonth: true,
  isThisQuarter: true,
  isThisSecond: true,
  isThisWeek: true,
  isThisYear: true,
  isThursday: true,
  isToday: true,
  isTomorrow: true,
  isTuesday: true,
  isValid: true,
  isWednesday: true,
  isWeekend: true,
  isWithinInterval: true,
  isYesterday: true,
  lastDayOfDecade: true,
  lastDayOfISOWeek: true,
  lastDayOfISOWeekYear: true,
  lastDayOfMonth: true,
  lastDayOfQuarter: true,
  lastDayOfWeek: true,
  lastDayOfYear: true,
  lightFormat: true,
  max: true,
  milliseconds: true,
  millisecondsToHours: true,
  millisecondsToMinutes: true,
  millisecondsToSeconds: true,
  min: true,
  minutesToHours: true,
  minutesToMilliseconds: true,
  minutesToSeconds: true,
  monthsToQuarters: true,
  monthsToYears: true,
  nextDay: true,
  nextFriday: true,
  nextMonday: true,
  nextSaturday: true,
  nextSunday: true,
  nextThursday: true,
  nextTuesday: true,
  nextWednesday: true,
  parse: true,
  parseISO: true,
  parseJSON: true,
  previousDay: true,
  previousFriday: true,
  previousMonday: true,
  previousSaturday: true,
  previousSunday: true,
  previousThursday: true,
  previousTuesday: true,
  previousWednesday: true,
  quartersToMonths: true,
  quartersToYears: true,
  roundToNearestMinutes: true,
  secondsToHours: true,
  secondsToMilliseconds: true,
  secondsToMinutes: true,
  set: true,
  setDate: true,
  setDay: true,
  setDayOfYear: true,
  setDefaultOptions: true,
  setHours: true,
  setISODay: true,
  setISOWeek: true,
  setISOWeekYear: true,
  setMilliseconds: true,
  setMinutes: true,
  setMonth: true,
  setQuarter: true,
  setSeconds: true,
  setWeek: true,
  setWeekYear: true,
  setYear: true,
  startOfDay: true,
  startOfDecade: true,
  startOfHour: true,
  startOfISOWeek: true,
  startOfISOWeekYear: true,
  startOfMinute: true,
  startOfMonth: true,
  startOfQuarter: true,
  startOfSecond: true,
  startOfToday: true,
  startOfTomorrow: true,
  startOfWeek: true,
  startOfWeekYear: true,
  startOfYear: true,
  startOfYesterday: true,
  sub: true,
  subBusinessDays: true,
  subDays: true,
  subHours: true,
  subISOWeekYears: true,
  subMilliseconds: true,
  subMinutes: true,
  subMonths: true,
  subQuarters: true,
  subSeconds: true,
  subWeeks: true,
  subYears: true,
  toDate: true,
  weeksToDays: true,
  yearsToMonths: true,
  yearsToQuarters: true
};
Object.defineProperty(exports, "add", ({
  enumerable: true,
  get: function get() {
    return _index.default;
  }
}));
Object.defineProperty(exports, "addBusinessDays", ({
  enumerable: true,
  get: function get() {
    return _index2.default;
  }
}));
Object.defineProperty(exports, "addDays", ({
  enumerable: true,
  get: function get() {
    return _index3.default;
  }
}));
Object.defineProperty(exports, "addHours", ({
  enumerable: true,
  get: function get() {
    return _index4.default;
  }
}));
Object.defineProperty(exports, "addISOWeekYears", ({
  enumerable: true,
  get: function get() {
    return _index5.default;
  }
}));
Object.defineProperty(exports, "addMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index6.default;
  }
}));
Object.defineProperty(exports, "addMinutes", ({
  enumerable: true,
  get: function get() {
    return _index7.default;
  }
}));
Object.defineProperty(exports, "addMonths", ({
  enumerable: true,
  get: function get() {
    return _index8.default;
  }
}));
Object.defineProperty(exports, "addQuarters", ({
  enumerable: true,
  get: function get() {
    return _index9.default;
  }
}));
Object.defineProperty(exports, "addSeconds", ({
  enumerable: true,
  get: function get() {
    return _index10.default;
  }
}));
Object.defineProperty(exports, "addWeeks", ({
  enumerable: true,
  get: function get() {
    return _index11.default;
  }
}));
Object.defineProperty(exports, "addYears", ({
  enumerable: true,
  get: function get() {
    return _index12.default;
  }
}));
Object.defineProperty(exports, "areIntervalsOverlapping", ({
  enumerable: true,
  get: function get() {
    return _index13.default;
  }
}));
Object.defineProperty(exports, "clamp", ({
  enumerable: true,
  get: function get() {
    return _index14.default;
  }
}));
Object.defineProperty(exports, "closestIndexTo", ({
  enumerable: true,
  get: function get() {
    return _index15.default;
  }
}));
Object.defineProperty(exports, "closestTo", ({
  enumerable: true,
  get: function get() {
    return _index16.default;
  }
}));
Object.defineProperty(exports, "compareAsc", ({
  enumerable: true,
  get: function get() {
    return _index17.default;
  }
}));
Object.defineProperty(exports, "compareDesc", ({
  enumerable: true,
  get: function get() {
    return _index18.default;
  }
}));
Object.defineProperty(exports, "daysToWeeks", ({
  enumerable: true,
  get: function get() {
    return _index19.default;
  }
}));
Object.defineProperty(exports, "differenceInBusinessDays", ({
  enumerable: true,
  get: function get() {
    return _index20.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarDays", ({
  enumerable: true,
  get: function get() {
    return _index21.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarISOWeekYears", ({
  enumerable: true,
  get: function get() {
    return _index22.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarISOWeeks", ({
  enumerable: true,
  get: function get() {
    return _index23.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarMonths", ({
  enumerable: true,
  get: function get() {
    return _index24.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarQuarters", ({
  enumerable: true,
  get: function get() {
    return _index25.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarWeeks", ({
  enumerable: true,
  get: function get() {
    return _index26.default;
  }
}));
Object.defineProperty(exports, "differenceInCalendarYears", ({
  enumerable: true,
  get: function get() {
    return _index27.default;
  }
}));
Object.defineProperty(exports, "differenceInDays", ({
  enumerable: true,
  get: function get() {
    return _index28.default;
  }
}));
Object.defineProperty(exports, "differenceInHours", ({
  enumerable: true,
  get: function get() {
    return _index29.default;
  }
}));
Object.defineProperty(exports, "differenceInISOWeekYears", ({
  enumerable: true,
  get: function get() {
    return _index30.default;
  }
}));
Object.defineProperty(exports, "differenceInMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index31.default;
  }
}));
Object.defineProperty(exports, "differenceInMinutes", ({
  enumerable: true,
  get: function get() {
    return _index32.default;
  }
}));
Object.defineProperty(exports, "differenceInMonths", ({
  enumerable: true,
  get: function get() {
    return _index33.default;
  }
}));
Object.defineProperty(exports, "differenceInQuarters", ({
  enumerable: true,
  get: function get() {
    return _index34.default;
  }
}));
Object.defineProperty(exports, "differenceInSeconds", ({
  enumerable: true,
  get: function get() {
    return _index35.default;
  }
}));
Object.defineProperty(exports, "differenceInWeeks", ({
  enumerable: true,
  get: function get() {
    return _index36.default;
  }
}));
Object.defineProperty(exports, "differenceInYears", ({
  enumerable: true,
  get: function get() {
    return _index37.default;
  }
}));
Object.defineProperty(exports, "eachDayOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index38.default;
  }
}));
Object.defineProperty(exports, "eachHourOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index39.default;
  }
}));
Object.defineProperty(exports, "eachMinuteOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index40.default;
  }
}));
Object.defineProperty(exports, "eachMonthOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index41.default;
  }
}));
Object.defineProperty(exports, "eachQuarterOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index42.default;
  }
}));
Object.defineProperty(exports, "eachWeekOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index43.default;
  }
}));
Object.defineProperty(exports, "eachWeekendOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index44.default;
  }
}));
Object.defineProperty(exports, "eachWeekendOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index45.default;
  }
}));
Object.defineProperty(exports, "eachWeekendOfYear", ({
  enumerable: true,
  get: function get() {
    return _index46.default;
  }
}));
Object.defineProperty(exports, "eachYearOfInterval", ({
  enumerable: true,
  get: function get() {
    return _index47.default;
  }
}));
Object.defineProperty(exports, "endOfDay", ({
  enumerable: true,
  get: function get() {
    return _index48.default;
  }
}));
Object.defineProperty(exports, "endOfDecade", ({
  enumerable: true,
  get: function get() {
    return _index49.default;
  }
}));
Object.defineProperty(exports, "endOfHour", ({
  enumerable: true,
  get: function get() {
    return _index50.default;
  }
}));
Object.defineProperty(exports, "endOfISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index51.default;
  }
}));
Object.defineProperty(exports, "endOfISOWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index52.default;
  }
}));
Object.defineProperty(exports, "endOfMinute", ({
  enumerable: true,
  get: function get() {
    return _index53.default;
  }
}));
Object.defineProperty(exports, "endOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index54.default;
  }
}));
Object.defineProperty(exports, "endOfQuarter", ({
  enumerable: true,
  get: function get() {
    return _index55.default;
  }
}));
Object.defineProperty(exports, "endOfSecond", ({
  enumerable: true,
  get: function get() {
    return _index56.default;
  }
}));
Object.defineProperty(exports, "endOfToday", ({
  enumerable: true,
  get: function get() {
    return _index57.default;
  }
}));
Object.defineProperty(exports, "endOfTomorrow", ({
  enumerable: true,
  get: function get() {
    return _index58.default;
  }
}));
Object.defineProperty(exports, "endOfWeek", ({
  enumerable: true,
  get: function get() {
    return _index59.default;
  }
}));
Object.defineProperty(exports, "endOfYear", ({
  enumerable: true,
  get: function get() {
    return _index60.default;
  }
}));
Object.defineProperty(exports, "endOfYesterday", ({
  enumerable: true,
  get: function get() {
    return _index61.default;
  }
}));
Object.defineProperty(exports, "format", ({
  enumerable: true,
  get: function get() {
    return _index62.default;
  }
}));
Object.defineProperty(exports, "formatDistance", ({
  enumerable: true,
  get: function get() {
    return _index63.default;
  }
}));
Object.defineProperty(exports, "formatDistanceStrict", ({
  enumerable: true,
  get: function get() {
    return _index64.default;
  }
}));
Object.defineProperty(exports, "formatDistanceToNow", ({
  enumerable: true,
  get: function get() {
    return _index65.default;
  }
}));
Object.defineProperty(exports, "formatDistanceToNowStrict", ({
  enumerable: true,
  get: function get() {
    return _index66.default;
  }
}));
Object.defineProperty(exports, "formatDuration", ({
  enumerable: true,
  get: function get() {
    return _index67.default;
  }
}));
Object.defineProperty(exports, "formatISO", ({
  enumerable: true,
  get: function get() {
    return _index68.default;
  }
}));
Object.defineProperty(exports, "formatISO9075", ({
  enumerable: true,
  get: function get() {
    return _index69.default;
  }
}));
Object.defineProperty(exports, "formatISODuration", ({
  enumerable: true,
  get: function get() {
    return _index70.default;
  }
}));
Object.defineProperty(exports, "formatRFC3339", ({
  enumerable: true,
  get: function get() {
    return _index71.default;
  }
}));
Object.defineProperty(exports, "formatRFC7231", ({
  enumerable: true,
  get: function get() {
    return _index72.default;
  }
}));
Object.defineProperty(exports, "formatRelative", ({
  enumerable: true,
  get: function get() {
    return _index73.default;
  }
}));
Object.defineProperty(exports, "fromUnixTime", ({
  enumerable: true,
  get: function get() {
    return _index74.default;
  }
}));
Object.defineProperty(exports, "getDate", ({
  enumerable: true,
  get: function get() {
    return _index75.default;
  }
}));
Object.defineProperty(exports, "getDay", ({
  enumerable: true,
  get: function get() {
    return _index76.default;
  }
}));
Object.defineProperty(exports, "getDayOfYear", ({
  enumerable: true,
  get: function get() {
    return _index77.default;
  }
}));
Object.defineProperty(exports, "getDaysInMonth", ({
  enumerable: true,
  get: function get() {
    return _index78.default;
  }
}));
Object.defineProperty(exports, "getDaysInYear", ({
  enumerable: true,
  get: function get() {
    return _index79.default;
  }
}));
Object.defineProperty(exports, "getDecade", ({
  enumerable: true,
  get: function get() {
    return _index80.default;
  }
}));
Object.defineProperty(exports, "getDefaultOptions", ({
  enumerable: true,
  get: function get() {
    return _index81.default;
  }
}));
Object.defineProperty(exports, "getHours", ({
  enumerable: true,
  get: function get() {
    return _index82.default;
  }
}));
Object.defineProperty(exports, "getISODay", ({
  enumerable: true,
  get: function get() {
    return _index83.default;
  }
}));
Object.defineProperty(exports, "getISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index84.default;
  }
}));
Object.defineProperty(exports, "getISOWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index85.default;
  }
}));
Object.defineProperty(exports, "getISOWeeksInYear", ({
  enumerable: true,
  get: function get() {
    return _index86.default;
  }
}));
Object.defineProperty(exports, "getMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index87.default;
  }
}));
Object.defineProperty(exports, "getMinutes", ({
  enumerable: true,
  get: function get() {
    return _index88.default;
  }
}));
Object.defineProperty(exports, "getMonth", ({
  enumerable: true,
  get: function get() {
    return _index89.default;
  }
}));
Object.defineProperty(exports, "getOverlappingDaysInIntervals", ({
  enumerable: true,
  get: function get() {
    return _index90.default;
  }
}));
Object.defineProperty(exports, "getQuarter", ({
  enumerable: true,
  get: function get() {
    return _index91.default;
  }
}));
Object.defineProperty(exports, "getSeconds", ({
  enumerable: true,
  get: function get() {
    return _index92.default;
  }
}));
Object.defineProperty(exports, "getTime", ({
  enumerable: true,
  get: function get() {
    return _index93.default;
  }
}));
Object.defineProperty(exports, "getUnixTime", ({
  enumerable: true,
  get: function get() {
    return _index94.default;
  }
}));
Object.defineProperty(exports, "getWeek", ({
  enumerable: true,
  get: function get() {
    return _index95.default;
  }
}));
Object.defineProperty(exports, "getWeekOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index96.default;
  }
}));
Object.defineProperty(exports, "getWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index97.default;
  }
}));
Object.defineProperty(exports, "getWeeksInMonth", ({
  enumerable: true,
  get: function get() {
    return _index98.default;
  }
}));
Object.defineProperty(exports, "getYear", ({
  enumerable: true,
  get: function get() {
    return _index99.default;
  }
}));
Object.defineProperty(exports, "hoursToMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index100.default;
  }
}));
Object.defineProperty(exports, "hoursToMinutes", ({
  enumerable: true,
  get: function get() {
    return _index101.default;
  }
}));
Object.defineProperty(exports, "hoursToSeconds", ({
  enumerable: true,
  get: function get() {
    return _index102.default;
  }
}));
Object.defineProperty(exports, "intervalToDuration", ({
  enumerable: true,
  get: function get() {
    return _index103.default;
  }
}));
Object.defineProperty(exports, "intlFormat", ({
  enumerable: true,
  get: function get() {
    return _index104.default;
  }
}));
Object.defineProperty(exports, "intlFormatDistance", ({
  enumerable: true,
  get: function get() {
    return _index105.default;
  }
}));
Object.defineProperty(exports, "isAfter", ({
  enumerable: true,
  get: function get() {
    return _index106.default;
  }
}));
Object.defineProperty(exports, "isBefore", ({
  enumerable: true,
  get: function get() {
    return _index107.default;
  }
}));
Object.defineProperty(exports, "isDate", ({
  enumerable: true,
  get: function get() {
    return _index108.default;
  }
}));
Object.defineProperty(exports, "isEqual", ({
  enumerable: true,
  get: function get() {
    return _index109.default;
  }
}));
Object.defineProperty(exports, "isExists", ({
  enumerable: true,
  get: function get() {
    return _index110.default;
  }
}));
Object.defineProperty(exports, "isFirstDayOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index111.default;
  }
}));
Object.defineProperty(exports, "isFriday", ({
  enumerable: true,
  get: function get() {
    return _index112.default;
  }
}));
Object.defineProperty(exports, "isFuture", ({
  enumerable: true,
  get: function get() {
    return _index113.default;
  }
}));
Object.defineProperty(exports, "isLastDayOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index114.default;
  }
}));
Object.defineProperty(exports, "isLeapYear", ({
  enumerable: true,
  get: function get() {
    return _index115.default;
  }
}));
Object.defineProperty(exports, "isMatch", ({
  enumerable: true,
  get: function get() {
    return _index116.default;
  }
}));
Object.defineProperty(exports, "isMonday", ({
  enumerable: true,
  get: function get() {
    return _index117.default;
  }
}));
Object.defineProperty(exports, "isPast", ({
  enumerable: true,
  get: function get() {
    return _index118.default;
  }
}));
Object.defineProperty(exports, "isSameDay", ({
  enumerable: true,
  get: function get() {
    return _index119.default;
  }
}));
Object.defineProperty(exports, "isSameHour", ({
  enumerable: true,
  get: function get() {
    return _index120.default;
  }
}));
Object.defineProperty(exports, "isSameISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index121.default;
  }
}));
Object.defineProperty(exports, "isSameISOWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index122.default;
  }
}));
Object.defineProperty(exports, "isSameMinute", ({
  enumerable: true,
  get: function get() {
    return _index123.default;
  }
}));
Object.defineProperty(exports, "isSameMonth", ({
  enumerable: true,
  get: function get() {
    return _index124.default;
  }
}));
Object.defineProperty(exports, "isSameQuarter", ({
  enumerable: true,
  get: function get() {
    return _index125.default;
  }
}));
Object.defineProperty(exports, "isSameSecond", ({
  enumerable: true,
  get: function get() {
    return _index126.default;
  }
}));
Object.defineProperty(exports, "isSameWeek", ({
  enumerable: true,
  get: function get() {
    return _index127.default;
  }
}));
Object.defineProperty(exports, "isSameYear", ({
  enumerable: true,
  get: function get() {
    return _index128.default;
  }
}));
Object.defineProperty(exports, "isSaturday", ({
  enumerable: true,
  get: function get() {
    return _index129.default;
  }
}));
Object.defineProperty(exports, "isSunday", ({
  enumerable: true,
  get: function get() {
    return _index130.default;
  }
}));
Object.defineProperty(exports, "isThisHour", ({
  enumerable: true,
  get: function get() {
    return _index131.default;
  }
}));
Object.defineProperty(exports, "isThisISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index132.default;
  }
}));
Object.defineProperty(exports, "isThisMinute", ({
  enumerable: true,
  get: function get() {
    return _index133.default;
  }
}));
Object.defineProperty(exports, "isThisMonth", ({
  enumerable: true,
  get: function get() {
    return _index134.default;
  }
}));
Object.defineProperty(exports, "isThisQuarter", ({
  enumerable: true,
  get: function get() {
    return _index135.default;
  }
}));
Object.defineProperty(exports, "isThisSecond", ({
  enumerable: true,
  get: function get() {
    return _index136.default;
  }
}));
Object.defineProperty(exports, "isThisWeek", ({
  enumerable: true,
  get: function get() {
    return _index137.default;
  }
}));
Object.defineProperty(exports, "isThisYear", ({
  enumerable: true,
  get: function get() {
    return _index138.default;
  }
}));
Object.defineProperty(exports, "isThursday", ({
  enumerable: true,
  get: function get() {
    return _index139.default;
  }
}));
Object.defineProperty(exports, "isToday", ({
  enumerable: true,
  get: function get() {
    return _index140.default;
  }
}));
Object.defineProperty(exports, "isTomorrow", ({
  enumerable: true,
  get: function get() {
    return _index141.default;
  }
}));
Object.defineProperty(exports, "isTuesday", ({
  enumerable: true,
  get: function get() {
    return _index142.default;
  }
}));
Object.defineProperty(exports, "isValid", ({
  enumerable: true,
  get: function get() {
    return _index143.default;
  }
}));
Object.defineProperty(exports, "isWednesday", ({
  enumerable: true,
  get: function get() {
    return _index144.default;
  }
}));
Object.defineProperty(exports, "isWeekend", ({
  enumerable: true,
  get: function get() {
    return _index145.default;
  }
}));
Object.defineProperty(exports, "isWithinInterval", ({
  enumerable: true,
  get: function get() {
    return _index146.default;
  }
}));
Object.defineProperty(exports, "isYesterday", ({
  enumerable: true,
  get: function get() {
    return _index147.default;
  }
}));
Object.defineProperty(exports, "lastDayOfDecade", ({
  enumerable: true,
  get: function get() {
    return _index148.default;
  }
}));
Object.defineProperty(exports, "lastDayOfISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index149.default;
  }
}));
Object.defineProperty(exports, "lastDayOfISOWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index150.default;
  }
}));
Object.defineProperty(exports, "lastDayOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index151.default;
  }
}));
Object.defineProperty(exports, "lastDayOfQuarter", ({
  enumerable: true,
  get: function get() {
    return _index152.default;
  }
}));
Object.defineProperty(exports, "lastDayOfWeek", ({
  enumerable: true,
  get: function get() {
    return _index153.default;
  }
}));
Object.defineProperty(exports, "lastDayOfYear", ({
  enumerable: true,
  get: function get() {
    return _index154.default;
  }
}));
Object.defineProperty(exports, "lightFormat", ({
  enumerable: true,
  get: function get() {
    return _index155.default;
  }
}));
Object.defineProperty(exports, "max", ({
  enumerable: true,
  get: function get() {
    return _index156.default;
  }
}));
Object.defineProperty(exports, "milliseconds", ({
  enumerable: true,
  get: function get() {
    return _index157.default;
  }
}));
Object.defineProperty(exports, "millisecondsToHours", ({
  enumerable: true,
  get: function get() {
    return _index158.default;
  }
}));
Object.defineProperty(exports, "millisecondsToMinutes", ({
  enumerable: true,
  get: function get() {
    return _index159.default;
  }
}));
Object.defineProperty(exports, "millisecondsToSeconds", ({
  enumerable: true,
  get: function get() {
    return _index160.default;
  }
}));
Object.defineProperty(exports, "min", ({
  enumerable: true,
  get: function get() {
    return _index161.default;
  }
}));
Object.defineProperty(exports, "minutesToHours", ({
  enumerable: true,
  get: function get() {
    return _index162.default;
  }
}));
Object.defineProperty(exports, "minutesToMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index163.default;
  }
}));
Object.defineProperty(exports, "minutesToSeconds", ({
  enumerable: true,
  get: function get() {
    return _index164.default;
  }
}));
Object.defineProperty(exports, "monthsToQuarters", ({
  enumerable: true,
  get: function get() {
    return _index165.default;
  }
}));
Object.defineProperty(exports, "monthsToYears", ({
  enumerable: true,
  get: function get() {
    return _index166.default;
  }
}));
Object.defineProperty(exports, "nextDay", ({
  enumerable: true,
  get: function get() {
    return _index167.default;
  }
}));
Object.defineProperty(exports, "nextFriday", ({
  enumerable: true,
  get: function get() {
    return _index168.default;
  }
}));
Object.defineProperty(exports, "nextMonday", ({
  enumerable: true,
  get: function get() {
    return _index169.default;
  }
}));
Object.defineProperty(exports, "nextSaturday", ({
  enumerable: true,
  get: function get() {
    return _index170.default;
  }
}));
Object.defineProperty(exports, "nextSunday", ({
  enumerable: true,
  get: function get() {
    return _index171.default;
  }
}));
Object.defineProperty(exports, "nextThursday", ({
  enumerable: true,
  get: function get() {
    return _index172.default;
  }
}));
Object.defineProperty(exports, "nextTuesday", ({
  enumerable: true,
  get: function get() {
    return _index173.default;
  }
}));
Object.defineProperty(exports, "nextWednesday", ({
  enumerable: true,
  get: function get() {
    return _index174.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function get() {
    return _index175.default;
  }
}));
Object.defineProperty(exports, "parseISO", ({
  enumerable: true,
  get: function get() {
    return _index176.default;
  }
}));
Object.defineProperty(exports, "parseJSON", ({
  enumerable: true,
  get: function get() {
    return _index177.default;
  }
}));
Object.defineProperty(exports, "previousDay", ({
  enumerable: true,
  get: function get() {
    return _index178.default;
  }
}));
Object.defineProperty(exports, "previousFriday", ({
  enumerable: true,
  get: function get() {
    return _index179.default;
  }
}));
Object.defineProperty(exports, "previousMonday", ({
  enumerable: true,
  get: function get() {
    return _index180.default;
  }
}));
Object.defineProperty(exports, "previousSaturday", ({
  enumerable: true,
  get: function get() {
    return _index181.default;
  }
}));
Object.defineProperty(exports, "previousSunday", ({
  enumerable: true,
  get: function get() {
    return _index182.default;
  }
}));
Object.defineProperty(exports, "previousThursday", ({
  enumerable: true,
  get: function get() {
    return _index183.default;
  }
}));
Object.defineProperty(exports, "previousTuesday", ({
  enumerable: true,
  get: function get() {
    return _index184.default;
  }
}));
Object.defineProperty(exports, "previousWednesday", ({
  enumerable: true,
  get: function get() {
    return _index185.default;
  }
}));
Object.defineProperty(exports, "quartersToMonths", ({
  enumerable: true,
  get: function get() {
    return _index186.default;
  }
}));
Object.defineProperty(exports, "quartersToYears", ({
  enumerable: true,
  get: function get() {
    return _index187.default;
  }
}));
Object.defineProperty(exports, "roundToNearestMinutes", ({
  enumerable: true,
  get: function get() {
    return _index188.default;
  }
}));
Object.defineProperty(exports, "secondsToHours", ({
  enumerable: true,
  get: function get() {
    return _index189.default;
  }
}));
Object.defineProperty(exports, "secondsToMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index190.default;
  }
}));
Object.defineProperty(exports, "secondsToMinutes", ({
  enumerable: true,
  get: function get() {
    return _index191.default;
  }
}));
Object.defineProperty(exports, "set", ({
  enumerable: true,
  get: function get() {
    return _index192.default;
  }
}));
Object.defineProperty(exports, "setDate", ({
  enumerable: true,
  get: function get() {
    return _index193.default;
  }
}));
Object.defineProperty(exports, "setDay", ({
  enumerable: true,
  get: function get() {
    return _index194.default;
  }
}));
Object.defineProperty(exports, "setDayOfYear", ({
  enumerable: true,
  get: function get() {
    return _index195.default;
  }
}));
Object.defineProperty(exports, "setDefaultOptions", ({
  enumerable: true,
  get: function get() {
    return _index196.default;
  }
}));
Object.defineProperty(exports, "setHours", ({
  enumerable: true,
  get: function get() {
    return _index197.default;
  }
}));
Object.defineProperty(exports, "setISODay", ({
  enumerable: true,
  get: function get() {
    return _index198.default;
  }
}));
Object.defineProperty(exports, "setISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index199.default;
  }
}));
Object.defineProperty(exports, "setISOWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index200.default;
  }
}));
Object.defineProperty(exports, "setMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index201.default;
  }
}));
Object.defineProperty(exports, "setMinutes", ({
  enumerable: true,
  get: function get() {
    return _index202.default;
  }
}));
Object.defineProperty(exports, "setMonth", ({
  enumerable: true,
  get: function get() {
    return _index203.default;
  }
}));
Object.defineProperty(exports, "setQuarter", ({
  enumerable: true,
  get: function get() {
    return _index204.default;
  }
}));
Object.defineProperty(exports, "setSeconds", ({
  enumerable: true,
  get: function get() {
    return _index205.default;
  }
}));
Object.defineProperty(exports, "setWeek", ({
  enumerable: true,
  get: function get() {
    return _index206.default;
  }
}));
Object.defineProperty(exports, "setWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index207.default;
  }
}));
Object.defineProperty(exports, "setYear", ({
  enumerable: true,
  get: function get() {
    return _index208.default;
  }
}));
Object.defineProperty(exports, "startOfDay", ({
  enumerable: true,
  get: function get() {
    return _index209.default;
  }
}));
Object.defineProperty(exports, "startOfDecade", ({
  enumerable: true,
  get: function get() {
    return _index210.default;
  }
}));
Object.defineProperty(exports, "startOfHour", ({
  enumerable: true,
  get: function get() {
    return _index211.default;
  }
}));
Object.defineProperty(exports, "startOfISOWeek", ({
  enumerable: true,
  get: function get() {
    return _index212.default;
  }
}));
Object.defineProperty(exports, "startOfISOWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index213.default;
  }
}));
Object.defineProperty(exports, "startOfMinute", ({
  enumerable: true,
  get: function get() {
    return _index214.default;
  }
}));
Object.defineProperty(exports, "startOfMonth", ({
  enumerable: true,
  get: function get() {
    return _index215.default;
  }
}));
Object.defineProperty(exports, "startOfQuarter", ({
  enumerable: true,
  get: function get() {
    return _index216.default;
  }
}));
Object.defineProperty(exports, "startOfSecond", ({
  enumerable: true,
  get: function get() {
    return _index217.default;
  }
}));
Object.defineProperty(exports, "startOfToday", ({
  enumerable: true,
  get: function get() {
    return _index218.default;
  }
}));
Object.defineProperty(exports, "startOfTomorrow", ({
  enumerable: true,
  get: function get() {
    return _index219.default;
  }
}));
Object.defineProperty(exports, "startOfWeek", ({
  enumerable: true,
  get: function get() {
    return _index220.default;
  }
}));
Object.defineProperty(exports, "startOfWeekYear", ({
  enumerable: true,
  get: function get() {
    return _index221.default;
  }
}));
Object.defineProperty(exports, "startOfYear", ({
  enumerable: true,
  get: function get() {
    return _index222.default;
  }
}));
Object.defineProperty(exports, "startOfYesterday", ({
  enumerable: true,
  get: function get() {
    return _index223.default;
  }
}));
Object.defineProperty(exports, "sub", ({
  enumerable: true,
  get: function get() {
    return _index224.default;
  }
}));
Object.defineProperty(exports, "subBusinessDays", ({
  enumerable: true,
  get: function get() {
    return _index225.default;
  }
}));
Object.defineProperty(exports, "subDays", ({
  enumerable: true,
  get: function get() {
    return _index226.default;
  }
}));
Object.defineProperty(exports, "subHours", ({
  enumerable: true,
  get: function get() {
    return _index227.default;
  }
}));
Object.defineProperty(exports, "subISOWeekYears", ({
  enumerable: true,
  get: function get() {
    return _index228.default;
  }
}));
Object.defineProperty(exports, "subMilliseconds", ({
  enumerable: true,
  get: function get() {
    return _index229.default;
  }
}));
Object.defineProperty(exports, "subMinutes", ({
  enumerable: true,
  get: function get() {
    return _index230.default;
  }
}));
Object.defineProperty(exports, "subMonths", ({
  enumerable: true,
  get: function get() {
    return _index231.default;
  }
}));
Object.defineProperty(exports, "subQuarters", ({
  enumerable: true,
  get: function get() {
    return _index232.default;
  }
}));
Object.defineProperty(exports, "subSeconds", ({
  enumerable: true,
  get: function get() {
    return _index233.default;
  }
}));
Object.defineProperty(exports, "subWeeks", ({
  enumerable: true,
  get: function get() {
    return _index234.default;
  }
}));
Object.defineProperty(exports, "subYears", ({
  enumerable: true,
  get: function get() {
    return _index235.default;
  }
}));
Object.defineProperty(exports, "toDate", ({
  enumerable: true,
  get: function get() {
    return _index236.default;
  }
}));
Object.defineProperty(exports, "weeksToDays", ({
  enumerable: true,
  get: function get() {
    return _index237.default;
  }
}));
Object.defineProperty(exports, "yearsToMonths", ({
  enumerable: true,
  get: function get() {
    return _index238.default;
  }
}));
Object.defineProperty(exports, "yearsToQuarters", ({
  enumerable: true,
  get: function get() {
    return _index239.default;
  }
}));
var _index = _interopRequireDefault(__webpack_require__(49639));
var _index2 = _interopRequireDefault(__webpack_require__(42975));
var _index3 = _interopRequireDefault(__webpack_require__(83530));
var _index4 = _interopRequireDefault(__webpack_require__(43462));
var _index5 = _interopRequireDefault(__webpack_require__(17006));
var _index6 = _interopRequireDefault(__webpack_require__(11098));
var _index7 = _interopRequireDefault(__webpack_require__(98958));
var _index8 = _interopRequireDefault(__webpack_require__(86069));
var _index9 = _interopRequireDefault(__webpack_require__(75633));
var _index10 = _interopRequireDefault(__webpack_require__(87344));
var _index11 = _interopRequireDefault(__webpack_require__(11237));
var _index12 = _interopRequireDefault(__webpack_require__(66291));
var _index13 = _interopRequireDefault(__webpack_require__(17814));
var _index14 = _interopRequireDefault(__webpack_require__(96050));
var _index15 = _interopRequireDefault(__webpack_require__(48557));
var _index16 = _interopRequireDefault(__webpack_require__(7215));
var _index17 = _interopRequireDefault(__webpack_require__(74876));
var _index18 = _interopRequireDefault(__webpack_require__(93711));
var _index19 = _interopRequireDefault(__webpack_require__(17911));
var _index20 = _interopRequireDefault(__webpack_require__(36630));
var _index21 = _interopRequireDefault(__webpack_require__(64618));
var _index22 = _interopRequireDefault(__webpack_require__(67507));
var _index23 = _interopRequireDefault(__webpack_require__(53428));
var _index24 = _interopRequireDefault(__webpack_require__(86223));
var _index25 = _interopRequireDefault(__webpack_require__(41222));
var _index26 = _interopRequireDefault(__webpack_require__(79279));
var _index27 = _interopRequireDefault(__webpack_require__(75921));
var _index28 = _interopRequireDefault(__webpack_require__(93688));
var _index29 = _interopRequireDefault(__webpack_require__(23815));
var _index30 = _interopRequireDefault(__webpack_require__(45018));
var _index31 = _interopRequireDefault(__webpack_require__(86213));
var _index32 = _interopRequireDefault(__webpack_require__(98970));
var _index33 = _interopRequireDefault(__webpack_require__(63310));
var _index34 = _interopRequireDefault(__webpack_require__(96778));
var _index35 = _interopRequireDefault(__webpack_require__(6538));
var _index36 = _interopRequireDefault(__webpack_require__(40816));
var _index37 = _interopRequireDefault(__webpack_require__(15957));
var _index38 = _interopRequireDefault(__webpack_require__(20242));
var _index39 = _interopRequireDefault(__webpack_require__(46607));
var _index40 = _interopRequireDefault(__webpack_require__(52663));
var _index41 = _interopRequireDefault(__webpack_require__(81757));
var _index42 = _interopRequireDefault(__webpack_require__(97144));
var _index43 = _interopRequireDefault(__webpack_require__(14890));
var _index44 = _interopRequireDefault(__webpack_require__(59737));
var _index45 = _interopRequireDefault(__webpack_require__(72393));
var _index46 = _interopRequireDefault(__webpack_require__(76893));
var _index47 = _interopRequireDefault(__webpack_require__(3044));
var _index48 = _interopRequireDefault(__webpack_require__(62660));
var _index49 = _interopRequireDefault(__webpack_require__(27429));
var _index50 = _interopRequireDefault(__webpack_require__(47343));
var _index51 = _interopRequireDefault(__webpack_require__(12284));
var _index52 = _interopRequireDefault(__webpack_require__(41330));
var _index53 = _interopRequireDefault(__webpack_require__(21064));
var _index54 = _interopRequireDefault(__webpack_require__(74192));
var _index55 = _interopRequireDefault(__webpack_require__(56197));
var _index56 = _interopRequireDefault(__webpack_require__(32664));
var _index57 = _interopRequireDefault(__webpack_require__(4493));
var _index58 = _interopRequireDefault(__webpack_require__(41659));
var _index59 = _interopRequireDefault(__webpack_require__(28626));
var _index60 = _interopRequireDefault(__webpack_require__(356));
var _index61 = _interopRequireDefault(__webpack_require__(60390));
var _index62 = _interopRequireDefault(__webpack_require__(55076));
var _index63 = _interopRequireDefault(__webpack_require__(87280));
var _index64 = _interopRequireDefault(__webpack_require__(69359));
var _index65 = _interopRequireDefault(__webpack_require__(46683));
var _index66 = _interopRequireDefault(__webpack_require__(33160));
var _index67 = _interopRequireDefault(__webpack_require__(67208));
var _index68 = _interopRequireDefault(__webpack_require__(37002));
var _index69 = _interopRequireDefault(__webpack_require__(77665));
var _index70 = _interopRequireDefault(__webpack_require__(29906));
var _index71 = _interopRequireDefault(__webpack_require__(69697));
var _index72 = _interopRequireDefault(__webpack_require__(67840));
var _index73 = _interopRequireDefault(__webpack_require__(73613));
var _index74 = _interopRequireDefault(__webpack_require__(43804));
var _index75 = _interopRequireDefault(__webpack_require__(36471));
var _index76 = _interopRequireDefault(__webpack_require__(48461));
var _index77 = _interopRequireDefault(__webpack_require__(9374));
var _index78 = _interopRequireDefault(__webpack_require__(54223));
var _index79 = _interopRequireDefault(__webpack_require__(74418));
var _index80 = _interopRequireDefault(__webpack_require__(60219));
var _index81 = _interopRequireDefault(__webpack_require__(34269));
var _index82 = _interopRequireDefault(__webpack_require__(60026));
var _index83 = _interopRequireDefault(__webpack_require__(91655));
var _index84 = _interopRequireDefault(__webpack_require__(54343));
var _index85 = _interopRequireDefault(__webpack_require__(6874));
var _index86 = _interopRequireDefault(__webpack_require__(87569));
var _index87 = _interopRequireDefault(__webpack_require__(66600));
var _index88 = _interopRequireDefault(__webpack_require__(11802));
var _index89 = _interopRequireDefault(__webpack_require__(63983));
var _index90 = _interopRequireDefault(__webpack_require__(20039));
var _index91 = _interopRequireDefault(__webpack_require__(59164));
var _index92 = _interopRequireDefault(__webpack_require__(10648));
var _index93 = _interopRequireDefault(__webpack_require__(2018));
var _index94 = _interopRequireDefault(__webpack_require__(2761));
var _index95 = _interopRequireDefault(__webpack_require__(81507));
var _index96 = _interopRequireDefault(__webpack_require__(95322));
var _index97 = _interopRequireDefault(__webpack_require__(36878));
var _index98 = _interopRequireDefault(__webpack_require__(63030));
var _index99 = _interopRequireDefault(__webpack_require__(69401));
var _index100 = _interopRequireDefault(__webpack_require__(53100));
var _index101 = _interopRequireDefault(__webpack_require__(71495));
var _index102 = _interopRequireDefault(__webpack_require__(45469));
var _index103 = _interopRequireDefault(__webpack_require__(68023));
var _index104 = _interopRequireDefault(__webpack_require__(13740));
var _index105 = _interopRequireDefault(__webpack_require__(47207));
var _index106 = _interopRequireDefault(__webpack_require__(62845));
var _index107 = _interopRequireDefault(__webpack_require__(79621));
var _index108 = _interopRequireDefault(__webpack_require__(80370));
var _index109 = _interopRequireDefault(__webpack_require__(34871));
var _index110 = _interopRequireDefault(__webpack_require__(12079));
var _index111 = _interopRequireDefault(__webpack_require__(7397));
var _index112 = _interopRequireDefault(__webpack_require__(58008));
var _index113 = _interopRequireDefault(__webpack_require__(28150));
var _index114 = _interopRequireDefault(__webpack_require__(47072));
var _index115 = _interopRequireDefault(__webpack_require__(75501));
var _index116 = _interopRequireDefault(__webpack_require__(27577));
var _index117 = _interopRequireDefault(__webpack_require__(61258));
var _index118 = _interopRequireDefault(__webpack_require__(78040));
var _index119 = _interopRequireDefault(__webpack_require__(95795));
var _index120 = _interopRequireDefault(__webpack_require__(27638));
var _index121 = _interopRequireDefault(__webpack_require__(34656));
var _index122 = _interopRequireDefault(__webpack_require__(87728));
var _index123 = _interopRequireDefault(__webpack_require__(59444));
var _index124 = _interopRequireDefault(__webpack_require__(72875));
var _index125 = _interopRequireDefault(__webpack_require__(67446));
var _index126 = _interopRequireDefault(__webpack_require__(94797));
var _index127 = _interopRequireDefault(__webpack_require__(94522));
var _index128 = _interopRequireDefault(__webpack_require__(95177));
var _index129 = _interopRequireDefault(__webpack_require__(85104));
var _index130 = _interopRequireDefault(__webpack_require__(43889));
var _index131 = _interopRequireDefault(__webpack_require__(83746));
var _index132 = _interopRequireDefault(__webpack_require__(34511));
var _index133 = _interopRequireDefault(__webpack_require__(32174));
var _index134 = _interopRequireDefault(__webpack_require__(66059));
var _index135 = _interopRequireDefault(__webpack_require__(13047));
var _index136 = _interopRequireDefault(__webpack_require__(20905));
var _index137 = _interopRequireDefault(__webpack_require__(21424));
var _index138 = _interopRequireDefault(__webpack_require__(49371));
var _index139 = _interopRequireDefault(__webpack_require__(52168));
var _index140 = _interopRequireDefault(__webpack_require__(44058));
var _index141 = _interopRequireDefault(__webpack_require__(31713));
var _index142 = _interopRequireDefault(__webpack_require__(32325));
var _index143 = _interopRequireDefault(__webpack_require__(92401));
var _index144 = _interopRequireDefault(__webpack_require__(66968));
var _index145 = _interopRequireDefault(__webpack_require__(31125));
var _index146 = _interopRequireDefault(__webpack_require__(47379));
var _index147 = _interopRequireDefault(__webpack_require__(56721));
var _index148 = _interopRequireDefault(__webpack_require__(28540));
var _index149 = _interopRequireDefault(__webpack_require__(87749));
var _index150 = _interopRequireDefault(__webpack_require__(23522));
var _index151 = _interopRequireDefault(__webpack_require__(8305));
var _index152 = _interopRequireDefault(__webpack_require__(2721));
var _index153 = _interopRequireDefault(__webpack_require__(90407));
var _index154 = _interopRequireDefault(__webpack_require__(14123));
var _index155 = _interopRequireDefault(__webpack_require__(33938));
var _index156 = _interopRequireDefault(__webpack_require__(374));
var _index157 = _interopRequireDefault(__webpack_require__(47301));
var _index158 = _interopRequireDefault(__webpack_require__(74957));
var _index159 = _interopRequireDefault(__webpack_require__(85160));
var _index160 = _interopRequireDefault(__webpack_require__(70781));
var _index161 = _interopRequireDefault(__webpack_require__(32131));
var _index162 = _interopRequireDefault(__webpack_require__(23884));
var _index163 = _interopRequireDefault(__webpack_require__(25124));
var _index164 = _interopRequireDefault(__webpack_require__(50875));
var _index165 = _interopRequireDefault(__webpack_require__(59762));
var _index166 = _interopRequireDefault(__webpack_require__(96391));
var _index167 = _interopRequireDefault(__webpack_require__(58585));
var _index168 = _interopRequireDefault(__webpack_require__(13758));
var _index169 = _interopRequireDefault(__webpack_require__(79719));
var _index170 = _interopRequireDefault(__webpack_require__(69054));
var _index171 = _interopRequireDefault(__webpack_require__(81503));
var _index172 = _interopRequireDefault(__webpack_require__(42671));
var _index173 = _interopRequireDefault(__webpack_require__(85638));
var _index174 = _interopRequireDefault(__webpack_require__(57677));
var _index175 = _interopRequireDefault(__webpack_require__(53651));
var _index176 = _interopRequireDefault(__webpack_require__(20202));
var _index177 = _interopRequireDefault(__webpack_require__(48435));
var _index178 = _interopRequireDefault(__webpack_require__(79994));
var _index179 = _interopRequireDefault(__webpack_require__(87034));
var _index180 = _interopRequireDefault(__webpack_require__(78336));
var _index181 = _interopRequireDefault(__webpack_require__(59133));
var _index182 = _interopRequireDefault(__webpack_require__(14146));
var _index183 = _interopRequireDefault(__webpack_require__(22439));
var _index184 = _interopRequireDefault(__webpack_require__(36237));
var _index185 = _interopRequireDefault(__webpack_require__(28250));
var _index186 = _interopRequireDefault(__webpack_require__(22519));
var _index187 = _interopRequireDefault(__webpack_require__(77293));
var _index188 = _interopRequireDefault(__webpack_require__(62784));
var _index189 = _interopRequireDefault(__webpack_require__(7328));
var _index190 = _interopRequireDefault(__webpack_require__(17368));
var _index191 = _interopRequireDefault(__webpack_require__(7967));
var _index192 = _interopRequireDefault(__webpack_require__(71993));
var _index193 = _interopRequireDefault(__webpack_require__(69074));
var _index194 = _interopRequireDefault(__webpack_require__(20401));
var _index195 = _interopRequireDefault(__webpack_require__(70994));
var _index196 = _interopRequireDefault(__webpack_require__(13666));
var _index197 = _interopRequireDefault(__webpack_require__(39109));
var _index198 = _interopRequireDefault(__webpack_require__(1837));
var _index199 = _interopRequireDefault(__webpack_require__(17983));
var _index200 = _interopRequireDefault(__webpack_require__(75574));
var _index201 = _interopRequireDefault(__webpack_require__(61652));
var _index202 = _interopRequireDefault(__webpack_require__(37517));
var _index203 = _interopRequireDefault(__webpack_require__(7305));
var _index204 = _interopRequireDefault(__webpack_require__(40631));
var _index205 = _interopRequireDefault(__webpack_require__(11405));
var _index206 = _interopRequireDefault(__webpack_require__(12256));
var _index207 = _interopRequireDefault(__webpack_require__(35163));
var _index208 = _interopRequireDefault(__webpack_require__(51954));
var _index209 = _interopRequireDefault(__webpack_require__(87597));
var _index210 = _interopRequireDefault(__webpack_require__(84667));
var _index211 = _interopRequireDefault(__webpack_require__(18982));
var _index212 = _interopRequireDefault(__webpack_require__(38674));
var _index213 = _interopRequireDefault(__webpack_require__(4407));
var _index214 = _interopRequireDefault(__webpack_require__(10515));
var _index215 = _interopRequireDefault(__webpack_require__(63104));
var _index216 = _interopRequireDefault(__webpack_require__(20183));
var _index217 = _interopRequireDefault(__webpack_require__(70783));
var _index218 = _interopRequireDefault(__webpack_require__(63647));
var _index219 = _interopRequireDefault(__webpack_require__(16002));
var _index220 = _interopRequireDefault(__webpack_require__(11790));
var _index221 = _interopRequireDefault(__webpack_require__(70669));
var _index222 = _interopRequireDefault(__webpack_require__(69280));
var _index223 = _interopRequireDefault(__webpack_require__(58148));
var _index224 = _interopRequireDefault(__webpack_require__(93118));
var _index225 = _interopRequireDefault(__webpack_require__(4494));
var _index226 = _interopRequireDefault(__webpack_require__(48070));
var _index227 = _interopRequireDefault(__webpack_require__(73811));
var _index228 = _interopRequireDefault(__webpack_require__(11144));
var _index229 = _interopRequireDefault(__webpack_require__(2665));
var _index230 = _interopRequireDefault(__webpack_require__(45675));
var _index231 = _interopRequireDefault(__webpack_require__(898));
var _index232 = _interopRequireDefault(__webpack_require__(71384));
var _index233 = _interopRequireDefault(__webpack_require__(21881));
var _index234 = _interopRequireDefault(__webpack_require__(80276));
var _index235 = _interopRequireDefault(__webpack_require__(77493));
var _index236 = _interopRequireDefault(__webpack_require__(70107));
var _index237 = _interopRequireDefault(__webpack_require__(30803));
var _index238 = _interopRequireDefault(__webpack_require__(33821));
var _index239 = _interopRequireDefault(__webpack_require__(7370));
var _index240 = __webpack_require__(53372);
Object.keys(_index240).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index240[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index240[key];
    }
  });
});

/***/ }),

/***/ 68023:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = intervalToDuration;
var _index = _interopRequireDefault(__webpack_require__(74876));
var _index2 = _interopRequireDefault(__webpack_require__(49639));
var _index3 = _interopRequireDefault(__webpack_require__(93688));
var _index4 = _interopRequireDefault(__webpack_require__(23815));
var _index5 = _interopRequireDefault(__webpack_require__(98970));
var _index6 = _interopRequireDefault(__webpack_require__(63310));
var _index7 = _interopRequireDefault(__webpack_require__(6538));
var _index8 = _interopRequireDefault(__webpack_require__(15957));
var _index9 = _interopRequireDefault(__webpack_require__(70107));
var _index10 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name intervalToDuration
 * @category Common Helpers
 * @summary Convert interval to duration
 *
 * @description
 * Convert a interval object to a duration object.
 *
 * @param {Interval} interval - the interval to convert to duration
 *
 * @returns {Duration} The duration Object
 * @throws {TypeError} Requires 2 arguments
 * @throws {RangeError} `start` must not be Invalid Date
 * @throws {RangeError} `end` must not be Invalid Date
 *
 * @example
 * // Get the duration between January 15, 1929 and April 4, 1968.
 * intervalToDuration({
 *   start: new Date(1929, 0, 15, 12, 0, 0),
 *   end: new Date(1968, 3, 4, 19, 5, 0)
 * })
 * // => { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }
 */
function intervalToDuration(interval) {
  (0, _index10.default)(1, arguments);
  var start = (0, _index9.default)(interval.start);
  var end = (0, _index9.default)(interval.end);
  if (isNaN(start.getTime())) throw new RangeError('Start Date is invalid');
  if (isNaN(end.getTime())) throw new RangeError('End Date is invalid');
  var duration = {};
  duration.years = Math.abs((0, _index8.default)(end, start));
  var sign = (0, _index.default)(end, start);
  var remainingMonths = (0, _index2.default)(start, {
    years: sign * duration.years
  });
  duration.months = Math.abs((0, _index6.default)(end, remainingMonths));
  var remainingDays = (0, _index2.default)(remainingMonths, {
    months: sign * duration.months
  });
  duration.days = Math.abs((0, _index3.default)(end, remainingDays));
  var remainingHours = (0, _index2.default)(remainingDays, {
    days: sign * duration.days
  });
  duration.hours = Math.abs((0, _index4.default)(end, remainingHours));
  var remainingMinutes = (0, _index2.default)(remainingHours, {
    hours: sign * duration.hours
  });
  duration.minutes = Math.abs((0, _index5.default)(end, remainingMinutes));
  var remainingSeconds = (0, _index2.default)(remainingMinutes, {
    minutes: sign * duration.minutes
  });
  duration.seconds = Math.abs((0, _index7.default)(end, remainingSeconds));
  return duration;
}
module.exports = exports.default;

/***/ }),

/***/ 13740:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = intlFormat;
var _index = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name intlFormat
 * @category Common Helpers
 * @summary  Format the date with Intl.DateTimeFormat (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat).
 *
 * @description
 * Return the formatted date string in the given format.
 * The method uses [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat) inside.
 * formatOptions are the same as [`Intl.DateTimeFormat` options](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options)
 *
 * > ⚠️ Please note that before Node version 13.0.0, only the locale data for en-US is available by default.
 *
 * @param {Date|Number} argument - the original date.
 * @param {Object} [formatOptions] - an object with options.
 * @param {'lookup'|'best fit'} [formatOptions.localeMatcher='best fit'] - locale selection algorithm.
 * @param {'narrow'|'short'|'long'} [formatOptions.weekday] - representation the days of the week.
 * @param {'narrow'|'short'|'long'} [formatOptions.era] - representation of eras.
 * @param {'numeric'|'2-digit'} [formatOptions.year] - representation of years.
 * @param {'numeric'|'2-digit'|'narrow'|'short'|'long'} [formatOptions.month='numeric'] - representation of month.
 * @param {'numeric'|'2-digit'} [formatOptions.day='numeric'] - representation of day.
 * @param {'numeric'|'2-digit'} [formatOptions.hour='numeric'] - representation of hours.
 * @param {'numeric'|'2-digit'} [formatOptions.minute] - representation of minutes.
 * @param {'numeric'|'2-digit'} [formatOptions.second] - representation of seconds.
 * @param {'short'|'long'} [formatOptions.timeZoneName] - representation of names of time zones.
 * @param {'basic'|'best fit'} [formatOptions.formatMatcher='best fit'] - format selection algorithm.
 * @param {Boolean} [formatOptions.hour12] - determines whether to use 12-hour time format.
 * @param {String} [formatOptions.timeZone] - the time zone to use.
 * @param {Object} [localeOptions] - an object with locale.
 * @param {String|String[]} [localeOptions.locale] - the locale code
 * @returns {String} the formatted date string.
 * @throws {TypeError} 1 argument required.
 * @throws {RangeError} `date` must not be Invalid Date
 *
 * @example
 * // Represent 10 October 2019 in German.
 * // Convert the date with format's options and locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *      weekday: 'long',
 *      year: 'numeric',
 *      month: 'long',
 *      day: 'numeric',
 *    }, {
 *      locale: 'de-DE',
 *  })
 * //=> Freitag, 4. Oktober 2019
 *
 * @example
 * // Represent 10 October 2019.
 * // Convert the date with format's options.
 * const result = intlFormat.default(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *      year: 'numeric',
 *      month: 'numeric',
 *      day: 'numeric',
 *      hour: 'numeric',
 *  })
 * //=> 10/4/2019, 12 PM
 *
 * @example
 * // Represent 10 October 2019 in Korean.
 * // Convert the date with locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *      locale: 'ko-KR',
 *  })
 * //=> 2019. 10. 4.
 *
 * @example
 * // Represent 10 October 2019 in middle-endian format:
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456))
 * //=> 10/4/2019
 */
function intlFormat(date, formatOrLocale, localeOptions) {
  var _localeOptions;
  (0, _index.default)(1, arguments);
  var formatOptions;
  if (isFormatOptions(formatOrLocale)) {
    formatOptions = formatOrLocale;
  } else {
    localeOptions = formatOrLocale;
  }
  return new Intl.DateTimeFormat((_localeOptions = localeOptions) === null || _localeOptions === void 0 ? void 0 : _localeOptions.locale, formatOptions).format(date);
}
function isFormatOptions(opts) {
  return opts !== undefined && !('locale' in opts);
}
module.exports = exports.default;

/***/ }),

/***/ 47207:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = intlFormatDistance;
var _index = __webpack_require__(53372);
var _index2 = _interopRequireDefault(__webpack_require__(64618));
var _index3 = _interopRequireDefault(__webpack_require__(86223));
var _index4 = _interopRequireDefault(__webpack_require__(41222));
var _index5 = _interopRequireDefault(__webpack_require__(79279));
var _index6 = _interopRequireDefault(__webpack_require__(75921));
var _index7 = _interopRequireDefault(__webpack_require__(23815));
var _index8 = _interopRequireDefault(__webpack_require__(98970));
var _index9 = _interopRequireDefault(__webpack_require__(6538));
var _index10 = _interopRequireDefault(__webpack_require__(70107));
var _index11 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name intlFormatDistance
 * @category Common Helpers
 * @summary Formats distance between two dates in a human-readable format
 * @description
 * The function calculates the difference between two dates and formats it as a human-readable string.
 *
 * The function will pick the most appropriate unit depending on the distance between dates. For example, if the distance is a few hours, it might return `x hours`. If the distance is a few months, it might return `x months`.
 *
 * You can also specify a unit to force using it regardless of the distance to get a result like `123456 hours`.
 *
 * See the table below for the unit picking logic:
 *
 * | Distance between dates | Result (past)  | Result (future) |
 * | ---------------------- | -------------- | --------------- |
 * | 0 seconds              | now            | now             |
 * | 1-59 seconds           | X seconds ago  | in X seconds    |
 * | 1-59 minutes           | X minutes ago  | in X minutes    |
 * | 1-23 hours             | X hours ago    | in X hours      |
 * | 1 day                  | yesterday      | tomorrow        |
 * | 2-6 days               | X days ago     | in X days       |
 * | 7 days                 | last week      | next week       |
 * | 8 days-1 month         | X weeks ago    | in X weeks      |
 * | 1 month                | last month     | next month      |
 * | 2-3 months             | X months ago   | in X months     |
 * | 1 quarter              | last quarter   | next quarter    |
 * | 2-3 quarters           | X quarters ago | in X quarters   |
 * | 1 year                 | last year      | next year       |
 * | 2+ years               | X years ago    | in X years      |
 *
 * @param {Date|Number} date - the date
 * @param {Date|Number} baseDate - the date to compare with.
 * @param {Object} [options] - an object with options.
 * @param {String} [options.unit] - formats the distance with the given unit ('year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second').
 * @param {String|String[]} [options.locale] - the locale to use.
 * @param {String} [options.localeMatcher='best fit'] - the locale matching algorithm to use. Other value: 'lookup'.
 * See MDN for details [Locale identification and negotiation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)
 * @param {String} [options.numeric='auto'] - the output message format. The values are 'auto' (e.g. `yesterday`), 'always'(e.g. `1 day ago`).
 * @param {String} [options.style='long'] - the length of the result. The values are: 'long' (e.g. `1 month`), 'short' (e.g. 'in 1 mo.'), 'narrow' (e.g. 'in 1 mo.').
 * The narrow one could be similar to the short one for some locales.
 * @returns {String} the distance in words according to language-sensitive relative time formatting.
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `baseDate` must not be Invalid Date
 * @throws {RangeError} `options.unit` must not be invalid Unit
 * @throws {RangeError} `options.locale` must not be invalid locale
 * @throws {RangeError} `options.localeMatcher` must not be invalid localeMatcher
 * @throws {RangeError} `options.numeric` must not be invalid numeric
 * @throws {RangeError} `options.style` must not be invalid style
 *
 * @example
 * // What is the distance between the dates when the fist date is after the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0)
 * )
 * //=> 'in 1 hour'
 *
 * // What is the distance between the dates when the fist date is before the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0)
 * )
 * //=> '1 hour ago'
 *
 * @example
 * // Use the unit option to force the function to output the result in quarters. Without setting it, the example would return "next year"
 * intlFormatDistance(
 *   new Date(1987, 6, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { unit: 'quarter' }
 * )
 * //=> 'in 5 quarters'
 *
 * @example
 * // Use the locale option to get the result in Spanish. Without setting it, the example would return "in 1 hour".
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { locale: 'es' }
 * )
 * //=> 'dentro de 1 hora'
 *
 * @example
 * // Use the numeric option to force the function to use numeric values. Without setting it, the example would return "tomorrow".
 * intlFormatDistance(
 *   new Date(1986, 3, 5, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { numeric: 'always' }
 * )
 * //=> 'in 1 day'
 *
 * @example
 * // Use the style option to force the function to use short values. Without setting it, the example would return "in 2 years".
 * intlFormatDistance(
 *   new Date(1988, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { style: 'short' }
 * )
 * //=> 'in 2 yr'
 */
function intlFormatDistance(date, baseDate, options) {
  (0, _index11.default)(2, arguments);
  var value = 0;
  var unit;
  var dateLeft = (0, _index10.default)(date);
  var dateRight = (0, _index10.default)(baseDate);
  if (!(options !== null && options !== void 0 && options.unit)) {
    // Get the unit based on diffInSeconds calculations if no unit is specified
    var diffInSeconds = (0, _index9.default)(dateLeft, dateRight); // The smallest unit

    if (Math.abs(diffInSeconds) < _index.secondsInMinute) {
      value = (0, _index9.default)(dateLeft, dateRight);
      unit = 'second';
    } else if (Math.abs(diffInSeconds) < _index.secondsInHour) {
      value = (0, _index8.default)(dateLeft, dateRight);
      unit = 'minute';
    } else if (Math.abs(diffInSeconds) < _index.secondsInDay && Math.abs((0, _index2.default)(dateLeft, dateRight)) < 1) {
      value = (0, _index7.default)(dateLeft, dateRight);
      unit = 'hour';
    } else if (Math.abs(diffInSeconds) < _index.secondsInWeek && (value = (0, _index2.default)(dateLeft, dateRight)) && Math.abs(value) < 7) {
      unit = 'day';
    } else if (Math.abs(diffInSeconds) < _index.secondsInMonth) {
      value = (0, _index5.default)(dateLeft, dateRight);
      unit = 'week';
    } else if (Math.abs(diffInSeconds) < _index.secondsInQuarter) {
      value = (0, _index3.default)(dateLeft, dateRight);
      unit = 'month';
    } else if (Math.abs(diffInSeconds) < _index.secondsInYear) {
      if ((0, _index4.default)(dateLeft, dateRight) < 4) {
        // To filter out cases that are less than a year but match 4 quarters
        value = (0, _index4.default)(dateLeft, dateRight);
        unit = 'quarter';
      } else {
        value = (0, _index6.default)(dateLeft, dateRight);
        unit = 'year';
      }
    } else {
      value = (0, _index6.default)(dateLeft, dateRight);
      unit = 'year';
    }
  } else {
    // Get the value if unit is specified
    unit = options === null || options === void 0 ? void 0 : options.unit;
    if (unit === 'second') {
      value = (0, _index9.default)(dateLeft, dateRight);
    } else if (unit === 'minute') {
      value = (0, _index8.default)(dateLeft, dateRight);
    } else if (unit === 'hour') {
      value = (0, _index7.default)(dateLeft, dateRight);
    } else if (unit === 'day') {
      value = (0, _index2.default)(dateLeft, dateRight);
    } else if (unit === 'week') {
      value = (0, _index5.default)(dateLeft, dateRight);
    } else if (unit === 'month') {
      value = (0, _index3.default)(dateLeft, dateRight);
    } else if (unit === 'quarter') {
      value = (0, _index4.default)(dateLeft, dateRight);
    } else if (unit === 'year') {
      value = (0, _index6.default)(dateLeft, dateRight);
    }
  }
  var rtf = new Intl.RelativeTimeFormat(options === null || options === void 0 ? void 0 : options.locale, {
    localeMatcher: options === null || options === void 0 ? void 0 : options.localeMatcher,
    numeric: (options === null || options === void 0 ? void 0 : options.numeric) || 'auto',
    style: options === null || options === void 0 ? void 0 : options.style
  });
  return rtf.format(value, unit);
}
module.exports = exports.default;

/***/ }),

/***/ 62845:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isAfter;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|Number} date - the date that should be after the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */
function isAfter(dirtyDate, dirtyDateToCompare) {
  (0, _index2.default)(2, arguments);
  var date = (0, _index.default)(dirtyDate);
  var dateToCompare = (0, _index.default)(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 79621:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isBefore;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */
function isBefore(dirtyDate, dirtyDateToCompare) {
  (0, _index2.default)(2, arguments);
  var date = (0, _index.default)(dirtyDate);
  var dateToCompare = (0, _index.default)(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 80370:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isDate;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */
function isDate(value) {
  (0, _index.default)(1, arguments);
  return value instanceof Date || (0, _typeof2.default)(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}
module.exports = exports.default;

/***/ }),

/***/ 34871:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isEqual;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Boolean} the dates are equal
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * const result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */
function isEqual(dirtyLeftDate, dirtyRightDate) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyLeftDate);
  var dateRight = (0, _index.default)(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 12079:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isExists;
/**
 * @name isExists
 * @category Common Helpers
 * @summary Is the given date exists?
 *
 * @description
 * Checks if the given arguments convert to an existing date.
 *
 * @param {Number} year of the date to check
 * @param {Number} month of the date to check
 * @param {Number} day of the date to check
 * @returns {Boolean} the date exists
 * @throws {TypeError} 3 arguments required
 *
 * @example
 * // For the valid date:
 * const result = isExists(2018, 0, 31)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isExists(2018, 1, 31)
 * //=> false
 */
function isExists(year, month, day) {
  if (arguments.length < 3) {
    throw new TypeError('3 argument required, but only ' + arguments.length + ' present');
  }
  var date = new Date(year, month, day);
  return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;
}
module.exports = exports.default;

/***/ }),

/***/ 7397:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isFirstDayOfMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isFirstDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the first day of a month?
 *
 * @description
 * Is the given date the first day of a month?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is the first day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 1 September 2014 the first day of a month?
 * const result = isFirstDayOfMonth(new Date(2014, 8, 1))
 * //=> true
 */
function isFirstDayOfMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDate() === 1;
}
module.exports = exports.default;

/***/ }),

/***/ 58008:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isFriday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isFriday
 * @category Weekday Helpers
 * @summary Is the given date Friday?
 *
 * @description
 * Is the given date Friday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Friday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 26 September 2014 Friday?
 * const result = isFriday(new Date(2014, 8, 26))
 * //=> true
 */
function isFriday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDay() === 5;
}
module.exports = exports.default;

/***/ }),

/***/ 28150:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isFuture;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isFuture
 * @category Common Helpers
 * @summary Is the given date in the future?
 * @pure false
 *
 * @description
 * Is the given date in the future?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in the future
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 31 December 2014 in the future?
 * const result = isFuture(new Date(2014, 11, 31))
 * //=> true
 */
function isFuture(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getTime() > Date.now();
}
module.exports = exports.default;

/***/ }),

/***/ 47072:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isLastDayOfMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(62660));
var _index3 = _interopRequireDefault(__webpack_require__(74192));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isLastDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the last day of a month?
 *
 * @description
 * Is the given date the last day of a month?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is the last day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 28 February 2014 the last day of a month?
 * const result = isLastDayOfMonth(new Date(2014, 1, 28))
 * //=> true
 */
function isLastDayOfMonth(dirtyDate) {
  (0, _index4.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  return (0, _index2.default)(date).getTime() === (0, _index3.default)(date).getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 75501:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isLeapYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isLeapYear
 * @category Year Helpers
 * @summary Is the given date in the leap year?
 *
 * @description
 * Is the given date in the leap year?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in the leap year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 1 September 2012 in the leap year?
 * const result = isLeapYear(new Date(2012, 8, 1))
 * //=> true
 */
function isLeapYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
module.exports = exports.default;

/***/ }),

/***/ 27577:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isMatch;
var _index = _interopRequireDefault(__webpack_require__(53651));
var _index2 = _interopRequireDefault(__webpack_require__(92401));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isMatch
 * @category Common Helpers
 * @summary validates the date string against given formats
 *
 * @description
 * Return the true if given date is string correct against the given format else
 * will return false.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * isMatch('23 AM', 'HH a')
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `isMatch` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `isMatch('50', 'yy') //=> true`
 *
 *    `isMatch('75', 'yy') //=> true`
 *
 *    while `uu` will use the year as is:
 *
 *    `isMatch('50', 'uu') //=> true`
 *
 *    `isMatch('75', 'uu') //=> true`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be checked in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
 * the values will be taken from today's using `new Date()` date which works as a context of parsing.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 *
 *
 * @param {String} dateString - the date string to verify
 * @param {String} formatString - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Boolean}
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Match 11 February 2014 from middle-endian format:
 * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
 * //=> true
 *
 * @example
 * // Match 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
 *   locale: eo
 * })
 * //=> true
 */
function isMatch(dateString, formatString, options) {
  (0, _index3.default)(2, arguments);
  return (0, _index2.default)((0, _index.default)(dateString, formatString, new Date(), options));
}
module.exports = exports.default;

/***/ }),

/***/ 61258:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isMonday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isMonday
 * @category Weekday Helpers
 * @summary Is the given date Monday?
 *
 * @description
 * Is the given date Monday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Monday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 22 September 2014 Monday?
 * const result = isMonday(new Date(2014, 8, 22))
 * //=> true
 */
function isMonday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date).getDay() === 1;
}
module.exports = exports.default;

/***/ }),

/***/ 78040:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isPast;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isPast
 * @category Common Helpers
 * @summary Is the given date in the past?
 * @pure false
 *
 * @description
 * Is the given date in the past?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in the past
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 2 July 2014 in the past?
 * const result = isPast(new Date(2014, 6, 2))
 * //=> true
 */
function isPast(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getTime() < Date.now();
}
module.exports = exports.default;

/***/ }),

/***/ 95795:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameDay;
var _index = _interopRequireDefault(__webpack_require__(87597));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfDay = (0, _index.default)(dirtyDateLeft);
  var dateRightStartOfDay = (0, _index.default)(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 27638:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameHour;
var _index = _interopRequireDefault(__webpack_require__(18982));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour (and same day)?
 *
 * @description
 * Are the given dates in the same hour (and same day)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same hour (and same day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
 * //=> false
 */
function isSameHour(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfHour = (0, _index.default)(dirtyDateLeft);
  var dateRightStartOfHour = (0, _index.default)(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 34656:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameISOWeek;
var _index = _interopRequireDefault(__webpack_require__(94522));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameISOWeek
 * @category ISO Week Helpers
 * @summary Are the given dates in the same ISO week (and year)?
 *
 * @description
 * Are the given dates in the same ISO week (and year)?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same ISO week (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 1 September 2014 and 7 September 2014 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2014, 8, 7))
 * //=> true
 *
 * @example
 * // Are 1 September 2014 and 1 September 2015 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2015, 8, 1))
 * //=> false
 */
function isSameISOWeek(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  return (0, _index.default)(dirtyDateLeft, dirtyDateRight, {
    weekStartsOn: 1
  });
}
module.exports = exports.default;

/***/ }),

/***/ 87728:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(4407));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Are the given dates in the same ISO week-numbering year?
 *
 * @description
 * Are the given dates in the same ISO week-numbering year?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same ISO week-numbering year
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 29 December 2003 and 2 January 2005 in the same ISO week-numbering year?
 * const result = isSameISOWeekYear(new Date(2003, 11, 29), new Date(2005, 0, 2))
 * //=> true
 */
function isSameISOWeekYear(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfYear = (0, _index.default)(dirtyDateLeft);
  var dateRightStartOfYear = (0, _index.default)(dirtyDateRight);
  return dateLeftStartOfYear.getTime() === dateRightStartOfYear.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 59444:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameMinute;
var _index = _interopRequireDefault(__webpack_require__(10515));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameMinute
 * @category Minute Helpers
 * @summary Are the given dates in the same minute (and hour and day)?
 *
 * @description
 * Are the given dates in the same minute (and hour and day)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same minute (and hour and day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 4 September 2014 06:30:15 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 4, 6, 30, 15)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 5 September 2014 06:30:00 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 5, 6, 30)
 * )
 * //=> false
 */
function isSameMinute(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfMinute = (0, _index.default)(dirtyDateLeft);
  var dateRightStartOfMinute = (0, _index.default)(dirtyDateRight);
  return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 72875:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same month (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
module.exports = exports.default;

/***/ }),

/***/ 67446:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameQuarter;
var _index = _interopRequireDefault(__webpack_require__(20183));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameQuarter
 * @category Quarter Helpers
 * @summary Are the given dates in the same quarter (and year)?
 *
 * @description
 * Are the given dates in the same quarter (and year)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same quarter (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 1 January 2014 and 8 March 2014 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
 * //=> true
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfQuarter = (0, _index.default)(dirtyDateLeft);
  var dateRightStartOfQuarter = (0, _index.default)(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 94797:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameSecond;
var _index = _interopRequireDefault(__webpack_require__(70783));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameSecond
 * @category Second Helpers
 * @summary Are the given dates in the same second (and hour and day)?
 *
 * @description
 * Are the given dates in the same second (and hour and day)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same second (and hour and day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:30:15.000 and 4 September 2014 06:30.15.500 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 30, 15),
 *   new Date(2014, 8, 4, 6, 30, 15, 500)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 4 September 2014 06:01.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 4, 6, 1, 15)
 * )
 * //=> false
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 5 September 2014 06:00.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 5, 6, 0, 15)
 * )
 * //=> false
 */
function isSameSecond(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfSecond = (0, _index.default)(dirtyDateLeft);
  var dateRightStartOfSecond = (0, _index.default)(dirtyDateRight);
  return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 94522:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameWeek;
var _index = _interopRequireDefault(__webpack_require__(11790));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameWeek
 * @category Week Helpers
 * @summary Are the given dates in the same week (and month and year)?
 *
 * @description
 * Are the given dates in the same week (and month and year)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Boolean} the dates are in the same week (and month and year)
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // Are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
 * //=> true
 *
 * @example
 * // If week starts with Monday,
 * // are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
 *   weekStartsOn: 1
 * })
 * //=> false
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same week?
 * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameWeek(dirtyDateLeft, dirtyDateRight, options) {
  (0, _index2.default)(2, arguments);
  var dateLeftStartOfWeek = (0, _index.default)(dirtyDateLeft, options);
  var dateRightStartOfWeek = (0, _index.default)(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}
module.exports = exports.default;

/***/ }),

/***/ 95177:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSameYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same year
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  (0, _index2.default)(2, arguments);
  var dateLeft = (0, _index.default)(dirtyDateLeft);
  var dateRight = (0, _index.default)(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
module.exports = exports.default;

/***/ }),

/***/ 85104:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSaturday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSaturday
 * @category Weekday Helpers
 * @summary Is the given date Saturday?
 *
 * @description
 * Is the given date Saturday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Saturday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 27 September 2014 Saturday?
 * const result = isSaturday(new Date(2014, 8, 27))
 * //=> true
 */
function isSaturday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDay() === 6;
}
module.exports = exports.default;

/***/ }),

/***/ 43889:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isSunday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isSunday
 * @category Weekday Helpers
 * @summary Is the given date Sunday?
 *
 * @description
 * Is the given date Sunday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 21 September 2014 Sunday?
 * const result = isSunday(new Date(2014, 8, 21))
 * //=> true
 */
function isSunday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDay() === 0;
}
module.exports = exports.default;

/***/ }),

/***/ 83746:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisHour;
var _index = _interopRequireDefault(__webpack_require__(27638));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisHour
 * @category Hour Helpers
 * @summary Is the given date in the same hour as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same hour as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this hour
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:00:00 in this hour?
 * const result = isThisHour(new Date(2014, 8, 25, 18))
 * //=> true
 */
function isThisHour(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(Date.now(), dirtyDate);
}
module.exports = exports.default;

/***/ }),

/***/ 34511:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisISOWeek;
var _index = _interopRequireDefault(__webpack_require__(34656));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisISOWeek
 * @category ISO Week Helpers
 * @summary Is the given date in the same ISO week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same ISO week as the current date?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 25 September 2014, is 22 September 2014 in this ISO week?
 * const result = isThisISOWeek(new Date(2014, 8, 22))
 * //=> true
 */

function isThisISOWeek(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, Date.now());
}
module.exports = exports.default;

/***/ }),

/***/ 32174:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisMinute;
var _index = _interopRequireDefault(__webpack_require__(59444));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisMinute
 * @category Minute Helpers
 * @summary Is the given date in the same minute as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same minute as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this minute
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:00 in this minute?
 * const result = isThisMinute(new Date(2014, 8, 25, 18, 30))
 * //=> true
 */

function isThisMinute(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(Date.now(), dirtyDate);
}
module.exports = exports.default;

/***/ }),

/***/ 66059:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisMonth;
var _index = _interopRequireDefault(__webpack_require__(72875));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisMonth
 * @category Month Helpers
 * @summary Is the given date in the same month as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same month as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 25 September 2014, is 15 September 2014 in this month?
 * const result = isThisMonth(new Date(2014, 8, 15))
 * //=> true
 */

function isThisMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(Date.now(), dirtyDate);
}
module.exports = exports.default;

/***/ }),

/***/ 13047:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisQuarter;
var _index = _interopRequireDefault(__webpack_require__(67446));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisQuarter
 * @category Quarter Helpers
 * @summary Is the given date in the same quarter as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same quarter as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this quarter?
 * const result = isThisQuarter(new Date(2014, 6, 2))
 * //=> true
 */
function isThisQuarter(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(Date.now(), dirtyDate);
}
module.exports = exports.default;

/***/ }),

/***/ 20905:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisSecond;
var _index = _interopRequireDefault(__webpack_require__(94797));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisSecond
 * @category Second Helpers
 * @summary Is the given date in the same second as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same second as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this second
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:15.000 in this second?
 * const result = isThisSecond(new Date(2014, 8, 25, 18, 30, 15))
 * //=> true
 */
function isThisSecond(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(Date.now(), dirtyDate);
}
module.exports = exports.default;

/***/ }),

/***/ 21424:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisWeek;
var _index = _interopRequireDefault(__webpack_require__(94522));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisWeek
 * @category Week Helpers
 * @summary Is the given date in the same week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same week as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @param {Object} [options] - the object with options
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Boolean} the date is in this week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // If today is 25 September 2014, is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21))
 * //=> true
 *
 * @example
 * // If today is 25 September 2014 and week starts with Monday
 * // is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })
 * //=> false
 */

function isThisWeek(dirtyDate, options) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, Date.now(), options);
}
module.exports = exports.default;

/***/ }),

/***/ 49371:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThisYear;
var _index = _interopRequireDefault(__webpack_require__(95177));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThisYear
 * @category Year Helpers
 * @summary Is the given date in the same year as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same year as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in this year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this year?
 * const result = isThisYear(new Date(2014, 6, 2))
 * //=> true
 */
function isThisYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, Date.now());
}
module.exports = exports.default;

/***/ }),

/***/ 52168:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isThursday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isThursday
 * @category Weekday Helpers
 * @summary Is the given date Thursday?
 *
 * @description
 * Is the given date Thursday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Thursday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 25 September 2014 Thursday?
 * const result = isThursday(new Date(2014, 8, 25))
 * //=> true
 */
function isThursday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDay() === 4;
}
module.exports = exports.default;

/***/ }),

/***/ 44058:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isToday;
var _index = _interopRequireDefault(__webpack_require__(95795));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is today
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * const result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */
function isToday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, Date.now());
}
module.exports = exports.default;

/***/ }),

/***/ 31713:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isTomorrow;
var _index = _interopRequireDefault(__webpack_require__(83530));
var _index2 = _interopRequireDefault(__webpack_require__(95795));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isTomorrow
 * @category Day Helpers
 * @summary Is the given date tomorrow?
 * @pure false
 *
 * @description
 * Is the given date tomorrow?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is tomorrow
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 7 October 14:00:00 tomorrow?
 * const result = isTomorrow(new Date(2014, 9, 7, 14, 0))
 * //=> true
 */
function isTomorrow(dirtyDate) {
  (0, _index3.default)(1, arguments);
  return (0, _index2.default)(dirtyDate, (0, _index.default)(Date.now(), 1));
}
module.exports = exports.default;

/***/ }),

/***/ 32325:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isTuesday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isTuesday
 * @category Weekday Helpers
 * @summary Is the given date Tuesday?
 *
 * @description
 * Is the given date Tuesday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Tuesday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 23 September 2014 Tuesday?
 * const result = isTuesday(new Date(2014, 8, 23))
 * //=> true
 */
function isTuesday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDay() === 2;
}
module.exports = exports.default;

/***/ }),

/***/ 92401:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isValid;
var _index = _interopRequireDefault(__webpack_require__(80370));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */
function isValid(dirtyDate) {
  (0, _index3.default)(1, arguments);
  if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }
  var date = (0, _index2.default)(dirtyDate);
  return !isNaN(Number(date));
}
module.exports = exports.default;

/***/ }),

/***/ 66968:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isWednesday;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isWednesday
 * @category Weekday Helpers
 * @summary Is the given date Wednesday?
 *
 * @description
 * Is the given date Wednesday?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is Wednesday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 24 September 2014 Wednesday?
 * const result = isWednesday(new Date(2014, 8, 24))
 * //=> true
 */
function isWednesday(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate).getDay() === 3;
}
module.exports = exports.default;

/***/ }),

/***/ 31125:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isWeekend;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isWeekend
 * @category Weekday Helpers
 * @summary Does the given date fall on a weekend?
 *
 * @description
 * Does the given date fall on a weekend?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date falls on a weekend
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Does 5 October 2014 fall on a weekend?
 * const result = isWeekend(new Date(2014, 9, 5))
 * //=> true
 */
function isWeekend(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var day = date.getDay();
  return day === 0 || day === 6;
}
module.exports = exports.default;

/***/ }),

/***/ 47379:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isWithinInterval;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * @param {Date|Number} date - the date to check
 * @param {Interval} interval - the interval to check
 * @returns {Boolean} the date is within the interval
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date }) // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end }) // => true
 */
function isWithinInterval(dirtyDate, interval) {
  (0, _index2.default)(2, arguments);
  var time = (0, _index.default)(dirtyDate).getTime();
  var startTime = (0, _index.default)(interval.start).getTime();
  var endTime = (0, _index.default)(interval.end).getTime();

  // Throw an exception if start date is after end date or if any date is `Invalid Date`
  if (!(startTime <= endTime)) {
    throw new RangeError('Invalid interval');
  }
  return time >= startTime && time <= endTime;
}
module.exports = exports.default;

/***/ }),

/***/ 56721:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = isYesterday;
var _index = _interopRequireDefault(__webpack_require__(95795));
var _index2 = _interopRequireDefault(__webpack_require__(48070));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name isYesterday
 * @category Day Helpers
 * @summary Is the given date yesterday?
 * @pure false
 *
 * @description
 * Is the given date yesterday?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is yesterday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 5 October 14:00:00 yesterday?
 * const result = isYesterday(new Date(2014, 9, 5, 14, 0))
 * //=> true
 */
function isYesterday(dirtyDate) {
  (0, _index3.default)(1, arguments);
  return (0, _index.default)(dirtyDate, (0, _index2.default)(Date.now(), 1));
}
module.exports = exports.default;

/***/ }),

/***/ 28540:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfDecade;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name lastDayOfDecade
 * @category Decade Helpers
 * @summary Return the last day of a decade for the given date.
 *
 * @description
 * Return the last day of a decade for the given date.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of a decade
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of a decade for 21 December 2012 21:12:00:
 * const result = lastDayOfDecade(new Date(2012, 11, 21, 21, 12, 00))
 * //=> Wed Dec 31 2019 00:00:00
 */
function lastDayOfDecade(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  var decade = 9 + Math.floor(year / 10) * 10;
  date.setFullYear(decade + 1, 0, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 87749:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfISOWeek;
var _index = _interopRequireDefault(__webpack_require__(90407));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name lastDayOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the last day of an ISO week for the given date.
 *
 * @description
 * Return the last day of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of an ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of an ISO week for 2 September 2014 11:55:00:
 * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 00:00:00
 */
function lastDayOfISOWeek(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, {
    weekStartsOn: 1
  });
}
module.exports = exports.default;

/***/ }),

/***/ 23522:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(6874));
var _index2 = _interopRequireDefault(__webpack_require__(38674));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name lastDayOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the last day of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the last day of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of an ISO week-numbering year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of an ISO week-numbering year for 2 July 2005:
 * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 00:00:00
 */
function lastDayOfISOWeekYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var year = (0, _index.default)(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year + 1, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = (0, _index2.default)(fourthOfJanuary);
  date.setDate(date.getDate() - 1);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 8305:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name lastDayOfMonth
 * @category Month Helpers
 * @summary Return the last day of a month for the given date.
 *
 * @description
 * Return the last day of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of a month for 2 September 2014 11:55:00:
 * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 2721:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfQuarter;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name lastDayOfQuarter
 * @category Quarter Helpers
 * @summary Return the last day of a year quarter for the given date.
 *
 * @description
 * Return the last day of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the last day of a quarter
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // The last day of a quarter for 2 September 2014 11:55:00:
 * const result = lastDayOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */
function lastDayOfQuarter(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date.setMonth(month, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 90407:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(50687));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var _index4 = __webpack_require__(30596);
/**
 * @name lastDayOfWeek
 * @category Week Helpers
 * @summary Return the last day of a week for the given date.
 *
 * @description
 * Return the last day of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the last day of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The last day of a week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the last day of the week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function lastDayOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index3.default)(1, arguments);
  var defaultOptions = (0, _index4.getDefaultOptions)();
  var weekStartsOn = (0, _index2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6');
  }
  var date = (0, _index.default)(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setHours(0, 0, 0, 0);
  date.setDate(date.getDate() + diff);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 14123:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lastDayOfYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name lastDayOfYear
 * @category Year Helpers
 * @summary Return the last day of a year for the given date.
 *
 * @description
 * Return the last day of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of a year for 2 September 2014 11:55:00:
 * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 00:00:00
 */
function lastDayOfYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 33938:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = lightFormat;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(941));
var _index3 = _interopRequireDefault(__webpack_require__(10944));
var _index4 = _interopRequireDefault(__webpack_require__(92401));
var _index5 = _interopRequireDefault(__webpack_require__(2665));
var _index6 = _interopRequireDefault(__webpack_require__(37716));
// This RegExp consists of three parts separated by `|`:
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name lightFormat
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. Unlike `format`,
 * `lightFormat` doesn't use locales and outputs date using the most popular tokens.
 *
 * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   |
 * |---------------------------------|---------|-----------------------------------|
 * | AM, PM                          | a..aaa  | AM, PM                            |
 * |                                 | aaaa    | a.m., p.m.                        |
 * |                                 | aaaaa   | a, p                              |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 |
 * |                                 | yy      | 44, 01, 00, 17                    |
 * |                                 | yyy     | 044, 001, 000, 017                |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |
 * |                                 | MM      | 01, 02, ..., 12                   |
 * | Day of month                    | d       | 1, 2, ..., 31                     |
 * |                                 | dd      | 01, 02, ..., 31                   |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |
 * |                                 | hh      | 01, 02, ..., 11, 12               |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |
 * |                                 | HH      | 00, 01, 02, ..., 23               |
 * | Minute                          | m       | 0, 1, ..., 59                     |
 * |                                 | mm      | 00, 01, ..., 59                   |
 * | Second                          | s       | 0, 1, ..., 59                     |
 * |                                 | ss      | 00, 01, ..., 59                   |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |
 * |                                 | SS      | 00, 01, ..., 99                   |
 * |                                 | SSS     | 000, 001, ..., 999                |
 * |                                 | SSSS    | ...                               |
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')
 * //=> '2014-02-11'
 */

function lightFormat(dirtyDate, formatStr) {
  (0, _index6.default)(2, arguments);
  var originalDate = (0, _index.default)(dirtyDate);
  if (!(0, _index4.default)(originalDate)) {
    throw new RangeError('Invalid time value');
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
  var timezoneOffset = (0, _index3.default)(originalDate);
  var utcDate = (0, _index5.default)(originalDate, timezoneOffset);
  var tokens = formatStr.match(formattingTokensRegExp);

  // The only case when formattingTokensRegExp doesn't match the string is when it's empty
  if (!tokens) return '';
  var result = tokens.map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = _index2.default[firstCharacter];
    if (formatter) {
      return formatter(utcDate, substring);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }
    return substring;
  }).join('');
  return result;
}
function cleanEscapedString(input) {
  var matches = input.match(escapedStringRegExp);
  if (!matches) {
    return input;
  }
  return matches[1].replace(doubleQuoteRegExp, "'");
}
module.exports = exports.default;

/***/ }),

/***/ 25257:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = buildFormatLongFn;
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}
module.exports = exports.default;

/***/ }),

/***/ 41134:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = buildLocalizeFn;
function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;
    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
    return valuesArray[index];
  };
}
module.exports = exports.default;

/***/ }),

/***/ 69618:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = buildMatchFn;
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return undefined;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return undefined;
}
module.exports = exports.default;

/***/ }),

/***/ 73037:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = buildMatchPatternFn;
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
module.exports = exports.default;

/***/ }),

/***/ 28518:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};
var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }
  return result;
};
var _default = formatDistance;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 71393:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(25257));
var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: (0, _index.default)({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0, _index.default)({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0, _index.default)({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var _default = formatLong;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 50796:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};
var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var _default = formatRelative;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 36708:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(41134));
var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
};

// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};
var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber);

  // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
    }
  }
  return number + 'th';
};
var localize = {
  ordinalNumber: ordinalNumber,
  era: (0, _index.default)({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0, _index.default)({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: (0, _index.default)({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0, _index.default)({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0, _index.default)({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var _default = localize;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 77659:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(69618));
var _index2 = _interopRequireDefault(__webpack_require__(73037));
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: (0, _index2.default)({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: (0, _index.default)({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0, _index.default)({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: (0, _index.default)({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0, _index.default)({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0, _index.default)({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var _default = match;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 37703:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _index = _interopRequireDefault(__webpack_require__(28518));
var _index2 = _interopRequireDefault(__webpack_require__(71393));
var _index3 = _interopRequireDefault(__webpack_require__(50796));
var _index4 = _interopRequireDefault(__webpack_require__(36708));
var _index5 = _interopRequireDefault(__webpack_require__(77659));
/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: _index.default,
  formatLong: _index2.default,
  formatRelative: _index3.default,
  localize: _index4.default,
  match: _index5.default,
  options: {
    weekStartsOn: 0 /* Sunday */,
    firstWeekContainsDate: 1
  }
};
var _default = locale;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 374:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = max;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name max
 * @category Common Helpers
 * @summary Return the latest of the given dates.
 *
 * @description
 * Return the latest of the given dates.
 *
 * @param {Date[]|Number[]} datesArray - the dates to compare
 * @returns {Date} the latest of the dates
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which of these dates is the latest?
 * const result = max([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Sun Jul 02 1995 00:00:00
 */
function max(dirtyDatesArray) {
  (0, _index2.default)(1, arguments);
  var datesArray;
  // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === 'function') {
    datesArray = dirtyDatesArray;

    // If `dirtyDatesArray` is Array-like Object, convert to Array.
  } else if ((0, _typeof2.default)(dirtyDatesArray) === 'object' && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    // `dirtyDatesArray` is non-iterable, return Invalid Date
    return new Date(NaN);
  }
  var result;
  datesArray.forEach(function (dirtyDate) {
    var currentDate = (0, _index.default)(dirtyDate);
    if (result === undefined || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
module.exports = exports.default;

/***/ }),

/***/ 47301:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = milliseconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
// Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
// 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
var daysInYear = 365.2425;

/**
 * @name milliseconds
 * @category Millisecond Helpers
 * @summary
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * @description
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * One month is a year divided by 12.
 *
 * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {number} the milliseconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // 1 year in milliseconds
 * milliseconds({ years: 1 })
 * //=> 31556952000
 *
 * // 3 months in milliseconds
 * milliseconds({ months: 3 })
 * //=> 7889238000
 */
function milliseconds(_ref) {
  var years = _ref.years,
    months = _ref.months,
    weeks = _ref.weeks,
    days = _ref.days,
    hours = _ref.hours,
    minutes = _ref.minutes,
    seconds = _ref.seconds;
  (0, _index.default)(1, arguments);
  var totalDays = 0;
  if (years) totalDays += years * daysInYear;
  if (months) totalDays += months * (daysInYear / 12);
  if (weeks) totalDays += weeks * 7;
  if (days) totalDays += days;
  var totalSeconds = totalDays * 24 * 60 * 60;
  if (hours) totalSeconds += hours * 60 * 60;
  if (minutes) totalSeconds += minutes * 60;
  if (seconds) totalSeconds += seconds;
  return Math.round(totalSeconds * 1000);
}
module.exports = exports.default;

/***/ }),

/***/ 74957:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = millisecondsToHours;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name millisecondsToHours
 * @category Conversion Helpers
 * @summary Convert milliseconds to hours.
 *
 * @description
 * Convert a number of milliseconds to a full number of hours.
 *
 * @param {number} milliseconds - number of milliseconds to be converted
 *
 * @returns {number} the number of milliseconds converted in hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 7200000 milliseconds to hours:
 * const result = millisecondsToHours(7200000)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToHours(7199999)
 * //=> 1
 */
function millisecondsToHours(milliseconds) {
  (0, _index.default)(1, arguments);
  var hours = milliseconds / _index2.millisecondsInHour;
  return Math.floor(hours);
}
module.exports = exports.default;

/***/ }),

/***/ 85160:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = millisecondsToMinutes;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name millisecondsToMinutes
 * @category Conversion Helpers
 * @summary Convert milliseconds to minutes.
 *
 * @description
 * Convert a number of milliseconds to a full number of minutes.
 *
 * @param {number} milliseconds - number of milliseconds to be converted.
 *
 * @returns {number} the number of milliseconds converted in minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 60000 milliseconds to minutes:
 * const result = millisecondsToMinutes(60000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToMinutes(119999)
 * //=> 1
 */
function millisecondsToMinutes(milliseconds) {
  (0, _index.default)(1, arguments);
  var minutes = milliseconds / _index2.millisecondsInMinute;
  return Math.floor(minutes);
}
module.exports = exports.default;

/***/ }),

/***/ 70781:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = millisecondsToSeconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name millisecondsToSeconds
 * @category Conversion Helpers
 * @summary Convert milliseconds to seconds.
 *
 * @description
 * Convert a number of milliseconds to a full number of seconds.
 *
 * @param {number} milliseconds - number of milliseconds to be converted
 *
 * @returns {number} the number of milliseconds converted in seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 1000 miliseconds to seconds:
 * const result = millisecondsToSeconds(1000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToSeconds(1999)
 * //=> 1
 */
function millisecondsToSeconds(milliseconds) {
  (0, _index.default)(1, arguments);
  var seconds = milliseconds / _index2.millisecondsInSecond;
  return Math.floor(seconds);
}
module.exports = exports.default;

/***/ }),

/***/ 32131:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = min;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name min
 * @category Common Helpers
 * @summary Returns the earliest of the given dates.
 *
 * @description
 * Returns the earliest of the given dates.
 *
 * @param {Date[]|Number[]} datesArray - the dates to compare
 * @returns {Date} - the earliest of the dates
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which of these dates is the earliest?
 * const result = min([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Wed Feb 11 1987 00:00:00
 */
function min(dirtyDatesArray) {
  (0, _index2.default)(1, arguments);
  var datesArray;
  // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === 'function') {
    datesArray = dirtyDatesArray;
    // If `dirtyDatesArray` is Array-like Object, convert to Array.
  } else if ((0, _typeof2.default)(dirtyDatesArray) === 'object' && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    // `dirtyDatesArray` is non-iterable, return Invalid Date
    return new Date(NaN);
  }
  var result;
  datesArray.forEach(function (dirtyDate) {
    var currentDate = (0, _index.default)(dirtyDate);
    if (result === undefined || result > currentDate || isNaN(currentDate.getDate())) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
module.exports = exports.default;

/***/ }),

/***/ 23884:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = minutesToHours;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name minutesToHours
 * @category Conversion Helpers
 * @summary Convert minutes to hours.
 *
 * @description
 * Convert a number of minutes to a full number of hours.
 *
 * @param {number} minutes - number of minutes to be converted
 *
 * @returns {number} the number of minutes converted in hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 140 minutes to hours:
 * const result = minutesToHours(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = minutesToHours(179)
 * //=> 2
 */
function minutesToHours(minutes) {
  (0, _index.default)(1, arguments);
  var hours = minutes / _index2.minutesInHour;
  return Math.floor(hours);
}
module.exports = exports.default;

/***/ }),

/***/ 25124:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = minutesToMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name minutesToMilliseconds
 * @category Conversion Helpers
 * @summary Convert minutes to milliseconds.
 *
 * @description
 * Convert a number of minutes to a full number of milliseconds.
 *
 * @param {number} minutes - number of minutes to be converted
 *
 * @returns {number} the number of minutes converted in milliseconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 minutes to milliseconds
 * const result = minutesToMilliseconds(2)
 * //=> 120000
 */
function minutesToMilliseconds(minutes) {
  (0, _index.default)(1, arguments);
  return Math.floor(minutes * _index2.millisecondsInMinute);
}
module.exports = exports.default;

/***/ }),

/***/ 50875:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = minutesToSeconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name minutesToSeconds
 * @category Conversion Helpers
 * @summary Convert minutes to seconds.
 *
 * @description
 * Convert a number of minutes to a full number of seconds.
 *
 * @param { number } minutes - number of minutes to be converted
 *
 * @returns {number} the number of minutes converted in seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 minutes to seconds
 * const result = minutesToSeconds(2)
 * //=> 120
 */
function minutesToSeconds(minutes) {
  (0, _index.default)(1, arguments);
  return Math.floor(minutes * _index2.secondsInMinute);
}
module.exports = exports.default;

/***/ }),

/***/ 59762:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = monthsToQuarters;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name monthsToQuarters
 * @category Conversion Helpers
 * @summary Convert number of months to quarters.
 *
 * @description
 * Convert a number of months to a full number of quarters.
 *
 * @param {number} months - number of months to be converted.
 *
 * @returns {number} the number of months converted in quarters
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 6 months to quarters:
 * const result = monthsToQuarters(6)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = monthsToQuarters(7)
 * //=> 2
 */
function monthsToQuarters(months) {
  (0, _index.default)(1, arguments);
  var quarters = months / _index2.monthsInQuarter;
  return Math.floor(quarters);
}
module.exports = exports.default;

/***/ }),

/***/ 96391:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = monthsToYears;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name monthsToYears
 * @category Conversion Helpers
 * @summary Convert number of months to years.
 *
 * @description
 * Convert a number of months to a full number of years.
 *
 * @param {number} months - number of months to be converted
 *
 * @returns {number} the number of months converted in years
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 36 months to years:
 * const result = monthsToYears(36)
 * //=> 3
 *
 * // It uses floor rounding:
 * const result = monthsToYears(40)
 * //=> 3
 */
function monthsToYears(months) {
  (0, _index.default)(1, arguments);
  var years = months / _index2.monthsInYear;
  return Math.floor(years);
}
module.exports = exports.default;

/***/ }),

/***/ 58585:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextDay;
var _index = _interopRequireDefault(__webpack_require__(83530));
var _index2 = _interopRequireDefault(__webpack_require__(48461));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextDay
 * @category Weekday Helpers
 * @summary When is the next day of the week?
 *
 * @description
 * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @param {Date | number} date - the date to check
 * @param {Day} day - day of the week
 * @returns {Date} - the date is the next day of week
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // When is the next Monday after Mar, 20, 2020?
 * const result = nextDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 23 2020 00:00:00
 *
 * @example
 * // When is the next Tuesday after Mar, 21, 2020?
 * const result = nextDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 24 2020 00:00:00
 */
function nextDay(date, day) {
  (0, _index3.default)(2, arguments);
  var delta = day - (0, _index2.default)(date);
  if (delta <= 0) delta += 7;
  return (0, _index.default)(date, delta);
}
module.exports = exports.default;

/***/ }),

/***/ 13758:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextFriday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextFriday
 * @category Weekday Helpers
 * @summary When is the next Friday?
 *
 * @description
 * When is the next Friday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Friday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Friday after Mar, 22, 2020?
 * const result = nextFriday(new Date(2020, 2, 22))
 * //=> Fri Mar 27 2020 00:00:00
 */
function nextFriday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 5);
}
module.exports = exports.default;

/***/ }),

/***/ 79719:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextMonday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextMonday
 * @category Weekday Helpers
 * @summary When is the next Monday?
 *
 * @description
 * When is the next Monday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Monday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Monday after Mar, 22, 2020?
 * const result = nextMonday(new Date(2020, 2, 22))
 * //=> Mon Mar 23 2020 00:00:00
 */
function nextMonday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 1);
}
module.exports = exports.default;

/***/ }),

/***/ 69054:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextSaturday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextSaturday
 * @category Weekday Helpers
 * @summary When is the next Saturday?
 *
 * @description
 * When is the next Saturday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Saturday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Saturday after Mar, 22, 2020?
 * const result = nextSaturday(new Date(2020, 2, 22))
 * //=> Sat Mar 28 2020 00:00:00
 */
function nextSaturday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 6);
}
module.exports = exports.default;

/***/ }),

/***/ 81503:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextSunday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextSunday
 * @category Weekday Helpers
 * @summary When is the next Sunday?
 *
 * @description
 * When is the next Sunday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Sunday after Mar, 22, 2020?
 * const result = nextSunday(new Date(2020, 2, 22))
 * //=> Sun Mar 29 2020 00:00:00
 */
function nextSunday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 0);
}
module.exports = exports.default;

/***/ }),

/***/ 42671:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextThursday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextThursday
 * @category Weekday Helpers
 * @summary When is the next Thursday?
 *
 * @description
 * When is the next Thursday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Thursday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Thursday after Mar, 22, 2020?
 * const result = nextThursday(new Date(2020, 2, 22))
 * //=> Thur Mar 26 2020 00:00:00
 */
function nextThursday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 4);
}
module.exports = exports.default;

/***/ }),

/***/ 85638:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextTuesday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextTuesday
 * @category Weekday Helpers
 * @summary When is the next Tuesday?
 *
 * @description
 * When is the next Tuesday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Tuesday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Tuesday after Mar, 22, 2020?
 * const result = nextTuesday(new Date(2020, 2, 22))
 * //=> Tue Mar 24 2020 00:00:00
 */
function nextTuesday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 2);
}
module.exports = exports.default;

/***/ }),

/***/ 57677:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = nextWednesday;
var _index = _interopRequireDefault(__webpack_require__(58585));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name nextWednesday
 * @category Weekday Helpers
 * @summary When is the next Wednesday?
 *
 * @description
 * When is the next Wednesday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the next Wednesday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the next Wednesday after Mar, 22, 2020?
 * const result = nextWednesday(new Date(2020, 2, 22))
 * //=> Wed Mar 25 2020 00:00:00
 */
function nextWednesday(date) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(date, 3);
}
module.exports = exports.default;

/***/ }),

/***/ 98741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Parser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Setter = __webpack_require__(69638);
var Parser = /*#__PURE__*/function () {
  function Parser() {
    (0, _classCallCheck2.default)(this, Parser);
    (0, _defineProperty2.default)(this, "incompatibleTokens", void 0);
    (0, _defineProperty2.default)(this, "priority", void 0);
    (0, _defineProperty2.default)(this, "subPriority", void 0);
  }
  (0, _createClass2.default)(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);
      if (!result) {
        return null;
      }
      return {
        setter: new _Setter.ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser;
}();
exports.Parser = Parser;

/***/ }),

/***/ 69638:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ValueSetter = exports.Setter = exports.DateToSystemTimezoneSetter = void 0;
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    (0, _classCallCheck2.default)(this, Setter);
    (0, _defineProperty2.default)(this, "priority", void 0);
    (0, _defineProperty2.default)(this, "subPriority", 0);
  }
  (0, _createClass2.default)(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter;
}();
exports.Setter = Setter;
var ValueSetter = /*#__PURE__*/function (_Setter) {
  (0, _inherits2.default)(ValueSetter, _Setter);
  var _super = (0, _createSuper2.default)(ValueSetter);
  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;
    (0, _classCallCheck2.default)(this, ValueSetter);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  (0, _createClass2.default)(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter;
}(Setter);
exports.ValueSetter = ValueSetter;
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  (0, _inherits2.default)(DateToSystemTimezoneSetter, _Setter2);
  var _super2 = (0, _createSuper2.default)(DateToSystemTimezoneSetter);
  function DateToSystemTimezoneSetter() {
    var _this2;
    (0, _classCallCheck2.default)(this, DateToSystemTimezoneSetter);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "subPriority", -1);
    return _this2;
  }
  (0, _createClass2.default)(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter;
}(Setter);
exports.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;

/***/ }),

/***/ 30401:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.timezonePatterns = exports.numericPatterns = void 0;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59

  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999

  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
};
exports.numericPatterns = numericPatterns;
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
exports.timezonePatterns = timezonePatterns;

/***/ }),

/***/ 8676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AMPMMidnightParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(AMPMMidnightParser, _Parser);
  var _super = (0, _createSuper2.default)(AMPMMidnightParser);
  function AMPMMidnightParser() {
    var _this;
    (0, _classCallCheck2.default)(this, AMPMMidnightParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser;
}(_Parser2.Parser);
exports.AMPMMidnightParser = AMPMMidnightParser;

/***/ }),

/***/ 27532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AMPMParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var AMPMParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(AMPMParser, _Parser);
  var _super = (0, _createSuper2.default)(AMPMParser);
  function AMPMParser() {
    var _this;
    (0, _classCallCheck2.default)(this, AMPMParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser;
}(_Parser2.Parser);
exports.AMPMParser = AMPMParser;

/***/ }),

/***/ 5746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DateParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _utils = __webpack_require__(95495);
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// Day of the month
var DateParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(DateParser, _Parser);
  var _super = (0, _createSuper2.default)(DateParser);
  function DateParser() {
    var _this;
    (0, _classCallCheck2.default)(this, DateParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subPriority", 1);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.date, dateString);
        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = (0, _utils.isLeapYearIndex)(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser;
}(_Parser2.Parser);
exports.DateParser = DateParser;

/***/ }),

/***/ 44842:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DayOfYearParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(DayOfYearParser, _Parser);
  var _super = (0, _createSuper2.default)(DayOfYearParser);
  function DayOfYearParser() {
    var _this;
    (0, _classCallCheck2.default)(this, DayOfYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subpriority", 1);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.dayOfYear, dateString);
        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = (0, _utils.isLeapYearIndex)(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser;
}(_Parser2.Parser);
exports.DayOfYearParser = DayOfYearParser;

/***/ }),

/***/ 20132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DayParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _index = _interopRequireDefault(__webpack_require__(65275));
// Day of week
var DayParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(DayParser, _Parser);
  var _super = (0, _createSuper2.default)(DayParser);
  function DayParser() {
    var _this;
    (0, _classCallCheck2.default)(this, DayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T
        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday
        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = (0, _index.default)(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser;
}(_Parser2.Parser);
exports.DayParser = DayParser;

/***/ }),

/***/ 22835:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DayPeriodParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
// in the morning, in the afternoon, in the evening, at night
var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(DayPeriodParser, _Parser);
  var _super = (0, _createSuper2.default)(DayPeriodParser);
  function DayPeriodParser() {
    var _this;
    (0, _classCallCheck2.default)(this, DayPeriodParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser;
}(_Parser2.Parser);
exports.DayPeriodParser = DayPeriodParser;

/***/ }),

/***/ 23193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EraParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var EraParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(EraParser, _Parser);
  var _super = (0, _createSuper2.default)(EraParser);
  function EraParser() {
    var _this;
    (0, _classCallCheck2.default)(this, EraParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 140);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B
        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ
        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser;
}(_Parser2.Parser);
exports.EraParser = EraParser;

/***/ }),

/***/ 15033:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ExtendedYearParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(ExtendedYearParser, _Parser);
  var _super = (0, _createSuper2.default)(ExtendedYearParser);
  function ExtendedYearParser() {
    var _this;
    (0, _classCallCheck2.default)(this, ExtendedYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return (0, _utils.parseNDigitsSigned)(4, dateString);
      }
      return (0, _utils.parseNDigitsSigned)(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser;
}(_Parser2.Parser);
exports.ExtendedYearParser = ExtendedYearParser;

/***/ }),

/***/ 74124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FractionOfSecondParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(FractionOfSecondParser, _Parser);
  var _super = (0, _createSuper2.default)(FractionOfSecondParser);
  function FractionOfSecondParser() {
    var _this;
    (0, _classCallCheck2.default)(this, FractionOfSecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 30);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  (0, _createClass2.default)(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser;
}(_Parser2.Parser);
exports.FractionOfSecondParser = FractionOfSecondParser;

/***/ }),

/***/ 97:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Hour0To11Parser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(Hour0To11Parser, _Parser);
  var _super = (0, _createSuper2.default)(Hour0To11Parser);
  function Hour0To11Parser() {
    var _this;
    (0, _classCallCheck2.default)(this, Hour0To11Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour11h, dateString);
        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser;
}(_Parser2.Parser);
exports.Hour0To11Parser = Hour0To11Parser;

/***/ }),

/***/ 60570:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Hour0to23Parser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(Hour0to23Parser, _Parser);
  var _super = (0, _createSuper2.default)(Hour0to23Parser);
  function Hour0to23Parser() {
    var _this;
    (0, _classCallCheck2.default)(this, Hour0to23Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour23h, dateString);
        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser;
}(_Parser2.Parser);
exports.Hour0to23Parser = Hour0to23Parser;

/***/ }),

/***/ 13506:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Hour1To24Parser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(Hour1To24Parser, _Parser);
  var _super = (0, _createSuper2.default)(Hour1To24Parser);
  function Hour1To24Parser() {
    var _this;
    (0, _classCallCheck2.default)(this, Hour1To24Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour24h, dateString);
        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser;
}(_Parser2.Parser);
exports.Hour1To24Parser = Hour1To24Parser;

/***/ }),

/***/ 72939:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Hour1to12Parser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(Hour1to12Parser, _Parser);
  var _super = (0, _createSuper2.default)(Hour1to12Parser);
  function Hour1to12Parser() {
    var _this;
    (0, _classCallCheck2.default)(this, Hour1to12Parser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour12h, dateString);
        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser;
}(_Parser2.Parser);
exports.Hour1to12Parser = Hour1to12Parser;

/***/ }),

/***/ 17121:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISODayParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(18385));
// ISO day of week
var ISODayParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(ISODayParser, _Parser);
  var _super = (0, _createSuper2.default)(ISODayParser);
  function ISODayParser() {
    var _this;
    (0, _classCallCheck2.default)(this, ISODayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return (0, _utils.parseNDigits)(token.length, dateString);
        // 2nd
        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue
        case 'iii':
          return (0, _utils.mapValue)(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T
        case 'iiiii':
          return (0, _utils.mapValue)(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu
        case 'iiiiii':
          return (0, _utils.mapValue)(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday
        case 'iiii':
        default:
          return (0, _utils.mapValue)(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = (0, _index.default)(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser;
}(_Parser2.Parser);
exports.ISODayParser = ISODayParser;

/***/ }),

/***/ 99604:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOTimezoneParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
// Timezone (ISO-8601)
var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(ISOTimezoneParser, _Parser);
  var _super = (0, _createSuper2.default)(ISOTimezoneParser);
  function ISOTimezoneParser() {
    var _this;
    (0, _classCallCheck2.default)(this, ISOTimezoneParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 10);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['t', 'T', 'X']);
    return _this;
  }
  (0, _createClass2.default)(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
        case 'xx':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
        case 'xxxx':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
        case 'xxxxx':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
        case 'xxx':
        default:
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser;
}(_Parser2.Parser);
exports.ISOTimezoneParser = ISOTimezoneParser;

/***/ }),

/***/ 25179:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOTimezoneWithZParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
// Timezone (ISO-8601. +00:00 is `'Z'`)
var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(ISOTimezoneWithZParser, _Parser);
  var _super = (0, _createSuper2.default)(ISOTimezoneWithZParser);
  function ISOTimezoneWithZParser() {
    var _this;
    (0, _classCallCheck2.default)(this, ISOTimezoneWithZParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 10);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['t', 'T', 'x']);
    return _this;
  }
  (0, _createClass2.default)(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
        case 'XX':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
        case 'XXXX':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
        case 'XXXXX':
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
        case 'XXX':
        default:
          return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser;
}(_Parser2.Parser);
exports.ISOTimezoneWithZParser = ISOTimezoneWithZParser;

/***/ }),

/***/ 33574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOWeekParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(6622));
var _index2 = _interopRequireDefault(__webpack_require__(12246));
// ISO week of year
var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(ISOWeekParser, _Parser);
  var _super = (0, _createSuper2.default)(ISOWeekParser);
  function ISOWeekParser() {
    var _this;
    (0, _classCallCheck2.default)(this, ISOWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 100);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return (0, _index2.default)((0, _index.default)(date, value));
    }
  }]);
  return ISOWeekParser;
}(_Parser2.Parser);
exports.ISOWeekParser = ISOWeekParser;

/***/ }),

/***/ 36921:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOWeekYearParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(12246));
// ISO week-numbering year
var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(ISOWeekYearParser, _Parser);
  var _super = (0, _createSuper2.default)(ISOWeekYearParser);
  function ISOWeekYearParser() {
    var _this;
    (0, _classCallCheck2.default)(this, ISOWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return (0, _utils.parseNDigitsSigned)(4, dateString);
      }
      return (0, _utils.parseNDigitsSigned)(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return (0, _index.default)(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser;
}(_Parser2.Parser);
exports.ISOWeekYearParser = ISOWeekYearParser;

/***/ }),

/***/ 66931:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalDayParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(65275));
// Local day of week
var LocalDayParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(LocalDayParser, _Parser);
  var _super = (0, _createSuper2.default)(LocalDayParser);
  function LocalDayParser() {
    var _this;
    (0, _classCallCheck2.default)(this, LocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        // 3rd
        case 'eo':
          return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue
        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T
        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday
        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = (0, _index.default)(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser;
}(_Parser2.Parser);
exports.LocalDayParser = LocalDayParser;

/***/ }),

/***/ 60792:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalWeekParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(89369));
var _index2 = _interopRequireDefault(__webpack_require__(97968));
// Local week of year
var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(LocalWeekParser, _Parser);
  var _super = (0, _createSuper2.default)(LocalWeekParser);
  function LocalWeekParser() {
    var _this;
    (0, _classCallCheck2.default)(this, LocalWeekParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 100);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return (0, _index2.default)((0, _index.default)(date, value, options), options);
    }
  }]);
  return LocalWeekParser;
}(_Parser2.Parser);
exports.LocalWeekParser = LocalWeekParser;

/***/ }),

/***/ 38985:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalWeekYearParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(28465));
var _index2 = _interopRequireDefault(__webpack_require__(97968));
// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(LocalWeekYearParser, _Parser);
  var _super = (0, _createSuper2.default)(LocalWeekYearParser);
  function LocalWeekYearParser() {
    var _this;
    (0, _classCallCheck2.default)(this, LocalWeekYearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };
      switch (token) {
        case 'Y':
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
        case 'Yo':
          return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = (0, _index.default)(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return (0, _index2.default)(date, options);
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return (0, _index2.default)(date, options);
    }
  }]);
  return LocalWeekYearParser;
}(_Parser2.Parser);
exports.LocalWeekYearParser = LocalWeekYearParser;

/***/ }),

/***/ 55625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MinuteParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var MinuteParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(MinuteParser, _Parser);
  var _super = (0, _createSuper2.default)(MinuteParser);
  function MinuteParser() {
    var _this;
    (0, _classCallCheck2.default)(this, MinuteParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 60);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  (0, _createClass2.default)(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.minute, dateString);
        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser;
}(_Parser2.Parser);
exports.MinuteParser = MinuteParser;

/***/ }),

/***/ 48930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MonthParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _utils = __webpack_require__(95495);
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var MonthParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(MonthParser, _Parser);
  var _super = (0, _createSuper2.default)(MonthParser);
  function MonthParser() {
    var _this;
    (0, _classCallCheck2.default)(this, MonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 110);
    return _this;
  }
  (0, _createClass2.default)(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12
        case 'MM':
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case 'Mo':
          return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec
        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D
        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December
        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser;
}(_Parser2.Parser);
exports.MonthParser = MonthParser;

/***/ }),

/***/ 10361:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.QuarterParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var QuarterParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(QuarterParser, _Parser);
  var _super = (0, _createSuper2.default)(QuarterParser);
  function QuarterParser() {
    var _this;
    (0, _classCallCheck2.default)(this, QuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 120);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return (0, _utils.parseNDigits)(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...
        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser;
}(_Parser2.Parser);
exports.QuarterParser = QuarterParser;

/***/ }),

/***/ 99001:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SecondParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var SecondParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(SecondParser, _Parser);
  var _super = (0, _createSuper2.default)(SecondParser);
  function SecondParser() {
    var _this;
    (0, _classCallCheck2.default)(this, SecondParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 50);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['t', 'T']);
    return _this;
  }
  (0, _createClass2.default)(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return (0, _utils.parseNumericPattern)(_constants.numericPatterns.second, dateString);
        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });
        default:
          return (0, _utils.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser;
}(_Parser2.Parser);
exports.SecondParser = SecondParser;

/***/ }),

/***/ 72085:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StandAloneLocalDayParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var _index = _interopRequireDefault(__webpack_require__(65275));
// Stand-alone local day of week
var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(StandAloneLocalDayParser, _Parser);
  var _super = (0, _createSuper2.default)(StandAloneLocalDayParser);
  function StandAloneLocalDayParser() {
    var _this;
    (0, _classCallCheck2.default)(this, StandAloneLocalDayParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        // 3rd
        case 'co':
          return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue
        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T
        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu
        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday
        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = (0, _index.default)(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser;
}(_Parser2.Parser);
exports.StandAloneLocalDayParser = StandAloneLocalDayParser;

/***/ }),

/***/ 54122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StandAloneMonthParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _constants = __webpack_require__(30401);
var _utils = __webpack_require__(95495);
var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(StandAloneMonthParser, _Parser);
  var _super = (0, _createSuper2.default)(StandAloneMonthParser);
  function StandAloneMonthParser() {
    var _this;
    (0, _classCallCheck2.default)(this, StandAloneMonthParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 110);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12
        case 'LL':
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case 'Lo':
          return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec
        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D
        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December
        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser;
}(_Parser2.Parser);
exports.StandAloneMonthParser = StandAloneMonthParser;

/***/ }),

/***/ 35176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StandAloneQuarterParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(StandAloneQuarterParser, _Parser);
  var _super = (0, _createSuper2.default)(StandAloneQuarterParser);
  function StandAloneQuarterParser() {
    var _this;
    (0, _classCallCheck2.default)(this, StandAloneQuarterParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 120);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return (0, _utils.parseNDigits)(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...
        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser;
}(_Parser2.Parser);
exports.StandAloneQuarterParser = StandAloneQuarterParser;

/***/ }),

/***/ 54586:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TimestampMillisecondsParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(TimestampMillisecondsParser, _Parser);
  var _super = (0, _createSuper2.default)(TimestampMillisecondsParser);
  function TimestampMillisecondsParser() {
    var _this;
    (0, _classCallCheck2.default)(this, TimestampMillisecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 20);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", '*');
    return _this;
  }
  (0, _createClass2.default)(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return (0, _utils.parseAnyDigitsSigned)(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser;
}(_Parser2.Parser);
exports.TimestampMillisecondsParser = TimestampMillisecondsParser;

/***/ }),

/***/ 42613:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TimestampSecondsParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(TimestampSecondsParser, _Parser);
  var _super = (0, _createSuper2.default)(TimestampSecondsParser);
  function TimestampSecondsParser() {
    var _this;
    (0, _classCallCheck2.default)(this, TimestampSecondsParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 40);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", '*');
    return _this;
  }
  (0, _createClass2.default)(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return (0, _utils.parseAnyDigitsSigned)(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser;
}(_Parser2.Parser);
exports.TimestampSecondsParser = TimestampSecondsParser;

/***/ }),

/***/ 43878:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.YearParser = void 0;
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7432));
var _createClass2 = _interopRequireDefault(__webpack_require__(46063));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(95295));
var _inherits2 = _interopRequireDefault(__webpack_require__(14287));
var _createSuper2 = _interopRequireDefault(__webpack_require__(1052));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(75166));
var _Parser2 = __webpack_require__(98741);
var _utils = __webpack_require__(95495);
// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  (0, _inherits2.default)(YearParser, _Parser);
  var _super = (0, _createSuper2.default)(YearParser);
  function YearParser() {
    var _this;
    (0, _classCallCheck2.default)(this, YearParser);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
    return _this;
  }
  (0, _createClass2.default)(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };
      switch (token) {
        case 'y':
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
        case 'yo':
          return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);
        default:
          return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser;
}(_Parser2.Parser);
exports.YearParser = YearParser;

/***/ }),

/***/ 61396:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parsers = void 0;
var _EraParser = __webpack_require__(23193);
var _YearParser = __webpack_require__(43878);
var _LocalWeekYearParser = __webpack_require__(38985);
var _ISOWeekYearParser = __webpack_require__(36921);
var _ExtendedYearParser = __webpack_require__(15033);
var _QuarterParser = __webpack_require__(10361);
var _StandAloneQuarterParser = __webpack_require__(35176);
var _MonthParser = __webpack_require__(48930);
var _StandAloneMonthParser = __webpack_require__(54122);
var _LocalWeekParser = __webpack_require__(60792);
var _ISOWeekParser = __webpack_require__(33574);
var _DateParser = __webpack_require__(5746);
var _DayOfYearParser = __webpack_require__(44842);
var _DayParser = __webpack_require__(20132);
var _LocalDayParser = __webpack_require__(66931);
var _StandAloneLocalDayParser = __webpack_require__(72085);
var _ISODayParser = __webpack_require__(17121);
var _AMPMParser = __webpack_require__(27532);
var _AMPMMidnightParser = __webpack_require__(8676);
var _DayPeriodParser = __webpack_require__(22835);
var _Hour1to12Parser = __webpack_require__(72939);
var _Hour0to23Parser = __webpack_require__(60570);
var _Hour0To11Parser = __webpack_require__(97);
var _Hour1To24Parser = __webpack_require__(13506);
var _MinuteParser = __webpack_require__(55625);
var _SecondParser = __webpack_require__(99001);
var _FractionOfSecondParser = __webpack_require__(74124);
var _ISOTimezoneWithZParser = __webpack_require__(25179);
var _ISOTimezoneParser = __webpack_require__(99604);
var _TimestampSecondsParser = __webpack_require__(42613);
var _TimestampMillisecondsParser = __webpack_require__(54586);
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */
var parsers = {
  G: new _EraParser.EraParser(),
  y: new _YearParser.YearParser(),
  Y: new _LocalWeekYearParser.LocalWeekYearParser(),
  R: new _ISOWeekYearParser.ISOWeekYearParser(),
  u: new _ExtendedYearParser.ExtendedYearParser(),
  Q: new _QuarterParser.QuarterParser(),
  q: new _StandAloneQuarterParser.StandAloneQuarterParser(),
  M: new _MonthParser.MonthParser(),
  L: new _StandAloneMonthParser.StandAloneMonthParser(),
  w: new _LocalWeekParser.LocalWeekParser(),
  I: new _ISOWeekParser.ISOWeekParser(),
  d: new _DateParser.DateParser(),
  D: new _DayOfYearParser.DayOfYearParser(),
  E: new _DayParser.DayParser(),
  e: new _LocalDayParser.LocalDayParser(),
  c: new _StandAloneLocalDayParser.StandAloneLocalDayParser(),
  i: new _ISODayParser.ISODayParser(),
  a: new _AMPMParser.AMPMParser(),
  b: new _AMPMMidnightParser.AMPMMidnightParser(),
  B: new _DayPeriodParser.DayPeriodParser(),
  h: new _Hour1to12Parser.Hour1to12Parser(),
  H: new _Hour0to23Parser.Hour0to23Parser(),
  K: new _Hour0To11Parser.Hour0To11Parser(),
  k: new _Hour1To24Parser.Hour1To24Parser(),
  m: new _MinuteParser.MinuteParser(),
  s: new _SecondParser.SecondParser(),
  S: new _FractionOfSecondParser.FractionOfSecondParser(),
  X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser(),
  x: new _ISOTimezoneParser.ISOTimezoneParser(),
  t: new _TimestampSecondsParser.TimestampSecondsParser(),
  T: new _TimestampMillisecondsParser.TimestampMillisecondsParser()
};
exports.parsers = parsers;

/***/ }),

/***/ 95495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
exports.isLeapYearIndex = isLeapYearIndex;
exports.mapValue = mapValue;
exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
exports.parseNDigits = parseNDigits;
exports.parseNDigitsSigned = parseNDigitsSigned;
exports.parseNumericPattern = parseNumericPattern;
exports.parseTimezonePattern = parseTimezonePattern;
var _index = __webpack_require__(53372);
var _constants = __webpack_require__(30401);
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * _index.millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(_constants.numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(_constants.numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(_constants.numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(_constants.numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(_constants.numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(_constants.numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(_constants.numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(_constants.numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(_constants.numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;
    case 'evening':
      return 17;
    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;
    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

/***/ }),

/***/ 53651:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parse;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(29845));
var _index = _interopRequireDefault(__webpack_require__(67030));
var _index2 = _interopRequireDefault(__webpack_require__(2665));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(38177));
var _index5 = _interopRequireDefault(__webpack_require__(74049));
var _index6 = _interopRequireDefault(__webpack_require__(10944));
var _index7 = __webpack_require__(31374);
var _index8 = _interopRequireDefault(__webpack_require__(50687));
var _index9 = _interopRequireDefault(__webpack_require__(37716));
var _Setter = __webpack_require__(69638);
var _index10 = __webpack_require__(61396);
var _index11 = __webpack_require__(30596);
// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  (0, _index9.default)(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = (0, _index11.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index.default;
  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }
  var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }
  var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  if (formatString === '') {
    if (dateString === '') {
      return (0, _index3.default)(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  };

  // If timezone isn't specified, it will be set to the system timezone
  var setters = [new _Setter.DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in _index5.default) {
      var longFormatter = _index5.default[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = (0, _createForOfIteratorHelper2.default)(tokens),
    _step;
  try {
    var _loop = function _loop() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(token)) {
        (0, _index7.throwProtectedError)(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(token)) {
        (0, _index7.throwProtectedError)(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = _index10.parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        // Replace two single quote characters with one single quote character
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }

        // Cut token from string, or, if string doesn't match the token, return Invalid Date
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if ((0, _typeof2.default)(_ret) === "object") return _ret.v;
    }

    // Check if the remaining input contains something other than whitespace
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = (0, _index3.default)(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }

  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  var utcDate = (0, _index2.default)(date, (0, _index6.default)(date));
  var flags = {};
  var _iterator2 = (0, _createForOfIteratorHelper2.default)(uniquePrioritySetters),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      // Result is tuple (date, flags)
      if (Array.isArray(result)) {
        utcDate = result[0];
        (0, _index4.default)(flags, result[1]);
        // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
module.exports = exports.default;

/***/ }),

/***/ 20202:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parseISO;
var _index = __webpack_require__(53372);
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
function parseISO(argument, options) {
  var _options$additionalDi;
  (0, _index2.default)(1, arguments);
  var additionalDigits = (0, _index3.default)((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }
  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return {
    year: NaN,
    restDateString: ''
  };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);
  var captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * 1000;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
module.exports = exports.default;

/***/ }),

/***/ 48435:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parseJSON;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name parseJSON
 * @category Common Helpers
 * @summary Parse a JSON date string
 *
 * @description
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate]{@link https://date-fns.org/docs/toDate}:
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @param {String|Number|Date} argument A fully formed ISO8601 date string to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 */
function parseJSON(argument) {
  (0, _index2.default)(1, arguments);
  if (typeof argument === 'string') {
    var parts = argument.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/);
    if (parts) {
      // Group 8 matches the sign
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4] - (+parts[9] || 0) * (parts[8] == '-' ? -1 : 1), +parts[5] - (+parts[10] || 0) * (parts[8] == '-' ? -1 : 1), +parts[6], +((parts[7] || '0') + '00').substring(0, 3)));
    }
    return new Date(NaN);
  }
  return (0, _index.default)(argument);
}
module.exports = exports.default;

/***/ }),

/***/ 79994:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousDay;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(48461));
var _index3 = _interopRequireDefault(__webpack_require__(48070));
/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @param {Date | number} date - the date to check
 * @param {number} day - day of the week
 * @returns {Date} - the date is the previous day of week
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
function previousDay(date, day) {
  (0, _index.default)(2, arguments);
  var delta = (0, _index2.default)(date) - day;
  if (delta <= 0) delta += 7;
  return (0, _index3.default)(date, delta);
}
module.exports = exports.default;

/***/ }),

/***/ 87034:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousFriday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Friday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
function previousFriday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 5);
}
module.exports = exports.default;

/***/ }),

/***/ 78336:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousMonday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Monday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
function previousMonday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 1);
}
module.exports = exports.default;

/***/ }),

/***/ 59133:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousSaturday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Saturday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
function previousSaturday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 6);
}
module.exports = exports.default;

/***/ }),

/***/ 14146:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousSunday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
function previousSunday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 0);
}
module.exports = exports.default;

/***/ }),

/***/ 22439:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousThursday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Thursday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
function previousThursday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 4);
}
module.exports = exports.default;

/***/ }),

/***/ 36237:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousTuesday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Tuesday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
function previousTuesday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 2);
}
module.exports = exports.default;

/***/ }),

/***/ 28250:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = previousWednesday;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = _interopRequireDefault(__webpack_require__(79994));
/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @param {Date | number} date - the date to start counting from
 * @returns {Date} the previous Wednesday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
function previousWednesday(date) {
  (0, _index.default)(1, arguments);
  return (0, _index2.default)(date, 3);
}
module.exports = exports.default;

/***/ }),

/***/ 22519:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = quartersToMonths;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @param {number} quarters - number of quarters to be converted
 *
 * @returns {number} the number of quarters converted in months
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
function quartersToMonths(quarters) {
  (0, _index.default)(1, arguments);
  return Math.floor(quarters * _index2.monthsInQuarter);
}
module.exports = exports.default;

/***/ }),

/***/ 77293:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = quartersToYears;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @param {number} quarters - number of quarters to be converted
 *
 * @returns {number} the number of quarters converted in years
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
function quartersToYears(quarters) {
  (0, _index.default)(1, arguments);
  var years = quarters / _index2.quartersInYear;
  return Math.floor(years);
}
module.exports = exports.default;

/***/ }),

/***/ 62784:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = roundToNearestMinutes;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = __webpack_require__(43010);
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @param {Date|Number} date - the date to round
 * @param {Object} [options] - an object with options.
 * @param {Number} [options.nearestTo=1] - nearest number of minutes to round to. E.g. `15` to round to quarter hours.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Date} the new date rounded to the closest minute
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.nearestTo` must be between 1 and 30
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:07:30 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * // rounds up because given date is exactly between 12:00:00 and 12:15:00
 * //=> Thu Jul 10 2014 12:15:00
 */
function roundToNearestMinutes(dirtyDate, options) {
  var _options$nearestTo;
  if (arguments.length < 1) {
    throw new TypeError('1 argument required, but only none provided present');
  }
  var nearestTo = (0, _index3.default)((_options$nearestTo = options === null || options === void 0 ? void 0 : options.nearestTo) !== null && _options$nearestTo !== void 0 ? _options$nearestTo : 1);
  if (nearestTo < 1 || nearestTo > 30) {
    throw new RangeError('`options.nearestTo` must be between 1 and 30');
  }
  var date = (0, _index.default)(dirtyDate);
  var seconds = date.getSeconds(); // relevant if nearestTo is 1, which is the default case
  var minutes = date.getMinutes() + seconds / 60;
  var roundingMethod = (0, _index2.getRoundingMethod)(options === null || options === void 0 ? void 0 : options.roundingMethod);
  var roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;
  var remainderMinutes = minutes % nearestTo;
  var addedMinutes = Math.round(remainderMinutes / nearestTo) * nearestTo;
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), roundedMinutes + addedMinutes);
}
module.exports = exports.default;

/***/ }),

/***/ 7328:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = secondsToHours;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param {number} seconds - number of seconds to be converted
 *
 * @returns {number} the number of seconds converted in hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
function secondsToHours(seconds) {
  (0, _index.default)(1, arguments);
  var hours = seconds / _index2.secondsInHour;
  return Math.floor(hours);
}
module.exports = exports.default;

/***/ }),

/***/ 17368:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = secondsToMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param {number} seconds - number of seconds to be converted
 *
 * @returns {number} the number of seconds converted in milliseconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
function secondsToMilliseconds(seconds) {
  (0, _index.default)(1, arguments);
  return seconds * _index2.millisecondsInSecond;
}
module.exports = exports.default;

/***/ }),

/***/ 7967:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = secondsToMinutes;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param {number} seconds - number of seconds to be converted
 *
 * @returns {number} the number of seconds converted in minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
function secondsToMinutes(seconds) {
  (0, _index.default)(1, arguments);
  var minutes = seconds / _index2.secondsInMinute;
  return Math.floor(minutes);
}
module.exports = exports.default;

/***/ }),

/***/ 71993:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = set;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(7305));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Object} values - an object with options
 * @param {Number} [values.year] - the number of years to be set
 * @param {Number} [values.month] - the number of months to be set
 * @param {Number} [values.date] - the number of days to be set
 * @param {Number} [values.hours] - the number of hours to be set
 * @param {Number} [values.minutes] - the number of minutes to be set
 * @param {Number} [values.seconds] - the number of seconds to be set
 * @param {Number} [values.milliseconds] - the number of milliseconds to be set
 * @returns {Date} the new date with options set
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `values` must be an object
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */
function set(dirtyDate, values) {
  (0, _index4.default)(2, arguments);
  if ((0, _typeof2.default)(values) !== 'object' || values === null) {
    throw new RangeError('values parameter must be an object');
  }
  var date = (0, _index.default)(dirtyDate);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = (0, _index2.default)(date, values.month);
  }
  if (values.date != null) {
    date.setDate((0, _index3.default)(values.date));
  }
  if (values.hours != null) {
    date.setHours((0, _index3.default)(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes((0, _index3.default)(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds((0, _index3.default)(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds((0, _index3.default)(values.milliseconds));
  }
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 69074:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setDate;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} dayOfMonth - the day of the month of the new date
 * @returns {Date} the new date with the day of the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
function setDate(dirtyDate, dirtyDayOfMonth) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var dayOfMonth = (0, _index.default)(dirtyDayOfMonth);
  date.setDate(dayOfMonth);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 20401:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setDay;
var _index = _interopRequireDefault(__webpack_require__(83530));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var _index5 = __webpack_require__(30596);
/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} day - the day of the week of the new date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the new date with the day of the week set
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function setDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index4.default)(2, arguments);
  var defaultOptions = (0, _index5.getDefaultOptions)();
  var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = (0, _index2.default)(dirtyDate);
  var day = (0, _index3.default)(dirtyDay);
  var currentDay = date.getDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var delta = 7 - weekStartsOn;
  var diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return (0, _index.default)(date, diff);
}
module.exports = exports.default;

/***/ }),

/***/ 70994:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setDayOfYear;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} dayOfYear - the day of the year of the new date
 * @returns {Date} the new date with the day of the year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
function setDayOfYear(dirtyDate, dirtyDayOfYear) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var dayOfYear = (0, _index.default)(dirtyDayOfYear);
  date.setMonth(0);
  date.setDate(dayOfYear);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 13666:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setDefaultOptions;
var _index = __webpack_require__(30596);
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param {Object} newOptions - an object with options.
 * @param {Locale} [newOptions.locale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [newOptions.weekStartsOn] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [newOptions.firstWeekContainsDate] - the day of January, which is always in the first week of the year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
function setDefaultOptions(newOptions) {
  (0, _index2.default)(1, arguments);
  var result = {};
  var defaultOptions = (0, _index.getDefaultOptions)();
  for (var property in defaultOptions) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
      ;
      result[property] = defaultOptions[property];
    }
  }
  for (var _property in newOptions) {
    if (Object.prototype.hasOwnProperty.call(newOptions, _property)) {
      if (newOptions[_property] === undefined) {
        delete result[_property];
      } else {
        ;
        result[_property] = newOptions[_property];
      }
    }
  }
  (0, _index.setDefaultOptions)(result);
}
module.exports = exports.default;

/***/ }),

/***/ 39109:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setHours;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} hours - the hours of the new date
 * @returns {Date} the new date with the hours set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
function setHours(dirtyDate, dirtyHours) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var hours = (0, _index.default)(dirtyHours);
  date.setHours(hours);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 1837:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setISODay;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(83530));
var _index4 = _interopRequireDefault(__webpack_require__(91655));
var _index5 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday etc.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} day - the day of the ISO week of the new date
 * @returns {Date} the new date with the day of the ISO week set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
function setISODay(dirtyDate, dirtyDay) {
  (0, _index5.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var day = (0, _index.default)(dirtyDay);
  var currentDay = (0, _index4.default)(date);
  var diff = day - currentDay;
  return (0, _index3.default)(date, diff);
}
module.exports = exports.default;

/***/ }),

/***/ 17983:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setISOWeek;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(54343));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} isoWeek - the ISO week of the new date
 * @returns {Date} the new date with the ISO week set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
function setISOWeek(dirtyDate, dirtyISOWeek) {
  (0, _index4.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var isoWeek = (0, _index.default)(dirtyISOWeek);
  var diff = (0, _index3.default)(date) - isoWeek;
  date.setDate(date.getDate() - diff * 7);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 75574:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(4407));
var _index4 = _interopRequireDefault(__webpack_require__(64618));
var _index5 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} isoWeekYear - the ISO week-numbering year of the new date
 * @returns {Date} the new date with the ISO week-numbering year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
function setISOWeekYear(dirtyDate, dirtyISOWeekYear) {
  (0, _index5.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var isoWeekYear = (0, _index.default)(dirtyISOWeekYear);
  var diff = (0, _index4.default)(date, (0, _index3.default)(date));
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(isoWeekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  date = (0, _index3.default)(fourthOfJanuary);
  date.setDate(date.getDate() + diff);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 61652:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} milliseconds - the milliseconds of the new date
 * @returns {Date} the new date with the milliseconds set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var milliseconds = (0, _index.default)(dirtyMilliseconds);
  date.setMilliseconds(milliseconds);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 37517:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setMinutes;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} minutes - the minutes of the new date
 * @returns {Date} the new date with the minutes set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
function setMinutes(dirtyDate, dirtyMinutes) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var minutes = (0, _index.default)(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 7305:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setMonth;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(54223));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} month - the month of the new date
 * @returns {Date} the new date with the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
function setMonth(dirtyDate, dirtyMonth) {
  (0, _index4.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var month = (0, _index.default)(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = (0, _index3.default)(dateWithDesiredMonth);
  // Set the last day of the new month
  // if the original date was the last day of the longer month
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 40631:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setQuarter;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(7305));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} quarter - the quarter of the new date
 * @returns {Date} the new date with the quarter set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
function setQuarter(dirtyDate, dirtyQuarter) {
  (0, _index4.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var quarter = (0, _index.default)(dirtyQuarter);
  var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
  var diff = quarter - oldQuarter;
  return (0, _index3.default)(date, date.getMonth() + diff * 3);
}
module.exports = exports.default;

/***/ }),

/***/ 11405:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setSeconds;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} seconds - the seconds of the new date
 * @returns {Date} the new date with the seconds set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
function setSeconds(dirtyDate, dirtySeconds) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var seconds = (0, _index.default)(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 12256:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setWeek;
var _index = _interopRequireDefault(__webpack_require__(81507));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var _index4 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} week - the week of the new date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the new date with the local week set
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
function setWeek(dirtyDate, dirtyWeek, options) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var week = (0, _index4.default)(dirtyWeek);
  var diff = (0, _index.default)(date, options) - week;
  date.setDate(date.getDate() - diff * 7);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 35163:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setWeekYear;
var _index = _interopRequireDefault(__webpack_require__(64618));
var _index2 = _interopRequireDefault(__webpack_require__(70669));
var _index3 = _interopRequireDefault(__webpack_require__(70107));
var _index4 = _interopRequireDefault(__webpack_require__(50687));
var _index5 = _interopRequireDefault(__webpack_require__(37716));
var _index6 = __webpack_require__(30596);
/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} weekYear - the local week-numbering year of the new date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the new date with the local week-numbering year set
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
function setWeekYear(dirtyDate, dirtyWeekYear, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index5.default)(2, arguments);
  var defaultOptions = (0, _index6.getDefaultOptions)();
  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var date = (0, _index3.default)(dirtyDate);
  var weekYear = (0, _index4.default)(dirtyWeekYear);
  var diff = (0, _index.default)(date, (0, _index2.default)(date, options));
  var firstWeek = new Date(0);
  firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  date = (0, _index2.default)(firstWeek, options);
  date.setDate(date.getDate() + diff);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 51954:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = setYear;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(70107));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} year - the year of the new date
 * @returns {Date} the new date with the year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
function setYear(dirtyDate, dirtyYear) {
  (0, _index3.default)(2, arguments);
  var date = (0, _index2.default)(dirtyDate);
  var year = (0, _index.default)(dirtyYear);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 87597:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfDay;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 84667:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfDecade;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a decade
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
function startOfDecade(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var year = date.getFullYear();
  var decade = Math.floor(year / 10) * 10;
  date.setFullYear(decade, 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 18982:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfHour;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an hour
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
function startOfHour(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 38674:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfISOWeek;
var _index = _interopRequireDefault(__webpack_require__(11790));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(dirtyDate) {
  (0, _index2.default)(1, arguments);
  return (0, _index.default)(dirtyDate, {
    weekStartsOn: 1
  });
}
module.exports = exports.default;

/***/ }),

/***/ 4407:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfISOWeekYear;
var _index = _interopRequireDefault(__webpack_require__(6874));
var _index2 = _interopRequireDefault(__webpack_require__(38674));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an ISO week-numbering year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOWeekYear(dirtyDate) {
  (0, _index3.default)(1, arguments);
  var year = (0, _index.default)(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = (0, _index2.default)(fourthOfJanuary);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 10515:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfMinute;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a minute
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
function startOfMinute(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setSeconds(0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 63104:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfMonth;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfMonth(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 20183:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfQuarter;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a quarter
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
function startOfQuarter(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 70783:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfSecond;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a second
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
function startOfSecond(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var date = (0, _index.default)(dirtyDate);
  date.setMilliseconds(0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 63647:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfToday;
var _index = _interopRequireDefault(__webpack_require__(87597));
/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
function startOfToday() {
  return (0, _index.default)(Date.now());
}
module.exports = exports.default;

/***/ }),

/***/ 16002:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfTomorrow;
/**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @description
 * Return the start of tomorrow.
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `new Date()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the start of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
function startOfTomorrow() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 11790:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfWeek;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(50687));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var _index4 = __webpack_require__(30596);
/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index3.default)(1, arguments);
  var defaultOptions = (0, _index4.getDefaultOptions)();
  var weekStartsOn = (0, _index2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }
  var date = (0, _index.default)(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 70669:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfWeekYear;
var _index = _interopRequireDefault(__webpack_require__(36878));
var _index2 = _interopRequireDefault(__webpack_require__(11790));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
var _index4 = _interopRequireDefault(__webpack_require__(37716));
var _index5 = __webpack_require__(30596);
/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the start of a week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  (0, _index4.default)(1, arguments);
  var defaultOptions = (0, _index5.getDefaultOptions)();
  var firstWeekContainsDate = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = (0, _index.default)(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = (0, _index2.default)(firstWeek, options);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 69280:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfYear;
var _index = _interopRequireDefault(__webpack_require__(70107));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(dirtyDate) {
  (0, _index2.default)(1, arguments);
  var cleanDate = (0, _index.default)(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 58148:
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = startOfYesterday;
/**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @description
 * Return the start of yesterday.
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `new Date()` internally hence impure and can't be safely curried.
 *
 * @returns {Date} the start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
function startOfYesterday() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
module.exports = exports.default;

/***/ }),

/***/ 93118:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = sub;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(48070));
var _index2 = _interopRequireDefault(__webpack_require__(898));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
var _index4 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns {Date} the new date with the seconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
function sub(date, duration) {
  (0, _index3.default)(2, arguments);
  if (!duration || (0, _typeof2.default)(duration) !== 'object') return new Date(NaN);
  var years = duration.years ? (0, _index4.default)(duration.years) : 0;
  var months = duration.months ? (0, _index4.default)(duration.months) : 0;
  var weeks = duration.weeks ? (0, _index4.default)(duration.weeks) : 0;
  var days = duration.days ? (0, _index4.default)(duration.days) : 0;
  var hours = duration.hours ? (0, _index4.default)(duration.hours) : 0;
  var minutes = duration.minutes ? (0, _index4.default)(duration.minutes) : 0;
  var seconds = duration.seconds ? (0, _index4.default)(duration.seconds) : 0;

  // Subtract years and months
  var dateWithoutMonths = (0, _index2.default)(date, months + years * 12);

  // Subtract weeks and days
  var dateWithoutDays = (0, _index.default)(dateWithoutMonths, days + weeks * 7);

  // Subtract hours, minutes and seconds
  var minutestoSub = minutes + hours * 60;
  var secondstoSub = seconds + minutestoSub * 60;
  var mstoSub = secondstoSub * 1000;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}
module.exports = exports.default;

/***/ }),

/***/ 4494:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subBusinessDays;
var _index = _interopRequireDefault(__webpack_require__(42975));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Substract the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Substract the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of business days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the business days subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Substract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
function subBusinessDays(dirtyDate, dirtyAmount) {
  (0, _index2.default)(2, arguments);
  var amount = (0, _index3.default)(dirtyAmount);
  return (0, _index.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 48070:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subDays;
var _index = _interopRequireDefault(__webpack_require__(83530));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
function subDays(dirtyDate, dirtyAmount) {
  (0, _index2.default)(2, arguments);
  var amount = (0, _index3.default)(dirtyAmount);
  return (0, _index.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 73811:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subHours;
var _index = _interopRequireDefault(__webpack_require__(43462));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of hours to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the hours subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
function subHours(dirtyDate, dirtyAmount) {
  (0, _index2.default)(2, arguments);
  var amount = (0, _index3.default)(dirtyAmount);
  return (0, _index.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 11144:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subISOWeekYears;
var _index = _interopRequireDefault(__webpack_require__(17006));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of ISO week-numbering years to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the ISO week-numbering years subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
function subISOWeekYears(dirtyDate, dirtyAmount) {
  (0, _index2.default)(2, arguments);
  var amount = (0, _index3.default)(dirtyAmount);
  return (0, _index.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 2665:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subMilliseconds;
var _index = _interopRequireDefault(__webpack_require__(11098));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */
function subMilliseconds(dirtyDate, dirtyAmount) {
  (0, _index2.default)(2, arguments);
  var amount = (0, _index3.default)(dirtyAmount);
  return (0, _index.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 45675:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subMinutes;
var _index = _interopRequireDefault(__webpack_require__(98958));
var _index2 = _interopRequireDefault(__webpack_require__(37716));
var _index3 = _interopRequireDefault(__webpack_require__(50687));
/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the minutes subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
function subMinutes(dirtyDate, dirtyAmount) {
  (0, _index2.default)(2, arguments);
  var amount = (0, _index3.default)(dirtyAmount);
  return (0, _index.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 898:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subMonths;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(86069));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
function subMonths(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 71384:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subQuarters;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(75633));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of quarters to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the quarters subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
function subQuarters(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 21881:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subSeconds;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(87344));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name subSeconds
 * @category Second Helpers
 * @summary Subtract the specified number of seconds from the given date.
 *
 * @description
 * Subtract the specified number of seconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the seconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
function subSeconds(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 80276:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subWeeks;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(11237));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
function subWeeks(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 77493:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = subYears;
var _index = _interopRequireDefault(__webpack_require__(50687));
var _index2 = _interopRequireDefault(__webpack_require__(66291));
var _index3 = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
function subYears(dirtyDate, dirtyAmount) {
  (0, _index3.default)(2, arguments);
  var amount = (0, _index.default)(dirtyAmount);
  return (0, _index2.default)(dirtyDate, -amount);
}
module.exports = exports.default;

/***/ }),

/***/ 70107:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = toDate;
var _typeof2 = _interopRequireDefault(__webpack_require__(50426));
var _index = _interopRequireDefault(__webpack_require__(37716));
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument) {
  (0, _index.default)(1, arguments);
  var argStr = Object.prototype.toString.call(argument);

  // Clone the date
  if (argument instanceof Date || (0, _typeof2.default)(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      // eslint-disable-next-line no-console
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
module.exports = exports.default;

/***/ }),

/***/ 30803:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = weeksToDays;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param {number} weeks - number of weeks to be converted
 *
 * @returns {number} the number of weeks converted in days
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
function weeksToDays(weeks) {
  (0, _index.default)(1, arguments);
  return Math.floor(weeks * _index2.daysInWeek);
}
module.exports = exports.default;

/***/ }),

/***/ 33821:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = yearsToMonths;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param {number} years - number of years to be converted
 *
 * @returns {number} the number of years converted in months
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
function yearsToMonths(years) {
  (0, _index.default)(1, arguments);
  return Math.floor(years * _index2.monthsInYear);
}
module.exports = exports.default;

/***/ }),

/***/ 7370:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = (__webpack_require__(27574)["default"]);
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = yearsToQuarters;
var _index = _interopRequireDefault(__webpack_require__(37716));
var _index2 = __webpack_require__(53372);
/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param {number} years - number of years to be converted
 *
 * @returns {number} the number of years converted in quarters
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
function yearsToQuarters(years) {
  (0, _index.default)(1, arguments);
  return Math.floor(years * _index2.quartersInYear);
}
module.exports = exports.default;

/***/ }),

/***/ 98144:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
Object.defineProperty(exports, "Z", ({
    enumerable: true,
    get: function() {
        return _interopRequireDefault;
    }
}));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}


/***/ }),

/***/ 9840:
/***/ ((module) => {

"use strict";

/**
 * Create a new instance
 */ function Kareem() {
    this._pres = new Map();
    this._posts = new Map();
}
Kareem.skipWrappedFunction = function skipWrappedFunction() {
    if (!(this instanceof Kareem.skipWrappedFunction)) {
        return new Kareem.skipWrappedFunction(...arguments);
    }
    this.args = [
        ...arguments
    ];
};
Kareem.overwriteResult = function overwriteResult() {
    if (!(this instanceof Kareem.overwriteResult)) {
        return new Kareem.overwriteResult(...arguments);
    }
    this.args = [
        ...arguments
    ];
};
/**
 * Execute all "pre" hooks for "name"
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array|Function} args Optional arguments or directly the callback
 * @param {Function} [callback] The callback to call when executing all hooks are finished
 * @returns {void}
 */ Kareem.prototype.execPre = function(name, context, args, callback) {
    if (arguments.length === 3) {
        callback = args;
        args = [];
    }
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    const numAsyncPres = pres.numAsync || 0;
    let currentPre = 0;
    let asyncPresLeft = numAsyncPres;
    let done = false;
    const $args = args;
    let shouldSkipWrappedFunction = null;
    if (!numPres) {
        return nextTick(function() {
            callback(null);
        });
    }
    function next() {
        if (currentPre >= numPres) {
            return;
        }
        const pre = pres[currentPre];
        if (pre.isAsync) {
            const args = [
                decorateNextFn(_next),
                decorateNextFn(function(error) {
                    if (error) {
                        if (done) {
                            return;
                        }
                        if (error instanceof Kareem.skipWrappedFunction) {
                            shouldSkipWrappedFunction = error;
                        } else {
                            done = true;
                            return callback(error);
                        }
                    }
                    if (--asyncPresLeft === 0 && currentPre >= numPres) {
                        return callback(shouldSkipWrappedFunction);
                    }
                })
            ];
            callMiddlewareFunction(pre.fn, context, args, args[0]);
        } else if (pre.fn.length > 0) {
            const args = [
                decorateNextFn(_next)
            ];
            const _args = arguments.length >= 2 ? arguments : [
                null
            ].concat($args);
            for(let i = 1; i < _args.length; ++i){
                if (i === _args.length - 1 && typeof _args[i] === "function") {
                    continue; // skip callbacks to avoid accidentally calling the callback from a hook
                }
                args.push(_args[i]);
            }
            callMiddlewareFunction(pre.fn, context, args, args[0]);
        } else {
            let maybePromiseLike = null;
            try {
                maybePromiseLike = pre.fn.call(context);
            } catch (err) {
                if (err != null) {
                    return callback(err);
                }
            }
            if (isPromiseLike(maybePromiseLike)) {
                maybePromiseLike.then(()=>_next(), (err)=>_next(err));
            } else {
                if (++currentPre >= numPres) {
                    if (asyncPresLeft > 0) {
                        // Leave parallel hooks to run
                        return;
                    } else {
                        return nextTick(function() {
                            callback(shouldSkipWrappedFunction);
                        });
                    }
                }
                next();
            }
        }
    }
    next.apply(null, [
        null
    ].concat(args));
    function _next(error) {
        if (error) {
            if (done) {
                return;
            }
            if (error instanceof Kareem.skipWrappedFunction) {
                shouldSkipWrappedFunction = error;
            } else {
                done = true;
                return callback(error);
            }
        }
        if (++currentPre >= numPres) {
            if (asyncPresLeft > 0) {
                // Leave parallel hooks to run
                return;
            } else {
                return callback(shouldSkipWrappedFunction);
            }
        }
        next.apply(context, arguments);
    }
};
/**
 * Execute all "pre" hooks for "name" synchronously
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array} [args] Apply custom arguments to the hook
 * @returns {void}
 */ Kareem.prototype.execPreSync = function(name, context, args) {
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    for(let i = 0; i < numPres; ++i){
        pres[i].fn.apply(context, args || []);
    }
};
/**
 * Execute all "post" hooks for "name"
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array|Function} args Apply custom arguments to the hook
 * @param {*} options Optional options or directly the callback
 * @param {Function} [callback] The callback to call when executing all hooks are finished
 * @returns {void}
 */ Kareem.prototype.execPost = function(name, context, args, options, callback) {
    if (arguments.length < 5) {
        callback = options;
        options = null;
    }
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    let currentPost = 0;
    let firstError = null;
    if (options && options.error) {
        firstError = options.error;
    }
    if (!numPosts) {
        return nextTick(function() {
            callback.apply(null, [
                firstError
            ].concat(args));
        });
    }
    function next() {
        const post = posts[currentPost].fn;
        let numArgs = 0;
        const argLength = args.length;
        const newArgs = [];
        for(let i = 0; i < argLength; ++i){
            numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
            if (!args[i] || !args[i]._kareemIgnore) {
                newArgs.push(args[i]);
            }
        }
        if (firstError) {
            if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
                const _cb = decorateNextFn(function(error) {
                    if (error) {
                        if (error instanceof Kareem.overwriteResult) {
                            args = error.args;
                            if (++currentPost >= numPosts) {
                                return callback.call(null, firstError);
                            }
                            return next();
                        }
                        firstError = error;
                    }
                    if (++currentPost >= numPosts) {
                        return callback.call(null, firstError);
                    }
                    next();
                });
                callMiddlewareFunction(post, context, [
                    firstError
                ].concat(newArgs).concat([
                    _cb
                ]), _cb);
            } else {
                if (++currentPost >= numPosts) {
                    return callback.call(null, firstError);
                }
                next();
            }
        } else {
            const _cb = decorateNextFn(function(error) {
                if (error) {
                    if (error instanceof Kareem.overwriteResult) {
                        args = error.args;
                        if (++currentPost >= numPosts) {
                            return callback.apply(null, [
                                null
                            ].concat(args));
                        }
                        return next();
                    }
                    firstError = error;
                    return next();
                }
                if (++currentPost >= numPosts) {
                    return callback.apply(null, [
                        null
                    ].concat(args));
                }
                next();
            });
            if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
                // Skip error handlers if no error
                if (++currentPost >= numPosts) {
                    return callback.apply(null, [
                        null
                    ].concat(args));
                }
                return next();
            }
            if (post.length === numArgs + 1) {
                callMiddlewareFunction(post, context, newArgs.concat([
                    _cb
                ]), _cb);
            } else {
                let error;
                let maybePromiseLike;
                try {
                    maybePromiseLike = post.apply(context, newArgs);
                } catch (err) {
                    error = err;
                    firstError = err;
                }
                if (isPromiseLike(maybePromiseLike)) {
                    return maybePromiseLike.then((res)=>{
                        _cb(res instanceof Kareem.overwriteResult ? res : null);
                    }, (err)=>_cb(err));
                }
                if (maybePromiseLike instanceof Kareem.overwriteResult) {
                    args = maybePromiseLike.args;
                }
                if (++currentPost >= numPosts) {
                    return callback.apply(null, [
                        error
                    ].concat(args));
                }
                next();
            }
        }
    }
    next();
};
/**
 * Execute all "post" hooks for "name" synchronously
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array|Function} args Apply custom arguments to the hook
 * @returns {Array} The used arguments
 */ Kareem.prototype.execPostSync = function(name, context, args) {
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    for(let i = 0; i < numPosts; ++i){
        const res = posts[i].fn.apply(context, args || []);
        if (res instanceof Kareem.overwriteResult) {
            args = res.args;
        }
    }
    return args;
};
/**
 * Create a synchronous wrapper for "fn"
 * @param {String} name The name of the hook
 * @param {Function} fn The function to wrap
 * @returns {Function} The wrapped function
 */ Kareem.prototype.createWrapperSync = function(name, fn) {
    const _this = this;
    return function syncWrapper() {
        _this.execPreSync(name, this, arguments);
        const toReturn = fn.apply(this, arguments);
        const result = _this.execPostSync(name, this, [
            toReturn
        ]);
        return result[0];
    };
};
function _handleWrapError(instance, error, name, context, args, options, callback) {
    if (options.useErrorHandlers) {
        return instance.execPost(name, context, args, {
            error: error
        }, function(error) {
            return typeof callback === "function" && callback(error);
        });
    } else {
        return typeof callback === "function" && callback(error);
    }
}
/**
 * Executes pre hooks, followed by the wrapped function, followed by post hooks.
 * @param {String} name The name of the hook
 * @param {Function} fn The function for the hook
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array} args Apply custom arguments to the hook
 * @param {Object} [options]
 * @param {Boolean} [options.checkForPromise]
 * @returns {void}
 */ Kareem.prototype.wrap = function(name, fn, context, args, options) {
    const lastArg = args.length > 0 ? args[args.length - 1] : null;
    const argsWithoutCb = Array.from(args);
    typeof lastArg === "function" && argsWithoutCb.pop();
    const _this = this;
    options = options || {};
    const checkForPromise = options.checkForPromise;
    this.execPre(name, context, args, function(error) {
        if (error && !(error instanceof Kareem.skipWrappedFunction)) {
            const numCallbackParams = options.numCallbackParams || 0;
            const errorArgs = options.contextParameter ? [
                context
            ] : [];
            for(let i = errorArgs.length; i < numCallbackParams; ++i){
                errorArgs.push(null);
            }
            return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);
        }
        const numParameters = fn.length;
        let ret;
        if (error instanceof Kareem.skipWrappedFunction) {
            ret = error.args[0];
            return _cb(null, ...error.args);
        } else {
            try {
                ret = fn.apply(context, argsWithoutCb.concat(_cb));
            } catch (err) {
                return _cb(err);
            }
        }
        if (checkForPromise) {
            if (isPromiseLike(ret)) {
                // Thenable, use it
                return ret.then((res)=>_cb(null, res), (err)=>_cb(err));
            }
            // If `fn()` doesn't have a callback argument and doesn't return a
            // promise, assume it is sync
            if (numParameters < argsWithoutCb.length + 1) {
                return _cb(null, ret);
            }
        }
        function _cb() {
            const argsWithoutError = Array.from(arguments);
            argsWithoutError.shift();
            if (options.nullResultByDefault && argsWithoutError.length === 0) {
                argsWithoutError.push(null);
            }
            if (arguments[0]) {
                // Assume error
                return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);
            } else {
                _this.execPost(name, context, argsWithoutError, function() {
                    if (lastArg === null) {
                        return;
                    }
                    arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);
                });
            }
        }
    });
};
/**
 * Filter current instance for something specific and return the filtered clone
 * @param {Function} fn The filter function
 * @returns {Kareem} The cloned and filtered instance
 */ Kareem.prototype.filter = function(fn) {
    const clone = this.clone();
    const pres = Array.from(clone._pres.keys());
    for (const name of pres){
        const hooks = this._pres.get(name).map((h)=>Object.assign({}, h, {
                name: name
            })).filter(fn);
        if (hooks.length === 0) {
            clone._pres.delete(name);
            continue;
        }
        hooks.numAsync = hooks.filter((h)=>h.isAsync).length;
        clone._pres.set(name, hooks);
    }
    const posts = Array.from(clone._posts.keys());
    for (const name of posts){
        const hooks = this._posts.get(name).map((h)=>Object.assign({}, h, {
                name: name
            })).filter(fn);
        if (hooks.length === 0) {
            clone._posts.delete(name);
            continue;
        }
        clone._posts.set(name, hooks);
    }
    return clone;
};
/**
 * Check for a "name" to exist either in pre or post hooks
 * @param {String} name The name of the hook
 * @returns {Boolean} "true" if found, "false" otherwise
 */ Kareem.prototype.hasHooks = function(name) {
    return this._pres.has(name) || this._posts.has(name);
};
/**
 * Create a Wrapper for "fn" on "name" and return the wrapped function
 * @param {String} name The name of the hook
 * @param {Function} fn The function to wrap
 * @param {*} context Overwrite the "this" for the hook
 * @param {Object} [options]
 * @returns {Function} The wrapped function
 */ Kareem.prototype.createWrapper = function(name, fn, context, options) {
    const _this = this;
    if (!this.hasHooks(name)) {
        // Fast path: if there's no hooks for this function, just return the
        // function wrapped in a nextTick()
        return function() {
            nextTick(()=>fn.apply(this, arguments));
        };
    }
    return function() {
        const _context = context || this;
        _this.wrap(name, fn, _context, Array.from(arguments), options);
    };
};
/**
 * Register a new hook for "pre"
 * @param {String} name The name of the hook
 * @param {Boolean} [isAsync]
 * @param {Function} fn The function to register for "name"
 * @param {never} error Unused
 * @param {Boolean} [unshift] Wheter to "push" or to "unshift" the new hook
 * @returns {Kareem}
 */ Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {
    let options = {};
    if (typeof isAsync === "object" && isAsync !== null) {
        options = isAsync;
        isAsync = options.isAsync;
    } else if (typeof arguments[1] !== "boolean") {
        fn = isAsync;
        isAsync = false;
    }
    const pres = this._pres.get(name) || [];
    this._pres.set(name, pres);
    if (isAsync) {
        pres.numAsync = pres.numAsync || 0;
        ++pres.numAsync;
    }
    if (typeof fn !== "function") {
        throw new Error('pre() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
        pres.unshift(Object.assign({}, options, {
            fn: fn,
            isAsync: isAsync
        }));
    } else {
        pres.push(Object.assign({}, options, {
            fn: fn,
            isAsync: isAsync
        }));
    }
    return this;
};
/**
 * Register a new hook for "post"
 * @param {String} name The name of the hook
 * @param {Object} [options]
 * @param {Function} fn The function to register for "name"
 * @param {Boolean} [unshift] Wheter to "push" or to "unshift" the new hook
 * @returns {Kareem}
 */ Kareem.prototype.post = function(name, options, fn, unshift) {
    const posts = this._posts.get(name) || [];
    if (typeof options === "function") {
        unshift = !!fn;
        fn = options;
        options = {};
    }
    if (typeof fn !== "function") {
        throw new Error('post() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
        posts.unshift(Object.assign({}, options, {
            fn: fn
        }));
    } else {
        posts.push(Object.assign({}, options, {
            fn: fn
        }));
    }
    this._posts.set(name, posts);
    return this;
};
/**
 * Clone the current instance
 * @returns {Kareem} The cloned instance
 */ Kareem.prototype.clone = function() {
    const n = new Kareem();
    for (const key of this._pres.keys()){
        const clone = this._pres.get(key).slice();
        clone.numAsync = this._pres.get(key).numAsync;
        n._pres.set(key, clone);
    }
    for (const key of this._posts.keys()){
        n._posts.set(key, this._posts.get(key).slice());
    }
    return n;
};
/**
 * Merge "other" into self or "clone"
 * @param {Kareem} other The instance to merge with
 * @param {Kareem} [clone] The instance to merge onto (if not defined, using "this")
 * @returns {Kareem} The merged instance
 */ Kareem.prototype.merge = function(other, clone) {
    clone = arguments.length === 1 ? true : clone;
    const ret = clone ? this.clone() : this;
    for (const key of other._pres.keys()){
        const sourcePres = ret._pres.get(key) || [];
        const deduplicated = other._pres.get(key).// Deduplicate based on `fn`
        filter((p)=>sourcePres.map((_p)=>_p.fn).indexOf(p.fn) === -1);
        const combined = sourcePres.concat(deduplicated);
        combined.numAsync = sourcePres.numAsync || 0;
        combined.numAsync += deduplicated.filter((p)=>p.isAsync).length;
        ret._pres.set(key, combined);
    }
    for (const key of other._posts.keys()){
        const sourcePosts = ret._posts.get(key) || [];
        const deduplicated = other._posts.get(key).filter((p)=>sourcePosts.indexOf(p) === -1);
        ret._posts.set(key, sourcePosts.concat(deduplicated));
    }
    return ret;
};
function callMiddlewareFunction(fn, context, args, next) {
    let maybePromiseLike;
    try {
        maybePromiseLike = fn.apply(context, args);
    } catch (error) {
        return next(error);
    }
    if (isPromiseLike(maybePromiseLike)) {
        maybePromiseLike.then(()=>next(), (err)=>next(err));
    }
}
function isPromiseLike(v) {
    return typeof v === "object" && v !== null && typeof v.then === "function";
}
function decorateNextFn(fn) {
    let called = false;
    const _this = this;
    return function() {
        // Ensure this function can only be called once
        if (called) {
            return;
        }
        called = true;
        // Make sure to clear the stack so try/catch doesn't catch errors
        // in subsequent middleware
        return nextTick(()=>fn.apply(_this, arguments));
    };
}
const nextTick = typeof process === "object" && process !== null && process.nextTick || function nextTick(cb) {
    setTimeout(cb, 0);
};
function isErrorHandlingMiddleware(post, numArgs) {
    if (post.errorHandler) {
        return true;
    }
    return post.fn.length === numArgs + 2;
}
module.exports = Kareem;


/***/ }),

/***/ 80669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Export lib/mongoose
 *
 */ 
const mongoose = __webpack_require__(18070);
module.exports = mongoose;
module.exports["default"] = mongoose;
module.exports.mongoose = mongoose;
// Re-export for ESM support
module.exports.cast = mongoose.cast;
module.exports.STATES = mongoose.STATES;
module.exports.setDriver = mongoose.setDriver;
module.exports.set = mongoose.set;
module.exports.get = mongoose.get;
module.exports.createConnection = mongoose.createConnection;
module.exports.connect = mongoose.connect;
module.exports.disconnect = mongoose.disconnect;
module.exports.startSession = mongoose.startSession;
module.exports.pluralize = mongoose.pluralize;
module.exports.model = mongoose.model;
module.exports.deleteModel = mongoose.deleteModel;
module.exports.modelNames = mongoose.modelNames;
module.exports.plugin = mongoose.plugin;
module.exports.connections = mongoose.connections;
module.exports.version = mongoose.version;
module.exports.Mongoose = mongoose.Mongoose;
module.exports.Schema = mongoose.Schema;
module.exports.SchemaType = mongoose.SchemaType;
module.exports.SchemaTypes = mongoose.SchemaTypes;
module.exports.VirtualType = mongoose.VirtualType;
module.exports.Types = mongoose.Types;
module.exports.Query = mongoose.Query;
module.exports.Promise = mongoose.Promise;
module.exports.Model = mongoose.Model;
module.exports.Document = mongoose.Document;
module.exports.ObjectId = mongoose.ObjectId;
module.exports.isValidObjectId = mongoose.isValidObjectId;
module.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;
module.exports.syncIndexes = mongoose.syncIndexes;
module.exports.Decimal128 = mongoose.Decimal128;
module.exports.Mixed = mongoose.Mixed;
module.exports.Date = mongoose.Date;
module.exports.Number = mongoose.Number;
module.exports.Error = mongoose.Error;
module.exports.now = mongoose.now;
module.exports.CastError = mongoose.CastError;
module.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;
module.exports.mongo = mongoose.mongo;
module.exports.mquery = mongoose.mquery;
module.exports.sanitizeFilter = mongoose.sanitizeFilter;
module.exports.trusted = mongoose.trusted;
module.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;
module.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult; // The following properties are not exported using ESM because `setDriver()` can mutate these
 // module.exports.connection = mongoose.connection;
 // module.exports.Collection = mongoose.Collection;
 // module.exports.Connection = mongoose.Connection;


/***/ }),

/***/ 7545:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies
 */ const AggregationCursor = __webpack_require__(72689);
const Query = __webpack_require__(42921);
const { applyGlobalMaxTimeMS , applyGlobalDiskUse  } = __webpack_require__(73111);
const getConstructorName = __webpack_require__(4065);
const prepareDiscriminatorPipeline = __webpack_require__(52409);
const promiseOrCallback = __webpack_require__(83593);
const stringifyFunctionOperators = __webpack_require__(46873);
const utils = __webpack_require__(52100);
const read = Query.prototype.read;
const readConcern = Query.prototype.readConcern;
const validRedactStringValues = new Set([
    "$$DESCEND",
    "$$PRUNE",
    "$$KEEP"
]);
/**
 * Aggregate constructor used for building aggregation pipelines. Do not
 * instantiate this class directly, use [Model.aggregate()](/docs/api/model.html#model_Model-aggregate) instead.
 *
 * #### Example:
 *
 *     const aggregate = Model.aggregate([
 *       { $project: { a: 1, b: 1 } },
 *       { $skip: 5 }
 *     ]);
 *
 *     Model.
 *       aggregate([{ $match: { age: { $gte: 21 }}}]).
 *       unwind('tags').
 *       exec(callback);
 *
 * #### Note:
 *
 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
 * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database
 *
 *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);
 *     // Do this instead to cast to an ObjectId
 *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);
 *
 * @see MongoDB https://docs.mongodb.org/manual/applications/aggregation/
 * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate
 * @param {Array} [pipeline] aggregation pipeline as an array of objects
 * @param {Model} [model] the model to use with this aggregate.
 * @api public
 */ function Aggregate(pipeline, model) {
    this._pipeline = [];
    this._model = model;
    this.options = {};
    if (arguments.length === 1 && Array.isArray(pipeline)) {
        this.append.apply(this, pipeline);
    }
}
/**
 * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).
 * Supported options are:
 *
 * - [`allowDiskUse`](./api/aggregate.html#aggregate_Aggregate-allowDiskUse)
 * - `bypassDocumentValidation`
 * - [`collation`](./api/aggregate.html#aggregate_Aggregate-collation)
 * - `comment`
 * - [`cursor`](./api/aggregate.html#aggregate_Aggregate-cursor)
 * - [`explain`](./api/aggregate.html#aggregate_Aggregate-explain)
 * - `fieldsAsRaw`
 * - `hint`
 * - `let`
 * - `maxTimeMS`
 * - `raw`
 * - `readConcern`
 * - `readPreference`
 * - [`session`](./api/aggregate.html#aggregate_Aggregate-session)
 * - `writeConcern`
 *
 * @property options
 * @memberOf Aggregate
 * @api public
 */ Aggregate.prototype.options;
/**
 * Get/set the model that this aggregation will execute on.
 *
 * #### Example:
 *
 *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);
 *     aggregate.model() === MyModel; // true
 *
 *     // Change the model. There's rarely any reason to do this.
 *     aggregate.model(SomeOtherModel);
 *     aggregate.model() === SomeOtherModel; // true
 *
 * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.
 * @return {Model}
 * @api public
 */ Aggregate.prototype.model = function(model) {
    if (arguments.length === 0) {
        return this._model;
    }
    this._model = model;
    if (model.schema != null) {
        if (this.options.readPreference == null && model.schema.options.read != null) {
            this.options.readPreference = model.schema.options.read;
        }
        if (this.options.collation == null && model.schema.options.collation != null) {
            this.options.collation = model.schema.options.collation;
        }
    }
    return model;
};
/**
 * Appends new operators to this aggregate pipeline
 *
 * #### Example:
 *
 *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });
 *
 *     // or pass an array
 *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];
 *     aggregate.append(pipeline);
 *
 * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.append = function() {
    const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [
        ...arguments
    ];
    if (!args.every(isOperator)) {
        throw new Error("Arguments must be aggregate pipeline operators");
    }
    this._pipeline = this._pipeline.concat(args);
    return this;
};
/**
 * Appends a new $addFields operator to this aggregate pipeline.
 * Requires MongoDB v3.4+ to work
 *
 * #### Example:
 *
 *     // adding new fields based on existing fields
 *     aggregate.addFields({
 *         newField: '$b.nested'
 *       , plusTen: { $add: ['$val', 10]}
 *       , sub: {
 *            name: '$a'
 *         }
 *     })
 *
 *     // etc
 *     aggregate.addFields({ salary_k: { $divide: [ "$salary", 1000 ] } });
 *
 * @param {Object} arg field specification
 * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.addFields = function(arg) {
    if (typeof arg !== "object" || arg === null || Array.isArray(arg)) {
        throw new Error("Invalid addFields() argument. Must be an object");
    }
    return this.append({
        $addFields: Object.assign({}, arg)
    });
};
/**
 * Appends a new $project operator to this aggregate pipeline.
 *
 * Mongoose query [selection syntax](#query_Query-select) is also supported.
 *
 * #### Example:
 *
 *     // include a, include b, exclude _id
 *     aggregate.project("a b -_id");
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     aggregate.project({a: 1, b: 1, _id: 0});
 *
 *     // reshaping documents
 *     aggregate.project({
 *         newField: '$b.nested'
 *       , plusTen: { $add: ['$val', 10]}
 *       , sub: {
 *            name: '$a'
 *         }
 *     })
 *
 *     // etc
 *     aggregate.project({ salary_k: { $divide: [ "$salary", 1000 ] } });
 *
 * @param {Object|String} arg field specification
 * @see projection https://docs.mongodb.org/manual/reference/aggregation/project/
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.project = function(arg) {
    const fields = {};
    if (typeof arg === "object" && !Array.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
            fields[field] = arg[field];
        });
    } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
            if (!field) {
                return;
            }
            const include = field[0] === "-" ? 0 : 1;
            if (include === 0) {
                field = field.substring(1);
            }
            fields[field] = include;
        });
    } else {
        throw new Error("Invalid project() argument. Must be string or object");
    }
    return this.append({
        $project: fields
    });
};
/**
 * Appends a new custom $group operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.group({ _id: "$department" });
 *
 * @see $group https://docs.mongodb.org/manual/reference/aggregation/group/
 * @method group
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg $group operator contents
 * @return {Aggregate}
 * @api public
 */ /**
 * Appends a new custom $match operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.match({ department: { $in: [ "sales", "engineering" ] } });
 *
 * @see $match https://docs.mongodb.org/manual/reference/aggregation/match/
 * @method match
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg $match operator contents
 * @return {Aggregate}
 * @api public
 */ /**
 * Appends a new $skip operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.skip(10);
 *
 * @see $skip https://docs.mongodb.org/manual/reference/aggregation/skip/
 * @method skip
 * @memberOf Aggregate
 * @instance
 * @param {Number} num number of records to skip before next stage
 * @return {Aggregate}
 * @api public
 */ /**
 * Appends a new $limit operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.limit(10);
 *
 * @see $limit https://docs.mongodb.org/manual/reference/aggregation/limit/
 * @method limit
 * @memberOf Aggregate
 * @instance
 * @param {Number} num maximum number of records to pass to the next stage
 * @return {Aggregate}
 * @api public
 */ /**
 * Appends a new $densify operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *      aggregate.densify({
 *        field: 'timestamp',
 *        range: {
 *          step: 1,
 *          unit: 'hour',
 *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]
 *        }
 *      });
 *
 * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/
 * @method densify
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg $densify operator contents
 * @return {Aggregate}
 * @api public
 */ /**
 * Appends a new $fill operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *      aggregate.fill({
 *        output: {
 *          bootsSold: { value: 0 },
 *          sandalsSold: { value: 0 },
 *          sneakersSold: { value: 0 }
 *        }
 *      });
 *
 * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/
 * @method fill
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg $fill operator contents
 * @return {Aggregate}
 * @api public
 */ /**
 * Appends a new $geoNear operator to this aggregate pipeline.
 *
 * #### Note:
 *
 * **MUST** be used as the first operator in the pipeline.
 *
 * #### Example:
 *
 *     aggregate.near({
 *       near: { type: 'Point', coordinates: [40.724, -73.997] },
 *       distanceField: "dist.calculated", // required
 *       maxDistance: 0.008,
 *       query: { type: "public" },
 *       includeLocs: "dist.location",
 *       spherical: true,
 *     });
 *
 * @see $geoNear https://docs.mongodb.org/manual/reference/aggregation/geoNear/
 * @method near
 * @memberOf Aggregate
 * @instance
 * @param {Object} arg
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.near = function(arg) {
    const op = {};
    op.$geoNear = arg;
    return this.append(op);
};
/*!
 * define methods
 */ "group match skip limit out densify fill".split(" ").forEach(function($operator) {
    Aggregate.prototype[$operator] = function(arg) {
        const op = {};
        op["$" + $operator] = arg;
        return this.append(op);
    };
});
/**
 * Appends new custom $unwind operator(s) to this aggregate pipeline.
 *
 * Note that the `$unwind` operator requires the path name to start with '$'.
 * Mongoose will prepend '$' if the specified field doesn't start '$'.
 *
 * #### Example:
 *
 *     aggregate.unwind("tags");
 *     aggregate.unwind("a", "b", "c");
 *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });
 *
 * @see $unwind https://docs.mongodb.org/manual/reference/aggregation/unwind/
 * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.unwind = function() {
    const args = [
        ...arguments
    ];
    const res = [];
    for (const arg of args){
        if (arg && typeof arg === "object") {
            res.push({
                $unwind: arg
            });
        } else if (typeof arg === "string") {
            res.push({
                $unwind: arg[0] === "$" ? arg : "$" + arg
            });
        } else {
            throw new Error('Invalid arg "' + arg + '" to unwind(), ' + "must be string or object");
        }
    }
    return this.append.apply(this, res);
};
/**
 * Appends a new $replaceRoot operator to this aggregate pipeline.
 *
 * Note that the `$replaceRoot` operator requires field strings to start with '$'.
 * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.
 * If you are passing in an object the strings in your expression will not be altered.
 *
 * #### Example:
 *
 *     aggregate.replaceRoot("user");
 *
 *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });
 *
 * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot
 * @param {String|Object} newRoot the field or document which will become the new root document
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.replaceRoot = function(newRoot) {
    let ret;
    if (typeof newRoot === "string") {
        ret = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
    } else {
        ret = newRoot;
    }
    return this.append({
        $replaceRoot: {
            newRoot: ret
        }
    });
};
/**
 * Appends a new $count operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.count("userCount");
 *
 * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count
 * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.count = function(fieldName) {
    return this.append({
        $count: fieldName
    });
};
/**
 * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name
 * or a pipeline object.
 *
 * Note that the `$sortByCount` operator requires the new root to start with '$'.
 * Mongoose will prepend '$' if the specified field name doesn't start with '$'.
 *
 * #### Example:
 *
 *     aggregate.sortByCount('users');
 *     aggregate.sortByCount({ $mergeObjects: [ "$employee", "$business" ] })
 *
 * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/
 * @param {Object|String} arg
 * @return {Aggregate} this
 * @api public
 */ Aggregate.prototype.sortByCount = function(arg) {
    if (arg && typeof arg === "object") {
        return this.append({
            $sortByCount: arg
        });
    } else if (typeof arg === "string") {
        return this.append({
            $sortByCount: arg[0] === "$" ? arg : "$" + arg
        });
    } else {
        throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), ' + "must be string or object");
    }
};
/**
 * Appends new custom $lookup operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });
 *
 * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup
 * @param {Object} options to $lookup as described in the above link
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.lookup = function(options) {
    return this.append({
        $lookup: options
    });
};
/**
 * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.
 *
 * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.
 *
 * #### Example:
 *
 *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`
 *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites
 *
 * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup
 * @param {Object} options to $graphLookup as described in the above link
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.graphLookup = function(options) {
    const cloneOptions = {};
    if (options) {
        if (!utils.isObject(options)) {
            throw new TypeError("Invalid graphLookup() argument. Must be an object.");
        }
        utils.mergeClone(cloneOptions, options);
        const startWith = cloneOptions.startWith;
        if (startWith && typeof startWith === "string") {
            cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
        }
    }
    return this.append({
        $graphLookup: cloneOptions
    });
};
/**
 * Appends new custom $sample operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.sample(3); // Add a pipeline that picks 3 random documents
 *
 * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample
 * @param {Number} size number of random documents to pick
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.sample = function(size) {
    return this.append({
        $sample: {
            size: size
        }
    });
};
/**
 * Appends a new $sort operator to this aggregate pipeline.
 *
 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
 *
 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
 *
 * #### Example:
 *
 *     // these are equivalent
 *     aggregate.sort({ field: 'asc', test: -1 });
 *     aggregate.sort('field -test');
 *
 * @see $sort https://docs.mongodb.org/manual/reference/aggregation/sort/
 * @param {Object|String} arg
 * @return {Aggregate} this
 * @api public
 */ Aggregate.prototype.sort = function(arg) {
    // TODO refactor to reuse the query builder logic
    const sort = {};
    if (getConstructorName(arg) === "Object") {
        const desc = [
            "desc",
            "descending",
            -1
        ];
        Object.keys(arg).forEach(function(field) {
            // If sorting by text score, skip coercing into 1/-1
            if (arg[field] instanceof Object && arg[field].$meta) {
                sort[field] = arg[field];
                return;
            }
            sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
        });
    } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
            if (!field) {
                return;
            }
            const ascend = field[0] === "-" ? -1 : 1;
            if (ascend === -1) {
                field = field.substring(1);
            }
            sort[field] = ascend;
        });
    } else {
        throw new TypeError("Invalid sort() argument. Must be a string or object.");
    }
    return this.append({
        $sort: sort
    });
};
/**
 * Appends new $unionWith operator to this aggregate pipeline.
 *
 * #### Example:
 *
 *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });
 *
 * @see $unionWith https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith
 * @param {Object} options to $unionWith query as described in the above link
 * @return {Aggregate}
 * @api public
 */ Aggregate.prototype.unionWith = function(options) {
    return this.append({
        $unionWith: options
    });
};
/**
 * Sets the readPreference option for the aggregation query.
 *
 * #### Example:
 *
 *     await Model.aggregate(pipeline).read('primaryPreferred');
 *
 * @param {String|ReadPreference} pref one of the listed preference options or their aliases
 * @param {Array} [tags] optional tags for this query. DEPRECATED
 * @return {Aggregate} this
 * @api public
 * @see mongodb https://docs.mongodb.org/manual/applications/replication/#read-preference
 */ Aggregate.prototype.read = function(pref, tags) {
    read.call(this, pref, tags);
    return this;
};
/**
 * Sets the readConcern level for the aggregation query.
 *
 * #### Example:
 *
 *     await Model.aggregate(pipeline).readConcern('majority');
 *
 * @param {String} level one of the listed read concern level or their aliases
 * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/
 * @return {Aggregate} this
 * @api public
 */ Aggregate.prototype.readConcern = function(level) {
    readConcern.call(this, level);
    return this;
};
/**
 * Appends a new $redact operator to this aggregate pipeline.
 *
 * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively
 * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.
 *
 * #### Example:
 *
 *     await Model.aggregate(pipeline).redact({
 *       $cond: {
 *         if: { $eq: [ '$level', 5 ] },
 *         then: '$$PRUNE',
 *         else: '$$DESCEND'
 *       }
 *     });
 *
 *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose
 *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');
 *
 * @param {Object} expression redact options or conditional expression
 * @param {String|Object} [thenExpr] true case for the condition
 * @param {String|Object} [elseExpr] false case for the condition
 * @return {Aggregate} this
 * @see $redact https://docs.mongodb.com/manual/reference/operator/aggregation/redact/
 * @api public
 */ Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
    if (arguments.length === 3) {
        if (typeof thenExpr === "string" && !validRedactStringValues.has(thenExpr) || typeof elseExpr === "string" && !validRedactStringValues.has(elseExpr)) {
            throw new Error("If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP");
        }
        expression = {
            $cond: {
                if: expression,
                then: thenExpr,
                else: elseExpr
            }
        };
    } else if (arguments.length !== 1) {
        throw new TypeError("Invalid arguments");
    }
    return this.append({
        $redact: expression
    });
};
/**
 * Execute the aggregation with explain
 *
 * #### Example:
 *
 *     Model.aggregate(..).explain(callback)
 *
 * @param {String} [verbosity]
 * @param {Function} [callback] The callback function to call, if not specified, will return a Promise instead.
 * @return {Promise} Returns a promise if no "callback" is given
 */ Aggregate.prototype.explain = function(verbosity, callback) {
    const model = this._model;
    if (typeof verbosity === "function") {
        callback = verbosity;
        verbosity = null;
    }
    return promiseOrCallback(callback, (cb)=>{
        if (!this._pipeline.length) {
            const err = new Error("Aggregate has empty pipeline");
            return cb(err);
        }
        prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
        model.hooks.execPre("aggregate", this, (error)=>{
            if (error) {
                const _opts = {
                    error: error
                };
                return model.hooks.execPost("aggregate", this, [
                    null
                ], _opts, (error)=>{
                    cb(error);
                });
            }
            model.collection.aggregate(this._pipeline, this.options, (error, cursor)=>{
                if (error != null) {
                    const _opts = {
                        error: error
                    };
                    return model.hooks.execPost("aggregate", this, [
                        null
                    ], _opts, (error)=>{
                        cb(error);
                    });
                }
                if (verbosity != null) {
                    cursor.explain(verbosity, (error, result)=>{
                        const _opts = {
                            error: error
                        };
                        return model.hooks.execPost("aggregate", this, [
                            result
                        ], _opts, (error)=>{
                            if (error) {
                                return cb(error);
                            }
                            return cb(null, result);
                        });
                    });
                } else {
                    cursor.explain((error, result)=>{
                        const _opts = {
                            error: error
                        };
                        return model.hooks.execPost("aggregate", this, [
                            result
                        ], _opts, (error)=>{
                            if (error) {
                                return cb(error);
                            }
                            return cb(null, result);
                        });
                    });
                }
            });
        });
    }, model.events);
};
/**
 * Sets the allowDiskUse option for the aggregation query
 *
 * #### Example:
 *
 *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);
 *
 * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.
 * @return {Aggregate} this
 * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/
 */ Aggregate.prototype.allowDiskUse = function(value) {
    this.options.allowDiskUse = value;
    return this;
};
/**
 * Sets the hint option for the aggregation query
 *
 * #### Example:
 *
 *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec(callback)
 *
 * @param {Object|String} value a hint object or the index name
 * @return {Aggregate} this
 * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/
 */ Aggregate.prototype.hint = function(value) {
    this.options.hint = value;
    return this;
};
/**
 * Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html).
 *
 * #### Example:
 *
 *     const session = await Model.startSession();
 *     await Model.aggregate(..).session(session);
 *
 * @param {ClientSession} session
 * @return {Aggregate} this
 * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/
 */ Aggregate.prototype.session = function(session) {
    if (session == null) {
        delete this.options.session;
    } else {
        this.options.session = session;
    }
    return this;
};
/**
 * Lets you set arbitrary options, for middleware or plugins.
 *
 * #### Example:
 *
 *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option
 *     agg.options; // `{ allowDiskUse: true }`
 *
 * @param {Object} options keys to merge into current options
 * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)
 * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation
 * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](./docs/api/aggregate.html#aggregate_Aggregate-collation)
 * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](./docs/api/aggregate.html#aggregate_Aggregate-session)
 * @see mongodb https://docs.mongodb.org/manual/reference/command/aggregate/
 * @return {Aggregate} this
 * @api public
 */ Aggregate.prototype.option = function(value) {
    for(const key in value){
        this.options[key] = value[key];
    }
    return this;
};
/**
 * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.
 * Cursors are useful if you want to process the results of the aggregation one-at-a-time
 * because the aggregation result is too big to fit into memory.
 *
 * #### Example:
 *
 *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });
 *     cursor.eachAsync(function(doc, i) {
 *       // use doc
 *     });
 *
 * @param {Object} options
 * @param {Number} [options.batchSize] set the cursor batch size
 * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)
 * @return {AggregationCursor} cursor representing this aggregation
 * @api public
 * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html
 */ Aggregate.prototype.cursor = function(options) {
    this.options.cursor = options || {};
    return new AggregationCursor(this); // return this;
};
/**
 * Adds a collation
 *
 * #### Example:
 *
 *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });
 *
 * @param {Object} collation options
 * @return {Aggregate} this
 * @api public
 * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html
 */ Aggregate.prototype.collation = function(collation) {
    this.options.collation = collation;
    return this;
};
/**
 * Combines multiple aggregation pipelines.
 *
 * #### Example:
 *
 *     const res = await Model.aggregate().facet({
 *       books: [{ groupBy: '$author' }],
 *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]
 *     });
 *
 *     // Output: { books: [...], price: [{...}, {...}] }
 *
 * @param {Object} facet options
 * @return {Aggregate} this
 * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/
 * @api public
 */ Aggregate.prototype.facet = function(options) {
    return this.append({
        $facet: options
    });
};
/**
 * Helper for [Atlas Text Search](https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/)'s
 * `$search` stage.
 *
 * #### Example:
 *
 *     const res = await Model.aggregate().
 *      search({
 *        text: {
 *          query: 'baseball',
 *          path: 'plot'
 *        }
 *      });
 *
 *     // Output: [{ plot: '...', title: '...' }]
 *
 * @param {Object} $search options
 * @return {Aggregate} this
 * @see $search https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/
 * @api public
 */ Aggregate.prototype.search = function(options) {
    return this.append({
        $search: options
    });
};
/**
 * Returns the current pipeline
 *
 * #### Example:
 *
 *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]
 *
 * @return {Array} The current pipeline similar to the operation that will be executed
 * @api public
 */ Aggregate.prototype.pipeline = function() {
    return this._pipeline;
};
/**
 * Executes the aggregate pipeline on the currently bound Model.
 *
 * #### Example:
 *
 *     aggregate.exec(callback);
 *
 *     // Because a promise is returned, the `callback` is optional.
 *     const result = await aggregate.exec();
 *
 * @param {Function} [callback]
 * @return {Promise} Returns a Promise if no "callback" is given.
 * @api public
 */ Aggregate.prototype.exec = function(callback) {
    if (!this._model) {
        throw new Error("Aggregate not bound to any Model");
    }
    const model = this._model;
    const collection = this._model.collection;
    applyGlobalMaxTimeMS(this.options, model);
    applyGlobalDiskUse(this.options, model);
    if (this.options && this.options.cursor) {
        return new AggregationCursor(this);
    }
    return promiseOrCallback(callback, (cb)=>{
        prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
        stringifyFunctionOperators(this._pipeline);
        model.hooks.execPre("aggregate", this, (error)=>{
            if (error) {
                const _opts = {
                    error: error
                };
                return model.hooks.execPost("aggregate", this, [
                    null
                ], _opts, (error)=>{
                    cb(error);
                });
            }
            if (!this._pipeline.length) {
                return cb(new Error("Aggregate has empty pipeline"));
            }
            const options = utils.clone(this.options || {});
            collection.aggregate(this._pipeline, options, (err, cursor)=>{
                if (err != null) {
                    return cb(err);
                }
                cursor.toArray((error, result)=>{
                    const _opts = {
                        error: error
                    };
                    model.hooks.execPost("aggregate", this, [
                        result
                    ], _opts, (error, result)=>{
                        if (error) {
                            return cb(error);
                        }
                        cb(null, result);
                    });
                });
            });
        });
    }, model.events);
};
/**
 * Provides a Promise-like `then` function, which will call `.exec` without a callback
 * Compatible with `await`.
 *
 * #### Example:
 *
 *     Model.aggregate(..).then(successCallback, errorCallback);
 *
 * @param {Function} [resolve] successCallback
 * @param {Function} [reject]  errorCallback
 * @return {Promise}
 */ Aggregate.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
};
/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 * Like [`.then()`](#query_Query-then), but only takes a rejection handler.
 * Compatible with `await`.
 *
 * @param {Function} [reject]
 * @return {Promise}
 * @api public
 */ Aggregate.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
};
/**
 * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)
 * You do not need to call this function explicitly, the JavaScript runtime
 * will call it for you.
 *
 * #### Example:
 *
 *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);
 *     for await (const doc of agg) {
 *       console.log(doc.name);
 *     }
 *
 * Node.js 10.x supports async iterators natively without any flags. You can
 * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).
 *
 * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If
 * `Symbol.asyncIterator` is undefined, that means your Node.js version does not
 * support async iterators.
 *
 * @method Symbol.asyncIterator
 * @memberOf Aggregate
 * @instance
 * @api public
 */ if (Symbol.asyncIterator != null) {
    Aggregate.prototype[Symbol.asyncIterator] = function() {
        return this.cursor({
            useMongooseAggCursor: true
        }).transformNull()._transformForAsyncIterator();
    };
}
/*!
 * Helpers
 */ /**
 * Checks whether an object is likely a pipeline operator
 *
 * @param {Object} obj object to check
 * @return {Boolean}
 * @api private
 */ function isOperator(obj) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const k = Object.keys(obj);
    return k.length === 1 && k[0][0] === "$";
}
/**
 * Adds the appropriate `$match` pipeline step to the top of an aggregate's
 * pipeline, should it's model is a non-root discriminator type. This is
 * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
 *
 * @param {Aggregate} aggregate Aggregate to prepare
 * @api private
 */ Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
/*!
 * Exports
 */ module.exports = Aggregate;


/***/ }),

/***/ 53279:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const NodeJSDocument = __webpack_require__(14001);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const MongooseError = __webpack_require__(40413);
const Schema = __webpack_require__(74951);
const ObjectId = __webpack_require__(41370);
const ValidationError = MongooseError.ValidationError;
const applyHooks = __webpack_require__(13202);
const isObject = __webpack_require__(89026);
/**
 * Document constructor.
 *
 * @param {Object} obj the values to set
 * @param {Object} schema
 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
 * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter
 * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.
 * @event `save`: Emitted when the document is successfully saved
 * @api private
 */ function Document(obj, schema, fields, skipId, skipInit) {
    if (!(this instanceof Document)) {
        return new Document(obj, schema, fields, skipId, skipInit);
    }
    if (isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
    }
    // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id
    schema = this.schema || schema;
    // Generate ObjectId if it is missing, but it requires a scheme
    if (!this.schema && schema.options._id) {
        obj = obj || {};
        if (obj._id === undefined) {
            obj._id = new ObjectId();
        }
    }
    if (!schema) {
        throw new MongooseError.MissingSchemaError();
    }
    this.$__setSchema(schema);
    NodeJSDocument.call(this, obj, fields, skipId, skipInit);
    applyHooks(this, schema, {
        decorateDoc: true
    });
    // apply methods
    for(const m in schema.methods){
        this[m] = schema.methods[m];
    }
    // apply statics
    for(const s in schema.statics){
        this[s] = schema.statics[s];
    }
}
/*!
 * Inherit from the NodeJS document
 */ Document.prototype = Object.create(NodeJSDocument.prototype);
Document.prototype.constructor = Document;
/*!
 * ignore
 */ Document.events = new EventEmitter();
/*!
 * Browser doc exposes the event emitter API
 */ Document.$emitter = new EventEmitter();
[
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
].forEach(function(emitterFn) {
    Document[emitterFn] = function() {
        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
    };
});
/*!
 * Module exports.
 */ Document.ValidationError = ValidationError;
module.exports = exports = Document;


/***/ }),

/***/ 54749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const CastError = __webpack_require__(96996);
const StrictModeError = __webpack_require__(51016);
const Types = __webpack_require__(20042);
const cast$expr = __webpack_require__(17153);
const castTextSearch = __webpack_require__(83398);
const get = __webpack_require__(39223);
const getConstructorName = __webpack_require__(4065);
const getSchemaDiscriminatorByValue = __webpack_require__(16049);
const isOperator = __webpack_require__(75831);
const util = __webpack_require__(73837);
const isObject = __webpack_require__(89026);
const isMongooseObject = __webpack_require__(36569);
const ALLOWED_GEOWITHIN_GEOJSON_TYPES = [
    "Polygon",
    "MultiPolygon"
];
/**
 * Handles internal casting for query filters.
 *
 * @param {Schema} schema
 * @param {Object} obj Object to cast
 * @param {Object} [options] the query options
 * @param {Boolean|"throw"} [options.strict] Wheter to enable all strict options
 * @param {Boolean|"throw"} [options.strictQuery] Enable strict Queries
 * @param {Boolean} [options.upsert]
 * @param {Query} [context] passed to setters
 * @api private
 */ module.exports = function cast(schema, obj, options, context) {
    if (Array.isArray(obj)) {
        throw new Error("Query filter must be an object, got an array ", util.inspect(obj));
    }
    if (obj == null) {
        return obj;
    }
    if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
        schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
    }
    const paths = Object.keys(obj);
    let i = paths.length;
    let _keys;
    let any$conditionals;
    let schematype;
    let nested;
    let path;
    let type;
    let val;
    options = options || {};
    while(i--){
        path = paths[i];
        val = obj[path];
        if (path === "$or" || path === "$nor" || path === "$and") {
            if (!Array.isArray(val)) {
                throw new CastError("Array", val, path);
            }
            for(let k = val.length - 1; k >= 0; k--){
                if (val[k] == null || typeof val[k] !== "object") {
                    throw new CastError("Object", val[k], path + "." + k);
                }
                val[k] = cast(schema, val[k], options, context);
                if (Object.keys(val[k]).length === 0) {
                    val.splice(k, 1);
                }
            }
            if (val.length === 0) {
                delete obj[path];
            }
        } else if (path === "$where") {
            type = typeof val;
            if (type !== "string" && type !== "function") {
                throw new Error("Must have a string or function for $where");
            }
            if (type === "function") {
                obj[path] = val.toString();
            }
            continue;
        } else if (path === "$expr") {
            val = cast$expr(val, schema);
            continue;
        } else if (path === "$elemMatch") {
            val = cast(schema, val, options, context);
        } else if (path === "$text") {
            val = castTextSearch(val, path);
        } else {
            if (!schema) {
                continue;
            }
            schematype = schema.path(path);
            // Check for embedded discriminator paths
            if (!schematype) {
                const split = path.split(".");
                let j = split.length;
                while(j--){
                    const pathFirstHalf = split.slice(0, j).join(".");
                    const pathLastHalf = split.slice(j).join(".");
                    const _schematype = schema.path(pathFirstHalf);
                    const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;
                    // gh-6027: if we haven't found the schematype but this path is
                    // underneath an embedded discriminator and the embedded discriminator
                    // key is in the query, use the embedded discriminator schema
                    if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
                        const discriminatorVal = get(obj, pathFirstHalf + "." + discriminatorKey);
                        if (discriminatorVal != null) {
                            schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);
                        }
                    }
                }
            }
            if (!schematype) {
                // Handle potential embedded array queries
                const split = path.split(".");
                let j = split.length;
                let pathFirstHalf;
                let pathLastHalf;
                let remainingConds;
                // Find the part of the var path that is a path of the Schema
                while(j--){
                    pathFirstHalf = split.slice(0, j).join(".");
                    schematype = schema.path(pathFirstHalf);
                    if (schematype) {
                        break;
                    }
                }
                // If a substring of the input path resolves to an actual real path...
                if (schematype) {
                    // Apply the casting; similar code for $elemMatch in schema/array.js
                    if (schematype.caster && schematype.caster.schema) {
                        remainingConds = {};
                        pathLastHalf = split.slice(j).join(".");
                        remainingConds[pathLastHalf] = val;
                        const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
                        if (ret === void 0) {
                            delete obj[path];
                        } else {
                            obj[path] = ret;
                        }
                    } else {
                        obj[path] = val;
                    }
                    continue;
                }
                if (isObject(val)) {
                    // handle geo schemas that use object notation
                    // { loc: { long: Number, lat: Number }
                    let geo = "";
                    if (val.$near) {
                        geo = "$near";
                    } else if (val.$nearSphere) {
                        geo = "$nearSphere";
                    } else if (val.$within) {
                        geo = "$within";
                    } else if (val.$geoIntersects) {
                        geo = "$geoIntersects";
                    } else if (val.$geoWithin) {
                        geo = "$geoWithin";
                    }
                    if (geo) {
                        const numbertype = new Types.Number("__QueryCasting__");
                        let value = val[geo];
                        if (val.$maxDistance != null) {
                            val.$maxDistance = numbertype.castForQueryWrapper({
                                val: val.$maxDistance,
                                context: context
                            });
                        }
                        if (val.$minDistance != null) {
                            val.$minDistance = numbertype.castForQueryWrapper({
                                val: val.$minDistance,
                                context: context
                            });
                        }
                        if (geo === "$within") {
                            const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                            if (!withinType) {
                                throw new Error("Bad $within parameter: " + JSON.stringify(val));
                            }
                            value = withinType;
                        } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                            // geojson; cast the coordinates
                            value = value.coordinates;
                        } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                            if (value.$maxDistance != null) {
                                value.$maxDistance = numbertype.castForQueryWrapper({
                                    val: value.$maxDistance,
                                    context: context
                                });
                            }
                            if (value.$minDistance != null) {
                                value.$minDistance = numbertype.castForQueryWrapper({
                                    val: value.$minDistance,
                                    context: context
                                });
                            }
                            if (isMongooseObject(value.$geometry)) {
                                value.$geometry = value.$geometry.toObject({
                                    transform: false,
                                    virtuals: false
                                });
                            }
                            value = value.$geometry.coordinates;
                        } else if (geo === "$geoWithin") {
                            if (value.$geometry) {
                                if (isMongooseObject(value.$geometry)) {
                                    value.$geometry = value.$geometry.toObject({
                                        virtuals: false
                                    });
                                }
                                const geoWithinType = value.$geometry.type;
                                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                                    throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                                }
                                value = value.$geometry.coordinates;
                            } else {
                                value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                                if (isMongooseObject(value)) {
                                    value = value.toObject({
                                        virtuals: false
                                    });
                                }
                            }
                        }
                        _cast(value, numbertype, context);
                        continue;
                    }
                }
                if (schema.nested[path]) {
                    continue;
                }
                const strict = "strict" in options ? options.strict : schema.options.strict;
                const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
                if (options.upsert && strict) {
                    if (strict === "throw") {
                        throw new StrictModeError(path);
                    }
                    throw new StrictModeError(path, 'Path "' + path + '" is not in ' + "schema, strict mode is `true`, and upsert is `true`.");
                }
                if (strictQuery === "throw") {
                    throw new StrictModeError(path, 'Path "' + path + '" is not in ' + "schema and strictQuery is 'throw'.");
                } else if (strictQuery) {
                    delete obj[path];
                }
            } else if (val == null) {
                continue;
            } else if (getConstructorName(val) === "Object") {
                any$conditionals = Object.keys(val).some(isOperator);
                if (!any$conditionals) {
                    obj[path] = schematype.castForQueryWrapper({
                        val: val,
                        context: context
                    });
                } else {
                    const ks = Object.keys(val);
                    let $cond;
                    let k = ks.length;
                    while(k--){
                        $cond = ks[k];
                        nested = val[$cond];
                        if ($cond === "$not") {
                            if (nested && schematype) {
                                _keys = Object.keys(nested);
                                if (_keys.length && isOperator(_keys[0])) {
                                    for(const key in nested){
                                        nested[key] = schematype.castForQueryWrapper({
                                            $conditional: key,
                                            val: nested[key],
                                            context: context
                                        });
                                    }
                                } else {
                                    val[$cond] = schematype.castForQueryWrapper({
                                        $conditional: $cond,
                                        val: nested,
                                        context: context
                                    });
                                }
                                continue;
                            }
                        } else {
                            val[$cond] = schematype.castForQueryWrapper({
                                $conditional: $cond,
                                val: nested,
                                context: context
                            });
                        }
                    }
                }
            } else if (Array.isArray(val) && [
                "Buffer",
                "Array"
            ].indexOf(schematype.instance) === -1) {
                const casted = [];
                const valuesArray = val;
                for (const _val of valuesArray){
                    casted.push(schematype.castForQueryWrapper({
                        val: _val,
                        context: context
                    }));
                }
                obj[path] = {
                    $in: casted
                };
            } else {
                obj[path] = schematype.castForQueryWrapper({
                    val: val,
                    context: context
                });
            }
        }
    }
    return obj;
};
function _cast(val, numbertype, context) {
    if (Array.isArray(val)) {
        val.forEach(function(item, i) {
            if (Array.isArray(item) || isObject(item)) {
                return _cast(item, numbertype, context);
            }
            val[i] = numbertype.castForQueryWrapper({
                val: item,
                context: context
            });
        });
    } else {
        const nearKeys = Object.keys(val);
        let nearLen = nearKeys.length;
        while(nearLen--){
            const nkey = nearKeys[nearLen];
            const item = val[nkey];
            if (Array.isArray(item) || isObject(item)) {
                _cast(item, numbertype, context);
                val[nkey] = item;
            } else {
                val[nkey] = numbertype.castForQuery({
                    val: item,
                    context: context
                });
            }
        }
    }
}
function getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
    if ("strictQuery" in queryOptions) {
        return queryOptions.strictQuery;
    }
    if ("strict" in queryOptions) {
        return queryOptions.strict;
    }
    if ("strictQuery" in schemaUserProvidedOptions) {
        return schemaUserProvidedOptions.strictQuery;
    }
    if ("strict" in schemaUserProvidedOptions) {
        return schemaUserProvidedOptions.strict;
    }
    const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;
    if (mongooseOptions) {
        if ("strictQuery" in mongooseOptions) {
            return mongooseOptions.strictQuery;
        }
        if ("strict" in mongooseOptions) {
            return mongooseOptions.strict;
        }
    }
    return schemaOptions.strictQuery;
}


/***/ }),

/***/ 46709:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CastError = __webpack_require__(96996);
/**
 * Given a value, cast it to a boolean, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {CastError} if `value` is not one of the allowed values
 * @api private
 */ module.exports = function castBoolean(value, path) {
    if (module.exports.convertToTrue.has(value)) {
        return true;
    }
    if (module.exports.convertToFalse.has(value)) {
        return false;
    }
    if (value == null) {
        return value;
    }
    throw new CastError("boolean", value, path);
};
module.exports.convertToTrue = new Set([
    true,
    "true",
    1,
    "1",
    "yes"
]);
module.exports.convertToFalse = new Set([
    false,
    "false",
    0,
    "0",
    "no"
]);


/***/ }),

/***/ 27320:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const assert = __webpack_require__(39491);
module.exports = function castDate(value) {
    // Support empty string because of empty form values. Originally introduced
    // in https://github.com/Automattic/mongoose/commit/efc72a1898fc3c33a319d915b8c5463a22938dfe
    if (value == null || value === "") {
        return null;
    }
    if (value instanceof Date) {
        assert.ok(!isNaN(value.valueOf()));
        return value;
    }
    let date;
    assert.ok(typeof value !== "boolean");
    if (value instanceof Number || typeof value === "number") {
        date = new Date(value);
    } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
        // string representation of milliseconds take this path
        date = new Date(Number(value));
    } else if (typeof value.valueOf === "function") {
        // support for moment.js. This is also the path strings will take because
        // strings have a `valueOf()`
        date = new Date(value.valueOf());
    } else {
        // fallback
        date = new Date(value);
    }
    if (!isNaN(date.valueOf())) {
        return date;
    }
    assert.ok(false);
};


/***/ }),

/***/ 46930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Decimal128Type = __webpack_require__(37489);
const assert = __webpack_require__(39491);
module.exports = function castDecimal128(value) {
    if (value == null) {
        return value;
    }
    if (typeof value === "object" && typeof value.$numberDecimal === "string") {
        return Decimal128Type.fromString(value.$numberDecimal);
    }
    if (value instanceof Decimal128Type) {
        return value;
    }
    if (typeof value === "string") {
        return Decimal128Type.fromString(value);
    }
    if (Buffer.isBuffer(value)) {
        return new Decimal128Type(value);
    }
    if (typeof value === "number") {
        return Decimal128Type.fromString(String(value));
    }
    if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
        return Decimal128Type.fromString(value.valueOf());
    }
    assert.ok(false);
};


/***/ }),

/***/ 71155:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const assert = __webpack_require__(39491);
/**
 * Given a value, cast it to a number, or throw an `Error` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @return {Number}
 * @throws {Error} if `value` is not one of the allowed values
 * @api private
 */ module.exports = function castNumber(val) {
    if (val == null) {
        return val;
    }
    if (val === "") {
        return null;
    }
    if (typeof val === "string" || typeof val === "boolean") {
        val = Number(val);
    }
    assert.ok(!isNaN(val));
    if (val instanceof Number) {
        return val.valueOf();
    }
    if (typeof val === "number") {
        return val;
    }
    if (!Array.isArray(val) && typeof val.valueOf === "function") {
        return Number(val.valueOf());
    }
    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
        return Number(val);
    }
    assert.ok(false);
};


/***/ }),

/***/ 82637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isBsonType = __webpack_require__(85847);
const ObjectId = (__webpack_require__(67085).get)().ObjectId;
module.exports = function castObjectId(value) {
    if (value == null) {
        return value;
    }
    if (isBsonType(value, "ObjectID")) {
        return value;
    }
    if (value._id) {
        if (isBsonType(value._id, "ObjectID")) {
            return value._id;
        }
        if (value._id.toString instanceof Function) {
            return new ObjectId(value._id.toString());
        }
    }
    if (value.toString instanceof Function) {
        return new ObjectId(value.toString());
    }
    return new ObjectId(value);
};


/***/ }),

/***/ 16199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CastError = __webpack_require__(96996);
/**
 * Given a value, cast it to a string, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {string|null|undefined}
 * @throws {CastError}
 * @api private
 */ module.exports = function castString(value, path) {
    // If null or undefined
    if (value == null) {
        return value;
    }
    // handle documents being passed
    if (value._id && typeof value._id === "string") {
        return value._id;
    }
    // Re: gh-647 and gh-3030, we're ok with casting using `toString()`
    // **unless** its the default Object.toString, because "[object Object]"
    // doesn't really qualify as useful data
    if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
        return value.toString();
    }
    throw new CastError("string", value, path);
};


/***/ }),

/***/ 26331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const EventEmitter = (__webpack_require__(82361).EventEmitter);
const STATES = __webpack_require__(25840);
const immediate = __webpack_require__(96621);
/**
 * Abstract Collection constructor
 *
 * This is the base class that drivers inherit from and implement.
 *
 * @param {String} name name of the collection
 * @param {Connection} conn A MongooseConnection instance
 * @param {Object} [opts] optional collection options
 * @api public
 */ function Collection(name, conn, opts) {
    if (opts === void 0) {
        opts = {};
    }
    this.opts = opts;
    this.name = name;
    this.collectionName = name;
    this.conn = conn;
    this.queue = [];
    this.buffer = true;
    this.emitter = new EventEmitter();
    if (STATES.connected === this.conn.readyState) {
        this.onOpen();
    }
}
/**
 * The collection name
 *
 * @api public
 * @property name
 */ Collection.prototype.name;
/**
 * The collection name
 *
 * @api public
 * @property collectionName
 */ Collection.prototype.collectionName;
/**
 * The Connection instance
 *
 * @api public
 * @property conn
 */ Collection.prototype.conn;
/**
 * Called when the database connects
 *
 * @api private
 */ Collection.prototype.onOpen = function() {
    this.buffer = false;
    immediate(()=>this.doQueue());
};
/**
 * Called when the database disconnects
 *
 * @api private
 */ Collection.prototype.onClose = function() {};
/**
 * Queues a method for later execution when its
 * database connection opens.
 *
 * @param {String} name name of the method to queue
 * @param {Array} args arguments to pass to the method when executed
 * @api private
 */ Collection.prototype.addQueue = function(name, args) {
    this.queue.push([
        name,
        args
    ]);
    return this;
};
/**
 * Removes a queued method
 *
 * @param {String} name name of the method to queue
 * @param {Array} args arguments to pass to the method when executed
 * @api private
 */ Collection.prototype.removeQueue = function(name, args) {
    const index = this.queue.findIndex((v)=>v[0] === name && v[1] === args);
    if (index === -1) {
        return false;
    }
    this.queue.splice(index, 1);
    return true;
};
/**
 * Executes all queued methods and clears the queue.
 *
 * @api private
 */ Collection.prototype.doQueue = function() {
    for (const method of this.queue){
        if (typeof method[0] === "function") {
            method[0].apply(this, method[1]);
        } else {
            this[method[0]].apply(this, method[1]);
        }
    }
    this.queue = [];
    const _this = this;
    immediate(function() {
        _this.emitter.emit("queue");
    });
    return this;
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.ensureIndex = function() {
    throw new Error("Collection#ensureIndex unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.createIndex = function() {
    throw new Error("Collection#createIndex unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.findAndModify = function() {
    throw new Error("Collection#findAndModify unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.findOneAndUpdate = function() {
    throw new Error("Collection#findOneAndUpdate unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.findOneAndDelete = function() {
    throw new Error("Collection#findOneAndDelete unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.findOneAndReplace = function() {
    throw new Error("Collection#findOneAndReplace unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.findOne = function() {
    throw new Error("Collection#findOne unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.find = function() {
    throw new Error("Collection#find unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.insert = function() {
    throw new Error("Collection#insert unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.insertOne = function() {
    throw new Error("Collection#insertOne unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.insertMany = function() {
    throw new Error("Collection#insertMany unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.save = function() {
    throw new Error("Collection#save unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.update = function() {
    throw new Error("Collection#update unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.getIndexes = function() {
    throw new Error("Collection#getIndexes unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.mapReduce = function() {
    throw new Error("Collection#mapReduce unimplemented by driver");
};
/**
 * Abstract method that drivers must implement.
 */ Collection.prototype.watch = function() {
    throw new Error("Collection#watch unimplemented by driver");
};
/*!
 * ignore
 */ Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    const opts = this.opts;
    if (opts.bufferCommands != null) {
        return opts.bufferCommands;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
        return opts.schemaUserProvidedOptions.bufferCommands;
    }
    return this.conn._shouldBufferCommands();
};
/*!
 * ignore
 */ Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
    const conn = this.conn;
    const opts = this.opts;
    if (opts.bufferTimeoutMS != null) {
        return opts.bufferTimeoutMS;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
        return opts.schemaUserProvidedOptions.bufferTimeoutMS;
    }
    if (conn.config.bufferTimeoutMS != null) {
        return conn.config.bufferTimeoutMS;
    }
    if (conn.base != null && conn.base.get("bufferTimeoutMS") != null) {
        return conn.base.get("bufferTimeoutMS");
    }
    return 10000;
};
/*!
 * Module exports.
 */ module.exports = Collection;


/***/ }),

/***/ 63406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const ChangeStream = __webpack_require__(67659);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const Schema = __webpack_require__(74951);
const STATES = __webpack_require__(25840);
const MongooseError = __webpack_require__(40413);
const DisconnectedError = __webpack_require__(8089);
const SyncIndexesError = __webpack_require__(3144);
const PromiseProvider = __webpack_require__(46433);
const ServerSelectionError = __webpack_require__(76027);
const applyPlugins = __webpack_require__(36573);
const driver = __webpack_require__(67085);
const promiseOrCallback = __webpack_require__(83593);
const get = __webpack_require__(39223);
const immediate = __webpack_require__(96621);
const mongodb = __webpack_require__(38013);
const pkg = __webpack_require__(13991);
const utils = __webpack_require__(52100);
const processConnectionOptions = __webpack_require__(74976);
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const sessionNewDocuments = (__webpack_require__(5089).sessionNewDocuments);
/**
 * A list of authentication mechanisms that don't require a password for authentication.
 * This is used by the authMechanismDoesNotRequirePassword method.
 *
 * @api private
 */ const noPasswordAuthMechanisms = [
    "MONGODB-X509"
];
/**
 * Connection constructor
 *
 * For practical reasons, a Connection equals a Db.
 *
 * @param {Mongoose} base a mongoose instance
 * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter
 * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.
 * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.
 * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.
 * @event `disconnecting`: Emitted when `connection.close()` was executed.
 * @event `disconnected`: Emitted after getting disconnected from the db.
 * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.
 * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.
 * @event `error`: Emitted when an error occurs on this connection.
 * @event `fullsetup`: Emitted after the driver has connected to primary and all secondaries if specified in the connection string.
 * @api public
 */ function Connection(base) {
    this.base = base;
    this.collections = {};
    this.models = {};
    this.config = {};
    this.replica = false;
    this.options = null;
    this.otherDbs = []; // FIXME: To be replaced with relatedDbs
    this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection
    this.states = STATES;
    this._readyState = STATES.disconnected;
    this._closeCalled = false;
    this._hasOpened = false;
    this.plugins = [];
    if (typeof base === "undefined" || !base.connections.length) {
        this.id = 0;
    } else {
        this.id = base.nextConnectionId;
    }
    this._queue = [];
}
/*!
 * Inherit from EventEmitter
 */ Object.setPrototypeOf(Connection.prototype, EventEmitter.prototype);
/**
 * Connection ready state
 *
 * - 0 = disconnected
 * - 1 = connected
 * - 2 = connecting
 * - 3 = disconnecting
 *
 * Each state change emits its associated event name.
 *
 * #### Example:
 *
 *     conn.on('connected', callback);
 *     conn.on('disconnected', callback);
 *
 * @property readyState
 * @memberOf Connection
 * @instance
 * @api public
 */ Object.defineProperty(Connection.prototype, "readyState", {
    get: function() {
        return this._readyState;
    },
    set: function(val) {
        if (!(val in STATES)) {
            throw new Error("Invalid connection state: " + val);
        }
        if (this._readyState !== val) {
            this._readyState = val;
            // [legacy] loop over the otherDbs on this connection and change their state
            for (const db of this.otherDbs){
                db.readyState = val;
            }
            if (STATES.connected === val) {
                this._hasOpened = true;
            }
            this.emit(STATES[val]);
        }
    }
});
/**
 * Gets the value of the option `key`. Equivalent to `conn.options[key]`
 *
 * #### Example:
 *
 *     conn.get('test'); // returns the 'test' value
 *
 * @param {String} key
 * @method get
 * @api public
 */ Connection.prototype.get = function(key) {
    if (this.config.hasOwnProperty(key)) {
        return this.config[key];
    }
    return get(this.options, key);
};
/**
 * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`
 *
 * Supported options include:
 *
 * - `maxTimeMS`: Set [`maxTimeMS`](/docs/api/query.html#query_Query-maxTimeMS) for all queries on this connection.
 * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.
 *
 * #### Example:
 *
 *     conn.set('test', 'foo');
 *     conn.get('test'); // 'foo'
 *     conn.options.test; // 'foo'
 *
 * @param {String} key
 * @param {Any} val
 * @method set
 * @api public
 */ Connection.prototype.set = function(key, val) {
    if (this.config.hasOwnProperty(key)) {
        this.config[key] = val;
        return val;
    }
    this.options = this.options || {};
    this.options[key] = val;
    return val;
};
/**
 * A hash of the collections associated with this connection
 *
 * @property collections
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.collections;
/**
 * The name of the database this connection points to.
 *
 * #### Example:
 *
 *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // "mydb"
 *
 * @property name
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.name;
/**
 * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing
 * a map from model names to models. Contains all models that have been
 * added to this connection using [`Connection#model()`](/docs/api/connection.html#connection_Connection-model).
 *
 * #### Example:
 *
 *     const conn = mongoose.createConnection();
 *     const Test = conn.model('Test', mongoose.Schema({ name: String }));
 *
 *     Object.keys(conn.models).length; // 1
 *     conn.models.Test === Test; // true
 *
 * @property models
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.models;
/**
 * A number identifier for this connection. Used for debugging when
 * you have [multiple connections](/docs/connections.html#multiple_connections).
 *
 * #### Example:
 *
 *     // The default connection has `id = 0`
 *     mongoose.connection.id; // 0
 *
 *     // If you create a new connection, Mongoose increments id
 *     const conn = mongoose.createConnection();
 *     conn.id; // 1
 *
 * @property id
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.id;
/**
 * The plugins that will be applied to all models created on this connection.
 *
 * #### Example:
 *
 *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');
 *     db.plugin(() => console.log('Applied'));
 *     db.plugins.length; // 1
 *
 *     db.model('Test', new Schema({})); // Prints "Applied"
 *
 * @property plugins
 * @memberOf Connection
 * @instance
 * @api public
 */ Object.defineProperty(Connection.prototype, "plugins", {
    configurable: false,
    enumerable: true,
    writable: true
});
/**
 * The host name portion of the URI. If multiple hosts, such as a replica set,
 * this will contain the first host name in the URI
 *
 * #### Example:
 *
 *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // "127.0.0.1"
 *
 * @property host
 * @memberOf Connection
 * @instance
 * @api public
 */ Object.defineProperty(Connection.prototype, "host", {
    configurable: true,
    enumerable: true,
    writable: true
});
/**
 * The port portion of the URI. If multiple hosts, such as a replica set,
 * this will contain the port from the first host name in the URI.
 *
 * #### Example:
 *
 *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017
 *
 * @property port
 * @memberOf Connection
 * @instance
 * @api public
 */ Object.defineProperty(Connection.prototype, "port", {
    configurable: true,
    enumerable: true,
    writable: true
});
/**
 * The username specified in the URI
 *
 * #### Example:
 *
 *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // "val"
 *
 * @property user
 * @memberOf Connection
 * @instance
 * @api public
 */ Object.defineProperty(Connection.prototype, "user", {
    configurable: true,
    enumerable: true,
    writable: true
});
/**
 * The password specified in the URI
 *
 * #### Example:
 *
 *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // "psw"
 *
 * @property pass
 * @memberOf Connection
 * @instance
 * @api public
 */ Object.defineProperty(Connection.prototype, "pass", {
    configurable: true,
    enumerable: true,
    writable: true
});
/**
 * The mongodb.Db instance, set when the connection is opened
 *
 * @property db
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.db;
/**
 * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property
 * when the connection is opened.
 *
 * @property client
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.client;
/**
 * A hash of the global options that are associated with this connection
 *
 * @property config
 * @memberOf Connection
 * @instance
 * @api public
 */ Connection.prototype.config;
/**
 * Helper for `createCollection()`. Will explicitly create the given collection
 * with specified options. Used to create [capped collections](https://docs.mongodb.com/manual/core/capped-collections/)
 * and [views](https://docs.mongodb.com/manual/core/views/) from mongoose.
 *
 * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)
 *
 * @method createCollection
 * @param {string} collection The collection to create
 * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)
 * @param {Function} [callback]
 * @return {Promise} Returns a Promise if no `callback` is given.
 * @api public
 */ Connection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {
    if (typeof options === "function") {
        cb = options;
        options = {};
    }
    this.db.createCollection(collection, options, cb);
});
/**
 * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)
 * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),
 * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).
 *
 * #### Example:
 *
 *     const session = await conn.startSession();
 *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });
 *     await doc.remove();
 *     // `doc` will always be null, even if reading from a replica set
 *     // secondary. Without causal consistency, it is possible to
 *     // get a doc back from the below query if the query reads from a
 *     // secondary that is experiencing replication lag.
 *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });
 *
 *
 * @method startSession
 * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)
 * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency
 * @param {Function} [callback]
 * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`
 * @api public
 */ Connection.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {
    if (typeof options === "function") {
        cb = options;
        options = null;
    }
    const session = this.client.startSession(options);
    cb(null, session);
});
/**
 * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function
 * in a transaction. Mongoose will commit the transaction if the
 * async function executes successfully and attempt to retry if
 * there was a retriable error.
 *
 * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),
 * but also handles resetting Mongoose document state as shown below.
 *
 * #### Example:
 *
 *     const doc = new Person({ name: 'Will Riker' });
 *     await db.transaction(async function setRank(session) {
 *       doc.rank = 'Captain';
 *       await doc.save({ session });
 *       doc.isNew; // false
 *
 *       // Throw an error to abort the transaction
 *       throw new Error('Oops!');
 *     },{ readPreference: 'primary' }).catch(() => {});
 *
 *     // true, `transaction()` reset the document's state because the
 *     // transaction was aborted.
 *     doc.isNew;
 *
 * @method transaction
 * @param {Function} fn Function to execute in a transaction
 * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction
 * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.
 * @api public
 */ Connection.prototype.transaction = function transaction(fn, options) {
    return this.startSession().then((session)=>{
        session[sessionNewDocuments] = new Map();
        return session.withTransaction(()=>fn(session), options).then((res)=>{
            delete session[sessionNewDocuments];
            return res;
        }).catch((err)=>{
            // If transaction was aborted, we need to reset newly
            // inserted documents' `isNew`.
            for (const doc of session[sessionNewDocuments].keys()){
                const state = session[sessionNewDocuments].get(doc);
                if (state.hasOwnProperty("isNew")) {
                    doc.$isNew = state.$isNew;
                }
                if (state.hasOwnProperty("versionKey")) {
                    doc.set(doc.schema.options.versionKey, state.versionKey);
                }
                if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {
                    doc.$__.activePaths.states.modify = {};
                }
                for (const path of state.modifiedPaths){
                    doc.$__.activePaths.paths[path] = "modify";
                    doc.$__.activePaths.states.modify[path] = true;
                }
                for (const path of state.atomics.keys()){
                    const val = doc.$__getValue(path);
                    if (val == null) {
                        continue;
                    }
                    val[arrayAtomicsSymbol] = state.atomics.get(path);
                }
            }
            delete session[sessionNewDocuments];
            throw err;
        }).finally(()=>{
            session.endSession().catch(()=>{});
        });
    });
};
/**
 * Helper for `dropCollection()`. Will delete the given collection, including
 * all documents and indexes.
 *
 * @method dropCollection
 * @param {string} collection The collection to delete
 * @param {Function} [callback]
 * @return {Promise} Returns a Promise if no `callback` is given.
 * @api public
 */ Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
    this.db.dropCollection(collection, cb);
});
/**
 * Helper for `dropDatabase()`. Deletes the given database, including all
 * collections, documents, and indexes.
 *
 * #### Example:
 *
 *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');
 *     // Deletes the entire 'mydb' database
 *     await conn.dropDatabase();
 *
 * @method dropDatabase
 * @param {Function} [callback]
 * @return {Promise} Returns a Promise if no `callback` is given.
 * @api public
 */ Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
    // If `dropDatabase()` is called, this model's collection will not be
    // init-ed. It is sufficiently common to call `dropDatabase()` after
    // `mongoose.connect()` but before creating models that we want to
    // support this. See gh-6796
    for (const model of Object.values(this.models)){
        delete model.$init;
    }
    this.db.dropDatabase(cb);
});
/*!
 * ignore
 */ function _wrapConnHelper(fn) {
    return function() {
        const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
        const argsWithoutCb = typeof cb === "function" ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : Array.prototype.slice.call(arguments);
        const disconnectedError = new DisconnectedError(this.id, fn.name);
        return promiseOrCallback(cb, (cb)=>{
            immediate(()=>{
                if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
                    this._queue.push({
                        fn: fn,
                        ctx: this,
                        args: argsWithoutCb.concat([
                            cb
                        ])
                    });
                } else if (this.readyState === STATES.disconnected && this.db == null) {
                    cb(disconnectedError);
                } else {
                    try {
                        fn.apply(this, argsWithoutCb.concat([
                            cb
                        ]));
                    } catch (err) {
                        return cb(err);
                    }
                }
            });
        });
    };
}
/*!
 * ignore
 */ Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    if (this.config.bufferCommands != null) {
        return this.config.bufferCommands;
    }
    if (this.base.get("bufferCommands") != null) {
        return this.base.get("bufferCommands");
    }
    return true;
};
/**
 * error
 *
 * Graceful error handling, passes error to callback
 * if available, else emits error on the connection.
 *
 * @param {Error} err
 * @param {Function} callback optional
 * @emits "error" Emits the `error` event with the given `err`, unless a callback is specified
 * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.
 * @api private
 */ Connection.prototype.error = function(err, callback) {
    if (callback) {
        callback(err);
        return null;
    }
    if (this.listeners("error").length > 0) {
        this.emit("error", err);
    }
    return Promise.reject(err);
};
/**
 * Called when the connection is opened
 *
 * @api private
 */ Connection.prototype.onOpen = function() {
    this.readyState = STATES.connected;
    for (const d of this._queue){
        d.fn.apply(d.ctx, d.args);
    }
    this._queue = [];
    // avoid having the collection subscribe to our event emitter
    // to prevent 0.3 warning
    for(const i in this.collections){
        if (utils.object.hasOwnProperty(this.collections, i)) {
            this.collections[i].onOpen();
        }
    }
    this.emit("open");
};
/**
 * Opens the connection with a URI using `MongoClient.connect()`.
 *
 * @param {String} uri The URI to connect with.
 * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)
 * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.
 * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.
 * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.
 * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.
 * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.
 * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).
 * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).
 * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).
 * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.
 * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.
 * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).
 * @param {Number} [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _during initial connection_. Defaults to 30000. This option is passed transparently to [Node.js' `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback).
 * @param {Number} [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. This is set to `30000` by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.
 * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.
 * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.
 * @param {Function} [callback]
 * @returns {Promise<Connection>} Returns a Promise if no `callback` is given.
 * @api public
 */ Connection.prototype.openUri = function(uri, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if ([
        "string",
        "number"
    ].indexOf(typeof options) !== -1) {
        throw new MongooseError("Mongoose 5.x no longer supports " + "`mongoose.connect(host, dbname, port)` or " + "`mongoose.createConnection(host, dbname, port)`. See " + "https://mongoosejs.com/docs/connections.html for supported connection syntax");
    }
    if (typeof uri !== "string") {
        throw new MongooseError("The `uri` parameter to `openUri()` must be a " + `string, got "${typeof uri}". Make sure the first parameter to ` + "`mongoose.connect()` or `mongoose.createConnection()` is a string.");
    }
    if (callback != null && typeof callback !== "function") {
        throw new MongooseError("3rd parameter to `mongoose.connect()` or " + '`mongoose.createConnection()` must be a function, got "' + typeof callback + '"');
    }
    if (this._destroyCalled) {
        const error = "Connection has been closed and destroyed, and cannot be used for re-opening the connection. " + "Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.";
        if (typeof callback === "function") {
            callback(error);
            return;
        } else {
            throw new MongooseError(error);
        }
    }
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
        if (this._connectionString !== uri) {
            throw new MongooseError("Can't call `openUri()` on an active connection with " + "different connection strings. Make sure you aren't calling `mongoose.connect()` " + "multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
        }
        if (typeof callback === "function") {
            this.$initialConnection = this.$initialConnection.then(()=>callback(null, this), (err)=>callback(err));
        }
        return this;
    }
    this._connectionString = uri;
    this.readyState = STATES.connecting;
    this._closeCalled = false;
    const Promise1 = PromiseProvider.get();
    const _this = this;
    options = processConnectionOptions(uri, options);
    if (options) {
        options = utils.clone(options);
        const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
        if (autoIndex != null) {
            this.config.autoIndex = autoIndex !== false;
            delete options.config;
            delete options.autoIndex;
        }
        if ("autoCreate" in options) {
            this.config.autoCreate = !!options.autoCreate;
            delete options.autoCreate;
        }
        if ("sanitizeFilter" in options) {
            this.config.sanitizeFilter = options.sanitizeFilter;
            delete options.sanitizeFilter;
        }
        // Backwards compat
        if (options.user || options.pass) {
            options.auth = options.auth || {};
            options.auth.username = options.user;
            options.auth.password = options.pass;
            this.user = options.user;
            this.pass = options.pass;
        }
        delete options.user;
        delete options.pass;
        if (options.bufferCommands != null) {
            this.config.bufferCommands = options.bufferCommands;
            delete options.bufferCommands;
        }
    } else {
        options = {};
    }
    this._connectionOptions = options;
    const dbName = options.dbName;
    if (dbName != null) {
        this.$dbName = dbName;
    }
    delete options.dbName;
    if (!utils.hasUserDefinedProperty(options, "driverInfo")) {
        options.driverInfo = {
            name: "Mongoose",
            version: pkg.version
        };
    }
    const promise = new Promise1((resolve, reject)=>{
        let client;
        try {
            client = new mongodb.MongoClient(uri, options);
        } catch (error) {
            _this.readyState = STATES.disconnected;
            return reject(error);
        }
        _this.client = client;
        client.setMaxListeners(0);
        client.connect((error)=>{
            if (error) {
                return reject(error);
            }
            _setClient(_this, client, options, dbName);
            for (const db of this.otherDbs){
                _setClient(db, client, {}, db.name);
            }
            resolve(_this);
        });
    });
    const serverSelectionError = new ServerSelectionError();
    this.$initialConnection = promise.then(()=>this).catch((err)=>{
        this.readyState = STATES.disconnected;
        if (err != null && err.name === "MongoServerSelectionError") {
            err = serverSelectionError.assimilateError(err);
        }
        if (this.listeners("error").length > 0) {
            immediate(()=>this.emit("error", err));
        }
        throw err;
    });
    if (callback != null) {
        this.$initialConnection = this.$initialConnection.then(()=>{
            callback(null, this);
            return this;
        }, (err)=>callback(err));
    }
    for (const model of Object.values(this.models)){
        // Errors handled internally, so safe to ignore error
        model.init(function $modelInitNoop() {});
    }
    return this.$initialConnection;
};
/*!
 * ignore
 */ function _setClient(conn, client, options, dbName) {
    const db = dbName != null ? client.db(dbName) : client.db();
    conn.db = db;
    conn.client = client;
    conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || void 0;
    conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || void 0;
    conn.name = dbName != null ? dbName : client && client.s && client.s.options && client.s.options.dbName || void 0;
    conn._closeCalled = client._closeCalled;
    const _handleReconnect = ()=>{
        // If we aren't disconnected, we assume this reconnect is due to a
        // socket timeout. If there's no activity on a socket for
        // `socketTimeoutMS`, the driver will attempt to reconnect and emit
        // this event.
        if (conn.readyState !== STATES.connected) {
            conn.readyState = STATES.connected;
            conn.emit("reconnect");
            conn.emit("reconnected");
            conn.onOpen();
        }
    };
    const type = client && client.topology && client.topology.description && client.topology.description.type || "";
    if (type === "Single") {
        client.on("serverDescriptionChanged", (ev)=>{
            const newDescription = ev.newDescription;
            if (newDescription.type === "Unknown") {
                conn.readyState = STATES.disconnected;
            } else {
                _handleReconnect();
            }
        });
    } else if (type.startsWith("ReplicaSet")) {
        client.on("topologyDescriptionChanged", (ev)=>{
            // Emit disconnected if we've lost connectivity to the primary
            const description = ev.newDescription;
            if (conn.readyState === STATES.connected && description.type !== "ReplicaSetWithPrimary") {
                // Implicitly emits 'disconnected'
                conn.readyState = STATES.disconnected;
            } else if (conn.readyState === STATES.disconnected && description.type === "ReplicaSetWithPrimary") {
                _handleReconnect();
            }
        });
    }
    conn.onOpen();
    for(const i in conn.collections){
        if (utils.object.hasOwnProperty(conn.collections, i)) {
            conn.collections[i].onOpen();
        }
    }
}
/**
 * Destory the connection (not just a alias of [`.close`](#connection_Connection-close))
 *
 * @param {Boolean} [force]
 * @param {Function} [callback]
 * @returns {Promise} Returns a Promise if no `callback` is given.
 */ Connection.prototype.destroy = function(force, callback) {
    if (typeof force === "function") {
        callback = force;
        force = false;
    }
    if (force != null && typeof force === "object") {
        this.$wasForceClosed = !!force.force;
    } else {
        this.$wasForceClosed = !!force;
    }
    return promiseOrCallback(callback, (cb)=>{
        this._close(force, true, cb);
    });
};
/**
 * Closes the connection
 *
 * @param {Boolean} [force] optional
 * @param {Function} [callback] optional
 * @return {Promise} Returns a Promise if no `callback` is given.
 * @api public
 */ Connection.prototype.close = function(force, callback) {
    if (typeof force === "function") {
        callback = force;
        force = false;
    }
    if (force != null && typeof force === "object") {
        this.$wasForceClosed = !!force.force;
    } else {
        this.$wasForceClosed = !!force;
    }
    for (const model of Object.values(this.models)){
        // If manually disconnecting, make sure to clear each model's `$init`
        // promise, so Mongoose knows to re-run `init()` in case the
        // connection is re-opened. See gh-12047.
        delete model.$init;
    }
    return promiseOrCallback(callback, (cb)=>{
        this._close(force, false, cb);
    });
};
/**
 * Handles closing the connection
 *
 * @param {Boolean} force
 * @param {Boolean} destroy
 * @param {Function} [callback]
 * @returns {Connection} this
 * @api private
 */ Connection.prototype._close = function(force, destroy, callback) {
    const _this = this;
    const closeCalled = this._closeCalled;
    this._closeCalled = true;
    this._destroyCalled = destroy;
    if (this.client != null) {
        this.client._closeCalled = true;
        this.client._destroyCalled = destroy;
    }
    const conn = this;
    switch(this.readyState){
        case STATES.disconnected:
            if (destroy && this.base.connections.indexOf(conn) !== -1) {
                this.base.connections.splice(this.base.connections.indexOf(conn), 1);
            }
            if (closeCalled) {
                callback();
            } else {
                this.doClose(force, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    _this.onClose(force);
                    callback(null);
                });
            }
            break;
        case STATES.connected:
            this.readyState = STATES.disconnecting;
            this.doClose(force, function(err) {
                if (err) {
                    return callback(err);
                }
                if (destroy && _this.base.connections.indexOf(conn) !== -1) {
                    _this.base.connections.splice(_this.base.connections.indexOf(conn), 1);
                }
                _this.onClose(force);
                callback(null);
            });
            break;
        case STATES.connecting:
            this.once("open", function() {
                destroy ? _this.destroy(force, callback) : _this.close(force, callback);
            });
            break;
        case STATES.disconnecting:
            this.once("close", function() {
                if (destroy && _this.base.connections.indexOf(conn) !== -1) {
                    _this.base.connections.splice(_this.base.connections.indexOf(conn), 1);
                }
                callback();
            });
            break;
    }
    return this;
};
/**
 * Called when the connection closes
 *
 * @api private
 */ Connection.prototype.onClose = function(force) {
    this.readyState = STATES.disconnected;
    // avoid having the collection subscribe to our event emitter
    // to prevent 0.3 warning
    for(const i in this.collections){
        if (utils.object.hasOwnProperty(this.collections, i)) {
            this.collections[i].onClose(force);
        }
    }
    this.emit("close", force);
    for (const db of this.otherDbs){
        this._destroyCalled ? db.destroy({
            force: force,
            skipCloseClient: true
        }) : db.close({
            force: force,
            skipCloseClient: true
        });
    }
};
/**
 * Retrieves a collection, creating it if not cached.
 *
 * Not typically needed by applications. Just talk to your collection through your model.
 *
 * @param {String} name of the collection
 * @param {Object} [options] optional collection options
 * @return {Collection} collection instance
 * @api public
 */ Connection.prototype.collection = function(name, options) {
    const defaultOptions = {
        autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
        autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate
    };
    options = Object.assign({}, defaultOptions, options ? utils.clone(options) : {});
    options.$wasForceClosed = this.$wasForceClosed;
    const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;
    if (!(name in this.collections)) {
        this.collections[name] = new Collection(name, this, options);
    }
    return this.collections[name];
};
/**
 * Declares a plugin executed on all schemas you pass to `conn.model()`
 *
 * Equivalent to calling `.plugin(fn)` on each schema you create.
 *
 * #### Example:
 *
 *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');
 *     db.plugin(() => console.log('Applied'));
 *     db.plugins.length; // 1
 *
 *     db.model('Test', new Schema({})); // Prints "Applied"
 *
 * @param {Function} fn plugin callback
 * @param {Object} [opts] optional options
 * @return {Connection} this
 * @see plugins /docs/plugins
 * @api public
 */ Connection.prototype.plugin = function(fn, opts) {
    this.plugins.push([
        fn,
        opts
    ]);
    return this;
};
/**
 * Defines or retrieves a model.
 *
 *     const mongoose = require('mongoose');
 *     const db = mongoose.createConnection(..);
 *     db.model('Venue', new Schema(..));
 *     const Ticket = db.model('Ticket', new Schema(..));
 *     const Venue = db.model('Venue');
 *
 * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports-toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String }, { collection: 'actor' });
 *
 *     // or
 *
 *     schema.set('collection', 'actor');
 *
 *     // or
 *
 *     const collectionName = 'actor'
 *     const M = conn.model('Actor', schema, collectionName)
 *
 * @param {String|Function} name the model name or class extending Model
 * @param {Schema} [schema] a schema. necessary when defining a model
 * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name
 * @param {Object} [options]
 * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`
 * @see Mongoose#model #index_Mongoose-model
 * @return {Model} The compiled model
 * @api public
 */ Connection.prototype.model = function(name, schema, collection, options) {
    if (!(this instanceof Connection)) {
        throw new MongooseError("`connection.model()` should not be run with " + "`new`. If you are doing `new db.model(foo)(bar)`, use " + "`db.model(foo)(bar)` instead");
    }
    let fn;
    if (typeof name === "function") {
        fn = name;
        name = fn.name;
    }
    // collection name discovery
    if (typeof schema === "string") {
        collection = schema;
        schema = false;
    }
    if (utils.isObject(schema)) {
        if (!schema.instanceOfSchema) {
            schema = new Schema(schema);
        } else if (!(schema instanceof this.base.Schema)) {
            schema = schema._clone(this.base.Schema);
        }
    }
    if (schema && !schema.instanceOfSchema) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a " + "schema or a POJO");
    }
    const defaultOptions = {
        cache: false,
        overwriteModels: this.base.options.overwriteModels
    };
    const opts = Object.assign(defaultOptions, options, {
        connection: this
    });
    if (this.models[name] && !collection && opts.overwriteModels !== true) {
        // model exists but we are not subclassing with custom collection
        if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
            throw new MongooseError.OverwriteModelError(name);
        }
        return this.models[name];
    }
    let model;
    if (schema && schema.instanceOfSchema) {
        applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
        // compile a model
        model = this.base._model(fn || name, schema, collection, opts);
        // only the first model with this name is cached to allow
        // for one-offs with custom collection names etc.
        if (!this.models[name]) {
            this.models[name] = model;
        }
        // Errors handled internally, so safe to ignore error
        model.init(function $modelInitNoop() {});
        return model;
    }
    if (this.models[name] && collection) {
        // subclassing current model with alternate collection
        model = this.models[name];
        schema = model.prototype.schema;
        const sub = model.__subclass(this, schema, collection);
        // do not cache the sub model
        return sub;
    }
    if (arguments.length === 1) {
        model = this.models[name];
        if (!model) {
            throw new MongooseError.MissingSchemaError(name);
        }
        return model;
    }
    if (!model) {
        throw new MongooseError.MissingSchemaError(name);
    }
    if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
        // model already uses this connection.
        // only the first model with this name is cached to allow
        // for one-offs with custom collection names etc.
        if (!this.models[name]) {
            this.models[name] = model;
        }
        return model;
    }
    this.models[name] = model.__subclass(this, schema, collection);
    return this.models[name];
};
/**
 * Removes the model named `name` from this connection, if it exists. You can
 * use this function to clean up any models you created in your tests to
 * prevent OverwriteModelErrors.
 *
 * #### Example:
 *
 *     conn.model('User', new Schema({ name: String }));
 *     console.log(conn.model('User')); // Model object
 *     conn.deleteModel('User');
 *     console.log(conn.model('User')); // undefined
 *
 *     // Usually useful in a Mocha `afterEach()` hook
 *     afterEach(function() {
 *       conn.deleteModel(/.+/); // Delete every model
 *     });
 *
 * @api public
 * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.
 * @return {Connection} this
 */ Connection.prototype.deleteModel = function(name) {
    if (typeof name === "string") {
        const model = this.model(name);
        if (model == null) {
            return this;
        }
        const collectionName = model.collection.name;
        delete this.models[name];
        delete this.collections[collectionName];
        this.emit("deleteModel", model);
    } else if (name instanceof RegExp) {
        const pattern = name;
        const names = this.modelNames();
        for (const name of names){
            if (pattern.test(name)) {
                this.deleteModel(name);
            }
        }
    } else {
        throw new Error("First parameter to `deleteModel()` must be a string " + 'or regexp, got "' + name + '"');
    }
    return this;
};
/**
 * Watches the entire underlying database for changes. Similar to
 * [`Model.watch()`](/docs/api/model.html#model_Model-watch).
 *
 * This function does **not** trigger any middleware. In particular, it
 * does **not** trigger aggregate middleware.
 *
 * The ChangeStream object is an event emitter that emits the following events:
 *
 * - 'change': A change occurred, see below example
 * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.
 * - 'end': Emitted if the underlying stream is closed
 * - 'close': Emitted if the underlying stream is closed
 *
 * #### Example:
 *
 *     const User = conn.model('User', new Schema({ name: String }));
 *
 *     const changeStream = conn.watch().on('change', data => console.log(data));
 *
 *     // Triggers a 'change' event on the change stream.
 *     await User.create({ name: 'test' });
 *
 * @api public
 * @param {Array} [pipeline]
 * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)
 * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter
 */ Connection.prototype.watch = function(pipeline, options) {
    const disconnectedError = new DisconnectedError(this.id, "watch");
    const changeStreamThunk = (cb)=>{
        immediate(()=>{
            if (this.readyState === STATES.connecting) {
                this.once("open", function() {
                    const driverChangeStream = this.db.watch(pipeline, options);
                    cb(null, driverChangeStream);
                });
            } else if (this.readyState === STATES.disconnected && this.db == null) {
                cb(disconnectedError);
            } else {
                const driverChangeStream = this.db.watch(pipeline, options);
                cb(null, driverChangeStream);
            }
        });
    };
    const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);
    return changeStream;
};
/**
 * Returns a promise that resolves when this connection
 * successfully connects to MongoDB, or rejects if this connection failed
 * to connect.
 *
 * #### Example:
 *
 *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').
 *       asPromise();
 *     conn.readyState; // 1, means Mongoose is connected
 *
 * @api public
 * @return {Promise}
 */ Connection.prototype.asPromise = function asPromise() {
    return this.$initialConnection;
};
/**
 * Returns an array of model names created on this connection.
 * @api public
 * @return {String[]}
 */ Connection.prototype.modelNames = function() {
    return Object.keys(this.models);
};
/**
 * Returns if the connection requires authentication after it is opened. Generally if a
 * username and password are both provided than authentication is needed, but in some cases a
 * password is not required.
 *
 * @api private
 * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.
 */ Connection.prototype.shouldAuthenticate = function() {
    return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
};
/**
 * Returns a boolean value that specifies if the current authentication mechanism needs a
 * password to authenticate according to the auth objects passed into the openUri methods.
 *
 * @api private
 * @return {Boolean} true if the authentication mechanism specified in the options object requires
 *  a password, otherwise false.
 */ Connection.prototype.authMechanismDoesNotRequirePassword = function() {
    if (this.options && this.options.auth) {
        return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
    }
    return true;
};
/**
 * Returns a boolean value that specifies if the provided objects object provides enough
 * data to authenticate with. Generally this is true if the username and password are both specified
 * but in some authentication methods, a password is not required for authentication so only a username
 * is required.
 *
 * @param {Object} [options] the options object passed into the openUri methods.
 * @api private
 * @return {Boolean} true if the provided options object provides enough data to authenticate with,
 *   otherwise false.
 */ Connection.prototype.optionsProvideAuthenticationData = function(options) {
    return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
};
/**
 * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance
 * that this connection uses to talk to MongoDB.
 *
 * #### Example:
 *
 *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').
 *       asPromise();
 *
 *     conn.getClient(); // MongoClient { ... }
 *
 * @api public
 * @return {MongoClient}
 */ Connection.prototype.getClient = function getClient() {
    return this.client;
};
/**
 * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance
 * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to
 * reuse it.
 *
 * #### Example:
 *
 *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');
 *
 *     const conn = mongoose.createConnection().setClient(client);
 *
 *     conn.getClient(); // MongoClient { ... }
 *     conn.readyState; // 1, means 'CONNECTED'
 *
 * @api public
 * @param {MongClient} client The Client to set to be used.
 * @return {Connection} this
 */ Connection.prototype.setClient = function setClient(client) {
    if (!(client instanceof mongodb.MongoClient)) {
        throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
    }
    if (this.readyState !== STATES.disconnected) {
        throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
    }
    if (client.topology == null) {
        throw new MongooseError("Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.");
    }
    this._connectionString = client.s.url;
    _setClient(this, client, {}, client.s.options.dbName);
    for (const model of Object.values(this.models)){
        // Errors handled internally, so safe to ignore error
        model.init(function $modelInitNoop() {});
    }
    return this;
};
/**
 * Syncs all the indexes for the models registered with this connection.
 *
 * @param {Object} [options]
 * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.
 * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.
 */ Connection.prototype.syncIndexes = async function syncIndexes(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError  } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)){
        try {
            result[model.modelName] = await model.syncIndexes(options);
        } catch (err) {
            if (!continueOnError) {
                errorsMap[model.modelName] = err;
                break;
            } else {
                result[model.modelName] = err;
            }
        }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
        const message = Object.entries(errorsMap).map(([modelName, err])=>`${modelName}: ${err.message}`).join(", ");
        const syncIndexesError = new SyncIndexesError(message, errorsMap);
        throw syncIndexesError;
    }
    return result;
};
/**
 * Switches to a different database using the same connection pool.
 *
 * Returns a new connection object, with the new db.
 *
 * #### Example:
 *
 *     // Connect to `initialdb` first
 *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();
 *
 *     // Creates an un-cached connection to `mydb`
 *     const db = conn.useDb('mydb');
 *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same
 *     // connection instance as opposed to creating a new connection instance
 *     const db2 = conn.useDb('mydb2', { useCache: true });
 *
 * @method useDb
 * @memberOf Connection
 * @param {String} name The database name
 * @param {Object} [options]
 * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.
 * @param {Boolean} [options.noListener=false] If true, the connection object will not make the db listen to events on the original connection. See [issue #9961](https://github.com/Automattic/mongoose/issues/9961).
 * @return {Connection} New Connection Object
 * @api public
 */ /*!
 * Module exports.
 */ Connection.STATES = STATES;
module.exports = Connection;


/***/ }),

/***/ 25840:
/***/ ((module, exports) => {

"use strict";
/*!
 * Connection states
 */ 
const STATES = module.exports = exports = Object.create(null);
const disconnected = "disconnected";
const connected = "connected";
const connecting = "connecting";
const disconnecting = "disconnecting";
const uninitialized = "uninitialized";
STATES[0] = disconnected;
STATES[1] = connected;
STATES[2] = connecting;
STATES[3] = disconnecting;
STATES[99] = uninitialized;
STATES[disconnected] = 0;
STATES[connected] = 1;
STATES[connecting] = 2;
STATES[disconnecting] = 3;
STATES[uninitialized] = 99;


/***/ }),

/***/ 72689:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(51520);
const Readable = (__webpack_require__(12781).Readable);
const promiseOrCallback = __webpack_require__(83593);
const eachAsync = __webpack_require__(75468);
const immediate = __webpack_require__(96621);
const util = __webpack_require__(73837);
/**
 * An AggregationCursor is a concurrency primitive for processing aggregation
 * results one document at a time. It is analogous to QueryCursor.
 *
 * An AggregationCursor fulfills the Node.js streams3 API,
 * in addition to several other mechanisms for loading documents from MongoDB
 * one at a time.
 *
 * Creating an AggregationCursor executes the model's pre aggregate hooks,
 * but **not** the model's post aggregate hooks.
 *
 * Unless you're an advanced user, do **not** instantiate this class directly.
 * Use [`Aggregate#cursor()`](/docs/api/aggregate.html#aggregate_Aggregate-cursor) instead.
 *
 * @param {Aggregate} agg
 * @inherits Readable
 * @event `cursor`: Emitted when the cursor is created
 * @event `error`: Emitted when an error occurred
 * @event `data`: Emitted when the stream is flowing and the next doc is ready
 * @event `end`: Emitted when the stream is exhausted
 * @api public
 */ function AggregationCursor(agg) {
    // set autoDestroy=true because on node 12 it's by default false
    // gh-10902 need autoDestroy to destroy correctly and emit 'close' event
    Readable.call(this, {
        autoDestroy: true,
        objectMode: true
    });
    this.cursor = null;
    this.agg = agg;
    this._transforms = [];
    const model = agg._model;
    delete agg.options.cursor.useMongooseAggCursor;
    this._mongooseOptions = {};
    _init(model, this, agg);
}
util.inherits(AggregationCursor, Readable);
/*!
 * ignore
 */ function _init(model, c, agg) {
    if (!model.collection.buffer) {
        model.hooks.execPre("aggregate", agg, function() {
            c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
            c.emit("cursor", c.cursor);
        });
    } else {
        model.collection.emitter.once("queue", function() {
            model.hooks.execPre("aggregate", agg, function() {
                c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
                c.emit("cursor", c.cursor);
            });
        });
    }
}
/**
 * Necessary to satisfy the Readable API
 * @method _read
 * @memberOf AggregationCursor
 * @instance
 * @api private
 */ AggregationCursor.prototype._read = function() {
    const _this = this;
    _next(this, function(error, doc) {
        if (error) {
            return _this.emit("error", error);
        }
        if (!doc) {
            _this.push(null);
            _this.cursor.close(function(error) {
                if (error) {
                    return _this.emit("error", error);
                }
            });
            return;
        }
        _this.push(doc);
    });
};
if (Symbol.asyncIterator != null) {
    const msg = "Mongoose does not support using async iterators with an " + "existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation";
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        throw new MongooseError(msg);
    };
}
/**
 * Registers a transform function which subsequently maps documents retrieved
 * via the streams interface or `.next()`
 *
 * #### Example:
 *
 *     // Map documents returned by `data` events
 *     Thing.
 *       find({ name: /^hello/ }).
 *       cursor().
 *       map(function (doc) {
 *        doc.foo = "bar";
 *        return doc;
 *       })
 *       on('data', function(doc) { console.log(doc.foo); });
 *
 *     // Or map documents returned by `.next()`
 *     const cursor = Thing.find({ name: /^hello/ }).
 *       cursor().
 *       map(function (doc) {
 *         doc.foo = "bar";
 *         return doc;
 *       });
 *     cursor.next(function(error, doc) {
 *       console.log(doc.foo);
 *     });
 *
 * @param {Function} fn
 * @return {AggregationCursor}
 * @memberOf AggregationCursor
 * @api public
 * @method map
 */ Object.defineProperty(AggregationCursor.prototype, "map", {
    value: function(fn) {
        this._transforms.push(fn);
        return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
});
/**
 * Marks this cursor as errored
 * @method _markError
 * @instance
 * @memberOf AggregationCursor
 * @api private
 */ AggregationCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
};
/**
 * Marks this cursor as closed. Will stop streaming and subsequent calls to
 * `next()` will error.
 *
 * @param {Function} callback
 * @return {Promise}
 * @api public
 * @method close
 * @emits close
 * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close
 */ AggregationCursor.prototype.close = function(callback) {
    return promiseOrCallback(callback, (cb)=>{
        this.cursor.close((error)=>{
            if (error) {
                cb(error);
                return this.listeners("error").length > 0 && this.emit("error", error);
            }
            this.emit("close");
            cb(null);
        });
    });
};
/**
 * Get the next document from this cursor. Will return `null` when there are
 * no documents left.
 *
 * @param {Function} callback
 * @return {Promise}
 * @api public
 * @method next
 */ AggregationCursor.prototype.next = function(callback) {
    return promiseOrCallback(callback, (cb)=>{
        _next(this, cb);
    });
};
/**
 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
 * will wait for the promise to resolve before iterating on to the next one.
 * Returns a promise that resolves when done.
 *
 * @param {Function} fn
 * @param {Object} [options]
 * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.
 * @param {Function} [callback] executed when all docs have been processed
 * @return {Promise}
 * @api public
 * @method eachAsync
 */ AggregationCursor.prototype.eachAsync = function(fn, opts, callback) {
    const _this = this;
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    opts = opts || {};
    return eachAsync(function(cb) {
        return _next(_this, cb);
    }, fn, opts, callback);
};
/**
 * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)
 * You do not need to call this function explicitly, the JavaScript runtime
 * will call it for you.
 *
 * #### Example:
 *
 *     // Async iterator without explicitly calling `cursor()`. Mongoose still
 *     // creates an AggregationCursor instance internally.
 *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);
 *     for await (const doc of agg) {
 *       console.log(doc.name);
 *     }
 *
 *     // You can also use an AggregationCursor instance for async iteration
 *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();
 *     for await (const doc of cursor) {
 *       console.log(doc.name);
 *     }
 *
 * Node.js 10.x supports async iterators natively without any flags. You can
 * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).
 *
 * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If
 * `Symbol.asyncIterator` is undefined, that means your Node.js version does not
 * support async iterators.
 *
 * @method Symbol.asyncIterator
 * @memberOf AggregationCursor
 * @instance
 * @api public
 */ if (Symbol.asyncIterator != null) {
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
    };
}
/*!
 * ignore
 */ AggregationCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
    }
    return this;
};
/*!
 * ignore
 */ AggregationCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
        val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
};
/*!
 * ignore
 */ function _transformForAsyncIterator(doc) {
    return doc == null ? {
        done: true
    } : {
        value: doc,
        done: false
    };
}
/**
 * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).
 * Useful for setting the `noCursorTimeout` and `tailable` flags.
 *
 * @param {String} flag
 * @param {Boolean} value
 * @return {AggregationCursor} this
 * @api public
 * @method addCursorFlag
 */ AggregationCursor.prototype.addCursorFlag = function(flag, value) {
    const _this = this;
    _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
    });
    return this;
};
/*!
 * ignore
 */ function _waitForCursor(ctx, cb) {
    if (ctx.cursor) {
        return cb();
    }
    ctx.once("cursor", function() {
        cb();
    });
}
/**
 * Get the next doc from the underlying cursor and mongooseify it
 * (populate, etc.)
 * @param {Any} ctx
 * @param {Function} cb
 * @api private
 */ function _next(ctx, cb) {
    let callback = cb;
    if (ctx._transforms.length) {
        callback = function(err, doc) {
            if (err || doc === null && !ctx._mongooseOptions.transformNull) {
                return cb(err, doc);
            }
            cb(err, ctx._transforms.reduce(function(doc, fn) {
                return fn(doc);
            }, doc));
        };
    }
    if (ctx._error) {
        return immediate(function() {
            callback(ctx._error);
        });
    }
    if (ctx.cursor) {
        return ctx.cursor.next(function(error, doc) {
            if (error) {
                return callback(error);
            }
            if (!doc) {
                return callback(null, null);
            }
            callback(null, doc);
        });
    } else {
        ctx.once("cursor", function() {
            _next(ctx, cb);
        });
    }
}
module.exports = AggregationCursor;


/***/ }),

/***/ 67659:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const EventEmitter = (__webpack_require__(82361).EventEmitter);
/*!
 * ignore
 */ class ChangeStream extends EventEmitter {
    constructor(changeStreamThunk, pipeline, options){
        super();
        this.driverChangeStream = null;
        this.closed = false;
        this.bindedEvents = false;
        this.pipeline = pipeline;
        this.options = options;
        if (options && options.hydrate && !options.model) {
            throw new Error("Cannot create change stream with `hydrate: true` " + "unless calling `Model.watch()`");
        }
        // This wrapper is necessary because of buffering.
        changeStreamThunk((err, driverChangeStream)=>{
            if (err != null) {
                this.emit("error", err);
                return;
            }
            this.driverChangeStream = driverChangeStream;
            this.emit("ready");
        });
    }
    _bindEvents() {
        if (this.bindedEvents) {
            return;
        }
        this.bindedEvents = true;
        if (this.driverChangeStream == null) {
            this.once("ready", ()=>{
                this.driverChangeStream.on("close", ()=>{
                    this.closed = true;
                });
                [
                    "close",
                    "change",
                    "end",
                    "error"
                ].forEach((ev)=>{
                    this.driverChangeStream.on(ev, (data)=>{
                        // Sometimes Node driver still polls after close, so
                        // avoid any uncaught exceptions due to closed change streams
                        // See tests for gh-7022
                        if (ev === "error" && this.closed) {
                            return;
                        }
                        if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
                            data.fullDocument = this.options.model.hydrate(data.fullDocument);
                        }
                        this.emit(ev, data);
                    });
                });
            });
            return;
        }
        this.driverChangeStream.on("close", ()=>{
            this.closed = true;
        });
        [
            "close",
            "change",
            "end",
            "error"
        ].forEach((ev)=>{
            this.driverChangeStream.on(ev, (data)=>{
                // Sometimes Node driver still polls after close, so
                // avoid any uncaught exceptions due to closed change streams
                // See tests for gh-7022
                if (ev === "error" && this.closed) {
                    return;
                }
                this.emit(ev, data);
            });
        });
    }
    hasNext(cb) {
        return this.driverChangeStream.hasNext(cb);
    }
    next(cb) {
        if (this.options && this.options.hydrate) {
            if (cb != null) {
                const originalCb = cb;
                cb = (err, data)=>{
                    if (err != null) {
                        return originalCb(err);
                    }
                    if (data.fullDocument != null) {
                        data.fullDocument = this.options.model.hydrate(data.fullDocument);
                    }
                    return originalCb(null, data);
                };
            }
            let maybePromise = this.driverChangeStream.next(cb);
            if (maybePromise && typeof maybePromise.then === "function") {
                maybePromise = maybePromise.then((data)=>{
                    if (data.fullDocument != null) {
                        data.fullDocument = this.options.model.hydrate(data.fullDocument);
                    }
                    return data;
                });
            }
            return maybePromise;
        }
        return this.driverChangeStream.next(cb);
    }
    on(event, handler) {
        this._bindEvents();
        return super.on(event, handler);
    }
    once(event, handler) {
        this._bindEvents();
        return super.once(event, handler);
    }
    _queue(cb) {
        this.once("ready", ()=>cb());
    }
    close() {
        this.closed = true;
        if (this.driverChangeStream) {
            this.driverChangeStream.close();
        }
    }
}
/*!
 * ignore
 */ module.exports = ChangeStream;


/***/ }),

/***/ 93992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const Readable = (__webpack_require__(12781).Readable);
const promiseOrCallback = __webpack_require__(83593);
const eachAsync = __webpack_require__(75468);
const helpers = __webpack_require__(83524);
const immediate = __webpack_require__(96621);
const util = __webpack_require__(73837);
/**
 * A QueryCursor is a concurrency primitive for processing query results
 * one document at a time. A QueryCursor fulfills the Node.js streams3 API,
 * in addition to several other mechanisms for loading documents from MongoDB
 * one at a time.
 *
 * QueryCursors execute the model's pre `find` hooks before loading any documents
 * from MongoDB, and the model's post `find` hooks after loading each document.
 *
 * Unless you're an advanced user, do **not** instantiate this class directly.
 * Use [`Query#cursor()`](/docs/api/query.html#query_Query-cursor) instead.
 *
 * @param {Query} query
 * @param {Object} options query options passed to `.find()`
 * @inherits Readable
 * @event `cursor`: Emitted when the cursor is created
 * @event `error`: Emitted when an error occurred
 * @event `data`: Emitted when the stream is flowing and the next doc is ready
 * @event `end`: Emitted when the stream is exhausted
 * @api public
 */ function QueryCursor(query, options) {
    // set autoDestroy=true because on node 12 it's by default false
    // gh-10902 need autoDestroy to destroy correctly and emit 'close' event
    Readable.call(this, {
        autoDestroy: true,
        objectMode: true
    });
    this.cursor = null;
    this.query = query;
    const _this = this;
    const model = query.model;
    this._mongooseOptions = {};
    this._transforms = [];
    this.model = model;
    this.options = options || {};
    model.hooks.execPre("find", query, (err)=>{
        if (err != null) {
            _this._markError(err);
            _this.listeners("error").length > 0 && _this.emit("error", err);
            return;
        }
        this._transforms = this._transforms.concat(query._transforms.slice());
        if (this.options.transform) {
            this._transforms.push(options.transform);
        }
        // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level
        // `batchSize` option doesn't work.
        if (this.options.batchSize) {
            this.options.cursor = options.cursor || {};
            this.options.cursor.batchSize = options.batchSize;
            // Max out the number of documents we'll populate in parallel at 5000.
            this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);
        }
        model.collection.find(query._conditions, this.options, (err, cursor)=>{
            if (err != null) {
                _this._markError(err);
                _this.listeners("error").length > 0 && _this.emit("error", _this._error);
                return;
            }
            if (_this._error) {
                cursor.close(function() {});
                _this.listeners("error").length > 0 && _this.emit("error", _this._error);
            }
            _this.cursor = cursor;
            _this.emit("cursor", cursor);
        });
    });
}
util.inherits(QueryCursor, Readable);
/**
 * Necessary to satisfy the Readable API
 * @method _read
 * @memberOf QueryCursor
 * @instance
 * @api private
 */ QueryCursor.prototype._read = function() {
    const _this = this;
    _next(this, function(error, doc) {
        if (error) {
            return _this.emit("error", error);
        }
        if (!doc) {
            _this.push(null);
            _this.cursor.close(function(error) {
                if (error) {
                    return _this.emit("error", error);
                }
            });
            return;
        }
        _this.push(doc);
    });
};
/**
 * Registers a transform function which subsequently maps documents retrieved
 * via the streams interface or `.next()`
 *
 * #### Example:
 *
 *     // Map documents returned by `data` events
 *     Thing.
 *       find({ name: /^hello/ }).
 *       cursor().
 *       map(function (doc) {
 *        doc.foo = "bar";
 *        return doc;
 *       })
 *       on('data', function(doc) { console.log(doc.foo); });
 *
 *     // Or map documents returned by `.next()`
 *     const cursor = Thing.find({ name: /^hello/ }).
 *       cursor().
 *       map(function (doc) {
 *         doc.foo = "bar";
 *         return doc;
 *       });
 *     cursor.next(function(error, doc) {
 *       console.log(doc.foo);
 *     });
 *
 * @param {Function} fn
 * @return {QueryCursor}
 * @memberOf QueryCursor
 * @api public
 * @method map
 */ Object.defineProperty(QueryCursor.prototype, "map", {
    value: function(fn) {
        this._transforms.push(fn);
        return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
});
/**
 * Marks this cursor as errored
 * @method _markError
 * @memberOf QueryCursor
 * @instance
 * @api private
 */ QueryCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
};
/**
 * Marks this cursor as closed. Will stop streaming and subsequent calls to
 * `next()` will error.
 *
 * @param {Function} callback
 * @return {Promise}
 * @api public
 * @method close
 * @emits close
 * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close
 */ QueryCursor.prototype.close = function(callback) {
    return promiseOrCallback(callback, (cb)=>{
        this.cursor.close((error)=>{
            if (error) {
                cb(error);
                return this.listeners("error").length > 0 && this.emit("error", error);
            }
            this.emit("close");
            cb(null);
        });
    }, this.model.events);
};
/**
 * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
 * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
 * if the resultant data has already been retrieved by this cursor.
 *
 * @return {AggregationCursor} this
 * @api public
 * @method rewind
 */ QueryCursor.prototype.rewind = function() {
    const _this = this;
    _waitForCursor(this, function() {
        _this.cursor.rewind();
    });
    return this;
};
/**
 * Get the next document from this cursor. Will return `null` when there are
 * no documents left.
 *
 * @param {Function} callback
 * @return {Promise}
 * @api public
 * @method next
 */ QueryCursor.prototype.next = function(callback) {
    return promiseOrCallback(callback, (cb)=>{
        _next(this, function(error, doc) {
            if (error) {
                return cb(error);
            }
            cb(null, doc);
        });
    }, this.model.events);
};
/**
 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
 * will wait for the promise to resolve before iterating on to the next one.
 * Returns a promise that resolves when done.
 *
 * #### Example:
 *
 *     // Iterate over documents asynchronously
 *     Thing.
 *       find({ name: /^hello/ }).
 *       cursor().
 *       eachAsync(async function (doc, i) {
 *         doc.foo = doc.bar + i;
 *         await doc.save();
 *       })
 *
 * @param {Function} fn
 * @param {Object} [options]
 * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.
 * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`
 * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.
 * @param {Function} [callback] executed when all docs have been processed
 * @return {Promise}
 * @api public
 * @method eachAsync
 */ QueryCursor.prototype.eachAsync = function(fn, opts, callback) {
    const _this = this;
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    opts = opts || {};
    return eachAsync(function(cb) {
        return _next(_this, cb);
    }, fn, opts, callback);
};
/**
 * The `options` passed in to the `QueryCursor` constructor.
 *
 * @api public
 * @property options
 */ QueryCursor.prototype.options;
/**
 * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).
 * Useful for setting the `noCursorTimeout` and `tailable` flags.
 *
 * @param {String} flag
 * @param {Boolean} value
 * @return {AggregationCursor} this
 * @api public
 * @method addCursorFlag
 */ QueryCursor.prototype.addCursorFlag = function(flag, value) {
    const _this = this;
    _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
    });
    return this;
};
/*!
 * ignore
 */ QueryCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
        val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
};
/*!
 * ignore
 */ QueryCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
    }
    return this;
};
/**
 * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).
 * You do not need to call this function explicitly, the JavaScript runtime
 * will call it for you.
 *
 * #### Example:
 *
 *     // Works without using `cursor()`
 *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {
 *       console.log(doc.name);
 *     }
 *
 *     // Can also use `cursor()`
 *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {
 *       console.log(doc.name);
 *     }
 *
 * Node.js 10.x supports async iterators natively without any flags. You can
 * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).
 *
 * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If
 * `Symbol.asyncIterator` is undefined, that means your Node.js version does not
 * support async iterators.
 *
 * @method Symbol.asyncIterator
 * @memberOf QueryCursor
 * @instance
 * @api public
 */ if (Symbol.asyncIterator != null) {
    QueryCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
    };
}
/*!
 * ignore
 */ function _transformForAsyncIterator(doc) {
    return doc == null ? {
        done: true
    } : {
        value: doc,
        done: false
    };
}
/**
 * Get the next doc from the underlying cursor and mongooseify it
 * (populate, etc.)
 * @param {Any} ctx
 * @param {Function} cb
 * @api private
 */ function _next(ctx, cb) {
    let callback = cb;
    if (ctx._transforms.length) {
        callback = function(err, doc) {
            if (err || doc === null && !ctx._mongooseOptions.transformNull) {
                return cb(err, doc);
            }
            cb(err, ctx._transforms.reduce(function(doc, fn) {
                return fn.call(ctx, doc);
            }, doc));
        };
    }
    if (ctx._error) {
        return immediate(function() {
            callback(ctx._error);
        });
    }
    if (ctx.cursor) {
        if (ctx.query._mongooseOptions.populate && !ctx._pop) {
            ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);
            ctx._pop.__noPromise = true;
        }
        if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
            if (ctx._batchDocs && ctx._batchDocs.length) {
                // Return a cached populated doc
                return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
            } else if (ctx._batchExhausted) {
                // Internal cursor reported no more docs. Act the same here
                return callback(null, null);
            } else {
                // Request as many docs as batchSize, to populate them also in batch
                ctx._batchDocs = [];
                return ctx.cursor.next(_onNext.bind({
                    ctx,
                    callback
                }));
            }
        } else {
            return ctx.cursor.next(function(error, doc) {
                if (error) {
                    return callback(error);
                }
                if (!doc) {
                    return callback(null, null);
                }
                if (!ctx.query._mongooseOptions.populate) {
                    return _nextDoc(ctx, doc, null, callback);
                }
                ctx.query.model.populate(doc, ctx._pop, function(err, doc) {
                    if (err) {
                        return callback(err);
                    }
                    return _nextDoc(ctx, doc, ctx._pop, callback);
                });
            });
        }
    } else {
        ctx.once("error", cb);
        ctx.once("cursor", function(cursor) {
            ctx.removeListener("error", cb);
            if (cursor == null) {
                return;
            }
            _next(ctx, cb);
        });
    }
}
/*!
 * ignore
 */ function _onNext(error, doc) {
    if (error) {
        return this.callback(error);
    }
    if (!doc) {
        this.ctx._batchExhausted = true;
        return _populateBatch.call(this);
    }
    this.ctx._batchDocs.push(doc);
    if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
        // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may
        // cause a stack overflow. So make sure we clear the stack regularly.
        if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {
            return immediate(()=>this.ctx.cursor.next(_onNext.bind(this)));
        }
        this.ctx.cursor.next(_onNext.bind(this));
    } else {
        _populateBatch.call(this);
    }
}
/*!
 * ignore
 */ function _populateBatch() {
    if (!this.ctx._batchDocs.length) {
        return this.callback(null, null);
    }
    const _this = this;
    this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {
        if (err) {
            return _this.callback(err);
        }
        _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);
    });
}
/*!
 * ignore
 */ function _nextDoc(ctx, doc, pop, callback) {
    if (ctx.query._mongooseOptions.lean) {
        return ctx.model.hooks.execPost("find", ctx.query, [
            [
                doc
            ]
        ], (err)=>{
            if (err != null) {
                return callback(err);
            }
            callback(null, doc);
        });
    }
    const { model , _fields , _userProvidedFields , options  } = ctx.query;
    helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc)=>{
        if (err != null) {
            return callback(err);
        }
        ctx.model.hooks.execPost("find", ctx.query, [
            [
                doc
            ]
        ], (err)=>{
            if (err != null) {
                return callback(err);
            }
            callback(null, doc);
        });
    });
}
/*!
 * ignore
 */ function _waitForCursor(ctx, cb) {
    if (ctx.cursor) {
        return cb();
    }
    ctx.once("cursor", function(cursor) {
        if (cursor == null) {
            return;
        }
        cb();
    });
}
module.exports = QueryCursor;


/***/ }),

/***/ 14001:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const EventEmitter = (__webpack_require__(82361).EventEmitter);
const InternalCache = __webpack_require__(16897);
const MongooseError = __webpack_require__(40413);
const MixedSchema = __webpack_require__(76541);
const ObjectExpectedError = __webpack_require__(7860);
const ObjectParameterError = __webpack_require__(96255);
const ParallelValidateError = __webpack_require__(84443);
const Schema = __webpack_require__(74951);
const StrictModeError = __webpack_require__(51016);
const ValidationError = __webpack_require__(13837);
const ValidatorError = __webpack_require__(50666);
const VirtualType = __webpack_require__(3596);
const $__hasIncludedChildren = __webpack_require__(90970);
const promiseOrCallback = __webpack_require__(83593);
const castNumber = __webpack_require__(71155);
const applyDefaults = __webpack_require__(1796);
const cleanModifiedSubpaths = __webpack_require__(74797);
const compile = (__webpack_require__(35772)/* .compile */ .M);
const defineKey = (__webpack_require__(35772)/* .defineKey */ .c);
const flatten = (__webpack_require__(26170)/* .flatten */ .x);
const flattenObjectWithDottedPaths = __webpack_require__(26961);
const get = __webpack_require__(39223);
const getEmbeddedDiscriminatorPath = __webpack_require__(73877);
const getKeysInSchemaOrder = __webpack_require__(26618);
const handleSpreadDoc = __webpack_require__(4715);
const immediate = __webpack_require__(96621);
const isDefiningProjection = __webpack_require__(5281);
const isExclusive = __webpack_require__(12374);
const inspect = (__webpack_require__(73837).inspect);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const markArraySubdocsPopulated = __webpack_require__(53768);
const mpath = __webpack_require__(52988);
const queryhelpers = __webpack_require__(83524);
const utils = __webpack_require__(52100);
const isPromise = __webpack_require__(93923);
const clone = utils.clone;
const deepEqual = utils.deepEqual;
const isMongooseObject = utils.isMongooseObject;
const arrayAtomicsBackupSymbol = (__webpack_require__(5089).arrayAtomicsBackupSymbol);
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const documentArrayParent = (__webpack_require__(5089).documentArrayParent);
const documentIsModified = (__webpack_require__(5089).documentIsModified);
const documentModifiedPaths = (__webpack_require__(5089).documentModifiedPaths);
const documentSchemaSymbol = (__webpack_require__(5089).documentSchemaSymbol);
const getSymbol = (__webpack_require__(5089).getSymbol);
const populateModelSymbol = (__webpack_require__(5089).populateModelSymbol);
const scopeSymbol = (__webpack_require__(5089).scopeSymbol);
const schemaMixedSymbol = (__webpack_require__(36825).schemaMixedSymbol);
const parentPaths = __webpack_require__(79478);
let DocumentArray;
let MongooseArray;
let Embedded;
const specialProperties = utils.specialProperties;
/**
 * The core Mongoose document constructor. You should not call this directly,
 * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.
 *
 * @param {Object} obj the values to set
 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
 * @param {Object} [options] various configuration options for the document
 * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.
 * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter
 * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.
 * @event `save`: Emitted when the document is successfully saved
 * @api private
 */ function Document(obj, fields, skipId, options) {
    if (typeof skipId === "object" && skipId != null) {
        options = skipId;
        skipId = options.skipId;
    }
    options = Object.assign({}, options);
    // Support `browserDocument.js` syntax
    if (this.$__schema == null) {
        const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;
        this.$__setSchema(_schema);
        fields = skipId;
        skipId = options;
        options = arguments[4] || {};
    }
    this.$__ = new InternalCache();
    // Avoid setting `isNew` to `true`, because it is `true` by default
    if (options.isNew != null && options.isNew !== true) {
        this.$isNew = options.isNew;
    }
    if (options.priorDoc != null) {
        this.$__.priorDoc = options.priorDoc;
    }
    if (skipId) {
        this.$__.skipId = skipId;
    }
    if (obj != null && typeof obj !== "object") {
        throw new ObjectParameterError(obj, "obj", "Document");
    }
    let defaults = true;
    if (options.defaults !== undefined) {
        this.$__.defaults = options.defaults;
        defaults = options.defaults;
    }
    const schema = this.$__schema;
    if (typeof fields === "boolean" || fields === "throw") {
        if (fields !== true) {
            this.$__.strictMode = fields;
        }
        fields = undefined;
    } else if (schema.options.strict !== true) {
        this.$__.strictMode = schema.options.strict;
    }
    const requiredPaths = schema.requiredPaths(true);
    for (const path of requiredPaths){
        this.$__.activePaths.require(path);
    }
    let exclude = null;
    // determine if this doc is a result of a query with
    // excluded fields
    if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {
        exclude = isExclusive(fields);
        this.$__.selected = fields;
        this.$__.exclude = exclude;
    }
    const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;
    if (this._doc == null) {
        this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
        // By default, defaults get applied **before** setting initial values
        // Re: gh-6155
        if (defaults) {
            applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);
        }
    }
    if (obj) {
        // Skip set hooks
        if (this.$__original_set) {
            this.$__original_set(obj, undefined, true, options);
        } else {
            this.$set(obj, undefined, true, options);
        }
        if (obj instanceof Document) {
            this.$isNew = obj.$isNew;
        }
    }
    // Function defaults get applied **after** setting initial values so they
    // see the full doc rather than an empty one, unless they opt out.
    // Re: gh-3781, gh-6155
    if (options.willInit && defaults) {
        if (options.skipDefaults) {
            this.$__.skipDefaults = options.skipDefaults;
        }
    } else if (defaults) {
        applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);
    }
    if (!this.$__.strictMode && obj) {
        const _this = this;
        const keys = Object.keys(this._doc);
        keys.forEach(function(key) {
            // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting
            // Mongoose internals.
            if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith("$")) {
                defineKey({
                    prop: key,
                    subprops: null,
                    prototype: _this
                });
            }
        });
    }
    applyQueue(this);
}
Document.prototype.$isMongooseDocumentPrototype = true;
/**
 * Boolean flag specifying if the document is new. If you create a document
 * using `new`, this document will be considered "new". `$isNew` is how
 * Mongoose determines whether `save()` should use `insertOne()` to create
 * a new document or `updateOne()` to update an existing document.
 *
 * #### Example:
 *
 *     const user = new User({ name: 'John Smith' });
 *     user.$isNew; // true
 *
 *     await user.save(); // Sends an `insertOne` to MongoDB
 *
 * On the other hand, if you load an existing document from the database
 * using `findOne()` or another [query operation](/docs/queries.html),
 * `$isNew` will be false.
 *
 * #### Example:
 *
 *     const user = await User.findOne({ name: 'John Smith' });
 *     user.$isNew; // false
 *
 * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.
 * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.
 * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.
 *
 * #### Example:
 *
 *     userSchema.post('save', function() {
 *       this.$isNew; // false
 *     });
 *     await User.create({ name: 'John Smith' });
 *
 * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,
 * or if you create a new subdocument.
 *
 * #### Example:
 *
 *     // Assume `Group` has a document array `users`
 *     const group = await Group.findOne();
 *     group.users[0].$isNew; // false
 *
 *     group.users.push({ name: 'John Smith' });
 *     group.users[1].$isNew; // true
 *
 * @api public
 * @property $isNew
 * @memberOf Document
 * @instance
 */ Object.defineProperty(Document.prototype, "isNew", {
    get: function() {
        return this.$isNew;
    },
    set: function(value) {
        this.$isNew = value;
    }
});
/**
 * Hash containing current validation errors.
 *
 * @api public
 * @property errors
 * @memberOf Document
 * @instance
 */ Object.defineProperty(Document.prototype, "errors", {
    get: function() {
        return this.$errors;
    },
    set: function(value) {
        this.$errors = value;
    }
});
/*!
 * ignore
 */ Document.prototype.$isNew = true;
/*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */ utils.each([
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
], function(emitterFn) {
    Document.prototype[emitterFn] = function() {
        // Delay creating emitter until necessary because emitters take up a lot of memory,
        // especially for subdocuments.
        if (!this.$__.emitter) {
            if (emitterFn === "emit") {
                return;
            }
            this.$__.emitter = new EventEmitter();
            this.$__.emitter.setMaxListeners(0);
        }
        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];
});
Document.prototype.constructor = Document;
for(const i in EventEmitter.prototype){
    Document[i] = EventEmitter.prototype[i];
}
/**
 * The document's internal schema.
 *
 * @api private
 * @property schema
 * @memberOf Document
 * @instance
 */ Document.prototype.$__schema;
/**
 * The document's schema.
 *
 * @api public
 * @property schema
 * @memberOf Document
 * @instance
 */ Document.prototype.schema;
/**
 * Empty object that you can use for storing properties on the document. This
 * is handy for passing data to middleware without conflicting with Mongoose
 * internals.
 *
 * #### Example:
 *
 *     schema.pre('save', function() {
 *       // Mongoose will set `isNew` to `false` if `save()` succeeds
 *       this.$locals.wasNew = this.isNew;
 *     });
 *
 *     schema.post('save', function() {
 *       // Prints true if `isNew` was set before `save()`
 *       console.log(this.$locals.wasNew);
 *     });
 *
 * @api public
 * @property $locals
 * @memberOf Document
 * @instance
 */ Object.defineProperty(Document.prototype, "$locals", {
    configurable: false,
    enumerable: false,
    get: function() {
        if (this.$__.locals == null) {
            this.$__.locals = {};
        }
        return this.$__.locals;
    },
    set: function(v) {
        this.$__.locals = v;
    }
});
/**
 * Legacy alias for `$isNew`.
 *
 * @api public
 * @property isNew
 * @memberOf Document
 * @see $isNew #document_Document-$isNew
 * @instance
 */ Document.prototype.isNew;
/**
 * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.
 *
 * #### Example:
 *
 *     // Make sure `save()` never updates a soft deleted document.
 *     schema.pre('save', function() {
 *       this.$where = { isDeleted: false };
 *     });
 *
 * @api public
 * @property $where
 * @memberOf Document
 * @instance
 */ Object.defineProperty(Document.prototype, "$where", {
    configurable: false,
    enumerable: false,
    writable: true
});
/**
 * The string version of this documents _id.
 *
 * #### Note:
 *
 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
 *
 *     new Schema({ name: String }, { id: false });
 *
 * @api public
 * @see Schema options /docs/guide.html#options
 * @property id
 * @memberOf Document
 * @instance
 */ Document.prototype.id;
/**
 * Hash containing current validation $errors.
 *
 * @api public
 * @property $errors
 * @memberOf Document
 * @instance
 */ Document.prototype.$errors;
/**
 * A string containing the current operation that Mongoose is executing
 * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.
 *
 * #### Example:
 *
 *     const doc = new Model({ name: 'test' });
 *     doc.$op; // null
 *
 *     const promise = doc.save();
 *     doc.$op; // 'save'
 *
 *     await promise;
 *     doc.$op; // null
 *
 * @api public
 * @property $op
 * @memberOf Document
 * @instance
 */ Object.defineProperty(Document.prototype, "$op", {
    get: function() {
        return this.$__.op || null;
    },
    set: function(value) {
        this.$__.op = value;
    }
});
/*!
 * ignore
 */ function $applyDefaultsToNested(val, path, doc) {
    if (val == null) {
        return;
    }
    flattenObjectWithDottedPaths(val);
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    const pathPieces = path.indexOf(".") === -1 ? [
        path
    ] : path.split(".");
    for(let i = 0; i < plen; ++i){
        let curPath = "";
        const p = paths[i];
        if (!p.startsWith(path + ".")) {
            continue;
        }
        const type = doc.$__schema.paths[p];
        const pieces = type.splitPath().slice(pathPieces.length);
        const len = pieces.length;
        if (type.defaultValue === void 0) {
            continue;
        }
        let cur = val;
        for(let j = 0; j < len; ++j){
            if (cur == null) {
                break;
            }
            const piece = pieces[j];
            if (j === len - 1) {
                if (cur[piece] !== void 0) {
                    break;
                }
                try {
                    const def = type.getDefault(doc, false);
                    if (def !== void 0) {
                        cur[piece] = def;
                    }
                } catch (err) {
                    doc.invalidate(path + "." + curPath, err);
                    break;
                }
                break;
            }
            curPath += (!curPath.length ? "" : ".") + piece;
            cur[piece] = cur[piece] || {};
            cur = cur[piece];
        }
    }
}
/**
 * Builds the default doc structure
 *
 * @param {Object} obj
 * @param {Object} [fields]
 * @param {Boolean} [skipId]
 * @param {Boolean} [exclude]
 * @param {Object} [hasIncludedChildren]
 * @api private
 * @method $__buildDoc
 * @memberOf Document
 * @instance
 */ Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
    const doc = {};
    const paths = Object.keys(this.$__schema.paths).// Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter((p)=>!p.includes("$*"));
    const plen = paths.length;
    let ii = 0;
    for(; ii < plen; ++ii){
        const p = paths[ii];
        if (p === "_id") {
            if (skipId) {
                continue;
            }
            if (obj && "_id" in obj) {
                continue;
            }
        }
        const path = this.$__schema.paths[p].splitPath();
        const len = path.length;
        const last = len - 1;
        let curPath = "";
        let doc_ = doc;
        let included = false;
        for(let i = 0; i < len; ++i){
            const piece = path[i];
            if (!curPath.length) {
                curPath = piece;
            } else {
                curPath += "." + piece;
            }
            // support excluding intermediary levels
            if (exclude === true) {
                if (curPath in fields) {
                    break;
                }
            } else if (exclude === false && fields && !included) {
                if (curPath in fields) {
                    included = true;
                } else if (!hasIncludedChildren[curPath]) {
                    break;
                }
            }
            if (i < last) {
                doc_ = doc_[piece] || (doc_[piece] = {});
            }
        }
    }
    this._doc = doc;
};
/*!
 * Converts to POJO when you use the document for querying
 */ Document.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
};
/**
 * Initializes the document without setters or marking anything modified.
 *
 * Called internally after a document is returned from mongodb. Normally,
 * you do **not** need to call this function on your own.
 *
 * This function triggers `init` [middleware](/docs/middleware.html).
 * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).
 *
 * @param {Object} doc document returned by mongo
 * @param {Object} [opts]
 * @param {Function} [fn]
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.init = function(doc, opts, fn) {
    if (typeof opts === "function") {
        fn = opts;
        opts = null;
    }
    this.$__init(doc, opts);
    if (fn) {
        fn(null, this);
    }
    return this;
};
/**
 * Alias for [`.init`](#document_Document-init)
 *
 * @api public
 */ Document.prototype.$init = function() {
    return this.constructor.prototype.init.apply(this, arguments);
};
/**
 * Internal "init" function
 *
 * @param {Document} doc
 * @param {Object} [opts]
 * @returns {Document} this
 * @api private
 */ Document.prototype.$__init = function(doc, opts) {
    this.$isNew = false;
    opts = opts || {};
    // handle docs with populated paths
    // If doc._id is not null or undefined
    if (doc._id != null && opts.populated && opts.populated.length) {
        const id = String(doc._id);
        for (const item of opts.populated){
            if (item.isVirtual) {
                this.$populated(item.path, utils.getValue(item.path, doc), item);
            } else {
                this.$populated(item.path, item._docs[id], item);
            }
            if (item._childDocs == null) {
                continue;
            }
            for (const child of item._childDocs){
                if (child == null || child.$__ == null) {
                    continue;
                }
                child.$__.parent = this;
            }
            item._childDocs = [];
        }
    }
    init(this, doc, this._doc, opts);
    markArraySubdocsPopulated(this, opts.populated);
    this.$emit("init", this);
    this.constructor.emit("init", this);
    const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ? $__hasIncludedChildren(this.$__.selected) : null;
    applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);
    return this;
};
/**
 * Init helper.
 *
 * @param {Object} self document instance
 * @param {Object} obj raw mongodb doc
 * @param {Object} doc object we are initializing
 * @param {Object} [opts] Optional Options
 * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`
 * @param {String} [prefix] Prefix to add to each path
 * @api private
 */ function init(self, obj, doc, opts, prefix) {
    prefix = prefix || "";
    const keys = Object.keys(obj);
    const len = keys.length;
    let schemaType;
    let path;
    let i;
    let index = 0;
    const strict = self.$__.strictMode;
    const docSchema = self.$__schema;
    while(index < len){
        _init(index++);
    }
    function _init(index) {
        i = keys[index];
        path = prefix + i;
        schemaType = docSchema.path(path);
        // Should still work if not a model-level discriminator, but should not be
        // necessary. This is *only* to catch the case where we queried using the
        // base model and the discriminated model has a projection
        if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {
            return;
        }
        if (!schemaType && utils.isPOJO(obj[i])) {
            // assume nested object
            if (!doc[i]) {
                doc[i] = {};
                if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {
                    self[i] = doc[i];
                }
            }
            init(self, obj[i], doc[i], opts, path + ".");
        } else if (!schemaType) {
            doc[i] = obj[i];
            if (!strict && !prefix) {
                self[i] = obj[i];
            }
        } else {
            // Retain order when overwriting defaults
            if (doc.hasOwnProperty(i) && obj[i] !== void 0) {
                delete doc[i];
            }
            if (obj[i] === null) {
                doc[i] = schemaType._castNullish(null);
            } else if (obj[i] !== undefined) {
                const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;
                if (schemaType && !wasPopulated) {
                    try {
                        if (opts && opts.setters) {
                            // Call applySetters with `init = false` because otherwise setters are a noop
                            const overrideInit = false;
                            doc[i] = schemaType.applySetters(obj[i], self, overrideInit);
                        } else {
                            doc[i] = schemaType.cast(obj[i], self, true);
                        }
                    } catch (e) {
                        self.invalidate(e.path, new ValidatorError({
                            path: e.path,
                            message: e.message,
                            type: "cast",
                            value: e.value,
                            reason: e
                        }));
                    }
                } else {
                    doc[i] = obj[i];
                }
            }
            // mark as hydrated
            if (!self.$isModified(path)) {
                self.$__.activePaths.init(path);
            }
        }
    }
}
/**
 * Sends an update command with this document `_id` as the query selector.
 *
 * #### Example:
 *
 *     weirdCar.update({ $inc: { wheels:1 } }, { w: 1 }, callback);
 *
 * #### Valid options:
 *
 *  - same as in [Model.update](#model_Model-update)
 *
 * @see Model.update #model_Model-update
 * @param {...Object} ops
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.update = function update() {
    const args = [
        ...arguments
    ];
    args.unshift({
        _id: this._id
    });
    const query = this.constructor.update.apply(this.constructor, args);
    if (this.$session() != null) {
        if (!("session" in query.options)) {
            query.options.session = this.$session();
        }
    }
    return query;
};
/**
 * Sends an updateOne command with this document `_id` as the query selector.
 *
 * #### Example:
 *
 *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);
 *
 * #### Valid options:
 *
 *  - same as in [Model.updateOne](#model_Model-updateOne)
 *
 * @see Model.updateOne #model_Model-updateOne
 * @param {Object} doc
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.updateOne = function updateOne(doc, options, callback) {
    const query = this.constructor.updateOne({
        _id: this._id
    }, doc, options);
    const self = this;
    query.pre(function queryPreUpdateOne(cb) {
        self.constructor._middleware.execPre("updateOne", self, [
            self
        ], cb);
    });
    query.post(function queryPostUpdateOne(cb) {
        self.constructor._middleware.execPost("updateOne", self, [
            self
        ], {}, cb);
    });
    if (this.$session() != null) {
        if (!("session" in query.options)) {
            query.options.session = this.$session();
        }
    }
    if (callback != null) {
        return query.exec(callback);
    }
    return query;
};
/**
 * Sends a replaceOne command with this document `_id` as the query selector.
 *
 * #### Valid options:
 *
 *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model-replaceOne)
 *
 * @see Model.replaceOne #model_Model-replaceOne
 * @param {Object} doc
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.replaceOne = function replaceOne() {
    const args = [
        ...arguments
    ];
    args.unshift({
        _id: this._id
    });
    return this.constructor.replaceOne.apply(this.constructor, args);
};
/**
 * Getter/setter around the session associated with this document. Used to
 * automatically set `session` if you `save()` a doc that you got from a
 * query with an associated session.
 *
 * #### Example:
 *
 *     const session = MyModel.startSession();
 *     const doc = await MyModel.findOne().session(session);
 *     doc.$session() === session; // true
 *     doc.$session(null);
 *     doc.$session() === null; // true
 *
 * If this is a top-level document, setting the session propagates to all child
 * docs.
 *
 * @param {ClientSession} [session] overwrite the current session
 * @return {ClientSession}
 * @method $session
 * @api public
 * @memberOf Document
 */ Document.prototype.$session = function $session(session) {
    if (arguments.length === 0) {
        if (this.$__.session != null && this.$__.session.hasEnded) {
            this.$__.session = null;
            return null;
        }
        return this.$__.session;
    }
    if (session != null && session.hasEnded) {
        throw new MongooseError("Cannot set a document's session to a session that has ended. Make sure you haven't " + "called `endSession()` on the session you are passing to `$session()`.");
    }
    if (session == null && this.$__.session == null) {
        return;
    }
    this.$__.session = session;
    if (!this.$isSubdocument) {
        const subdocs = this.$getAllSubdocs();
        for (const child of subdocs){
            child.$session(session);
        }
    }
    return session;
};
/**
 * Getter/setter around whether this document will apply timestamps by
 * default when using `save()` and `bulkSave()`.
 *
 * #### Example:
 *
 *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));
 *     const doc = new TestModel({ name: 'John Smith' });
 *
 *     doc.$timestamps(); // true
 *
 *     doc.$timestamps(false);
 *     await doc.save(); // Does **not** apply timestamps
 *
 * @param {Boolean} [value] overwrite the current session
 * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset "undefined" will be used, otherwise will return "this"
 * @method $timestamps
 * @api public
 * @memberOf Document
 */ Document.prototype.$timestamps = function $timestamps(value) {
    if (arguments.length === 0) {
        if (this.$__.timestamps != null) {
            return this.$__.timestamps;
        }
        if (this.$__schema) {
            return this.$__schema.options.timestamps;
        }
        return undefined;
    }
    const currentValue = this.$timestamps();
    if (value !== currentValue) {
        this.$__.timestamps = value;
    }
    return this;
};
/**
 * Overwrite all values in this document with the values of `obj`, except
 * for immutable properties. Behaves similarly to `set()`, except for it
 * unsets all properties that aren't in `obj`.
 *
 * @param {Object} obj the object to overwrite this document with
 * @method overwrite
 * @memberOf Document
 * @instance
 * @api public
 * @return {Document} this
 */ Document.prototype.overwrite = function overwrite(obj) {
    const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
    for (const key of keys){
        if (key === "_id") {
            continue;
        }
        // Explicitly skip version key
        if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
            continue;
        }
        if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
            continue;
        }
        this.$set(key, obj[key]);
    }
    return this;
};
/**
 * Alias for `set()`, used internally to avoid conflicts
 *
 * @param {String|Object} path path or object of key/vals to set
 * @param {Any} val the value to set
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
 * @param {Object} [options] optionally specify options that modify the behavior of the set
 * @param {Boolean} [options.merge=false] if true, setting a [nested path](/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`
 * @return {Document} this
 * @method $set
 * @memberOf Document
 * @instance
 * @api public
 */ Document.prototype.$set = function $set(path, val, type, options) {
    if (utils.isPOJO(type)) {
        options = type;
        type = undefined;
    }
    const merge = options && options.merge;
    const adhoc = type && type !== true;
    const constructing = type === true;
    let adhocs;
    let keys;
    let i = 0;
    let pathtype;
    let key;
    let prefix;
    const strict = options && "strict" in options ? options.strict : this.$__.strictMode;
    if (adhoc) {
        adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
        adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    if (path == null) {
        [path, val] = [
            val,
            path
        ];
    } else if (typeof path !== "string") {
        // new Document({ key: val })
        if (path instanceof Document) {
            if (path.$__isNested) {
                path = path.toObject();
            } else {
                path = path._doc;
            }
        }
        if (path == null) {
            [path, val] = [
                val,
                path
            ];
        }
        prefix = val ? val + "." : "";
        keys = getKeysInSchemaOrder(this.$__schema, path);
        const len = keys.length;
        // `_skipMinimizeTopLevel` is because we may have deleted the top-level
        // nested key to ensure key order.
        const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;
        if (len === 0 && _skipMinimizeTopLevel) {
            delete options._skipMinimizeTopLevel;
            if (val) {
                this.$set(val, {});
            }
            return this;
        }
        for(let i = 0; i < len; ++i){
            key = keys[i];
            const pathName = prefix + key;
            pathtype = this.$__schema.pathType(pathName);
            const valForKey = path[key];
            // On initial set, delete any nested keys if we're going to overwrite
            // them to ensure we keep the user's key order.
            if (type === true && !prefix && valForKey != null && pathtype === "nested" && this._doc[key] != null) {
                delete this._doc[key];
                // Make sure we set `{}` back even if we minimize re: gh-8565
                options = Object.assign({}, options, {
                    _skipMinimizeTopLevel: true
                });
            } else {
                // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441
                options = Object.assign({}, options, {
                    _skipMinimizeTopLevel: false
                });
            }
            if (utils.isNonBuiltinObject(valForKey) && pathtype === "nested") {
                this.$set(prefix + key, path[key], constructing, Object.assign({}, options, {
                    _skipMarkModified: true
                }));
                $applyDefaultsToNested(this.$get(prefix + key), prefix + key, this);
                continue;
            } else if (strict) {
                // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
                if (constructing && path[key] === void 0 && this.$get(pathName) !== void 0) {
                    continue;
                }
                if (pathtype === "adhocOrUndefined") {
                    pathtype = getEmbeddedDiscriminatorPath(this, pathName, {
                        typeOnly: true
                    });
                }
                if (pathtype === "real" || pathtype === "virtual") {
                    const p = path[key];
                    this.$set(prefix + key, p, constructing, options);
                } else if (pathtype === "nested" && path[key] instanceof Document) {
                    this.$set(prefix + key, path[key].toObject({
                        transform: false
                    }), constructing, options);
                } else if (strict === "throw") {
                    if (pathtype === "nested") {
                        throw new ObjectExpectedError(key, path[key]);
                    } else {
                        throw new StrictModeError(key);
                    }
                }
            } else if (path[key] !== void 0) {
                this.$set(prefix + key, path[key], constructing, options);
            }
        }
        // Ensure all properties are in correct order
        const orderedDoc = {};
        const orderedKeys = Object.keys(this.$__schema.tree);
        for(let i = 0, len = orderedKeys.length; i < len; ++i){
            (key = orderedKeys[i]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = undefined);
        }
        this._doc = Object.assign(orderedDoc, this._doc);
        return this;
    }
    let pathType = this.$__schema.pathType(path);
    if (pathType === "adhocOrUndefined") {
        pathType = getEmbeddedDiscriminatorPath(this, path, {
            typeOnly: true
        });
    }
    // Assume this is a Mongoose document that was copied into a POJO using
    // `Object.assign()` or `{...doc}`
    val = handleSpreadDoc(val);
    // if this doc is being constructed we should not trigger getters
    const priorVal = (()=>{
        if (this.$__.priorDoc != null) {
            return this.$__.priorDoc.$__getValue(path);
        }
        if (constructing) {
            return void 0;
        }
        return this.$__getValue(path);
    })();
    if (pathType === "nested" && val) {
        if (typeof val === "object" && val != null) {
            if (val.$__ != null) {
                val = val.toObject(internalToObjectOptions);
            }
            if (val == null) {
                this.invalidate(path, new MongooseError.CastError("Object", val, path));
                return this;
            }
            const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
            if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {
                const initialVal = this.$__getValue(path);
                this.$__.savedState[path] = initialVal;
                const keys = Object.keys(initialVal || {});
                for (const key of keys){
                    this.$__.savedState[path + "." + key] = initialVal[key];
                }
            }
            if (!merge) {
                this.$__setValue(path, null);
                cleanModifiedSubpaths(this, path);
            } else {
                return this.$set(val, path, constructing);
            }
            const keys = getKeysInSchemaOrder(this.$__schema, val, path);
            this.$__setValue(path, {});
            for (const key of keys){
                this.$set(path + "." + key, val[key], constructing, options);
            }
            if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {
                this.unmarkModified(path);
            } else {
                this.markModified(path);
            }
            return this;
        }
        this.invalidate(path, new MongooseError.CastError("Object", val, path));
        return this;
    }
    let schema;
    const parts = path.indexOf(".") === -1 ? [
        path
    ] : path.split(".");
    // Might need to change path for top-level alias
    if (typeof this.$__schema.aliases[parts[0]] === "string") {
        parts[0] = this.$__schema.aliases[parts[0]];
    }
    if (pathType === "adhocOrUndefined" && strict) {
        // check for roots that are Mixed types
        let mixed;
        for(i = 0; i < parts.length; ++i){
            const subpath = parts.slice(0, i + 1).join(".");
            // If path is underneath a virtual, bypass everything and just set it.
            if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
                mpath.set(path, val, this);
                return this;
            }
            schema = this.$__schema.path(subpath);
            if (schema == null) {
                continue;
            }
            if (schema instanceof MixedSchema) {
                // allow changes to sub paths of mixed types
                mixed = true;
                break;
            }
        }
        if (schema == null) {
            // Check for embedded discriminators
            schema = getEmbeddedDiscriminatorPath(this, path);
        }
        if (!mixed && !schema) {
            if (strict === "throw") {
                throw new StrictModeError(path);
            }
            return this;
        }
    } else if (pathType === "virtual") {
        schema = this.$__schema.virtualpath(path);
        schema.applySetters(val, this);
        return this;
    } else {
        schema = this.$__path(path);
    }
    // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
    let cur = this._doc;
    let curPath = "";
    for(i = 0; i < parts.length - 1; ++i){
        cur = cur[parts[i]];
        curPath += (curPath.length !== 0 ? "." : "") + parts[i];
        if (!cur) {
            this.$set(curPath, {});
            // Hack re: gh-5800. If nested field is not selected, it probably exists
            // so `MongoServerError: cannot use the part (nested of nested.num) to
            // traverse the element ({nested: null})` is not likely. If user gets
            // that error, its their fault for now. We should reconsider disallowing
            // modifying not selected paths for 6.x
            if (!this.$__isSelected(curPath)) {
                this.unmarkModified(curPath);
            }
            cur = this.$__getValue(curPath);
        }
    }
    let pathToMark;
    // When using the $set operator the path to the field must already exist.
    // Else mongodb throws: "LEFT_SUBFIELD only supports Object"
    if (parts.length <= 1) {
        pathToMark = path;
    } else {
        const len = parts.length;
        for(i = 0; i < len; ++i){
            const subpath = parts.slice(0, i + 1).join(".");
            if (this.$get(subpath, null, {
                getters: false
            }) === null) {
                pathToMark = subpath;
                break;
            }
        }
        if (!pathToMark) {
            pathToMark = path;
        }
    }
    if (!schema) {
        this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
        if (pathType === "nested" && val == null) {
            cleanModifiedSubpaths(this, path);
        }
        return this;
    }
    // If overwriting a subdocument path, make sure to clear out
    // any errors _before_ setting, so new errors that happen
    // get persisted. Re: #9080
    if (schema.$isSingleNested || schema.$isMongooseArray) {
        _markValidSubpaths(this, path);
    }
    if (val != null && merge && schema.$isSingleNested) {
        if (val instanceof Document) {
            val = val.toObject({
                virtuals: false,
                transform: false
            });
        }
        const keys = Object.keys(val);
        for (const key of keys){
            this.$set(path + "." + key, val[key], constructing, options);
        }
        return this;
    }
    let shouldSet = true;
    try {
        // If the user is trying to set a ref path to a document with
        // the correct model name, treat it as populated
        const refMatches = (()=>{
            if (schema.options == null) {
                return false;
            }
            if (!(val instanceof Document)) {
                return false;
            }
            const model = val.constructor;
            // Check ref
            const ref = schema.options.ref;
            if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
                return true;
            }
            // Check refPath
            const refPath = schema.options.refPath;
            if (refPath == null) {
                return false;
            }
            const modelName = val.get(refPath);
            return modelName === model.modelName || modelName === model.baseModelName;
        })();
        let didPopulate = false;
        if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {
            const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._id;
            this.$populated(path, unpopulatedValue, {
                [populateModelSymbol]: val.constructor
            });
            val.$__.wasPopulated = {
                value: unpopulatedValue
            };
            didPopulate = true;
        }
        let popOpts;
        const typeKey = this.$__schema.options.typeKey;
        if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
            popOpts = {
                [populateModelSymbol]: val[0].constructor
            };
            this.$populated(path, val.map(function(v) {
                return v._id;
            }), popOpts);
            for (const doc of val){
                doc.$__.wasPopulated = {
                    value: doc._id
                };
            }
            didPopulate = true;
        }
        if (this.$__schema.singleNestedPaths[path] == null && (!refMatches || !schema.$isSingleNested || !val.$__)) {
            // If this path is underneath a single nested schema, we'll call the setter
            // later in `$__set()` because we don't take `_doc` when we iterate through
            // a single nested doc. That's to make sure we get the correct context.
            // Otherwise we would double-call the setter, see gh-7196.
            if (options != null && options.overwriteImmutable) {
                val = schema.applySetters(val, this, false, priorVal, {
                    overwriteImmutable: true
                });
            } else {
                val = schema.applySetters(val, this, false, priorVal);
            }
        }
        if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
            const populatedPaths = Object.keys(val[0].$__.populated);
            for (const populatedPath of populatedPaths){
                this.$populated(path + "." + populatedPath, val.map((v)=>v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);
            }
            didPopulate = true;
        }
        if (!didPopulate && this.$__.populated) {
            // If this array partially contains populated documents, convert them
            // all to ObjectIds re: #8443
            if (Array.isArray(val) && this.$__.populated[path]) {
                for(let i = 0; i < val.length; ++i){
                    if (val[i] instanceof Document) {
                        val.set(i, val[i]._id, true);
                    }
                }
            }
            delete this.$__.populated[path];
        }
        if (val != null && schema.$isSingleNested) {
            _checkImmutableSubpaths(val, schema, priorVal);
        }
        this.$markValid(path);
    } catch (e) {
        if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
            this.invalidate(path, e);
        } else if (e instanceof MongooseError.CastError) {
            this.invalidate(e.path, e);
            if (e.$originalErrorPath) {
                this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
            }
        } else {
            this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));
        }
        shouldSet = false;
    }
    if (shouldSet) {
        let savedState = null;
        let savedStatePath = null;
        if (!constructing) {
            const doc = this.$isSubdocument ? this.ownerDocument() : this;
            savedState = doc.$__.savedState;
            savedStatePath = this.$isSubdocument ? this.$__.fullPath + "." + path : path;
            doc.$__saveInitialState(savedStatePath);
        }
        this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
        if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {
            this.unmarkModified(path);
        }
    }
    if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
        cleanModifiedSubpaths(this, path);
    }
    return this;
};
/*!
 * ignore
 */ function _isManuallyPopulatedArray(val, ref) {
    if (!Array.isArray(val)) {
        return false;
    }
    if (val.length === 0) {
        return false;
    }
    for (const el of val){
        if (!(el instanceof Document)) {
            return false;
        }
        const modelName = el.constructor.modelName;
        if (modelName == null) {
            return false;
        }
        if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
            return false;
        }
    }
    return true;
}
/**
 * Sets the value of a path, or many paths.
 * Alias for [`.$set`](#document_Document-$set).
 *
 * #### Example:
 *
 *     // path, value
 *     doc.set(path, value)
 *
 *     // object
 *     doc.set({
 *         path  : value
 *       , path2 : {
 *            path  : value
 *         }
 *     })
 *
 *     // on-the-fly cast to number
 *     doc.set(path, value, Number)
 *
 *     // on-the-fly cast to string
 *     doc.set(path, value, String)
 *
 *     // changing strict mode behavior
 *     doc.set(path, value, { strict: false });
 *
 * @param {String|Object} path path or object of key/vals to set
 * @param {Any} val the value to set
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
 * @param {Object} [options] optionally specify options that modify the behavior of the set
 * @return {Document} this
 * @api public
 * @method set
 * @memberOf Document
 * @instance
 */ Document.prototype.set = Document.prototype.$set;
/**
 * Determine if we should mark this change as modified.
 *
 * @param {never} pathToMark UNUSED
 * @param {String|Symbol} path
 * @param {Object} options
 * @param {Any} constructing
 * @param {never} parts UNUSED
 * @param {Schema} schema
 * @param {Any} val
 * @param {Any} priorVal
 * @return {Boolean}
 * @api private
 * @method $__shouldModify
 * @memberOf Document
 * @instance
 */ Document.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    if (options && options._skipMarkModified) {
        return false;
    }
    if (this.$isNew) {
        return true;
    }
    // Is path already modified? If so, always modify. We may unmark modified later.
    if (path in this.$__.activePaths.getStatePaths("modify")) {
        return true;
    }
    // Re: the note about gh-7196, `val` is the raw value without casting or
    // setters if the full path is under a single nested subdoc because we don't
    // want to double run setters. So don't set it as modified. See gh-7264.
    if (this.$__schema.singleNestedPaths[path] != null) {
        return false;
    }
    if (val === void 0 && !this.$__isSelected(path)) {
        // when a path is not selected in a query, its initial
        // value will be undefined.
        return true;
    }
    if (val === void 0 && path in this.$__.activePaths.getStatePaths("default")) {
        // we're just unsetting the default value which was never saved
        return false;
    }
    // gh-3992: if setting a populated field to a doc, don't mark modified
    // if they have the same _id
    if (this.$populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {
        return false;
    }
    if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {
        return true;
    }
    if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.getStatePaths("default") && deepEqual(val, schema.getDefault(this, constructing))) {
        // a path with a default was $unset on the server
        // and the user is setting it to the same value again
        return true;
    }
    return false;
};
/**
 * Handles the actual setting of the value and marking the path modified if appropriate.
 *
 * @param {String} pathToMark
 * @param {String|Symbol} path
 * @param {Object} options
 * @param {Any} constructing
 * @param {Array} parts
 * @param {Schema} schema
 * @param {Any} val
 * @param {Any} priorVal
 * @api private
 * @method $__set
 * @memberOf Document
 * @instance
 */ Document.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    Embedded = Embedded || __webpack_require__(46829);
    const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);
    if (shouldModify) {
        if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {
            delete this.$__.primitiveAtomics[path];
            if (Object.keys(this.$__.primitiveAtomics).length === 0) {
                delete this.$__.primitiveAtomics;
            }
        }
        this.markModified(pathToMark);
        // handle directly setting arrays (gh-1126)
        MongooseArray || (MongooseArray = __webpack_require__(74484));
        if (val && utils.isMongooseArray(val)) {
            val._registerAtomic("$set", val);
            // Update embedded document parent references (gh-5189)
            if (utils.isMongooseDocumentArray(val)) {
                val.forEach(function(item) {
                    item && item.__parentArray && (item.__parentArray = val);
                });
            }
        }
    } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {
        val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];
        val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];
        if (utils.isMongooseDocumentArray(val)) {
            val.forEach((doc)=>{
                doc.isNew = false;
            });
        }
    }
    let obj = this._doc;
    let i = 0;
    const l = parts.length;
    let cur = "";
    for(; i < l; i++){
        const next = i + 1;
        const last = next === l;
        cur += cur ? "." + parts[i] : parts[i];
        if (specialProperties.has(parts[i])) {
            return;
        }
        if (last) {
            if (obj instanceof Map) {
                obj.set(parts[i], val);
            } else {
                obj[parts[i]] = val;
            }
        } else {
            if (utils.isPOJO(obj[parts[i]])) {
                obj = obj[parts[i]];
            } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
                obj = obj[parts[i]];
            } else if (obj[parts[i]] && !Array.isArray(obj[parts[i]]) && obj[parts[i]].$isSingleNested) {
                obj = obj[parts[i]];
            } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
                obj = obj[parts[i]];
            } else {
                obj[parts[i]] = obj[parts[i]] || {};
                obj = obj[parts[i]];
            }
        }
    }
};
/**
 * Gets a raw value from a path (no getters)
 *
 * @param {String} path
 * @return {Any} Returns the value from the given `path`.
 * @api private
 */ Document.prototype.$__getValue = function(path) {
    return utils.getValue(path, this._doc);
};
/**
 * Increments the numeric value at `path` by the given `val`.
 * When you call `save()` on this document, Mongoose will send a
 * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)
 * as opposed to a `$set`.
 *
 * #### Example:
 *
 *     const schema = new Schema({ counter: Number });
 *     const Test = db.model('Test', schema);
 *
 *     const doc = await Test.create({ counter: 0 });
 *     doc.$inc('counter', 2);
 *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB
 *     doc.counter; // 2
 *
 *     doc.counter += 2;
 *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB
 *
 * @param {String|Array} path path or paths to update
 * @param {Number} val increment `path` by this value
 * @return {Document} this
 */ Document.prototype.$inc = function $inc(path, val) {
    if (val == null) {
        val = 1;
    }
    if (Array.isArray(path)) {
        path.forEach((p)=>this.$inc(p, val));
        return this;
    }
    const schemaType = this.$__path(path);
    if (schemaType == null) {
        if (this.$__.strictMode === "throw") {
            throw new StrictModeError(path);
        } else if (this.$__.strictMode === true) {
            return this;
        }
    } else if (schemaType.instance !== "Number") {
        this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));
        return this;
    }
    try {
        val = castNumber(val);
    } catch (err) {
        this.invalidate(path, new MongooseError.CastError("number", val, path, err));
    }
    const currentValue = this.$__getValue(path) || 0;
    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};
    this.$__.primitiveAtomics[path] = {
        $inc: val
    };
    this.markModified(path);
    this.$__setValue(path, currentValue + val);
    return this;
};
/**
 * Sets a raw value for a path (no casting, setters, transformations)
 *
 * @param {String} path
 * @param {Object} value
 * @return {Document} this
 * @api private
 */ Document.prototype.$__setValue = function(path, val) {
    utils.setValue(path, val, this._doc);
    return this;
};
/**
 * Returns the value of a path.
 *
 * #### Example:
 *
 *     // path
 *     doc.get('age') // 47
 *
 *     // dynamic casting to a string
 *     doc.get('age', String) // "47"
 *
 * @param {String} path
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes
 * @param {Object} [options]
 * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path
 * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value
 * @return {Any}
 * @api public
 */ Document.prototype.get = function(path, type, options) {
    let adhoc;
    options = options || {};
    if (type) {
        adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    let schema = this.$__path(path);
    if (schema == null) {
        schema = this.$__schema.virtualpath(path);
    }
    if (schema instanceof MixedSchema) {
        const virtual = this.$__schema.virtualpath(path);
        if (virtual != null) {
            schema = virtual;
        }
    }
    const pieces = path.indexOf(".") === -1 ? [
        path
    ] : path.split(".");
    let obj = this._doc;
    if (schema instanceof VirtualType) {
        return schema.applyGetters(void 0, this);
    }
    // Might need to change path for top-level alias
    if (typeof this.$__schema.aliases[pieces[0]] === "string") {
        pieces[0] = this.$__schema.aliases[pieces[0]];
    }
    for(let i = 0, l = pieces.length; i < l; i++){
        if (obj && obj._doc) {
            obj = obj._doc;
        }
        if (obj == null) {
            obj = void 0;
        } else if (obj instanceof Map) {
            obj = obj.get(pieces[i], {
                getters: false
            });
        } else if (i === l - 1) {
            obj = utils.getValue(pieces[i], obj);
        } else {
            obj = obj[pieces[i]];
        }
    }
    if (adhoc) {
        obj = adhoc.cast(obj);
    }
    if (schema != null && options.getters !== false) {
        obj = schema.applyGetters(obj, this);
    } else if (this.$__schema.nested[path] && options.virtuals) {
        // Might need to apply virtuals if this is a nested path
        return applyVirtuals(this, utils.clone(obj) || {}, {
            path: path
        });
    }
    return obj;
};
/*!
 * ignore
 */ Document.prototype[getSymbol] = Document.prototype.get;
Document.prototype.$get = Document.prototype.get;
/**
 * Returns the schematype for the given `path`.
 *
 * @param {String} path
 * @return {SchemaPath}
 * @api private
 * @method $__path
 * @memberOf Document
 * @instance
 */ Document.prototype.$__path = function(path) {
    const adhocs = this.$__.adhocPaths;
    const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
    if (adhocType) {
        return adhocType;
    }
    return this.$__schema.path(path);
};
/**
 * Marks the path as having pending changes to write to the db.
 *
 * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._
 *
 * #### Example:
 *
 *     doc.mixed.type = 'changed';
 *     doc.markModified('mixed.type');
 *     doc.save() // changes to mixed.type are now persisted
 *
 * @param {String} path the path to mark modified
 * @param {Document} [scope] the scope to run validators with
 * @api public
 */ Document.prototype.markModified = function(path, scope) {
    this.$__saveInitialState(path);
    this.$__.activePaths.modify(path);
    if (scope != null && !this.$isSubdocument) {
        this.$__.pathsToScopes = this.$__pathsToScopes || {};
        this.$__.pathsToScopes[path] = scope;
    }
};
/*!
 * ignore
 */ Document.prototype.$__saveInitialState = function $__saveInitialState(path) {
    const savedState = this.$__.savedState;
    const savedStatePath = path;
    if (savedState != null) {
        const firstDot = savedStatePath.indexOf(".");
        const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);
        if (!savedState.hasOwnProperty(topLevelPath)) {
            savedState[topLevelPath] = utils.clone(this.$__getValue(topLevelPath));
        }
    }
};
/**
 * Clears the modified state on the specified path.
 *
 * #### Example:
 *
 *     doc.foo = 'bar';
 *     doc.unmarkModified('foo');
 *     doc.save(); // changes to foo will not be persisted
 *
 * @param {String} path the path to unmark modified
 * @api public
 */ Document.prototype.unmarkModified = function(path) {
    this.$__.activePaths.init(path);
    if (this.$__.pathsToScopes != null) {
        delete this.$__.pathsToScopes[path];
    }
};
/**
 * Don't run validation on this path or persist changes to this path.
 *
 * #### Example:
 *
 *     doc.foo = null;
 *     doc.$ignore('foo');
 *     doc.save(); // changes to foo will not be persisted and validators won't be run
 *
 * @memberOf Document
 * @instance
 * @method $ignore
 * @param {String} path the path to ignore
 * @api public
 */ Document.prototype.$ignore = function(path) {
    this.$__.activePaths.ignore(path);
};
/**
 * Returns the list of paths that have been directly modified. A direct
 * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,
 * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.
 *
 * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`
 * because a child of `a` was directly modified.
 *
 * #### Example:
 *
 *     const schema = new Schema({ foo: String, nested: { bar: String } });
 *     const Model = mongoose.model('Test', schema);
 *     await Model.create({ foo: 'original', nested: { bar: 'original' } });
 *
 *     const doc = await Model.findOne();
 *     doc.nested.bar = 'modified';
 *     doc.directModifiedPaths(); // ['nested.bar']
 *     doc.modifiedPaths(); // ['nested', 'nested.bar']
 *
 * @return {String[]}
 * @api public
 */ Document.prototype.directModifiedPaths = function() {
    return Object.keys(this.$__.activePaths.getStatePaths("modify"));
};
/**
 * Returns true if the given path is nullish or only contains empty objects.
 * Useful for determining whether this subdoc will get stripped out by the
 * [minimize option](/docs/guide.html#minimize).
 *
 * #### Example:
 *
 *     const schema = new Schema({ nested: { foo: String } });
 *     const Model = mongoose.model('Test', schema);
 *     const doc = new Model({});
 *     doc.$isEmpty('nested'); // true
 *     doc.nested.$isEmpty(); // true
 *
 *     doc.nested.foo = 'bar';
 *     doc.$isEmpty('nested'); // false
 *     doc.nested.$isEmpty(); // false
 *
 * @param {String} [path]
 * @memberOf Document
 * @instance
 * @api public
 * @method $isEmpty
 * @return {Boolean}
 */ Document.prototype.$isEmpty = function(path) {
    const isEmptyOptions = {
        minimize: true,
        virtuals: false,
        getters: false,
        transform: false
    };
    if (arguments.length !== 0) {
        const v = this.$get(path);
        if (v == null) {
            return true;
        }
        if (typeof v !== "object") {
            return false;
        }
        if (utils.isPOJO(v)) {
            return _isEmpty(v);
        }
        return Object.keys(v.toObject(isEmptyOptions)).length === 0;
    }
    return Object.keys(this.toObject(isEmptyOptions)).length === 0;
};
/*!
 * ignore
 */ function _isEmpty(v) {
    if (v == null) {
        return true;
    }
    if (typeof v !== "object" || Array.isArray(v)) {
        return false;
    }
    for (const key of Object.keys(v)){
        if (!_isEmpty(v[key])) {
            return false;
        }
    }
    return true;
}
/**
 * Returns the list of paths that have been modified.
 *
 * @param {Object} [options]
 * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.
 * @return {String[]}
 * @api public
 */ Document.prototype.modifiedPaths = function(options) {
    options = options || {};
    const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths("modify"));
    const result = new Set();
    let i = 0;
    let j = 0;
    const len = directModifiedPaths.length;
    for(i = 0; i < len; ++i){
        const path = directModifiedPaths[i];
        const parts = parentPaths(path);
        const pLen = parts.length;
        for(j = 0; j < pLen; ++j){
            result.add(parts[j]);
        }
        if (!options.includeChildren) {
            continue;
        }
        let ii = 0;
        let cur = this.$get(path);
        if (typeof cur === "object" && cur !== null) {
            if (cur._doc) {
                cur = cur._doc;
            }
            const len = cur.length;
            if (Array.isArray(cur)) {
                for(ii = 0; ii < len; ++ii){
                    const subPath = path + "." + ii;
                    if (!result.has(subPath)) {
                        result.add(subPath);
                        if (cur[ii] != null && cur[ii].$__) {
                            const modified = cur[ii].modifiedPaths();
                            let iii = 0;
                            const iiiLen = modified.length;
                            for(iii = 0; iii < iiiLen; ++iii){
                                result.add(subPath + "." + modified[iii]);
                            }
                        }
                    }
                }
            } else {
                const keys = Object.keys(cur);
                let ii = 0;
                const len = keys.length;
                for(ii = 0; ii < len; ++ii){
                    result.add(path + "." + keys[ii]);
                }
            }
        }
    }
    return Array.from(result);
};
Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;
/**
 * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path
 * in this document is modified.
 *
 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
 *
 * #### Example:
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isModified()                      // true
 *     doc.isModified('documents')           // true
 *     doc.isModified('documents.0.title')   // true
 *     doc.isModified('documents otherProp') // true
 *     doc.isDirectModified('documents')     // false
 *
 * @param {String} [path] optional
 * @return {Boolean}
 * @api public
 */ Document.prototype.isModified = function(paths, modifiedPaths) {
    if (paths) {
        const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths("modify"));
        if (directModifiedPaths.length === 0) {
            return false;
        }
        if (!Array.isArray(paths)) {
            paths = paths.indexOf(" ") === -1 ? [
                paths
            ] : paths.split(" ");
        }
        const modified = modifiedPaths || this[documentModifiedPaths]();
        const isModifiedChild = paths.some(function(path) {
            return !!~modified.indexOf(path);
        });
        return isModifiedChild || paths.some(function(path) {
            return directModifiedPaths.some(function(mod) {
                return mod === path || path.startsWith(mod + ".");
            });
        });
    }
    return this.$__.activePaths.some("modify");
};
/**
 * Alias of [`.isModified`](#document_Document-isModified)
 *
 * @method $isModified
 * @memberOf Document
 * @api public
 */ Document.prototype.$isModified = Document.prototype.isModified;
Document.prototype[documentIsModified] = Document.prototype.isModified;
/**
 * Checks if a path is set to its default.
 *
 * #### Example:
 *
 *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });
 *     const m = new MyModel();
 *     m.$isDefault('name'); // true
 *
 * @memberOf Document
 * @instance
 * @method $isDefault
 * @param {String} [path]
 * @return {Boolean}
 * @api public
 */ Document.prototype.$isDefault = function(path) {
    if (path == null) {
        return this.$__.activePaths.some("default");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.getStatePaths("default").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
        paths = paths.split(" ");
    }
    return paths.some((path)=>this.$__.activePaths.getStatePaths("default").hasOwnProperty(path));
};
/**
 * Getter/setter, determines whether the document was removed or not.
 *
 * #### Example:
 *
 *     const product = await product.remove();
 *     product.$isDeleted(); // true
 *     product.remove(); // no-op, doesn't send anything to the db
 *
 *     product.$isDeleted(false);
 *     product.$isDeleted(); // false
 *     product.remove(); // will execute a remove against the db
 *
 *
 * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted
 * @return {Boolean|Document} whether mongoose thinks this doc is deleted.
 * @method $isDeleted
 * @memberOf Document
 * @instance
 * @api public
 */ Document.prototype.$isDeleted = function(val) {
    if (arguments.length === 0) {
        return !!this.$__.isDeleted;
    }
    this.$__.isDeleted = !!val;
    return this;
};
/**
 * Returns true if `path` was directly set and modified, else false.
 *
 * #### Example:
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isDirectModified('documents.0.title') // true
 *     doc.isDirectModified('documents') // false
 *
 * @param {String|String[]} [path]
 * @return {Boolean}
 * @api public
 */ Document.prototype.isDirectModified = function(path) {
    if (path == null) {
        return this.$__.activePaths.some("modify");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
        paths = paths.split(" ");
    }
    return paths.some((path)=>this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path));
};
/**
 * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.
 *
 * @param {String} [path]
 * @return {Boolean}
 * @api public
 */ Document.prototype.isInit = function(path) {
    if (path == null) {
        return this.$__.activePaths.some("init");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.getStatePaths("init").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
        paths = paths.split(" ");
    }
    return paths.some((path)=>this.$__.activePaths.getStatePaths("init").hasOwnProperty(path));
};
/**
 * Checks if `path` was selected in the source query which initialized this document.
 *
 * #### Example:
 *
 *     const doc = await Thing.findOne().select('name');
 *     doc.isSelected('name') // true
 *     doc.isSelected('age')  // false
 *
 * @param {String|String[]} path
 * @return {Boolean}
 * @api public
 */ Document.prototype.isSelected = function isSelected(path) {
    if (this.$__.selected == null) {
        return true;
    }
    if (!path) {
        return false;
    }
    if (path === "_id") {
        return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
    }
    if (Array.isArray(path)) {
        return path.some((p)=>this.$__isSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
        // only _id was selected.
        return this.$__.selected._id === 0;
    }
    for (const cur of paths){
        if (cur === "_id") {
            continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
            continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
    }
    if (inclusive === null) {
        return true;
    }
    if (path in this.$__.selected) {
        return inclusive;
    }
    const pathDot = path + ".";
    for (const cur of paths){
        if (cur === "_id") {
            continue;
        }
        if (cur.startsWith(pathDot)) {
            return inclusive || cur !== pathDot;
        }
        if (pathDot.startsWith(cur + ".")) {
            return inclusive;
        }
    }
    return !inclusive;
};
Document.prototype.$__isSelected = Document.prototype.isSelected;
/**
 * Checks if `path` was explicitly selected. If no projection, always returns
 * true.
 *
 * #### Example:
 *
 *     Thing.findOne().select('nested.name').exec(function (err, doc) {
 *        doc.isDirectSelected('nested.name') // true
 *        doc.isDirectSelected('nested.otherName') // false
 *        doc.isDirectSelected('nested')  // false
 *     })
 *
 * @param {String} path
 * @return {Boolean}
 * @api public
 */ Document.prototype.isDirectSelected = function isDirectSelected(path) {
    if (this.$__.selected == null) {
        return true;
    }
    if (path === "_id") {
        return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
    }
    if (Array.isArray(path)) {
        return path.some((p)=>this.isDirectSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
        // only _id was selected.
        return this.$__.selected._id === 0;
    }
    for (const cur of paths){
        if (cur === "_id") {
            continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
            continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
    }
    if (inclusive === null) {
        return true;
    }
    if (this.$__.selected.hasOwnProperty(path)) {
        return inclusive;
    }
    return !inclusive;
};
/**
 * Executes registered validation rules for this document.
 *
 * #### Note:
 *
 * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.
 *
 * #### Example:
 *
 *     doc.validate(function (err) {
 *       if (err) handleError(err);
 *       else // validation passed
 *     });
 *
 * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.
 * @param {Object} [options] internal options
 * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.
 * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.
 * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred
 * @return {Promise} Returns a Promise if no `callback` is given.
 * @api public
 */ Document.prototype.validate = function(pathsToValidate, options, callback) {
    let parallelValidate;
    this.$op = "validate";
    if (this.$isSubdocument != null) {
    // Skip parallel validate check for subdocuments
    } else if (this.$__.validating) {
        parallelValidate = new ParallelValidateError(this, {
            parentStack: options && options.parentStack,
            conflictStack: this.$__.validating.stack
        });
    } else {
        this.$__.validating = new ParallelValidateError(this, {
            parentStack: options && options.parentStack
        });
    }
    if (arguments.length === 1) {
        if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
            options = arguments[0];
            callback = null;
            pathsToValidate = null;
        } else if (typeof arguments[0] === "function") {
            callback = arguments[0];
            options = null;
            pathsToValidate = null;
        }
    } else if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
    } else if (typeof options === "function") {
        callback = options;
        options = pathsToValidate;
        pathsToValidate = null;
    }
    if (options && typeof options.pathsToSkip === "string") {
        const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
        options.pathsToSkip = isOnePathOnly ? [
            options.pathsToSkip
        ] : options.pathsToSkip.split(" ");
    }
    return promiseOrCallback(callback, (cb)=>{
        if (parallelValidate != null) {
            return cb(parallelValidate);
        }
        this.$__validate(pathsToValidate, options, (error)=>{
            this.$op = null;
            this.$__.validating = null;
            cb(error);
        });
    }, this.constructor.events);
};
/**
 * Alias of [`.validate`](#document_Document-validate)
 *
 * @method $validate
 * @memberOf Document
 * @api public
 */ Document.prototype.$validate = Document.prototype.validate;
/*!
 * ignore
 */ function _evaluateRequiredFunctions(doc) {
    const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths("require"));
    let i = 0;
    const len = requiredFields.length;
    for(i = 0; i < len; ++i){
        const path = requiredFields[i];
        const p = doc.$__schema.path(path);
        if (p != null && typeof p.originalRequiredValue === "function") {
            doc.$__.cachedRequired = doc.$__.cachedRequired || {};
            try {
                doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
            } catch (err) {
                doc.invalidate(path, err);
            }
        }
    }
}
/*!
 * ignore
 */ function _getPathsToValidate(doc) {
    const skipSchemaValidators = {};
    _evaluateRequiredFunctions(doc);
    // only validate required fields when necessary
    let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths("require")).filter(function(path) {
        if (!doc.$__isSelected(path) && !doc.$isModified(path)) {
            return false;
        }
        if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {
            return doc.$__.cachedRequired[path];
        }
        return true;
    }));
    Object.keys(doc.$__.activePaths.getStatePaths("init")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("modify")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("default")).forEach(addToPaths);
    function addToPaths(p) {
        paths.add(p);
    }
    const subdocs = doc.$getAllSubdocs();
    const modifiedPaths = doc.modifiedPaths();
    for (const subdoc of subdocs){
        if (subdoc.$basePath) {
            // Remove child paths for now, because we'll be validating the whole
            // subdoc
            const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();
            for (const p of paths){
                if (p == null || p.startsWith(fullPathToSubdoc + ".")) {
                    paths.delete(p);
                }
            }
            if (doc.$isModified(fullPathToSubdoc, modifiedPaths) && !doc.isDirectModified(fullPathToSubdoc) && !doc.$isDefault(fullPathToSubdoc)) {
                paths.add(fullPathToSubdoc);
                skipSchemaValidators[fullPathToSubdoc] = true;
            }
        }
    }
    for (const path of paths){
        const _pathType = doc.$__schema.path(path);
        if (!_pathType) {
            continue;
        }
        if (_pathType.$isMongooseDocumentArray) {
            for (const p of paths){
                if (p == null || p.startsWith(_pathType.path + ".")) {
                    paths.delete(p);
                }
            }
        }
        // Optimization: if primitive path with no validators, or array of primitives
        // with no validators, skip validating this path entirely.
        if (!_pathType.caster && _pathType.validators.length === 0) {
            paths.delete(path);
        } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && // Skip document arrays...
        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays
        _pathType.validators.length === 0 && // and arrays with top-level validators
        _pathType.$embeddedSchemaType.validators.length === 0) {
            paths.delete(path);
        }
    }
    // from here on we're not removing items from paths
    // gh-661: if a whole array is modified, make sure to run validation on all
    // the children as well
    for (const path of paths){
        const _pathType = doc.$__schema.path(path);
        if (!_pathType) {
            continue;
        }
        if (!_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children
        // are not required. `getPositionalPathType()` may be slow, so avoid
        // it unless we have a case of #6364
        !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {
            continue;
        }
        // gh-11380: optimization. If the array isn't a document array and there's no validators
        // on the array type, there's no need to run validation on the individual array elements.
        if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && // Skip document arrays...
        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays
        _pathType.$embeddedSchemaType.validators.length === 0) {
            continue;
        }
        const val = doc.$__getValue(path);
        _pushNestedArrayPaths(val, paths, path);
    }
    function _pushNestedArrayPaths(val, paths, path) {
        if (val != null) {
            const numElements = val.length;
            for(let j = 0; j < numElements; ++j){
                if (Array.isArray(val[j])) {
                    _pushNestedArrayPaths(val[j], paths, path + "." + j);
                } else {
                    paths.add(path + "." + j);
                }
            }
        }
    }
    const flattenOptions = {
        skipArrays: true
    };
    for (const pathToCheck of paths){
        if (doc.$__schema.nested[pathToCheck]) {
            let _v = doc.$__getValue(pathToCheck);
            if (isMongooseObject(_v)) {
                _v = _v.toObject({
                    transform: false
                });
            }
            const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
            Object.keys(flat).forEach(addToPaths);
        }
    }
    for (const path of paths){
        // Single nested paths (paths embedded under single nested subdocs) will
        // be validated on their own when we call `validate()` on the subdoc itself.
        // Re: gh-8468
        if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {
            paths.delete(path);
            continue;
        }
        const _pathType = doc.$__schema.path(path);
        if (!_pathType || !_pathType.$isSchemaMap) {
            continue;
        }
        const val = doc.$__getValue(path);
        if (val == null) {
            continue;
        }
        for (const key of val.keys()){
            paths.add(path + "." + key);
        }
    }
    paths = Array.from(paths);
    return [
        paths,
        skipSchemaValidators
    ];
}
/*!
 * ignore
 */ Document.prototype.$__validate = function(pathsToValidate, options, callback) {
    if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
    const pathsToSkip = options && options.pathsToSkip || null;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    const _this = this;
    const _complete = ()=>{
        let validationError = this.$__.validationError;
        this.$__.validationError = null;
        this.$__.validating = null;
        if (shouldValidateModifiedOnly && validationError != null) {
            // Remove any validation errors that aren't from modified paths
            const errors = Object.keys(validationError.errors);
            for (const errPath of errors){
                if (!this.$isModified(errPath)) {
                    delete validationError.errors[errPath];
                }
            }
            if (Object.keys(validationError.errors).length === 0) {
                validationError = void 0;
            }
        }
        this.$__.cachedRequired = {};
        this.$emit("validate", _this);
        this.constructor.emit("validate", _this);
        if (validationError) {
            for(const key in validationError.errors){
                // Make sure cast errors persist
                if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
                    this.invalidate(key, validationError.errors[key]);
                }
            }
            return validationError;
        }
    };
    // only validate required fields when necessary
    const pathDetails = _getPathsToValidate(this);
    let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path)=>this.$isModified(path)) : pathDetails[0];
    const skipSchemaValidators = pathDetails[1];
    if (typeof pathsToValidate === "string") {
        pathsToValidate = pathsToValidate.split(" ");
    }
    if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
    } else if (pathsToSkip) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
    }
    if (paths.length === 0) {
        return immediate(function() {
            const error = _complete();
            if (error) {
                return _this.$__schema.s.hooks.execPost("validate:error", _this, [
                    _this
                ], {
                    error: error
                }, function(error) {
                    callback(error);
                });
            }
            callback(null, _this);
        });
    }
    const validated = {};
    let total = 0;
    for (const path of paths){
        validatePath(path);
    }
    function validatePath(path) {
        if (path == null || validated[path]) {
            return;
        }
        validated[path] = true;
        total++;
        immediate(function() {
            const schemaType = _this.$__schema.path(path);
            if (!schemaType) {
                return --total || complete();
            }
            // If user marked as invalid or there was a cast error, don't validate
            if (!_this.$isValid(path)) {
                --total || complete();
                return;
            }
            // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)
            if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
                return --total || complete();
            }
            let val = _this.$__getValue(path);
            // If you `populate()` and get back a null value, required validators
            // shouldn't fail (gh-8018). We should always fall back to the populated
            // value.
            let pop;
            if (pop = _this.$populated(path)) {
                val = pop;
            } else if (val != null && val.$__ != null && val.$__.wasPopulated) {
                // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,
                // so in that case pull out the document's id
                val = val._id;
            }
            const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;
            const doValidateOptions = {
                skipSchemaValidators: skipSchemaValidators[path],
                path: path,
                validateModifiedOnly: shouldValidateModifiedOnly
            };
            schemaType.doValidate(val, function(err) {
                if (err) {
                    const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;
                    if (isSubdoc && err instanceof ValidationError) {
                        return --total || complete();
                    }
                    _this.invalidate(path, err, undefined, true);
                }
                --total || complete();
            }, scope, doValidateOptions);
        });
    }
    function complete() {
        const error = _complete();
        if (error) {
            return _this.$__schema.s.hooks.execPost("validate:error", _this, [
                _this
            ], {
                error: error
            }, function(error) {
                callback(error);
            });
        }
        callback(null, _this);
    }
};
/*!
 * ignore
 */ function _handlePathsToValidate(paths, pathsToValidate) {
    const _pathsToValidate = new Set(pathsToValidate);
    const parentPaths = new Map([]);
    for (const path of pathsToValidate){
        if (path.indexOf(".") === -1) {
            continue;
        }
        const pieces = path.split(".");
        let cur = pieces[0];
        for(let i = 1; i < pieces.length; ++i){
            // Since we skip subpaths under single nested subdocs to
            // avoid double validation, we need to add back the
            // single nested subpath if the user asked for it (gh-8626)
            parentPaths.set(cur, path);
            cur = cur + "." + pieces[i];
        }
    }
    const ret = [];
    for (const path of paths){
        if (_pathsToValidate.has(path)) {
            ret.push(path);
        } else if (parentPaths.has(path)) {
            ret.push(parentPaths.get(path));
        }
    }
    return ret;
}
/*!
 * ignore
 */ function _handlePathsToSkip(paths, pathsToSkip) {
    pathsToSkip = new Set(pathsToSkip);
    paths = paths.filter((p)=>!pathsToSkip.has(p));
    return paths;
}
/**
 * Executes registered validation rules (skipping asynchronous validators) for this document.
 *
 * #### Note:
 *
 * This method is useful if you need synchronous validation.
 *
 * #### Example:
 *
 *     const err = doc.validateSync();
 *     if (err) {
 *       handleError(err);
 *     } else {
 *       // validation passed
 *     }
 *
 * @param {Array|string} [pathsToValidate] only validate the given paths
 * @param {Object} [options] options for validation
 * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.
 * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.
 * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.
 * @api public
 */ Document.prototype.validateSync = function(pathsToValidate, options) {
    const _this = this;
    if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    let pathsToSkip = options && options.pathsToSkip;
    if (typeof pathsToValidate === "string") {
        const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
        pathsToValidate = isOnePathOnly ? [
            pathsToValidate
        ] : pathsToValidate.split(" ");
    } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
        pathsToSkip = pathsToSkip.split(" ");
    }
    // only validate required fields when necessary
    const pathDetails = _getPathsToValidate(this);
    let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path)=>this.$isModified(path)) : pathDetails[0];
    const skipSchemaValidators = pathDetails[1];
    if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
    } else if (Array.isArray(pathsToSkip)) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
    }
    const validating = {};
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        if (validating[path]) {
            continue;
        }
        validating[path] = true;
        const p = _this.$__schema.path(path);
        if (!p) {
            continue;
        }
        if (!_this.$isValid(path)) {
            continue;
        }
        const val = _this.$__getValue(path);
        const err = p.doValidateSync(val, _this, {
            skipSchemaValidators: skipSchemaValidators[path],
            path: path,
            validateModifiedOnly: shouldValidateModifiedOnly
        });
        if (err) {
            const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;
            if (isSubdoc && err instanceof ValidationError) {
                continue;
            }
            _this.invalidate(path, err, undefined, true);
        }
    }
    const err = _this.$__.validationError;
    _this.$__.validationError = undefined;
    _this.$emit("validate", _this);
    _this.constructor.emit("validate", _this);
    if (err) {
        for(const key in err.errors){
            // Make sure cast errors persist
            if (err.errors[key] instanceof MongooseError.CastError) {
                _this.invalidate(key, err.errors[key]);
            }
        }
    }
    return err;
};
/**
 * Marks a path as invalid, causing validation to fail.
 *
 * The `errorMsg` argument will become the message of the `ValidationError`.
 *
 * The `value` argument (if passed) will be available through the `ValidationError.value` property.
 *
 *     doc.invalidate('size', 'must be less than 20', 14);
 *
 *     doc.validate(function (err) {
 *       console.log(err)
 *       // prints
 *       { message: 'Validation failed',
 *         name: 'ValidationError',
 *         errors:
 *          { size:
 *             { message: 'must be less than 20',
 *               name: 'ValidatorError',
 *               path: 'size',
 *               type: 'user defined',
 *               value: 14 } } }
 *     })
 *
 * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.
 * @param {String|Error} err the error which states the reason `path` was invalid
 * @param {Object|String|Number|any} val optional invalid value
 * @param {String} [kind] optional `kind` property for the error
 * @return {ValidationError} the current ValidationError, with all currently invalidated paths
 * @api public
 */ Document.prototype.invalidate = function(path, err, val, kind) {
    if (!this.$__.validationError) {
        this.$__.validationError = new ValidationError(this);
    }
    if (this.$__.validationError.errors[path]) {
        return;
    }
    if (!err || typeof err === "string") {
        err = new ValidatorError({
            path: path,
            message: err,
            type: kind || "user defined",
            value: val
        });
    }
    if (this.$__.validationError === err) {
        return this.$__.validationError;
    }
    this.$__.validationError.addError(path, err);
    return this.$__.validationError;
};
/**
 * Marks a path as valid, removing existing validation errors.
 *
 * @param {String} path the field to mark as valid
 * @api public
 * @memberOf Document
 * @instance
 * @method $markValid
 */ Document.prototype.$markValid = function(path) {
    if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
        return;
    }
    delete this.$__.validationError.errors[path];
    if (Object.keys(this.$__.validationError.errors).length === 0) {
        this.$__.validationError = null;
    }
};
/*!
 * ignore
 */ function _markValidSubpaths(doc, path) {
    if (!doc.$__.validationError) {
        return;
    }
    const keys = Object.keys(doc.$__.validationError.errors);
    for (const key of keys){
        if (key.startsWith(path + ".")) {
            delete doc.$__.validationError.errors[key];
        }
    }
    if (Object.keys(doc.$__.validationError.errors).length === 0) {
        doc.$__.validationError = null;
    }
}
/*!
 * ignore
 */ function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
    const schema = schematype.schema;
    if (schema == null) {
        return;
    }
    for (const key of Object.keys(schema.paths)){
        const path = schema.paths[key];
        if (path.$immutableSetter == null) {
            continue;
        }
        const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);
        // Calling immutableSetter with `oldVal` even though it expects `newVal`
        // is intentional. That's because `$immutableSetter` compares its param
        // to the current value.
        path.$immutableSetter.call(subdoc, oldVal);
    }
}
/**
 * Saves this document by inserting a new document into the database if [document.isNew](/docs/api/document.html#document_Document-isNew) is `true`,
 * or sends an [updateOne](/docs/api/document.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.
 *
 * #### Example:
 *
 *     product.sold = Date.now();
 *     product = await product.save();
 *
 * If save is successful, the returned promise will fulfill with the document
 * saved.
 *
 * #### Example:
 *
 *     const newProduct = await product.save();
 *     newProduct === product; // true
 *
 * @param {Object} [options] options optional options
 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api/document.html#document_Document-$session).
 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.
 * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.
 * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.
 * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)
 * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).
 * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)
 * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.
 * @param {Function} [fn] optional callback
 * @method save
 * @memberOf Document
 * @instance
 * @throws {DocumentNotFoundError} if this [save updates an existing document](api/document.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).
 * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.
 * @api public
 * @see middleware https://mongoosejs.com/docs/middleware.html
 */ /**
 * Checks if a path is invalid
 *
 * @param {String|String[]} [path] the field to check. If unset will always return "false"
 * @method $isValid
 * @memberOf Document
 * @instance
 * @api private
 */ Document.prototype.$isValid = function(path) {
    if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
        return true;
    }
    if (path == null) {
        return false;
    }
    if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
    }
    if (Array.isArray(path)) {
        return path.some((p)=>this.$__.validationError.errors[p] == null);
    }
    return this.$__.validationError.errors[path] == null;
};
/**
 * Resets the internal modified state of this document.
 *
 * @api private
 * @return {Document} this
 * @method $__reset
 * @memberOf Document
 * @instance
 */ Document.prototype.$__reset = function reset() {
    let _this = this;
    // Skip for subdocuments
    const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];
    const resetArrays = new Set();
    for (const subdoc of subdocs){
        const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();
        if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {
            subdoc.$__reset();
            if (subdoc.$isDocumentArrayElement) {
                if (!resetArrays.has(subdoc.parentArray())) {
                    const array = subdoc.parentArray();
                    this.$__.activePaths.clearPath(fullPathWithIndexes.replace(/\.\d+$/, "").slice(-subdoc.$basePath - 1));
                    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
                    array[arrayAtomicsSymbol] = {};
                    resetArrays.add(array);
                }
            } else {
                if (subdoc.$parent() === this) {
                    this.$__.activePaths.clearPath(subdoc.$basePath);
                } else if (subdoc.$parent() != null && subdoc.$parent().$isSubdocument) {
                    // If map path underneath subdocument, may end up with a case where
                    // map path is modified but parent still needs to be reset. See gh-10295
                    subdoc.$parent().$__reset();
                }
            }
        }
    }
    function isParentInit(path) {
        path = path.indexOf(".") === -1 ? [
            path
        ] : path.split(".");
        let cur = "";
        for(let i = 0; i < path.length; ++i){
            cur += (cur.length ? "." : "") + path[i];
            if (_this.$__.activePaths[cur] === "init") {
                return true;
            }
        }
        return false;
    }
    // clear atomics
    this.$__dirty().forEach(function(dirt) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol]) {
            type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
            type[arrayAtomicsSymbol] = {};
        }
    });
    this.$__.backup = {};
    this.$__.backup.activePaths = {
        modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")),
        default: Object.assign({}, this.$__.activePaths.getStatePaths("default"))
    };
    this.$__.backup.validationError = this.$__.validationError;
    this.$__.backup.errors = this.$errors;
    // Clear 'dirty' cache
    this.$__.activePaths.clear("modify");
    this.$__.activePaths.clear("default");
    this.$__.validationError = undefined;
    this.$errors = undefined;
    _this = this;
    this.$__schema.requiredPaths().forEach(function(path) {
        _this.$__.activePaths.require(path);
    });
    return this;
};
/*!
 * ignore
 */ Document.prototype.$__undoReset = function $__undoReset() {
    if (this.$__.backup == null || this.$__.backup.activePaths == null) {
        return;
    }
    this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
    this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
    this.$__.validationError = this.$__.backup.validationError;
    this.$errors = this.$__.backup.errors;
    for (const dirt of this.$__dirty()){
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
            type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
        }
    }
    for (const subdoc of this.$getAllSubdocs()){
        subdoc.$__undoReset();
    }
};
/**
 * Returns this documents dirty paths / vals.
 *
 * @return {Array}
 * @api private
 * @method $__dirty
 * @memberOf Document
 * @instance
 */ Document.prototype.$__dirty = function() {
    const _this = this;
    let all = this.$__.activePaths.map("modify", function(path) {
        return {
            path: path,
            value: _this.$__getValue(path),
            schema: _this.$__path(path)
        };
    });
    // gh-2558: if we had to set a default and the value is not undefined,
    // we have to save as well
    all = all.concat(this.$__.activePaths.map("default", function(path) {
        if (path === "_id" || _this.$__getValue(path) == null) {
            return;
        }
        return {
            path: path,
            value: _this.$__getValue(path),
            schema: _this.$__path(path)
        };
    }));
    const allPaths = new Map(all.filter((el)=>el != null).map((el)=>[
            el.path,
            el.value
        ]));
    // Ignore "foo.a" if "foo" is dirty already.
    const minimal = [];
    all.forEach(function(item) {
        if (!item) {
            return;
        }
        let top = null;
        const array = parentPaths(item.path);
        for(let i = 0; i < array.length - 1; i++){
            if (allPaths.has(array[i])) {
                top = allPaths.get(array[i]);
                break;
            }
        }
        if (top == null) {
            minimal.push(item);
        } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {
            // special case for top level MongooseArrays
            // the `top` array itself and a sub path of `top` are being set.
            // the only way to honor all of both modifications is through a $set
            // of entire array.
            top[arrayAtomicsSymbol] = {};
            top[arrayAtomicsSymbol].$set = top;
        }
    });
    return minimal;
};
/**
 * Assigns/compiles `schema` into this documents prototype.
 *
 * @param {Schema} schema
 * @api private
 * @method $__setSchema
 * @memberOf Document
 * @instance
 */ Document.prototype.$__setSchema = function(schema) {
    compile(schema.tree, this, undefined, schema.options);
    // Apply default getters if virtual doesn't have any (gh-6262)
    for (const key of Object.keys(schema.virtuals)){
        schema.virtuals[key]._applyDefaultGetters();
    }
    if (schema.path("schema") == null) {
        this.schema = schema;
    }
    this.$__schema = schema;
    this[documentSchemaSymbol] = schema;
};
/**
 * Get active path that were changed and are arrays
 *
 * @return {Array}
 * @api private
 * @method $__getArrayPathsToValidate
 * @memberOf Document
 * @instance
 */ Document.prototype.$__getArrayPathsToValidate = function() {
    DocumentArray || (DocumentArray = __webpack_require__(90102));
    // validate all document arrays.
    return this.$__.activePaths.map("init", "modify", (function(i) {
        return this.$__getValue(i);
    }).bind(this)).filter(function(val) {
        return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;
    }).reduce(function(seed, array) {
        return seed.concat(array);
    }, []).filter(function(doc) {
        return doc;
    });
};
/**
 * Get all subdocs (by bfs)
 *
 * @return {Array}
 * @api public
 * @method $getAllSubdocs
 * @memberOf Document
 * @instance
 */ Document.prototype.$getAllSubdocs = function() {
    DocumentArray || (DocumentArray = __webpack_require__(90102));
    Embedded = Embedded || __webpack_require__(46829);
    function docReducer(doc, seed, path) {
        let val = doc;
        let isNested = false;
        if (path) {
            if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
                val = doc._doc[path];
            } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {
                val = doc._doc[path];
                isNested = true;
            } else {
                val = doc[path];
            }
        }
        if (val instanceof Embedded) {
            seed.push(val);
        } else if (val instanceof Map) {
            seed = Array.from(val.keys()).reduce(function(seed, path) {
                return docReducer(val.get(path), seed, null);
            }, seed);
        } else if (val && !Array.isArray(val) && val.$isSingleNested) {
            seed = Object.keys(val._doc).reduce(function(seed, path) {
                return docReducer(val, seed, path);
            }, seed);
            seed.push(val);
        } else if (val && utils.isMongooseDocumentArray(val)) {
            val.forEach(function _docReduce(doc) {
                if (!doc || !doc._doc) {
                    return;
                }
                seed = Object.keys(doc._doc).reduce(function(seed, path) {
                    return docReducer(doc._doc, seed, path);
                }, seed);
                if (doc instanceof Embedded) {
                    seed.push(doc);
                }
            });
        } else if (isNested && val != null) {
            for (const path of Object.keys(val)){
                docReducer(val, seed, path);
            }
        }
        return seed;
    }
    const subDocs = [];
    for (const path of Object.keys(this._doc)){
        docReducer(this, subDocs, path);
    }
    return subDocs;
};
/*!
 * Runs queued functions
 */ function applyQueue(doc) {
    const q = doc.$__schema && doc.$__schema.callQueue;
    if (!q.length) {
        return;
    }
    for (const pair of q){
        if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
            doc[pair[0]].apply(doc, pair[1]);
        }
    }
}
/*!
 * ignore
 */ Document.prototype.$__handleReject = function handleReject(err) {
    // emit on the Model if listening
    if (this.$listeners("error").length) {
        this.$emit("error", err);
    } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
        this.constructor.emit("error", err);
    }
};
/**
 * Internal helper for toObject() and toJSON() that doesn't manipulate options
 *
 * @return {Object}
 * @api private
 * @method $toObject
 * @memberOf Document
 * @instance
 */ Document.prototype.$toObject = function(options, json) {
    let defaultOptions = {
        transform: true,
        flattenDecimals: true
    };
    const path = json ? "toJSON" : "toObject";
    const baseOptions = this.constructor && this.constructor.base && this.constructor.base.options && get(this.constructor.base.options, path) || {};
    const schemaOptions = this.$__schema && this.$__schema.options || {};
    // merge base default options with Schema's set default options if available.
    // `clone` is necessary here because `utils.options` directly modifies the second input.
    defaultOptions = utils.options(defaultOptions, clone(baseOptions));
    defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));
    // If options do not exist or is not an object, set it to empty object
    options = utils.isPOJO(options) ? {
        ...options
    } : {};
    options._calledWithOptions = options._calledWithOptions || {
        ...options
    };
    let _minimize;
    if (options._calledWithOptions.minimize != null) {
        _minimize = options.minimize;
    } else if (defaultOptions.minimize != null) {
        _minimize = defaultOptions.minimize;
    } else {
        _minimize = schemaOptions.minimize;
    }
    let flattenMaps;
    if (options._calledWithOptions.flattenMaps != null) {
        flattenMaps = options.flattenMaps;
    } else if (defaultOptions.flattenMaps != null) {
        flattenMaps = defaultOptions.flattenMaps;
    } else {
        flattenMaps = schemaOptions.flattenMaps;
    }
    // The original options that will be passed to `clone()`. Important because
    // `clone()` will recursively call `$toObject()` on embedded docs, so we
    // need the original options the user passed in, plus `_isNested` and
    // `_parentOptions` for checking whether we need to depopulate.
    const cloneOptions = Object.assign({}, options, {
        _isNested: true,
        json: json,
        minimize: _minimize,
        flattenMaps: flattenMaps,
        _seen: options && options._seen || new Map()
    });
    if (utils.hasUserDefinedProperty(options, "getters")) {
        cloneOptions.getters = options.getters;
    }
    if (utils.hasUserDefinedProperty(options, "virtuals")) {
        cloneOptions.virtuals = options.virtuals;
    }
    const depopulate = options.depopulate || options._parentOptions && options._parentOptions.depopulate || false;
    // _isNested will only be true if this is not the top level document, we
    // should never depopulate the top-level document
    if (depopulate && options._isNested && this.$__.wasPopulated) {
        return clone(this.$__.wasPopulated.value || this._id, cloneOptions);
    }
    // merge default options with input options.
    options = utils.options(defaultOptions, options);
    options._isNested = true;
    options.json = json;
    options.minimize = _minimize;
    cloneOptions._parentOptions = options;
    cloneOptions._skipSingleNestedGetters = false;
    const gettersOptions = Object.assign({}, cloneOptions);
    gettersOptions._skipSingleNestedGetters = true;
    // remember the root transform function
    // to save it from being overwritten by sub-transform functions
    const originalTransform = options.transform;
    let ret = clone(this._doc, cloneOptions) || {};
    if (options.getters) {
        applyGetters(this, ret, gettersOptions);
        if (options.minimize) {
            ret = minimize(ret) || {};
        }
    }
    if (options.virtuals || options.getters && options.virtuals !== false) {
        applyVirtuals(this, ret, gettersOptions, options);
    }
    if (options.versionKey === false && this.$__schema.options.versionKey) {
        delete ret[this.$__schema.options.versionKey];
    }
    let transform = options.transform;
    // In the case where a subdocument has its own transform function, we need to
    // check and see if the parent has a transform (options.transform) and if the
    // child schema has a transform (this.schema.options.toObject) In this case,
    // we need to adjust options.transform to be the child schema's transform and
    // not the parent schema's
    if (transform) {
        applySchemaTypeTransforms(this, ret);
    }
    if (options.useProjection) {
        omitDeselectedFields(this, ret);
    }
    if (transform === true || schemaOptions.toObject && transform) {
        const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;
        if (opts) {
            transform = typeof options.transform === "function" ? options.transform : opts.transform;
        }
    } else {
        options.transform = originalTransform;
    }
    if (typeof transform === "function") {
        const xformed = transform(this, ret, options);
        if (typeof xformed !== "undefined") {
            ret = xformed;
        }
    }
    return ret;
};
/**
 * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).
 *
 * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.
 *
 * #### Getters/Virtuals
 *
 * Example of only applying path getters
 *
 *     doc.toObject({ getters: true, virtuals: false })
 *
 * Example of only applying virtual getters
 *
 *     doc.toObject({ virtuals: true })
 *
 * Example of applying both path and virtual getters
 *
 *     doc.toObject({ getters: true })
 *
 * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.
 *
 *     schema.set('toObject', { virtuals: true })
 *
 * #### Transform:
 *
 * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.
 *
 * Transform functions receive three arguments
 *
 *     function (doc, ret, options) {}
 *
 * - `doc` The mongoose document which is being converted
 * - `ret` The plain object representation which has been converted
 * - `options` The options in use (either schema options or the options passed inline)
 *
 * #### Example:
 *
 *     // specify the transform schema option
 *     if (!schema.options.toObject) schema.options.toObject = {};
 *     schema.options.toObject.transform = function (doc, ret, options) {
 *       // remove the _id of every document before returning the result
 *       delete ret._id;
 *       return ret;
 *     }
 *
 *     // without the transformation in the schema
 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
 *
 *     // with the transformation
 *     doc.toObject(); // { name: 'Wreck-it Ralph' }
 *
 * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:
 *
 *     if (!schema.options.toObject) schema.options.toObject = {};
 *     schema.options.toObject.transform = function (doc, ret, options) {
 *       return { movie: ret.name }
 *     }
 *
 *     // without the transformation in the schema
 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
 *
 *     // with the transformation
 *     doc.toObject(); // { movie: 'Wreck-it Ralph' }
 *
 * _Note: if a transform function returns `undefined`, the return value will be ignored._
 *
 * Transformations may also be applied inline, overridding any transform set in the options:
 *
 *     function xform (doc, ret, options) {
 *       return { inline: ret.name, custom: true }
 *     }
 *
 *     // pass the transform as an inline option
 *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }
 *
 * If you want to skip transformations, use `transform: false`:
 *
 *     schema.options.toObject.hide = '_id';
 *     schema.options.toObject.transform = function (doc, ret, options) {
 *       if (options.hide) {
 *         options.hide.split(' ').forEach(function (prop) {
 *           delete ret[prop];
 *         });
 *       }
 *       return ret;
 *     }
 *
 *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });
 *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }
 *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }
 *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }
 *
 * If you pass a transform in `toObject()` options, Mongoose will apply the transform
 * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.
 * Similarly, `transform: false` skips transforms for all subdocuments.
 * Note that this behavior is different for transforms defined in the schema:
 * if you define a transform in `schema.options.toObject.transform`, that transform
 * will **not** apply to subdocuments.
 *
 *     const memberSchema = new Schema({ name: String, email: String });
 *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });
 *     const Group = mongoose.model('Group', groupSchema);
 *
 *     const doc = new Group({
 *       name: 'Engineering',
 *       email: 'dev@mongoosejs.io',
 *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]
 *     });
 *
 *     // Removes `email` from both top-level document **and** array elements
 *     // { name: 'Engineering', members: [{ name: 'Val' }] }
 *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });
 *
 * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.
 *
 * See [schema options](/docs/guide.html#toObject) for some more details.
 *
 * _During save, no custom options are applied to the document before being sent to the database._
 *
 * @param {Object} [options]
 * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals
 * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals
 * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.
 * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output
 * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object
 * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.
 * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output
 * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.
 * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.
 * @return {Object} js object (not a POJO)
 * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.toObject = function(options) {
    return this.$toObject(options);
};
/**
 * Minimizes an object, removing undefined values and empty objects
 *
 * @param {Object} object to minimize
 * @return {Object}
 * @api private
 */ function minimize(obj) {
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys;
    let key;
    let val;
    while(i--){
        key = keys[i];
        val = obj[key];
        if (utils.isPOJO(val)) {
            obj[key] = minimize(val);
        }
        if (undefined === obj[key]) {
            delete obj[key];
            continue;
        }
        hasKeys = true;
    }
    return hasKeys ? obj : undefined;
}
/*!
 * Applies virtuals properties to `json`.
 */ function applyVirtuals(self, json, options, toObjectOptions) {
    const schema = self.$__schema;
    const paths = Object.keys(schema.virtuals);
    let i = paths.length;
    const numPaths = i;
    let path;
    let assignPath;
    let cur = self._doc;
    let v;
    const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === "boolean" ? toObjectOptions.aliases : true;
    let virtualsToApply = null;
    if (Array.isArray(options.virtuals)) {
        virtualsToApply = new Set(options.virtuals);
    } else if (options.virtuals && options.virtuals.pathsToSkip) {
        virtualsToApply = new Set(paths);
        for(let i = 0; i < options.virtuals.pathsToSkip.length; i++){
            if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {
                virtualsToApply.delete(options.virtuals.pathsToSkip[i]);
            }
        }
    }
    if (!cur) {
        return json;
    }
    options = options || {};
    for(i = 0; i < numPaths; ++i){
        path = paths[i];
        if (virtualsToApply != null && !virtualsToApply.has(path)) {
            continue;
        }
        // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`
        if (!aliases && schema.aliases.hasOwnProperty(path)) {
            continue;
        }
        // We may be applying virtuals to a nested object, for example if calling
        // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,
        // will be a trailing substring of the `path`.
        assignPath = path;
        if (options.path != null) {
            if (!path.startsWith(options.path + ".")) {
                continue;
            }
            assignPath = path.substring(options.path.length + 1);
        }
        const parts = assignPath.split(".");
        v = clone(self.get(path), options);
        if (v === void 0) {
            continue;
        }
        const plen = parts.length;
        cur = json;
        for(let j = 0; j < plen - 1; ++j){
            cur[parts[j]] = cur[parts[j]] || {};
            cur = cur[parts[j]];
        }
        cur[parts[plen - 1]] = v;
    }
    return json;
}
/**
 * Applies virtuals properties to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @param {Object} [options]
 * @return {Object} `json`
 * @api private
 */ function applyGetters(self, json, options) {
    const schema = self.$__schema;
    const paths = Object.keys(schema.paths);
    let i = paths.length;
    let path;
    let cur = self._doc;
    let v;
    if (!cur) {
        return json;
    }
    while(i--){
        path = paths[i];
        const parts = path.split(".");
        const plen = parts.length;
        const last = plen - 1;
        let branch = json;
        let part;
        cur = self._doc;
        if (!self.$__isSelected(path)) {
            continue;
        }
        for(let ii = 0; ii < plen; ++ii){
            part = parts[ii];
            v = cur[part];
            if (ii === last) {
                const val = self.$get(path);
                branch[part] = clone(val, options);
            } else if (v == null) {
                if (part in cur) {
                    branch[part] = v;
                }
                break;
            } else {
                branch = branch[part] || (branch[part] = {});
            }
            cur = v;
        }
    }
    return json;
}
/**
 * Applies schema type transforms to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
 * @api private
 */ function applySchemaTypeTransforms(self, json) {
    const schema = self.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self._doc;
    if (!cur) {
        return json;
    }
    for (const path of paths){
        const schematype = schema.paths[path];
        if (typeof schematype.options.transform === "function") {
            const val = self.$get(path);
            if (val === undefined) {
                continue;
            }
            const transformedValue = schematype.options.transform.call(self, val);
            throwErrorIfPromise(path, transformedValue);
            utils.setValue(path, transformedValue, json);
        } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === "function") {
            const val = self.$get(path);
            if (val === undefined) {
                continue;
            }
            const vals = [].concat(val);
            const transform = schematype.$embeddedSchemaType.options.transform;
            for(let i = 0; i < vals.length; ++i){
                const transformedValue = transform.call(self, vals[i]);
                vals[i] = transformedValue;
                throwErrorIfPromise(path, transformedValue);
            }
            json[path] = vals;
        }
    }
    return json;
}
function throwErrorIfPromise(path, transformedValue) {
    if (isPromise(transformedValue)) {
        throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
    }
}
/*!
 * ignore
 */ function omitDeselectedFields(self, json) {
    const schema = self.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self._doc;
    if (!cur) {
        return json;
    }
    let selected = self.$__.selected;
    if (selected === void 0) {
        selected = {};
        queryhelpers.applyPaths(selected, schema);
    }
    if (selected == null || Object.keys(selected).length === 0) {
        return json;
    }
    for (const path of paths){
        if (selected[path] != null && !selected[path]) {
            delete json[path];
        }
    }
    return json;
}
/**
 * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).
 *
 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
 *
 *     schema.set('toJSON', { virtuals: true });
 *
 * There is one difference between `toJSON()` and `toObject()` options.
 * When you call `toJSON()`, the [`flattenMaps` option](./document.html#document_Document-toObject) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.
 * When you call `toObject()`, the `flattenMaps` option is `false` by default.
 *
 * See [schema options](/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.
 *
 * @param {Object} options
 * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.
 * @return {Object}
 * @see Document#toObject #document_Document-toObject
 * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.toJSON = function(options) {
    return this.$toObject(options, true);
};
Document.prototype.ownerDocument = function() {
    return this;
};
/**
 * If this document is a subdocument or populated document, returns the document's
 * parent. Returns the original document if there is no parent.
 *
 * @return {Document}
 * @api public
 * @method parent
 * @memberOf Document
 * @instance
 */ Document.prototype.parent = function() {
    if (this.$isSubdocument || this.$__.wasPopulated) {
        return this.$__.parent;
    }
    return this;
};
/**
 * Alias for [`parent()`](#document_Document-parent). If this document is a subdocument or populated
 * document, returns the document's parent. Returns `undefined` otherwise.
 *
 * @return {Document}
 * @api public
 * @method $parent
 * @memberOf Document
 * @instance
 */ Document.prototype.$parent = Document.prototype.parent;
/**
 * Helper for console.log
 *
 * @return {String}
 * @api public
 * @method inspect
 * @memberOf Document
 * @instance
 */ Document.prototype.inspect = function(options) {
    const isPOJO = utils.isPOJO(options);
    let opts;
    if (isPOJO) {
        opts = options;
        opts.minimize = false;
    }
    const ret = this.toObject(opts);
    if (ret == null) {
        // If `toObject()` returns null, `this` is still an object, so if `inspect()`
        // prints out null this can cause some serious confusion. See gh-7942.
        return "MongooseDocument { " + ret + " }";
    }
    return ret;
};
if (inspect.custom) {
    // Avoid Node deprecation warning DEP0079
    Document.prototype[inspect.custom] = Document.prototype.inspect;
}
/**
 * Helper for console.log
 *
 * @return {String}
 * @api public
 * @method toString
 * @memberOf Document
 * @instance
 */ Document.prototype.toString = function() {
    const ret = this.inspect();
    if (typeof ret === "string") {
        return ret;
    }
    return inspect(ret);
};
/**
 * Returns true if this document is equal to another document.
 *
 * Documents are considered equal when they have matching `_id`s, unless neither
 * document has an `_id`, in which case this function falls back to using
 * `deepEqual()`.
 *
 * @param {Document} [doc] a document to compare. If falsy, will always return "false".
 * @return {Boolean}
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.equals = function(doc) {
    if (!doc) {
        return false;
    }
    const tid = this.$__getValue("_id");
    const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
    if (!tid && !docid) {
        return deepEqual(this, doc);
    }
    return tid && tid.equals ? tid.equals(docid) : tid === docid;
};
/**
 * Populates paths on an existing document.
 *
 * #### Example:
 *
 *     // Given a document, `populate()` lets you pull in referenced docs
 *     await doc.populate([
 *       'stories',
 *       { path: 'fans', sort: { name: -1 } }
 *     ]);
 *     doc.populated('stories'); // Array of ObjectIds
 *     doc.stories[0].title; // 'Casino Royale'
 *     doc.populated('fans'); // Array of ObjectIds
 *
 *     // If the referenced doc has been deleted, `populate()` will
 *     // remove that entry from the array.
 *     await Story.delete({ title: 'Casino Royale' });
 *     await doc.populate('stories'); // Empty array
 *
 *     // You can also pass additional query options to `populate()`,
 *     // like projections:
 *     await doc.populate('fans', '-email');
 *     doc.fans[0].email // undefined because of 2nd param `select`
 *
 * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those
 * @param {Object|String} [select] Field selection for the population query
 * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
 * @param {Object} [match] Conditions for the population query
 * @param {Object} [options] Options for the population query (sort, etc)
 * @param {String} [options.path=null] The path to populate.
 * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).
 * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.
 * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).
 * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.
 * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.
 * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.
 * @param {Object} [options.options=null] Additional options like `limit` and `lean`.
 * @param {Function} [callback] Callback
 * @see population /docs/populate
 * @see Query#select #query_Query-select
 * @see Model.populate #model_Model-populate
 * @memberOf Document
 * @instance
 * @return {Promise|null} Returns a Promise if no `callback` is given.
 * @api public
 */ Document.prototype.populate = function populate() {
    const pop = {};
    const args = [
        ...arguments
    ];
    let fn;
    if (args.length !== 0) {
        if (typeof args[args.length - 1] === "function") {
            fn = args.pop();
        }
        // use hash to remove duplicate paths
        const res = utils.populate.apply(null, args);
        for (const populateOptions of res){
            pop[populateOptions.path] = populateOptions;
        }
    }
    const paths = utils.object.vals(pop);
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
        topLevelModel = this.$__[scopeSymbol].constructor;
        const nestedPath = this.$__.nestedPath;
        paths.forEach(function(populateOptions) {
            populateOptions.path = nestedPath + "." + populateOptions.path;
        });
    }
    // Use `$session()` by default if the document has an associated session
    // See gh-6754
    if (this.$session() != null) {
        const session = this.$session();
        paths.forEach((path)=>{
            if (path.options == null) {
                path.options = {
                    session: session
                };
                return;
            }
            if (!("session" in path.options)) {
                path.options.session = session;
            }
        });
    }
    paths.forEach((p)=>{
        p._localModel = topLevelModel;
    });
    return topLevelModel.populate(this, paths, fn);
};
/**
 * Gets all populated documents associated with this document.
 *
 * @api public
 * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.
 * @memberOf Document
 * @method $getPopulatedDocs
 * @instance
 */ Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
    let keys = [];
    if (this.$__.populated != null) {
        keys = keys.concat(Object.keys(this.$__.populated));
    }
    let result = [];
    for (const key of keys){
        const value = this.$get(key);
        if (Array.isArray(value)) {
            result = result.concat(value);
        } else if (value instanceof Document) {
            result.push(value);
        }
    }
    return result;
};
/**
 * Gets _id(s) used during population of the given `path`.
 *
 * #### Example:
 *
 *     const doc = await Model.findOne().populate('author');
 *
 *     console.log(doc.author.name); // Dr.Seuss
 *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'
 *
 * If the path was not populated, returns `undefined`.
 *
 * @param {String} path
 * @param {Any} [val]
 * @param {Object} [options]
 * @return {Array|ObjectId|Number|Buffer|String|undefined}
 * @memberOf Document
 * @instance
 * @api public
 */ Document.prototype.populated = function(path, val, options) {
    // val and options are internal
    if (val == null || val === true) {
        if (!this.$__.populated) {
            return undefined;
        }
        if (typeof path !== "string") {
            return undefined;
        }
        // Map paths can be populated with either `path.$*` or just `path`
        const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
        const v = this.$__.populated[_path];
        if (v) {
            return val === true ? v : v.value;
        }
        return undefined;
    }
    this.$__.populated || (this.$__.populated = {});
    this.$__.populated[path] = {
        value: val,
        options: options
    };
    // If this was a nested populate, make sure each populated doc knows
    // about its populated children (gh-7685)
    const pieces = path.split(".");
    for(let i = 0; i < pieces.length - 1; ++i){
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.$get(subpath);
        if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {
            const rest = pieces.slice(i + 1).join(".");
            subdoc.$populated(rest, val, options);
            break;
        }
    }
    return val;
};
/**
 * Alias of [`.populated`](#document_Document-populated).
 *
 * @method $populated
 * @memberOf Document
 * @api public
 */ Document.prototype.$populated = Document.prototype.populated;
/**
 * Throws an error if a given path is not populated
 *
 * #### Example:
 *
 *     const doc = await Model.findOne().populate('author');
 *
 *     doc.$assertPopulated('author'); // does not throw
 *     doc.$assertPopulated('other path'); // throws an error
 *
 *     // Manually populate and assert in one call. The following does
 *     // `doc.$set({ likes })` before asserting.
 *     doc.$assertPopulated('likes', { likes });
 *
 *
 * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.
 * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.
 * @return {Document} this
 * @memberOf Document
 * @method $assertPopulated
 * @instance
 * @api public
 */ Document.prototype.$assertPopulated = function $assertPopulated(path, values) {
    if (Array.isArray(path)) {
        path.forEach((p)=>this.$assertPopulated(p, values));
        return this;
    }
    if (arguments.length > 1) {
        this.$set(values);
    }
    if (!this.$populated(path)) {
        throw new MongooseError(`Expected path "${path}" to be populated`);
    }
    return this;
};
/**
 * Takes a populated field and returns it to its unpopulated state.
 *
 * #### Example:
 *
 *     Model.findOne().populate('author').exec(function (err, doc) {
 *       console.log(doc.author.name); // Dr.Seuss
 *       console.log(doc.depopulate('author'));
 *       console.log(doc.author); // '5144cf8050f071d979c118a7'
 *     })
 *
 * If the path was not provided, then all populated fields are returned to their unpopulated state.
 *
 * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.
 * @return {Document} this
 * @see Document.populate #document_Document-populate
 * @api public
 * @memberOf Document
 * @instance
 */ Document.prototype.depopulate = function(path) {
    if (typeof path === "string") {
        path = path.indexOf(" ") === -1 ? [
            path
        ] : path.split(" ");
    }
    let populatedIds;
    const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
    const populated = this.$__ && this.$__.populated || {};
    if (arguments.length === 0) {
        // Depopulate all
        for (const virtualKey of virtualKeys){
            delete this.$$populatedVirtuals[virtualKey];
            delete this._doc[virtualKey];
            delete populated[virtualKey];
        }
        const keys = Object.keys(populated);
        for (const key of keys){
            populatedIds = this.$populated(key);
            if (!populatedIds) {
                continue;
            }
            delete populated[key];
            utils.setValue(key, populatedIds, this._doc);
        }
        return this;
    }
    for (const singlePath of path){
        populatedIds = this.$populated(singlePath);
        delete populated[singlePath];
        if (virtualKeys.indexOf(singlePath) !== -1) {
            delete this.$$populatedVirtuals[singlePath];
            delete this._doc[singlePath];
        } else if (populatedIds) {
            utils.setValue(singlePath, populatedIds, this._doc);
        }
    }
    return this;
};
/**
 * Returns the full path to this document.
 *
 * @param {String} [path]
 * @return {String}
 * @api private
 * @method $__fullPath
 * @memberOf Document
 * @instance
 */ Document.prototype.$__fullPath = function(path) {
    // overridden in SubDocuments
    return path || "";
};
/**
 * Returns the changes that happened to the document
 * in the format that will be sent to MongoDB.
 *
 * #### Example:
 *
 *     const userSchema = new Schema({
 *       name: String,
 *       age: Number,
 *       country: String
 *     });
 *     const User = mongoose.model('User', userSchema);
 *     const user = await User.create({
 *       name: 'Hafez',
 *       age: 25,
 *       country: 'Egypt'
 *     });
 *
 *     // returns an empty object, no changes happened yet
 *     user.getChanges(); // { }
 *
 *     user.country = undefined;
 *     user.age = 26;
 *
 *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }
 *
 *     await user.save();
 *
 *     user.getChanges(); // { }
 *
 * Modifying the object that `getChanges()` returns does not affect the document's
 * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose
 * will still send a `$set` to the server.
 *
 * @return {Object}
 * @api public
 * @method getChanges
 * @memberOf Document
 * @instance
 */ Document.prototype.getChanges = function() {
    const delta = this.$__delta();
    const changes = delta ? delta[1] : {};
    return changes;
};
/**
 * Returns a copy of this document with a deep clone of `_doc` and `$__`.
 *
 * @return {Document} a copy of this document
 * @api public
 * @method $clone
 * @memberOf Document
 * @instance
 */ Document.prototype.$clone = function() {
    const Model = this.constructor;
    const clonedDoc = new Model();
    clonedDoc.$isNew = this.$isNew;
    if (this._doc) {
        clonedDoc._doc = clone(this._doc);
    }
    if (this.$__) {
        const Cache = this.$__.constructor;
        const clonedCache = new Cache();
        for (const key of Object.getOwnPropertyNames(this.$__)){
            if (key === "activePaths") {
                continue;
            }
            clonedCache[key] = clone(this.$__[key]);
        }
        Object.assign(clonedCache.activePaths, clone({
            ...this.$__.activePaths
        }));
        clonedDoc.$__ = clonedCache;
    }
    return clonedDoc;
};
/*!
 * Module exports.
 */ Document.ValidationError = ValidationError;
module.exports = exports = Document;


/***/ }),

/***/ 17660:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-env browser */ /*!
 * Module dependencies.
 */ const Document = __webpack_require__(14001);
const BrowserDocument = __webpack_require__(53279);
let isBrowser = false;
/**
 * Returns the Document constructor for the current context
 *
 * @api private
 */ module.exports = function() {
    if (isBrowser) {
        return BrowserDocument;
    }
    return Document;
};
/*!
 * ignore
 */ module.exports.setBrowser = function(flag) {
    isBrowser = flag;
};


/***/ }),

/***/ 67085:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ let driver = null;
module.exports.get = function() {
    return driver;
};
module.exports.set = function(v) {
    driver = v;
};


/***/ }),

/***/ 70343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const mongodb = __webpack_require__(38013);
const ReadPref = mongodb.ReadPreference;
/**
 * Converts arguments to ReadPrefs the driver
 * can understand.
 *
 * @param {String|Array} pref
 * @param {Array} [tags]
 */ module.exports = function readPref(pref, tags) {
    if (Array.isArray(pref)) {
        tags = pref[1];
        pref = pref[0];
    }
    if (pref instanceof ReadPref) {
        return pref;
    }
    switch(pref){
        case "p":
            pref = "primary";
            break;
        case "pp":
            pref = "primaryPreferred";
            break;
        case "s":
            pref = "secondary";
            break;
        case "sp":
            pref = "secondaryPreferred";
            break;
        case "n":
            pref = "nearest";
            break;
    }
    return new ReadPref(pref, tags);
};


/***/ }),

/***/ 93142:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const Binary = (__webpack_require__(38013).Binary);
module.exports = exports = Binary;


/***/ }),

/***/ 59398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseCollection = __webpack_require__(26331);
const MongooseError = __webpack_require__(51520);
const Collection = (__webpack_require__(38013).Collection);
const ObjectId = __webpack_require__(66893);
const getConstructorName = __webpack_require__(4065);
const stream = __webpack_require__(12781);
const util = __webpack_require__(73837);
/**
 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
 *
 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
 *
 * @inherits Collection
 * @api private
 */ function NativeCollection(name, conn, options) {
    this.collection = null;
    this.Promise = options.Promise || Promise;
    this.modelName = options.modelName;
    delete options.modelName;
    this._closed = false;
    MongooseCollection.apply(this, arguments);
}
/*!
 * Inherit from abstract Collection.
 */ Object.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);
/**
 * Called when the connection opens.
 *
 * @api private
 */ NativeCollection.prototype.onOpen = function() {
    this.collection = this.conn.db.collection(this.name);
    MongooseCollection.prototype.onOpen.call(this);
    return this.collection;
};
/**
 * Called when the connection closes
 *
 * @api private
 */ NativeCollection.prototype.onClose = function(force) {
    MongooseCollection.prototype.onClose.call(this, force);
};
/**
 * Helper to get the collection, in case `this.collection` isn't set yet.
 * May happen if `bufferCommands` is false and created the model when
 * Mongoose was disconnected.
 *
 * @api private
 */ NativeCollection.prototype._getCollection = function _getCollection() {
    if (this.collection) {
        return this.collection;
    }
    if (this.conn.db != null) {
        this.collection = this.conn.db.collection(this.name);
        return this.collection;
    }
    return null;
};
/*!
 * ignore
 */ const syncCollectionMethods = {
    watch: true,
    find: true,
    aggregate: true
};
/**
 * Copy the collection methods and make them subject to queues
 * @param {Number|String} I
 * @api private
 */ function iter(i) {
    NativeCollection.prototype[i] = function() {
        const collection = this._getCollection();
        const args = Array.from(arguments);
        const _this = this;
        const globalDebug = _this && _this.conn && _this.conn.base && _this.conn.base.options && _this.conn.base.options.debug;
        const connectionDebug = _this && _this.conn && _this.conn.options && _this.conn.options.debug;
        const debug = connectionDebug == null ? globalDebug : connectionDebug;
        const lastArg = arguments[arguments.length - 1];
        const opId = new ObjectId();
        // If user force closed, queueing will hang forever. See #5664
        if (this.conn.$wasForceClosed) {
            const error = new MongooseError("Connection was force closed");
            if (args.length > 0 && typeof args[args.length - 1] === "function") {
                args[args.length - 1](error);
                return;
            } else {
                throw error;
            }
        }
        let _args = args;
        let callback = null;
        if (this._shouldBufferCommands() && this.buffer) {
            if (syncCollectionMethods[i] && typeof lastArg !== "function") {
                throw new Error("Collection method " + i + " is synchronous");
            }
            this.conn.emit("buffer", {
                _id: opId,
                modelName: _this.modelName,
                collectionName: _this.name,
                method: i,
                args: args
            });
            let callback;
            let _args = args;
            let promise = null;
            let timeout = null;
            if (syncCollectionMethods[i]) {
                this.addQueue(()=>{
                    lastArg.call(this, null, this[i].apply(this, _args.slice(0, _args.length - 1)));
                }, []);
            } else if (typeof lastArg === "function") {
                callback = function collectionOperationCallback() {
                    if (timeout != null) {
                        clearTimeout(timeout);
                    }
                    return lastArg.apply(this, arguments);
                };
                _args = args.slice(0, args.length - 1).concat([
                    callback
                ]);
            } else {
                promise = new this.Promise((resolve, reject)=>{
                    callback = function collectionOperationCallback(err, res) {
                        if (timeout != null) {
                            clearTimeout(timeout);
                        }
                        if (err != null) {
                            return reject(err);
                        }
                        resolve(res);
                    };
                    _args = args.concat([
                        callback
                    ]);
                    this.addQueue(i, _args);
                });
            }
            const bufferTimeoutMS = this._getBufferTimeoutMS();
            timeout = setTimeout(()=>{
                const removed = this.removeQueue(i, _args);
                if (removed) {
                    const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
                    const err = new MongooseError(message);
                    this.conn.emit("buffer-end", {
                        _id: opId,
                        modelName: _this.modelName,
                        collectionName: _this.name,
                        method: i,
                        error: err
                    });
                    callback(err);
                }
            }, bufferTimeoutMS);
            if (!syncCollectionMethods[i] && typeof lastArg === "function") {
                this.addQueue(i, _args);
                return;
            }
            return promise;
        } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
            callback = function collectionOperationCallback(err, res) {
                if (err != null) {
                    _this.conn.emit("operation-end", {
                        _id: opId,
                        modelName: _this.modelName,
                        collectionName: _this.name,
                        method: i,
                        error: err
                    });
                } else {
                    _this.conn.emit("operation-end", {
                        _id: opId,
                        modelName: _this.modelName,
                        collectionName: _this.name,
                        method: i,
                        result: res
                    });
                }
                return lastArg.apply(this, arguments);
            };
            _args = args.slice(0, args.length - 1).concat([
                callback
            ]);
        }
        if (debug) {
            if (typeof debug === "function") {
                debug.apply(_this, [
                    _this.name,
                    i
                ].concat(args.slice(0, args.length - 1)));
            } else if (debug instanceof stream.Writable) {
                this.$printToStream(_this.name, i, args, debug);
            } else {
                const color = debug.color == null ? true : debug.color;
                const shell = debug.shell == null ? false : debug.shell;
                this.$print(_this.name, i, args, color, shell);
            }
        }
        this.conn.emit("operation-start", {
            _id: opId,
            modelName: _this.modelName,
            collectionName: this.name,
            method: i,
            params: _args
        });
        try {
            if (collection == null) {
                const message = "Cannot call `" + this.name + "." + i + "()` before initial connection " + "is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if " + "you have `bufferCommands = false`.";
                throw new MongooseError(message);
            }
            if (syncCollectionMethods[i] && typeof lastArg === "function") {
                return lastArg.call(this, null, collection[i].apply(collection, _args.slice(0, _args.length - 1)));
            }
            const ret = collection[i].apply(collection, _args);
            if (ret != null && typeof ret.then === "function") {
                return ret.then((res)=>{
                    this.conn.emit("operation-end", {
                        _id: opId,
                        modelName: this.modelName,
                        collectionName: this.name,
                        method: i,
                        result: res
                    });
                    return res;
                }, (err)=>{
                    this.conn.emit("operation-end", {
                        _id: opId,
                        modelName: this.modelName,
                        collectionName: this.name,
                        method: i,
                        error: err
                    });
                    throw err;
                });
            }
            return ret;
        } catch (error) {
            // Collection operation may throw because of max bson size, catch it here
            // See gh-3906
            if (typeof lastArg === "function") {
                return lastArg(error);
            } else {
                this.conn.emit("operation-end", {
                    _id: opId,
                    modelName: _this.modelName,
                    collectionName: this.name,
                    method: i,
                    error: error
                });
                throw error;
            }
        }
    };
}
for (const key of Object.getOwnPropertyNames(Collection.prototype)){
    // Janky hack to work around gh-3005 until we can get rid of the mongoose
    // collection abstraction
    const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
    // Skip properties with getters because they may throw errors (gh-8528)
    if (descriptor.get !== undefined) {
        continue;
    }
    if (typeof Collection.prototype[key] !== "function") {
        continue;
    }
    iter(key);
}
/**
 * Debug print helper
 *
 * @api public
 * @method $print
 */ NativeCollection.prototype.$print = function(name, i, args, color, shell) {
    const moduleName = color ? "\x1b[0;36mMongoose:\x1b[0m " : "Mongoose: ";
    const functionCall = [
        name,
        i
    ].join(".");
    const _args = [];
    for(let j = args.length - 1; j >= 0; --j){
        if (this.$format(args[j]) || _args.length) {
            _args.unshift(this.$format(args[j], color, shell));
        }
    }
    const params = "(" + _args.join(", ") + ")";
    console.info(moduleName + functionCall + params);
};
/**
 * Debug print helper
 *
 * @api public
 * @method $print
 */ NativeCollection.prototype.$printToStream = function(name, i, args, stream) {
    const functionCall = [
        name,
        i
    ].join(".");
    const _args = [];
    for(let j = args.length - 1; j >= 0; --j){
        if (this.$format(args[j]) || _args.length) {
            _args.unshift(this.$format(args[j]));
        }
    }
    const params = "(" + _args.join(", ") + ")";
    stream.write(functionCall + params, "utf8");
};
/**
 * Formatter for debug print args
 *
 * @api public
 * @method $format
 */ NativeCollection.prototype.$format = function(arg, color, shell) {
    const type = typeof arg;
    if (type === "function" || type === "undefined") return "";
    return format(arg, false, color, shell);
};
/**
 * Debug print helper
 * @param {Any} representation
 * @api private
 */ function inspectable(representation) {
    const ret = {
        inspect: function() {
            return representation;
        }
    };
    if (util.inspect.custom) {
        ret[util.inspect.custom] = ret.inspect;
    }
    return ret;
}
function map(o) {
    return format(o, true);
}
function formatObjectId(x, key) {
    x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
}
function formatDate(x, key, shell) {
    if (shell) {
        x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
    } else {
        x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
    }
}
function format(obj, sub, color, shell) {
    if (obj && typeof obj.toBSON === "function") {
        obj = obj.toBSON();
    }
    if (obj == null) {
        return obj;
    }
    const clone = __webpack_require__(99889);
    let x = clone(obj, {
        transform: false
    });
    const constructorName = getConstructorName(x);
    if (constructorName === "Binary") {
        x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
    } else if (constructorName === "ObjectID") {
        x = inspectable('ObjectId("' + x.toHexString() + '")');
    } else if (constructorName === "Date") {
        x = inspectable('new Date("' + x.toUTCString() + '")');
    } else if (constructorName === "Object") {
        const keys = Object.keys(x);
        const numKeys = keys.length;
        let key;
        for(let i = 0; i < numKeys; ++i){
            key = keys[i];
            if (x[key]) {
                let error;
                if (typeof x[key].toBSON === "function") {
                    try {
                        // `session.toBSON()` throws an error. This means we throw errors
                        // in debug mode when using transactions, see gh-6712. As a
                        // workaround, catch `toBSON()` errors, try to serialize without
                        // `toBSON()`, and rethrow if serialization still fails.
                        x[key] = x[key].toBSON();
                    } catch (_error) {
                        error = _error;
                    }
                }
                const _constructorName = getConstructorName(x[key]);
                if (_constructorName === "Binary") {
                    x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
                } else if (_constructorName === "Object") {
                    x[key] = format(x[key], true);
                } else if (_constructorName === "ObjectID") {
                    formatObjectId(x, key);
                } else if (_constructorName === "Date") {
                    formatDate(x, key, shell);
                } else if (_constructorName === "ClientSession") {
                    x[key] = inspectable('ClientSession("' + (x[key] && x[key].id && x[key].id.id && x[key].id.id.buffer || "").toString("hex") + '")');
                } else if (Array.isArray(x[key])) {
                    x[key] = x[key].map(map);
                } else if (error != null) {
                    // If there was an error with `toBSON()` and the object wasn't
                    // already converted to a string representation, rethrow it.
                    // Open to better ideas on how to handle this.
                    throw error;
                }
            }
        }
    }
    if (sub) {
        return x;
    }
    return util.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
}
/**
 * Retrieves information about this collections indexes.
 *
 * @param {Function} callback
 * @method getIndexes
 * @api public
 */ NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
/*!
 * Module exports.
 */ module.exports = NativeCollection;


/***/ }),

/***/ 47941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseConnection = __webpack_require__(63406);
const STATES = __webpack_require__(25840);
const immediate = __webpack_require__(96621);
const setTimeout = (__webpack_require__(29660)/* .setTimeout */ .i);
/**
 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.
 *
 * @inherits Connection
 * @api private
 */ function NativeConnection() {
    MongooseConnection.apply(this, arguments);
    this._listening = false;
}
/**
 * Expose the possible connection states.
 * @api public
 */ NativeConnection.STATES = STATES;
/*!
 * Inherits from Connection.
 */ Object.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);
/**
 * Switches to a different database using the same connection pool.
 *
 * Returns a new connection object, with the new db. If you set the `useCache`
 * option, `useDb()` will cache connections by `name`.
 *
 * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.
 *
 * @param {String} name The database name
 * @param {Object} [options]
 * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.
 * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.
 * @return {Connection} New Connection Object
 * @api public
 */ NativeConnection.prototype.useDb = function(name, options) {
    // Return immediately if cached
    options = options || {};
    if (options.useCache && this.relatedDbs[name]) {
        return this.relatedDbs[name];
    }
    // we have to manually copy all of the attributes...
    const newConn = new this.constructor();
    newConn.name = name;
    newConn.base = this.base;
    newConn.collections = {};
    newConn.models = {};
    newConn.replica = this.replica;
    newConn.config = Object.assign({}, this.config, newConn.config);
    newConn.name = this.name;
    newConn.options = this.options;
    newConn._readyState = this._readyState;
    newConn._closeCalled = this._closeCalled;
    newConn._hasOpened = this._hasOpened;
    newConn._listening = false;
    newConn._parent = this;
    newConn.host = this.host;
    newConn.port = this.port;
    newConn.user = this.user;
    newConn.pass = this.pass;
    // First, when we create another db object, we are not guaranteed to have a
    // db object to work with. So, in the case where we have a db object and it
    // is connected, we can just proceed with setting everything up. However, if
    // we do not have a db or the state is not connected, then we need to wait on
    // the 'open' event of the connection before doing the rest of the setup
    // the 'connected' event is the first time we'll have access to the db object
    const _this = this;
    newConn.client = _this.client;
    if (this.db && this._readyState === STATES.connected) {
        wireup();
    } else {
        this.once("connected", wireup);
    }
    function wireup() {
        newConn.client = _this.client;
        const _opts = {};
        if (options.hasOwnProperty("noListener")) {
            _opts.noListener = options.noListener;
        }
        newConn.db = _this.client.db(name, _opts);
        newConn.onOpen();
    }
    newConn.name = name;
    // push onto the otherDbs stack, this is used when state changes
    if (options.noListener !== true) {
        this.otherDbs.push(newConn);
    }
    newConn.otherDbs.push(this);
    // push onto the relatedDbs cache, this is used when state changes
    if (options && options.useCache) {
        this.relatedDbs[newConn.name] = newConn;
        newConn.relatedDbs = this.relatedDbs;
    }
    return newConn;
};
/**
 * Closes the connection
 *
 * @param {Boolean} [force]
 * @param {Function} [fn]
 * @return {Connection} this
 * @api private
 */ NativeConnection.prototype.doClose = function(force, fn) {
    if (this.client == null) {
        immediate(()=>fn());
        return this;
    }
    let skipCloseClient = false;
    if (force != null && typeof force === "object") {
        skipCloseClient = force.skipCloseClient;
        force = force.force;
    }
    if (skipCloseClient) {
        immediate(()=>fn());
        return this;
    }
    this.client.close(force, (err, res)=>{
        // Defer because the driver will wait at least 1ms before finishing closing
        // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.
        // If there's queued operations, you may still get some background work
        // after the callback is called.
        setTimeout(()=>fn(err, res), 1);
    });
    return this;
};
/*!
 * Module exports.
 */ module.exports = NativeConnection;


/***/ }),

/***/ 802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * ignore
 */ 
module.exports = __webpack_require__(38013).Decimal128;


/***/ }),

/***/ 26544:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module exports.
 */ 
exports.Binary = __webpack_require__(93142);
exports.Collection = __webpack_require__(59398);
exports.Decimal128 = __webpack_require__(802);
exports.ObjectId = __webpack_require__(66893);
exports.ReadPreference = __webpack_require__(70343);
exports.getConnection = ()=>__webpack_require__(47941);


/***/ }),

/***/ 66893:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
 * @constructor NodeMongoDbObjectId
 * @see ObjectId
 */ 
const ObjectId = (__webpack_require__(38013).ObjectId);
/*!
 * ignore
 */ module.exports = exports = ObjectId;


/***/ }),

/***/ 96996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(51520);
const util = __webpack_require__(73837);
/**
 * Casting Error constructor.
 *
 * @param {String} type
 * @param {String} value
 * @inherits MongooseError
 * @api private
 */ class CastError extends MongooseError {
    constructor(type, value, path, reason, schemaType){
        // If no args, assume we'll `init()` later.
        if (arguments.length > 0) {
            const stringValue = getStringValue(value);
            const valueType = getValueType(value);
            const messageFormat = getMessageFormat(schemaType);
            const msg = formatMessage(null, type, stringValue, path, messageFormat, valueType, reason);
            super(msg);
            this.init(type, value, path, reason, schemaType);
        } else {
            super(formatMessage());
        }
    }
    toJSON() {
        return {
            stringValue: this.stringValue,
            valueType: this.valueType,
            kind: this.kind,
            value: this.value,
            path: this.path,
            reason: this.reason,
            name: this.name,
            message: this.message
        };
    }
    /*!
   * ignore
   */ init(type, value, path, reason, schemaType) {
        this.stringValue = getStringValue(value);
        this.messageFormat = getMessageFormat(schemaType);
        this.kind = type;
        this.value = value;
        this.path = path;
        this.reason = reason;
        this.valueType = getValueType(value);
    }
    /**
   * ignore
   * @param {Readonly<CastError>} other
   * @api private
   */ copy(other) {
        this.messageFormat = other.messageFormat;
        this.stringValue = other.stringValue;
        this.kind = other.kind;
        this.value = other.value;
        this.path = other.path;
        this.reason = other.reason;
        this.message = other.message;
        this.valueType = other.valueType;
    }
    /*!
   * ignore
   */ setModel(model) {
        this.model = model;
        this.message = formatMessage(model, this.kind, this.stringValue, this.path, this.messageFormat, this.valueType);
    }
}
Object.defineProperty(CastError.prototype, "name", {
    value: "CastError"
});
function getStringValue(value) {
    let stringValue = util.inspect(value);
    stringValue = stringValue.replace(/^'|'$/g, '"');
    if (!stringValue.startsWith('"')) {
        stringValue = '"' + stringValue + '"';
    }
    return stringValue;
}
function getValueType(value) {
    if (value == null) {
        return "" + value;
    }
    const t = typeof value;
    if (t !== "object") {
        return t;
    }
    if (typeof value.constructor !== "function") {
        return t;
    }
    return value.constructor.name;
}
function getMessageFormat(schemaType) {
    const messageFormat = schemaType && schemaType.options && schemaType.options.cast || null;
    if (typeof messageFormat === "string") {
        return messageFormat;
    }
}
/*!
 * ignore
 */ function formatMessage(model, kind, stringValue, path, messageFormat, valueType, reason) {
    if (messageFormat != null) {
        let ret = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
        if (model != null) {
            ret = ret.replace("{MODEL}", model.modelName);
        }
        return ret;
    } else {
        const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
        let ret = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
        if (model != null) {
            ret += ' for model "' + model.modelName + '"';
        }
        if (reason != null && typeof reason.constructor === "function" && reason.constructor.name !== "AssertionError" && reason.constructor.name !== "Error") {
            ret += ' because of "' + reason.constructor.name + '"';
        }
        return ret;
    }
}
/*!
 * exports
 */ module.exports = CastError;


/***/ }),

/***/ 8089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
/**
 * The connection failed to reconnect and will never successfully reconnect to
 * MongoDB without manual intervention.
 * @api private
 */ class DisconnectedError extends MongooseError {
    /**
   * @param {String} connectionString
   */ constructor(id, fnName){
        super("Connection " + id + " was disconnected when calling `" + fnName + "()`");
    }
}
Object.defineProperty(DisconnectedError.prototype, "name", {
    value: "DisconnectedError"
});
/*!
 * exports
 */ module.exports = DisconnectedError;


/***/ }),

/***/ 33182:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class DivergentArrayError extends MongooseError {
    /**
   * DivergentArrayError constructor.
   * @param {Array<String>} paths
   * @api private
   */ constructor(paths){
        const msg = "For your own good, using `document.save()` to update an array " + "which was selected using an $elemMatch projection OR " + "populated using skip, limit, query conditions, or exclusion of " + "the _id field when the operation results in a $pop or $set of " + "the entire array is not supported. The following " + "path(s) would have been modified unsafely:\n" + "  " + paths.join("\n  ") + "\n" + "Use Model.update() to update these arrays instead.";
        // TODO write up a docs page (FAQ) and link to it
        super(msg);
    }
}
Object.defineProperty(DivergentArrayError.prototype, "name", {
    value: "DivergentArrayError"
});
/*!
 * exports
 */ module.exports = DivergentArrayError;


/***/ }),

/***/ 81596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
/**
 * If `eachAsync()` is called with `continueOnError: true`, there can be
 * multiple errors. This error class contains an `errors` property, which
 * contains an array of all errors that occurred in `eachAsync()`.
 *
 * @api private
 */ class EachAsyncMultiError extends MongooseError {
    /**
   * @param {String} connectionString
   */ constructor(errors){
        let preview = errors.map((e)=>e.message).join(", ");
        if (preview.length > 50) {
            preview = preview.slice(0, 50) + "...";
        }
        super(`eachAsync() finished with ${errors.length} errors: ${preview}`);
        this.errors = errors;
    }
}
Object.defineProperty(EachAsyncMultiError.prototype, "name", {
    value: "EachAsyncMultiError"
});
/*!
 * exports
 */ module.exports = EachAsyncMultiError;


/***/ }),

/***/ 40413:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/**
 * MongooseError constructor. MongooseError is the base class for all
 * Mongoose-specific errors.
 *
 * #### Example:
 *
 *     const Model = mongoose.model('Test', new mongoose.Schema({ answer: Number }));
 *     const doc = new Model({ answer: 'not a number' });
 *     const err = doc.validateSync();
 *
 *     err instanceof mongoose.Error.ValidationError; // true
 *
 * @constructor Error
 * @param {String} msg Error message
 * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error
 */ const MongooseError = __webpack_require__(51520);
/**
 * The name of the error. The name uniquely identifies this Mongoose error. The
 * possible values are:
 *
 * - `MongooseError`: general Mongoose error
 * - `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.
 * - `DisconnectedError`: This [connection](connections.html) timed out in trying to reconnect to MongoDB and will not successfully reconnect to MongoDB unless you explicitly reconnect.
 * - `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection
 * - `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](api/mongoose.html#mongoose_Mongoose-model) that was not defined
 * - `DocumentNotFoundError`: The document you tried to [`save()`](api/document.html#document_Document-save) was not found
 * - `ValidatorError`: error from an individual schema path's validator
 * - `ValidationError`: error returned from [`validate()`](api/document.html#document_Document-validate) or [`validateSync()`](api/document.html#document_Document-validateSync). Contains zero or more `ValidatorError` instances in `.errors` property.
 * - `MissingSchemaError`: You called `mongoose.Document()` without a schema
 * - `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](guide.html#strict).
 * - `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter
 * - `OverwriteModelError`: Thrown when you call [`mongoose.model()`](api/mongoose.html#mongoose_Mongoose-model) to re-define a model that was already defined.
 * - `ParallelSaveError`: Thrown when you call [`save()`](api/model.html#model_Model-save) on a document when the same document instance is already saving.
 * - `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](guide.html#strict) is set to `throw`.
 * - `VersionError`: Thrown when the [document is out of sync](guide.html#versionKey)
 *
 * @api public
 * @property {String} name
 * @memberOf Error
 * @instance
 */ /*!
 * Module exports.
 */ module.exports = exports = MongooseError;
/**
 * The default built-in validator error messages.
 *
 * @see Error.messages #error_messages_MongooseError-messages
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.messages = __webpack_require__(55468);
// backward compat
MongooseError.Messages = MongooseError.messages;
/**
 * An instance of this error class will be returned when `save()` fails
 * because the underlying
 * document was not found. The constructor takes one parameter, the
 * conditions that mongoose passed to `update()` when trying to update
 * the document.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.DocumentNotFoundError = __webpack_require__(8671);
/**
 * An instance of this error class will be returned when mongoose failed to
 * cast a value.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.CastError = __webpack_require__(96996);
/**
 * An instance of this error class will be returned when [validation](/docs/validation.html) failed.
 * The `errors` property contains an object whose keys are the paths that failed and whose values are
 * instances of CastError or ValidationError.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.ValidationError = __webpack_require__(13837);
/**
 * A `ValidationError` has a hash of `errors` that contain individual
 * `ValidatorError` instances.
 *
 * #### Example:
 *
 *     const schema = Schema({ name: { type: String, required: true } });
 *     const Model = mongoose.model('Test', schema);
 *     const doc = new Model({});
 *
 *     // Top-level error is a ValidationError, **not** a ValidatorError
 *     const err = doc.validateSync();
 *     err instanceof mongoose.Error.ValidationError; // true
 *
 *     // A ValidationError `err` has 0 or more ValidatorErrors keyed by the
 *     // path in the `err.errors` property.
 *     err.errors['name'] instanceof mongoose.Error.ValidatorError;
 *
 *     err.errors['name'].kind; // 'required'
 *     err.errors['name'].path; // 'name'
 *     err.errors['name'].value; // undefined
 *
 * Instances of `ValidatorError` have the following properties:
 *
 * - `kind`: The validator's `type`, like `'required'` or `'regexp'`
 * - `path`: The path that failed validation
 * - `value`: The value that failed validation
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.ValidatorError = __webpack_require__(50666);
/**
 * An instance of this error class will be returned when you call `save()` after
 * the document in the database was changed in a potentially unsafe way. See
 * the [`versionKey` option](/docs/guide.html#versionKey) for more information.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.VersionError = __webpack_require__(19096);
/**
 * An instance of this error class will be returned when you call `save()` multiple
 * times on the same document in parallel. See the [FAQ](/docs/faq.html) for more
 * information.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.ParallelSaveError = __webpack_require__(45254);
/**
 * Thrown when a model with the given name was already registered on the connection.
 * See [the FAQ about `OverwriteModelError`](/docs/faq.html#overwrite-model-error).
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.OverwriteModelError = __webpack_require__(13034);
/**
 * Thrown when you try to access a model that has not been registered yet
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.MissingSchemaError = __webpack_require__(34304);
/**
 * Thrown when the MongoDB Node driver can't connect to a valid server
 * to send an operation to.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.MongooseServerSelectionError = __webpack_require__(76027);
/**
 * An instance of this error will be returned if you used an array projection
 * and then modified the array in an unsafe way.
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.DivergentArrayError = __webpack_require__(33182);
/**
 * Thrown when your try to pass values to model contrtuctor that
 * were not specified in schema or change immutable properties when
 * `strict` mode is `"throw"`
 *
 * @api public
 * @memberOf Error
 * @static
 */ MongooseError.StrictModeError = __webpack_require__(51016);


/***/ }),

/***/ 55468:
/***/ ((module, exports) => {

"use strict";
/**
 * The default built-in validator error messages. These may be customized.
 *
 *     // customize within each schema or globally like so
 *     const mongoose = require('mongoose');
 *     mongoose.Error.messages.String.enum  = "Your custom message for {PATH}.";
 *
 * As you might have noticed, error messages support basic templating
 *
 * - `{PATH}` is replaced with the invalid document path
 * - `{VALUE}` is replaced with the invalid value
 * - `{TYPE}` is replaced with the validator type such as "regexp", "min", or "user defined"
 * - `{MIN}` is replaced with the declared min value for the Number.min validator
 * - `{MAX}` is replaced with the declared max value for the Number.max validator
 *
 * Click the "show code" link below to see all defaults.
 *
 * @static
 * @memberOf MongooseError
 * @api public
 */ 
const msg = module.exports = exports = {};
msg.DocumentNotFoundError = null;
msg.general = {};
msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
msg.general.required = "Path `{PATH}` is required.";
msg.Number = {};
msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
msg.Date = {};
msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
msg.String = {};
msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";


/***/ }),

/***/ 34304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class MissingSchemaError extends MongooseError {
    /**
   * MissingSchema Error constructor.
   * @param {String} name
   * @api private
   */ constructor(name){
        const msg = "Schema hasn't been registered for model \"" + name + '".\n' + "Use mongoose.model(name, schema)";
        super(msg);
    }
}
Object.defineProperty(MissingSchemaError.prototype, "name", {
    value: "MissingSchemaError"
});
/*!
 * exports
 */ module.exports = MissingSchemaError;


/***/ }),

/***/ 51520:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ class MongooseError extends Error {
}
Object.defineProperty(MongooseError.prototype, "name", {
    value: "MongooseError"
});
module.exports = MongooseError;


/***/ }),

/***/ 8671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(40413);
const util = __webpack_require__(73837);
class DocumentNotFoundError extends MongooseError {
    /**
   * OverwriteModel Error constructor.
   * @api private
   */ constructor(filter, model, numAffected, result){
        let msg;
        const messages = MongooseError.messages;
        if (messages.DocumentNotFoundError != null) {
            msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
        } else {
            msg = 'No document found for query "' + util.inspect(filter) + '" on model "' + model + '"';
        }
        super(msg);
        this.result = result;
        this.numAffected = numAffected;
        this.filter = filter;
        // Backwards compat
        this.query = filter;
    }
}
Object.defineProperty(DocumentNotFoundError.prototype, "name", {
    value: "DocumentNotFoundError"
});
/*!
 * exports
 */ module.exports = DocumentNotFoundError;


/***/ }),

/***/ 7860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class ObjectExpectedError extends MongooseError {
    /**
   * Strict mode error constructor
   *
   * @param {string} type
   * @param {string} value
   * @api private
   */ constructor(path, val){
        const typeDescription = Array.isArray(val) ? "array" : "primitive value";
        super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "`");
        this.path = path;
    }
}
Object.defineProperty(ObjectExpectedError.prototype, "name", {
    value: "ObjectExpectedError"
});
module.exports = ObjectExpectedError;


/***/ }),

/***/ 96255:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class ObjectParameterError extends MongooseError {
    /**
   * Constructor for errors that happen when a parameter that's expected to be
   * an object isn't an object
   *
   * @param {Any} value
   * @param {String} paramName
   * @param {String} fnName
   * @api private
   */ constructor(value, paramName, fnName){
        super('Parameter "' + paramName + '" to ' + fnName + "() must be an object, got " + value.toString());
    }
}
Object.defineProperty(ObjectParameterError.prototype, "name", {
    value: "ObjectParameterError"
});
module.exports = ObjectParameterError;


/***/ }),

/***/ 13034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class OverwriteModelError extends MongooseError {
    /**
   * OverwriteModel Error constructor.
   * @param {String} name
   * @api private
   */ constructor(name){
        super("Cannot overwrite `" + name + "` model once compiled.");
    }
}
Object.defineProperty(OverwriteModelError.prototype, "name", {
    value: "OverwriteModelError"
});
/*!
 * exports
 */ module.exports = OverwriteModelError;


/***/ }),

/***/ 45254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(40413);
class ParallelSaveError extends MongooseError {
    /**
   * ParallelSave Error constructor.
   *
   * @param {Document} doc
   * @api private
   */ constructor(doc){
        const msg = "Can't save() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
    }
}
Object.defineProperty(ParallelSaveError.prototype, "name", {
    value: "ParallelSaveError"
});
/*!
 * exports
 */ module.exports = ParallelSaveError;


/***/ }),

/***/ 84443:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(51520);
class ParallelValidateError extends MongooseError {
    /**
   * ParallelValidate Error constructor.
   *
   * @param {Document} doc
   * @api private
   */ constructor(doc){
        const msg = "Can't validate() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
    }
}
Object.defineProperty(ParallelValidateError.prototype, "name", {
    value: "ParallelValidateError"
});
/*!
 * exports
 */ module.exports = ParallelValidateError;


/***/ }),

/***/ 76027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(51520);
const allServersUnknown = __webpack_require__(42934);
const isAtlas = __webpack_require__(44592);
const isSSLError = __webpack_require__(72520);
/*!
 * ignore
 */ const atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. " + "One common reason is that you're trying to access the database from " + "an IP that isn't whitelisted. Make sure your current IP address is on your Atlas " + "cluster's IP whitelist: https://docs.atlas.mongodb.com/security-whitelist/";
const sslMessage = "Mongoose is connecting with SSL enabled, but the server is " + "not accepting SSL connections. Please ensure that the MongoDB server you are " + "connecting to is configured to accept SSL connections. Learn more: " + "https://mongoosejs.com/docs/tutorials/ssl.html";
class MongooseServerSelectionError extends MongooseError {
    /**
   * MongooseServerSelectionError constructor
   *
   * @api private
   */ assimilateError(err) {
        const reason = err.reason;
        // Special message for a case that is likely due to IP whitelisting issues.
        const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
        if (isAtlasWhitelistError) {
            this.message = atlasMessage;
        } else if (isSSLError(reason)) {
            this.message = sslMessage;
        } else {
            this.message = err.message;
        }
        for(const key in err){
            if (key !== "name") {
                this[key] = err[key];
            }
        }
        return this;
    }
}
Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
    value: "MongooseServerSelectionError"
});
module.exports = MongooseServerSelectionError;


/***/ }),

/***/ 46608:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module requirements
 */ 
const MongooseError = __webpack_require__(51520);
const util = __webpack_require__(73837);
const combinePathErrors = __webpack_require__(65068);
class SetOptionError extends MongooseError {
    /**
   * Mongoose.set Error
   *
   * @api private
   * @inherits MongooseError
   */ constructor(){
        super("");
        this.errors = {};
    }
    /**
   * Console.log helper
   */ toString() {
        return combinePathErrors(this);
    }
    /**
   * inspect helper
   * @api private
   */ inspect() {
        return Object.assign(new Error(this.message), this);
    }
    /**
  * add message
  * @param {String} key
  * @param {String|Error} error
  * @api private
  */ addError(key, error) {
        if (error instanceof SetOptionError) {
            const { errors  } = error;
            for (const optionKey of Object.keys(errors)){
                this.addError(optionKey, errors[optionKey]);
            }
            return;
        }
        this.errors[key] = error;
        this.message = combinePathErrors(this);
    }
}
if (util.inspect.custom) {
    // Avoid Node deprecation warning DEP0079
    SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;
}
/**
 * Helper for JSON.stringify
 * Ensure `name` and `message` show up in toJSON output re: gh-9847
 * @api private
 */ Object.defineProperty(SetOptionError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
        return Object.assign({}, this, {
            name: this.name,
            message: this.message
        });
    }
});
Object.defineProperty(SetOptionError.prototype, "name", {
    value: "SetOptionError"
});
class SetOptionInnerError extends MongooseError {
    /**
   * Error for the "errors" array in "SetOptionError" with consistent message
   * @param {String} key
   */ constructor(key){
        super(`"${key}" is not a valid option to set`);
    }
}
SetOptionError.SetOptionInnerError = SetOptionInnerError;
/*!
 * Module exports
 */ module.exports = SetOptionError;


/***/ }),

/***/ 51016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class StrictModeError extends MongooseError {
    /**
   * Strict mode error constructor
   *
   * @param {String} path
   * @param {String} [msg]
   * @param {Boolean} [immutable]
   * @inherits MongooseError
   * @api private
   */ constructor(path, msg, immutable){
        msg = msg || "Field `" + path + "` is not in schema and strict " + "mode is set to throw.";
        super(msg);
        this.isImmutableError = !!immutable;
        this.path = path;
    }
}
Object.defineProperty(StrictModeError.prototype, "name", {
    value: "StrictModeError"
});
module.exports = StrictModeError;


/***/ }),

/***/ 96546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class StrictPopulateError extends MongooseError {
    /**
   * Strict mode error constructor
   *
   * @param {String} path
   * @param {String} [msg]
   * @inherits MongooseError
   * @api private
   */ constructor(path, msg){
        msg = msg || "Cannot populate path `" + path + "` because it is not in your schema. " + "Set the `strictPopulate` option to false to override.";
        super(msg);
        this.path = path;
    }
}
Object.defineProperty(StrictPopulateError.prototype, "name", {
    value: "StrictPopulateError"
});
module.exports = StrictPopulateError;


/***/ }),

/***/ 3144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(51520);
/**
 * SyncIndexes Error constructor.
 *
 * @param {String} message
 * @param {String} errorsMap
 * @inherits MongooseError
 * @api private
 */ class SyncIndexesError extends MongooseError {
    constructor(message, errorsMap){
        super(message);
        this.errors = errorsMap;
    }
}
Object.defineProperty(SyncIndexesError.prototype, "name", {
    value: "SyncIndexesError"
});
module.exports = SyncIndexesError;


/***/ }),

/***/ 13837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module requirements
 */ 
const MongooseError = __webpack_require__(51520);
const getConstructorName = __webpack_require__(4065);
const util = __webpack_require__(73837);
const combinePathErrors = __webpack_require__(65068);
class ValidationError extends MongooseError {
    /**
   * Document Validation Error
   *
   * @api private
   * @param {Document} [instance]
   * @inherits MongooseError
   */ constructor(instance){
        let _message;
        if (getConstructorName(instance) === "model") {
            _message = instance.constructor.modelName + " validation failed";
        } else {
            _message = "Validation failed";
        }
        super(_message);
        this.errors = {};
        this._message = _message;
        if (instance) {
            instance.$errors = this.errors;
        }
    }
    /**
   * Console.log helper
   */ toString() {
        return this.name + ": " + combinePathErrors(this);
    }
    /**
   * inspect helper
   * @api private
   */ inspect() {
        return Object.assign(new Error(this.message), this);
    }
    /**
  * add message
  * @param {String} path
  * @param {String|Error} error
  * @api private
  */ addError(path, error) {
        if (error instanceof ValidationError) {
            const { errors  } = error;
            for (const errorPath of Object.keys(errors)){
                this.addError(`${path}.${errorPath}`, errors[errorPath]);
            }
            return;
        }
        this.errors[path] = error;
        this.message = this._message + ": " + combinePathErrors(this);
    }
}
if (util.inspect.custom) {
    // Avoid Node deprecation warning DEP0079
    ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
}
/**
 * Helper for JSON.stringify
 * Ensure `name` and `message` show up in toJSON output re: gh-9847
 * @api private
 */ Object.defineProperty(ValidationError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
        return Object.assign({}, this, {
            name: this.name,
            message: this.message
        });
    }
});
Object.defineProperty(ValidationError.prototype, "name", {
    value: "ValidationError"
});
/*!
 * Module exports
 */ module.exports = ValidationError;


/***/ }),

/***/ 50666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseError = __webpack_require__(40413);
class ValidatorError extends MongooseError {
    /**
   * Schema validator error
   *
   * @param {Object} properties
   * @param {Document} doc
   * @api private
   */ constructor(properties, doc){
        let msg = properties.message;
        if (!msg) {
            msg = MongooseError.messages.general.default;
        }
        const message = formatMessage(msg, properties, doc);
        super(message);
        properties = Object.assign({}, properties, {
            message: message
        });
        this.properties = properties;
        this.kind = properties.type;
        this.path = properties.path;
        this.value = properties.value;
        this.reason = properties.reason;
    }
    /**
   * toString helper
   * TODO remove? This defaults to `${this.name}: ${this.message}`
   * @api private
   */ toString() {
        return this.message;
    }
    /**
   * Ensure `name` and `message` show up in toJSON output re: gh-9296
   * @api private
   */ toJSON() {
        return Object.assign({
            name: this.name,
            message: this.message
        }, this);
    }
}
Object.defineProperty(ValidatorError.prototype, "name", {
    value: "ValidatorError"
});
/**
 * The object used to define this validator. Not enumerable to hide
 * it from `require('util').inspect()` output re: gh-3925
 * @api private
 */ Object.defineProperty(ValidatorError.prototype, "properties", {
    enumerable: false,
    writable: true,
    value: null
});
// Exposed for testing
ValidatorError.prototype.formatMessage = formatMessage;
/**
 * Formats error messages
 * @api private
 */ function formatMessage(msg, properties, doc) {
    if (typeof msg === "function") {
        return msg(properties, doc);
    }
    const propertyNames = Object.keys(properties);
    for (const propertyName of propertyNames){
        if (propertyName === "message") {
            continue;
        }
        msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
    }
    return msg;
}
/*!
 * exports
 */ module.exports = ValidatorError;


/***/ }),

/***/ 19096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(40413);
class VersionError extends MongooseError {
    /**
   * Version Error constructor.
   *
   * @param {Document} doc
   * @param {Number} currentVersion
   * @param {Array<String>} modifiedPaths
   * @api private
   */ constructor(doc, currentVersion, modifiedPaths){
        const modifiedPathsStr = modifiedPaths.join(", ");
        super('No matching document found for id "' + doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
        this.version = currentVersion;
        this.modifiedPaths = modifiedPaths;
    }
}
Object.defineProperty(VersionError.prototype, "name", {
    value: "VersionError"
});
/*!
 * exports
 */ module.exports = VersionError;


/***/ }),

/***/ 52409:
/***/ ((module) => {

"use strict";

module.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {
    const discriminatorMapping = schema && schema.discriminatorMapping;
    prefix = prefix || "";
    if (discriminatorMapping && !discriminatorMapping.isRoot) {
        const originalPipeline = pipeline;
        const filterKey = (prefix.length > 0 ? prefix + "." : prefix) + discriminatorMapping.key;
        const discriminatorValue = discriminatorMapping.value;
        // If the first pipeline stage is a match and it doesn't specify a `__t`
        // key, add the discriminator key to it. This allows for potential
        // aggregation query optimizations not to be disturbed by this feature.
        if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {
            originalPipeline[0].$match[filterKey] = discriminatorValue;
        // `originalPipeline` is a ref, so there's no need for
        // aggregate._pipeline = originalPipeline
        } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {
            originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
            originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;
        } else if (originalPipeline[0] != null && originalPipeline[0].$search) {
            if (originalPipeline[1] && originalPipeline[1].$match != null) {
                originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;
            } else {
                const match = {};
                match[filterKey] = discriminatorValue;
                originalPipeline.splice(1, 0, {
                    $match: match
                });
            }
        } else {
            const match = {};
            match[filterKey] = discriminatorValue;
            originalPipeline.unshift({
                $match: match
            });
        }
    }
};


/***/ }),

/***/ 46873:
/***/ ((module) => {

"use strict";

module.exports = function stringifyFunctionOperators(pipeline) {
    if (!Array.isArray(pipeline)) {
        return;
    }
    for (const stage of pipeline){
        if (stage == null) {
            continue;
        }
        const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
        if (canHaveAccumulator != null) {
            for (const key of Object.keys(canHaveAccumulator)){
                handleAccumulator(canHaveAccumulator[key]);
            }
        }
        const stageType = Object.keys(stage)[0];
        if (stageType && typeof stage[stageType] === "object") {
            const stageOptions = stage[stageType];
            for (const key of Object.keys(stageOptions)){
                if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
                    stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
                }
            }
        }
        if (stage.$facet != null) {
            for (const key of Object.keys(stage.$facet)){
                stringifyFunctionOperators(stage.$facet[key]);
            }
        }
    }
};
function handleAccumulator(operator) {
    if (operator == null || operator.$accumulator == null) {
        return;
    }
    for (const key of [
        "init",
        "accumulate",
        "merge",
        "finalize"
    ]){
        if (typeof operator.$accumulator[key] === "function") {
            operator.$accumulator[key] = String(operator.$accumulator[key]);
        }
    }
}


/***/ }),

/***/ 79163:
/***/ ((module) => {

"use strict";

module.exports = arrayDepth;
function arrayDepth(arr) {
    if (!Array.isArray(arr)) {
        return {
            min: 0,
            max: 0,
            containsNonArrayItem: true
        };
    }
    if (arr.length === 0) {
        return {
            min: 1,
            max: 1,
            containsNonArrayItem: false
        };
    }
    if (arr.length === 1 && !Array.isArray(arr[0])) {
        return {
            min: 1,
            max: 1,
            containsNonArrayItem: false
        };
    }
    const res = arrayDepth(arr[0]);
    for(let i = 1; i < arr.length; ++i){
        const _res = arrayDepth(arr[i]);
        if (_res.min < res.min) {
            res.min = _res.min;
        }
        if (_res.max > res.max) {
            res.max = _res.max;
        }
        res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
    }
    res.min = res.min + 1;
    res.max = res.max + 1;
    return res;
}


/***/ }),

/***/ 99889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Decimal = __webpack_require__(37489);
const ObjectId = __webpack_require__(41370);
const specialProperties = __webpack_require__(36848);
const isMongooseObject = __webpack_require__(36569);
const getFunctionName = __webpack_require__(50377);
const isBsonType = __webpack_require__(85847);
const isObject = __webpack_require__(89026);
const symbols = __webpack_require__(5089);
const trustedSymbol = (__webpack_require__(79657).trustedSymbol);
const utils = __webpack_require__(52100);
/**
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
 * @return {Object} the cloned object
 * @api private
 */ function clone(obj, options, isArrayChild) {
    if (obj == null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return cloneArray(utils.isMongooseArray(obj) ? obj.__array : obj, options);
    }
    if (isMongooseObject(obj)) {
        // Single nested subdocs should apply getters later in `applyGetters()`
        // when calling `toObject()`. See gh-7442, gh-8295
        if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {
            options = Object.assign({}, options, {
                getters: false
            });
        }
        const isSingleNested = obj.$isSingleNested;
        if (utils.isPOJO(obj) && obj.$__ != null && obj._doc != null) {
            return obj._doc;
        }
        let ret;
        if (options && options.json && typeof obj.toJSON === "function") {
            ret = obj.toJSON(options);
        } else {
            ret = obj.toObject(options);
        }
        if (options && options.minimize && isSingleNested && Object.keys(ret).length === 0) {
            return undefined;
        }
        return ret;
    }
    const objConstructor = obj.constructor;
    if (objConstructor) {
        switch(getFunctionName(objConstructor)){
            case "Object":
                return cloneObject(obj, options, isArrayChild);
            case "Date":
                return new objConstructor(+obj);
            case "RegExp":
                return cloneRegExp(obj);
            default:
                break;
        }
    }
    if (isBsonType(obj, "ObjectID")) {
        return new ObjectId(obj.id);
    }
    if (isBsonType(obj, "Decimal128")) {
        if (options && options.flattenDecimals) {
            return obj.toJSON();
        }
        return Decimal.fromString(obj.toString());
    }
    // object created with Object.create(null)
    if (!objConstructor && isObject(obj)) {
        return cloneObject(obj, options, isArrayChild);
    }
    if (typeof obj === "object" && obj[symbols.schemaTypeSymbol]) {
        return obj.clone();
    }
    // If we're cloning this object to go into a MongoDB command,
    // and there's a `toBSON()` function, assume this object will be
    // stored as a primitive in MongoDB and doesn't need to be cloned.
    if (options && options.bson && typeof obj.toBSON === "function") {
        return obj;
    }
    if (typeof obj.valueOf === "function") {
        return obj.valueOf();
    }
    return cloneObject(obj, options, isArrayChild);
}
module.exports = clone;
/*!
 * ignore
 */ function cloneObject(obj, options, isArrayChild) {
    const minimize = options && options.minimize;
    const omitUndefined = options && options.omitUndefined;
    const seen = options && options._seen;
    const ret = {};
    let hasKeys;
    if (seen && seen.has(obj)) {
        return seen.get(obj);
    } else if (seen) {
        seen.set(obj, ret);
    }
    if (trustedSymbol in obj) {
        ret[trustedSymbol] = obj[trustedSymbol];
    }
    let i = 0;
    let key = "";
    const keys = Object.keys(obj);
    const len = keys.length;
    for(i = 0; i < len; ++i){
        if (specialProperties.has(key = keys[i])) {
            continue;
        }
        // Don't pass `isArrayChild` down
        const val = clone(obj[key], options, false);
        if ((minimize === false || omitUndefined) && typeof val === "undefined") {
            delete ret[key];
        } else if (minimize !== true || typeof val !== "undefined") {
            hasKeys || (hasKeys = true);
            ret[key] = val;
        }
    }
    return minimize && !isArrayChild ? hasKeys && ret : ret;
}
function cloneArray(arr, options) {
    let i = 0;
    const len = arr.length;
    const ret = new Array(len);
    for(i = 0; i < len; ++i){
        ret[i] = clone(arr[i], options, true);
    }
    return ret;
}
function cloneRegExp(regexp) {
    const ret = new RegExp(regexp.source, regexp.flags);
    if (ret.lastIndex !== regexp.lastIndex) {
        ret.lastIndex = regexp.lastIndex;
    }
    return ret;
}


/***/ }),

/***/ 26170:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const Binary = (__webpack_require__(67085).get)().Binary;
const isBsonType = __webpack_require__(85847);
const isMongooseObject = __webpack_require__(36569);
const MongooseError = __webpack_require__(40413);
const util = __webpack_require__(73837);
exports.x = flatten;
exports.M = modifiedPaths;
/*!
 * ignore
 */ function flatten(update, path, options, schema) {
    let keys;
    if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
        keys = Object.keys(update.toObject({
            transform: false,
            virtuals: false
        }) || {});
    } else {
        keys = Object.keys(update || {});
    }
    const numKeys = keys.length;
    const result = {};
    path = path ? path + "." : "";
    for(let i = 0; i < numKeys; ++i){
        const key = keys[i];
        const val = update[key];
        result[path + key] = val;
        // Avoid going into mixed paths if schema is specified
        const keySchema = schema && schema.path && schema.path(path + key);
        const isNested = schema && schema.nested && schema.nested[path + key];
        if (keySchema && keySchema.instance === "Mixed") continue;
        if (shouldFlatten(val)) {
            if (options && options.skipArrays && Array.isArray(val)) {
                continue;
            }
            const flat = flatten(val, path + key, options, schema);
            for(const k in flat){
                result[k] = flat[k];
            }
            if (Array.isArray(val)) {
                result[path + key] = val;
            }
        }
        if (isNested) {
            const paths = Object.keys(schema.paths);
            for (const p of paths){
                if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
                    result[p] = void 0;
                }
            }
        }
    }
    return result;
}
/*!
 * ignore
 */ function modifiedPaths(update, path, result, recursion = null) {
    if (update == null || typeof update !== "object") {
        return;
    }
    if (recursion == null) {
        recursion = {
            raw: {
                update,
                path
            },
            trace: new WeakSet()
        };
    }
    if (recursion.trace.has(update)) {
        throw new MongooseError(`a circular reference in the update value, updateValue:
${util.inspect(recursion.raw.update, {
            showHidden: false,
            depth: 1
        })}
updatePath: '${recursion.raw.path}'`);
    }
    recursion.trace.add(update);
    const keys = Object.keys(update || {});
    const numKeys = keys.length;
    result = result || {};
    path = path ? path + "." : "";
    for(let i = 0; i < numKeys; ++i){
        const key = keys[i];
        let val = update[key];
        const _path = path + key;
        result[_path] = true;
        if (!Buffer.isBuffer(val) && isMongooseObject(val)) {
            val = val.toObject({
                transform: false,
                virtuals: false
            });
        }
        if (shouldFlatten(val)) {
            modifiedPaths(val, path + key, result, recursion);
        }
    }
    recursion.trace.delete(update);
    return result;
}
/*!
 * ignore
 */ function shouldFlatten(val) {
    return val && typeof val === "object" && !(val instanceof Date) && !isBsonType(val, "ObjectID") && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, "Decimal128") && !(val instanceof Binary);
}


/***/ }),

/***/ 75468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const EachAsyncMultiError = __webpack_require__(81596);
const immediate = __webpack_require__(96621);
const promiseOrCallback = __webpack_require__(83593);
/**
 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
 * will wait for the promise to resolve before iterating on to the next one.
 * Returns a promise that resolves when done.
 *
 * @param {Function} next the thunk to call to get the next document
 * @param {Function} fn
 * @param {Object} options
 * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document
 * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel
 * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.
 * @param {Function} [callback] executed when all docs have been processed
 * @return {Promise}
 * @api public
 * @method eachAsync
 */ module.exports = function eachAsync(next, fn, options, callback) {
    const parallel = options.parallel || 1;
    const batchSize = options.batchSize;
    const signal = options.signal;
    const continueOnError = options.continueOnError;
    const aggregatedErrors = [];
    const enqueue = asyncQueue();
    let aborted = false;
    return promiseOrCallback(callback, (cb)=>{
        if (signal != null) {
            if (signal.aborted) {
                return cb(null);
            }
            signal.addEventListener("abort", ()=>{
                aborted = true;
                return cb(null);
            }, {
                once: true
            });
        }
        if (batchSize != null) {
            if (typeof batchSize !== "number") {
                throw new TypeError("batchSize must be a number");
            } else if (!Number.isInteger(batchSize)) {
                throw new TypeError("batchSize must be an integer");
            } else if (batchSize < 1) {
                throw new TypeError("batchSize must be at least 1");
            }
        }
        iterate(cb);
    });
    function iterate(finalCallback) {
        let handleResultsInProgress = 0;
        let currentDocumentIndex = 0;
        let error = null;
        for(let i = 0; i < parallel; ++i){
            enqueue(createFetch());
        }
        function createFetch() {
            let documentsBatch = [];
            let drained = false;
            return fetch;
            function fetch(done) {
                if (drained || aborted) {
                    return done();
                } else if (error) {
                    return done();
                }
                next(function(err, doc) {
                    if (error != null) {
                        return done();
                    }
                    if (err != null) {
                        if (err.name === "MongoCursorExhaustedError") {
                            // We may end up calling `next()` multiple times on an exhausted
                            // cursor, which leads to an error. In case cursor is exhausted,
                            // just treat it as if the cursor returned no document, which is
                            // how a cursor indicates it is exhausted.
                            doc = null;
                        } else if (continueOnError) {
                            aggregatedErrors.push(err);
                        } else {
                            error = err;
                            finalCallback(err);
                            return done();
                        }
                    }
                    if (doc == null) {
                        drained = true;
                        if (handleResultsInProgress <= 0) {
                            const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                            finalCallback(finalErr);
                        } else if (batchSize && documentsBatch.length) {
                            handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
                        }
                        return done();
                    }
                    ++handleResultsInProgress;
                    // Kick off the subsequent `next()` before handling the result, but
                    // make sure we know that we still have a result to handle re: #8422
                    immediate(()=>done());
                    if (batchSize) {
                        documentsBatch.push(doc);
                    }
                    // If the current documents size is less than the provided batch size don't process the documents yet
                    if (batchSize && documentsBatch.length !== batchSize) {
                        immediate(()=>enqueue(fetch));
                        return;
                    }
                    const docsToProcess = batchSize ? documentsBatch : doc;
                    function handleNextResultCallBack(err) {
                        if (batchSize) {
                            handleResultsInProgress -= documentsBatch.length;
                            documentsBatch = [];
                        } else {
                            --handleResultsInProgress;
                        }
                        if (err != null) {
                            if (continueOnError) {
                                aggregatedErrors.push(err);
                            } else {
                                error = err;
                                return finalCallback(err);
                            }
                        }
                        if ((drained || aborted) && handleResultsInProgress <= 0) {
                            const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                            return finalCallback(finalErr);
                        }
                        immediate(()=>enqueue(fetch));
                    }
                    handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
                });
            }
        }
    }
    function handleNextResult(doc, i, callback) {
        let maybePromise;
        try {
            maybePromise = fn(doc, i);
        } catch (err) {
            return callback(err);
        }
        if (maybePromise && typeof maybePromise.then === "function") {
            maybePromise.then(function() {
                callback(null);
            }, function(error) {
                callback(error || new Error("`eachAsync()` promise rejected without error"));
            });
        } else {
            callback(null);
        }
    }
};
// `next()` can only execute one at a time, so make sure we always execute
// `next()` in series, while still allowing multiple `fn()` instances to run
// in parallel.
function asyncQueue() {
    const _queue = [];
    let inProgress = null;
    let id = 0;
    return function enqueue(fn) {
        if (inProgress === null && _queue.length === 0) {
            inProgress = id++;
            return fn(_step);
        }
        _queue.push(fn);
    };
    function _step() {
        if (_queue.length !== 0) {
            inProgress = id++;
            const fn = _queue.shift();
            fn(_step);
        } else {
            inProgress = null;
        }
    }
}
function createEachAsyncMultiError(aggregatedErrors) {
    if (aggregatedErrors.length === 0) {
        return null;
    }
    return new EachAsyncMultiError(aggregatedErrors);
}


/***/ }),

/***/ 59032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isBsonType = __webpack_require__(85847);
module.exports = function areDiscriminatorValuesEqual(a, b) {
    if (typeof a === "string" && typeof b === "string") {
        return a === b;
    }
    if (typeof a === "number" && typeof b === "number") {
        return a === b;
    }
    if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID")) {
        return a.toString() === b.toString();
    }
    return false;
};


/***/ }),

/***/ 72176:
/***/ ((module) => {

"use strict";

module.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
    const userProjectedInPath = Object.keys(userProjection).reduce((cur, key)=>cur || key.startsWith(path + "."), false);
    const _discriminatorKey = path + "." + schema.options.discriminatorKey;
    if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
        selected.splice(selected.indexOf(_discriminatorKey), 1);
    }
};


/***/ }),

/***/ 81442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const getDiscriminatorByValue = __webpack_require__(17492);
/**
 * Find the correct constructor, taking into account discriminators
 * @api private
 */ module.exports = function getConstructor(Constructor, value) {
    const discriminatorKey = Constructor.schema.options.discriminatorKey;
    if (value != null && Constructor.discriminators && value[discriminatorKey] != null) {
        if (Constructor.discriminators[value[discriminatorKey]]) {
            Constructor = Constructor.discriminators[value[discriminatorKey]];
        } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[discriminatorKey]);
            if (constructorByValue) {
                Constructor = constructorByValue;
            }
        }
    }
    return Constructor;
};


/***/ }),

/***/ 17492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const areDiscriminatorValuesEqual = __webpack_require__(59032);
/**
 * returns discriminator by discriminatorMapping.value
 *
 * @param {Object} discriminators
 * @param {string} value
 * @api private
 */ module.exports = function getDiscriminatorByValue(discriminators, value) {
    if (discriminators == null) {
        return null;
    }
    for (const name of Object.keys(discriminators)){
        const it = discriminators[name];
        if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
            return it;
        }
    }
    return null;
};


/***/ }),

/***/ 16049:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const areDiscriminatorValuesEqual = __webpack_require__(59032);
/**
 * returns discriminator by discriminatorMapping.value
 *
 * @param {Schema} schema
 * @param {string} value
 * @api private
 */ module.exports = function getSchemaDiscriminatorByValue(schema, value) {
    if (schema == null || schema.discriminators == null) {
        return null;
    }
    for (const key of Object.keys(schema.discriminators)){
        const discriminatorSchema = schema.discriminators[key];
        if (discriminatorSchema.discriminatorMapping == null) {
            continue;
        }
        if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
            return discriminatorSchema;
        }
    }
    return null;
};


/***/ }),

/***/ 25959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const schemaMerge = __webpack_require__(38359);
const specialProperties = __webpack_require__(36848);
const isBsonType = __webpack_require__(85847);
const ObjectId = __webpack_require__(41370);
const isObject = __webpack_require__(89026);
/**
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @param {String} [path]
 * @api private
 */ module.exports = function mergeDiscriminatorSchema(to, from, path) {
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    path = path || "";
    while(i < len){
        key = keys[i++];
        if (key === "discriminators" || key === "base" || key === "_applyDiscriminators") {
            continue;
        }
        if (path === "tree" && from != null && from.instanceOfSchema) {
            continue;
        }
        if (specialProperties.has(key)) {
            continue;
        }
        if (to[key] == null) {
            to[key] = from[key];
        } else if (isObject(from[key])) {
            if (!isObject(to[key])) {
                to[key] = {};
            }
            if (from[key] != null) {
                // Skip merging schemas if we're creating a discriminator schema and
                // base schema has a given path as a single nested but discriminator schema
                // has the path as a document array, or vice versa (gh-9534)
                if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
                    continue;
                } else if (from[key].instanceOfSchema) {
                    if (to[key].instanceOfSchema) {
                        schemaMerge(to[key], from[key].clone(), true);
                    } else {
                        to[key] = from[key].clone();
                    }
                    continue;
                } else if (isBsonType(from[key], "ObjectID")) {
                    to[key] = new ObjectId(from[key]);
                    continue;
                }
            }
            mergeDiscriminatorSchema(to[key], from[key], path ? path + "." + key : key);
        }
    }
};


/***/ }),

/***/ 1796:
/***/ ((module) => {

"use strict";

module.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    for(let i = 0; i < plen; ++i){
        let def;
        let curPath = "";
        const p = paths[i];
        if (p === "_id" && doc.$__.skipId) {
            continue;
        }
        const type = doc.$__schema.paths[p];
        const path = type.splitPath();
        const len = path.length;
        let included = false;
        let doc_ = doc._doc;
        for(let j = 0; j < len; ++j){
            if (doc_ == null) {
                break;
            }
            const piece = path[j];
            curPath += (!curPath.length ? "" : ".") + piece;
            if (exclude === true) {
                if (curPath in fields) {
                    break;
                }
            } else if (exclude === false && fields && !included) {
                const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;
                if (curPath in fields || hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath]) {
                    included = true;
                } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {
                    break;
                }
            }
            if (j === len - 1) {
                if (doc_[piece] !== void 0) {
                    break;
                }
                if (isBeforeSetters != null) {
                    if (typeof type.defaultValue === "function") {
                        if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                            break;
                        }
                        if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                            break;
                        }
                    } else if (!isBeforeSetters) {
                        continue;
                    }
                }
                if (pathsToSkip && pathsToSkip[curPath]) {
                    break;
                }
                if (fields && exclude !== null) {
                    if (exclude === true) {
                        // apply defaults to all non-excluded fields
                        if (p in fields) {
                            continue;
                        }
                        try {
                            def = type.getDefault(doc, false);
                        } catch (err) {
                            doc.invalidate(p, err);
                            break;
                        }
                        if (typeof def !== "undefined") {
                            doc_[piece] = def;
                            applyChangeTracking(doc, p);
                        }
                    } else if (included) {
                        // selected field
                        try {
                            def = type.getDefault(doc, false);
                        } catch (err) {
                            doc.invalidate(p, err);
                            break;
                        }
                        if (typeof def !== "undefined") {
                            doc_[piece] = def;
                            applyChangeTracking(doc, p);
                        }
                    }
                } else {
                    try {
                        def = type.getDefault(doc, false);
                    } catch (err) {
                        doc.invalidate(p, err);
                        break;
                    }
                    if (typeof def !== "undefined") {
                        doc_[piece] = def;
                        applyChangeTracking(doc, p);
                    }
                }
            } else {
                doc_ = doc_[piece];
            }
        }
    }
};
/*!
 * ignore
 */ function applyChangeTracking(doc, fullPath) {
    doc.$__.activePaths.default(fullPath);
    if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {
        doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));
    }
}


/***/ }),

/***/ 74797:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function cleanModifiedSubpaths(doc, path, options) {
    options = options || {};
    const skipDocArrays = options.skipDocArrays;
    let deleted = 0;
    if (!doc) {
        return deleted;
    }
    for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths("modify"))){
        if (skipDocArrays) {
            const schemaType = doc.$__schema.path(modifiedPath);
            if (schemaType && schemaType.$isMongooseDocumentArray) {
                continue;
            }
        }
        if (modifiedPath.startsWith(path + ".")) {
            doc.$__.activePaths.clearPath(modifiedPath);
            ++deleted;
            if (doc.$isSubdocument) {
                const owner = doc.ownerDocument();
                const fullPath = doc.$__fullPath(modifiedPath);
                owner.$__.activePaths.clearPath(fullPath);
            }
        }
    }
    return deleted;
};


/***/ }),

/***/ 35772:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const documentSchemaSymbol = (__webpack_require__(5089).documentSchemaSymbol);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const utils = __webpack_require__(52100);
let Document;
const getSymbol = (__webpack_require__(5089).getSymbol);
const scopeSymbol = (__webpack_require__(5089).scopeSymbol);
const isPOJO = utils.isPOJO;
/*!
 * exports
 */ exports.M = compile;
exports.c = defineKey;
const _isEmptyOptions = Object.freeze({
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
});
/**
 * Compiles schemas.
 * @param {Object} tree
 * @param {Any} proto
 * @param {String} prefix
 * @param {Object} options
 * @api private
 */ function compile(tree, proto, prefix, options) {
    Document = Document || __webpack_require__(14001);
    const typeKey = options.typeKey;
    for (const key of Object.keys(tree)){
        const limb = tree[key];
        const hasSubprops = isPOJO(limb) && Object.keys(limb).length > 0 && (!limb[typeKey] || typeKey === "type" && isPOJO(limb.type) && limb.type.type);
        const subprops = hasSubprops ? limb : null;
        defineKey({
            prop: key,
            subprops: subprops,
            prototype: proto,
            prefix: prefix,
            options: options
        });
    }
}
/**
 * Defines the accessor named prop on the incoming prototype.
 * @param {Object} options
 * @param {String} options.prop
 * @param {Boolean} options.subprops
 * @param {Any} options.prototype
 * @param {String} [options.prefix]
 * @param {Object} options.options
 * @api private
 */ function defineKey({ prop , subprops , prototype , prefix , options  }) {
    Document = Document || __webpack_require__(14001);
    const path = (prefix ? prefix + "." : "") + prop;
    prefix = prefix || "";
    if (subprops) {
        Object.defineProperty(prototype, prop, {
            enumerable: true,
            configurable: true,
            get: function() {
                const _this = this;
                if (!this.$__.getters) {
                    this.$__.getters = {};
                }
                if (!this.$__.getters[path]) {
                    const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
                    // save scope for nested getters/setters
                    if (!prefix) {
                        nested.$__[scopeSymbol] = this;
                    }
                    nested.$__.nestedPath = path;
                    Object.defineProperty(nested, "schema", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: prototype.schema
                    });
                    Object.defineProperty(nested, "$__schema", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: prototype.schema
                    });
                    Object.defineProperty(nested, documentSchemaSymbol, {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: prototype.schema
                    });
                    Object.defineProperty(nested, "toObject", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: function() {
                            return utils.clone(_this.get(path, null, {
                                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                            }));
                        }
                    });
                    Object.defineProperty(nested, "$__get", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: function() {
                            return _this.get(path, null, {
                                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                            });
                        }
                    });
                    Object.defineProperty(nested, "toJSON", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: function() {
                            return _this.get(path, null, {
                                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null
                            });
                        }
                    });
                    Object.defineProperty(nested, "$__isNested", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: true
                    });
                    Object.defineProperty(nested, "$isEmpty", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: function() {
                            return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
                        }
                    });
                    Object.defineProperty(nested, "$__parent", {
                        enumerable: false,
                        configurable: true,
                        writable: false,
                        value: this
                    });
                    compile(subprops, nested, path, options);
                    this.$__.getters[path] = nested;
                }
                return this.$__.getters[path];
            },
            set: function(v) {
                if (v != null && v.$__isNested) {
                    // Convert top-level to POJO, but leave subdocs hydrated so `$set`
                    // can handle them. See gh-9293.
                    v = v.$__get();
                } else if (v instanceof Document && !v.$__isNested) {
                    v = v.$toObject(internalToObjectOptions);
                }
                const doc = this.$__[scopeSymbol] || this;
                doc.$set(path, v);
            }
        });
    } else {
        Object.defineProperty(prototype, prop, {
            enumerable: true,
            configurable: true,
            get: function() {
                return this[getSymbol].call(this.$__[scopeSymbol] || this, path);
            },
            set: function(v) {
                this.$set.call(this.$__[scopeSymbol] || this, path, v);
            }
        });
    }
}
// gets descriptors for all properties of `object`
// makes all properties non-enumerable to match previous behavior to #2211
function getOwnPropertyDescriptors(object) {
    const result = {};
    Object.getOwnPropertyNames(object).forEach(function(key) {
        const skip = [
            "isNew",
            "$__",
            "$errors",
            "errors",
            "_doc",
            "$locals",
            "$op",
            "__parentArray",
            "__index",
            "$isDocumentArrayElement"
        ].indexOf(key) === -1;
        if (skip) {
            return;
        }
        result[key] = Object.getOwnPropertyDescriptor(object, key);
        result[key].enumerable = false;
    });
    return result;
}


/***/ }),

/***/ 73877:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
const getSchemaDiscriminatorByValue = __webpack_require__(16049);
/**
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 * @param {Document} doc
 * @param {String} path
 * @param {Object} [options]
 * @api private
 */ module.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {
    options = options || {};
    const typeOnly = options.typeOnly;
    const parts = path.indexOf(".") === -1 ? [
        path
    ] : path.split(".");
    let schemaType = null;
    let type = "adhocOrUndefined";
    const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;
    for(let i = 0; i < parts.length; ++i){
        const subpath = parts.slice(0, i + 1).join(".");
        schemaType = schema.path(subpath);
        if (schemaType == null) {
            type = "adhocOrUndefined";
            continue;
        }
        if (schemaType.instance === "Mixed") {
            return typeOnly ? "real" : schemaType;
        }
        type = schema.pathType(subpath);
        if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {
            const discriminators = schemaType.schema.discriminators;
            const discriminatorKey = doc.get(subpath + "." + get(schemaType, "schema.options.discriminatorKey"));
            if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
                continue;
            }
            const rest = parts.slice(i + 1).join(".");
            return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
        }
    }
    // Are we getting the whole schema or just the type, 'real', 'nested', etc.
    return typeOnly ? type : schemaType;
};


/***/ }),

/***/ 4715:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(52100);
const keysToSkip = new Set([
    "__index",
    "__parentArray",
    "_doc"
]);
/**
 * Using spread operator on a Mongoose document gives you a
 * POJO that has a tendency to cause infinite recursion. So
 * we use this function on `set()` to prevent that.
 */ module.exports = function handleSpreadDoc(v, includeExtraKeys) {
    if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {
        if (includeExtraKeys) {
            const extraKeys = {};
            for (const key of Object.keys(v)){
                if (typeof key === "symbol") {
                    continue;
                }
                if (key[0] === "$") {
                    continue;
                }
                if (keysToSkip.has(key)) {
                    continue;
                }
                extraKeys[key] = v[key];
            }
            return {
                ...v._doc,
                ...extraKeys
            };
        }
        return v._doc;
    }
    return v;
};


/***/ }),

/***/ 60233:
/***/ ((module) => {

"use strict";

module.exports = function each(arr, cb, done) {
    if (arr.length === 0) {
        return done();
    }
    let remaining = arr.length;
    let err = null;
    for (const v of arr){
        cb(v, function(_err) {
            if (err != null) {
                return;
            }
            if (_err != null) {
                err = _err;
                return done(err);
            }
            if (--remaining <= 0) {
                return done();
            }
        });
    }
};


/***/ }),

/***/ 65068:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function combinePathErrors(err) {
    const keys = Object.keys(err.errors || {});
    const len = keys.length;
    const msgs = [];
    let key;
    for(let i = 0; i < len; ++i){
        key = keys[i];
        if (err === err.errors[key]) {
            continue;
        }
        msgs.push(key + ": " + err.errors[key].message);
    }
    return msgs.join(", ");
};


/***/ }),

/***/ 12163:
/***/ ((module) => {

"use strict";

module.exports = function firstKey(obj) {
    if (obj == null) {
        return null;
    }
    return Object.keys(obj)[0];
};


/***/ }),

/***/ 39223:
/***/ ((module) => {

"use strict";

/**
 * Simplified lodash.get to work around the annoying null quirk. See:
 * https://github.com/lodash/lodash/issues/3659
 * @api private
 */ module.exports = function get(obj, path, def) {
    let parts;
    let isPathArray = false;
    if (typeof path === "string") {
        if (path.indexOf(".") === -1) {
            const _v = getProperty(obj, path);
            if (_v == null) {
                return def;
            }
            return _v;
        }
        parts = path.split(".");
    } else {
        isPathArray = true;
        parts = path;
        if (parts.length === 1) {
            const _v = getProperty(obj, parts[0]);
            if (_v == null) {
                return def;
            }
            return _v;
        }
    }
    let rest = path;
    let cur = obj;
    for (const part of parts){
        if (cur == null) {
            return def;
        }
        // `lib/cast.js` depends on being able to get dotted paths in updates,
        // like `{ $set: { 'a.b': 42 } }`
        if (!isPathArray && cur[rest] != null) {
            return cur[rest];
        }
        cur = getProperty(cur, part);
        if (!isPathArray) {
            rest = rest.substr(part.length + 1);
        }
    }
    return cur == null ? def : cur;
};
function getProperty(obj, prop) {
    if (obj == null) {
        return obj;
    }
    if (obj instanceof Map) {
        return obj.get(prop);
    }
    return obj[prop];
}


/***/ }),

/***/ 4065:
/***/ ((module) => {

"use strict";

/**
 * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.
 * @api private
 */ module.exports = function getConstructorName(val) {
    if (val == null) {
        return void 0;
    }
    if (typeof val.constructor !== "function") {
        return void 0;
    }
    return val.constructor.name;
};


/***/ }),

/***/ 54883:
/***/ ((module) => {

"use strict";

function getDefaultBulkwriteResult() {
    return {
        result: {
            ok: 1,
            writeErrors: [],
            writeConcernErrors: [],
            insertedIds: [],
            nInserted: 0,
            nUpserted: 0,
            nMatched: 0,
            nModified: 0,
            nRemoved: 0,
            upserted: []
        },
        insertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        upsertedCount: 0,
        upsertedIds: {},
        insertedIds: {},
        n: 0
    };
}
module.exports = getDefaultBulkwriteResult;


/***/ }),

/***/ 50377:
/***/ ((module) => {

"use strict";

const functionNameRE = /^function\s*([^\s(]+)/;
module.exports = function(fn) {
    return fn.name || (fn.toString().trim().match(functionNameRE) || [])[1];
};


/***/ }),

/***/ 96621:
/***/ ((module) => {

"use strict";
/*!
 * Centralize this so we can more easily work around issues with people
 * stubbing out `process.nextTick()` in tests using sinon:
 * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
 * See gh-6074
 */ 
const nextTick = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : (cb)=>setTimeout(cb, 0); // Fallback for browser build
module.exports = function immediate(cb) {
    return nextTick(cb);
};


/***/ }),

/***/ 3447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isTextIndex = __webpack_require__(54127);
module.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {
    if (isTextIndex(indexKeys)) {
        return;
    }
    if (schemaOptions.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation")) {
        indexOptions.collation = schemaOptions.collation;
    }
};


/***/ }),

/***/ 23846:
/***/ ((module) => {

"use strict";

module.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {
    // If the model is a discriminator and has an index, add a
    // partialFilterExpression by default so the index will only apply
    // to that discriminator.
    const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;
    if (discriminatorName && !("sparse" in indexOptions)) {
        const discriminatorKey = schema.options.discriminatorKey;
        indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};
        indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;
    }
    return indexOptions;
};


/***/ }),

/***/ 7896:
/***/ ((module) => {

"use strict";

function getRelatedSchemaIndexes(model, schemaIndexes) {
    return getRelatedIndexes({
        baseModelName: model.baseModelName,
        discriminatorMapping: model.schema.discriminatorMapping,
        indexes: schemaIndexes,
        indexesType: "schema"
    });
}
function getRelatedDBIndexes(model, dbIndexes) {
    return getRelatedIndexes({
        baseModelName: model.baseModelName,
        discriminatorMapping: model.schema.discriminatorMapping,
        indexes: dbIndexes,
        indexesType: "db"
    });
}
module.exports = {
    getRelatedSchemaIndexes,
    getRelatedDBIndexes
};
function getRelatedIndexes({ baseModelName , discriminatorMapping , indexes , indexesType  }) {
    const discriminatorKey = discriminatorMapping && discriminatorMapping.key;
    const discriminatorValue = discriminatorMapping && discriminatorMapping.value;
    if (!discriminatorKey) {
        return indexes;
    }
    const isChildDiscriminatorModel = Boolean(baseModelName);
    if (isChildDiscriminatorModel) {
        return indexes.filter((index)=>{
            const partialFilterExpression = getPartialFilterExpression(index, indexesType);
            return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;
        });
    }
    return indexes.filter((index)=>{
        const partialFilterExpression = getPartialFilterExpression(index, indexesType);
        return !partialFilterExpression || !partialFilterExpression[discriminatorKey];
    });
}
function getPartialFilterExpression(index, indexesType) {
    if (indexesType === "schema") {
        const options = index[1];
        return options && options.partialFilterExpression;
    }
    return index.partialFilterExpression;
}


/***/ }),

/***/ 92465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
module.exports = function isDefaultIdIndex(index) {
    if (Array.isArray(index)) {
        // Mongoose syntax
        const keys = Object.keys(index[0]);
        return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
    }
    if (typeof index !== "object") {
        return false;
    }
    const key = get(index, "key", {});
    return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
};


/***/ }),

/***/ 65147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
const utils = __webpack_require__(52100);
/**
 * Given a Mongoose index definition (key + options objects) and a MongoDB server
 * index definition, determine if the two indexes are equal.
 *
 * @param {Object} schemaIndexKeysObject the Mongoose index spec
 * @param {Object} options the Mongoose index definition's options
 * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`
 * @api private
 */ module.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {
    // Special case: text indexes have a special format in the db. For example,
    // `{ name: 'text' }` becomes:
    // {
    //   v: 2,
    //   key: { _fts: 'text', _ftsx: 1 },
    //   name: 'name_text',
    //   ns: 'test.tests',
    //   background: true,
    //   weights: { name: 1 },
    //   default_language: 'english',
    //   language_override: 'language',
    //   textIndexVersion: 3
    // }
    if (dbIndex.textIndexVersion != null) {
        delete dbIndex.key._fts;
        delete dbIndex.key._ftsx;
        const weights = {
            ...dbIndex.weights,
            ...dbIndex.key
        };
        if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {
            return false;
        }
        for (const prop of Object.keys(weights)){
            if (!(prop in schemaIndexKeysObject)) {
                return false;
            }
            const weight = weights[prop];
            if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
                return false;
            }
        }
        if (options["default_language"] !== dbIndex["default_language"]) {
            return dbIndex["default_language"] === "english" && options["default_language"] == null;
        }
        return true;
    }
    const optionKeys = [
        "unique",
        "partialFilterExpression",
        "sparse",
        "expireAfterSeconds",
        "collation"
    ];
    for (const key of optionKeys){
        if (!(key in options) && !(key in dbIndex)) {
            continue;
        }
        if (key === "collation") {
            if (options[key] == null || dbIndex[key] == null) {
                return options[key] == null && dbIndex[key] == null;
            }
            const definedKeys = Object.keys(options.collation);
            const schemaCollation = options.collation;
            const dbCollation = dbIndex.collation;
            for (const opt of definedKeys){
                if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
                    return false;
                }
            }
        } else if (!utils.deepEqual(options[key], dbIndex[key])) {
            return false;
        }
    }
    const schemaIndexKeys = Object.keys(schemaIndexKeysObject);
    const dbIndexKeys = Object.keys(dbIndex.key);
    if (schemaIndexKeys.length !== dbIndexKeys.length) {
        return false;
    }
    for(let i = 0; i < schemaIndexKeys.length; ++i){
        if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
            return false;
        }
        if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
            return false;
        }
    }
    return true;
};


/***/ }),

/***/ 54127:
/***/ ((module) => {

"use strict";

/**
 * Returns `true` if the given index options have a `text` option.
 */ module.exports = function isTextIndex(indexKeys) {
    let isTextIndex = false;
    for (const key of Object.keys(indexKeys)){
        if (indexKeys[key] === "text") {
            isTextIndex = true;
        }
    }
    return isTextIndex;
};


/***/ }),

/***/ 27297:
/***/ ((module) => {

"use strict";

module.exports = function isAsyncFunction(v) {
    return typeof v === "function" && v.constructor && v.constructor.name === "AsyncFunction";
};


/***/ }),

/***/ 85847:
/***/ ((module) => {

"use strict";

/**
 * Get the bson type, if it exists
 * @api private
 */ function isBsonType(obj, typename) {
    return typeof obj === "object" && obj !== null && obj._bsontype === typename;
}
module.exports = isBsonType;


/***/ }),

/***/ 36569:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isMongooseArray = (__webpack_require__(50911).isMongooseArray);
/**
 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
 *
 * This is for compatibility with libs like Date.js which do foolish things to Natives.
 *
 * @param {Any} v
 * @api private
 */ module.exports = function(v) {
    return v != null && (isMongooseArray(v) || // Array or Document Array
    v.$__ != null || // Document
    v.isMongooseBuffer || // Buffer
    v.$isMongooseMap // Map
    );
};


/***/ }),

/***/ 89026:
/***/ ((module) => {

"use strict";

/**
 * Determines if `arg` is an object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */ module.exports = function(arg) {
    return Buffer.isBuffer(arg) || Object.prototype.toString.call(arg) === "[object Object]";
};


/***/ }),

/***/ 93923:
/***/ ((module) => {

"use strict";

function isPromise(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
}
module.exports = isPromise;


/***/ }),

/***/ 51418:
/***/ ((module) => {

"use strict";

/**
 * Determines if `arg` is a flat object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */ module.exports = function isSimpleValidator(obj) {
    const keys = Object.keys(obj);
    let result = true;
    for(let i = 0, len = keys.length; i < len; ++i){
        if (typeof obj[keys[i]] === "object" && obj[keys[i]] !== null) {
            result = false;
            break;
        }
    }
    return result;
};


/***/ }),

/***/ 70126:
/***/ ((module) => {

"use strict";

module.exports = function applyDefaultsToPOJO(doc, schema) {
    const paths = Object.keys(schema.paths);
    const plen = paths.length;
    for(let i = 0; i < plen; ++i){
        let curPath = "";
        const p = paths[i];
        const type = schema.paths[p];
        const path = type.splitPath();
        const len = path.length;
        let doc_ = doc;
        for(let j = 0; j < len; ++j){
            if (doc_ == null) {
                break;
            }
            const piece = path[j];
            curPath += (!curPath.length ? "" : ".") + piece;
            if (j === len - 1) {
                if (typeof doc_[piece] !== "undefined") {
                    if (type.$isSingleNested) {
                        applyDefaultsToPOJO(doc_[piece], type.caster.schema);
                    } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {
                        doc_[piece].forEach((el)=>applyDefaultsToPOJO(el, type.schema));
                    }
                    break;
                }
                const def = type.getDefault(doc, false, {
                    skipCast: true
                });
                if (typeof def !== "undefined") {
                    doc_[piece] = def;
                    if (type.$isSingleNested) {
                        applyDefaultsToPOJO(def, type.caster.schema);
                    } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {
                        def.forEach((el)=>applyDefaultsToPOJO(el, type.schema));
                    }
                }
            } else {
                if (doc_[piece] == null) {
                    doc_[piece] = {};
                }
                doc_ = doc_[piece];
            }
        }
    }
};


/***/ }),

/***/ 13202:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const symbols = __webpack_require__(36825);
const promiseOrCallback = __webpack_require__(83593);
/*!
 * ignore
 */ module.exports = applyHooks;
/*!
 * ignore
 */ applyHooks.middlewareFunctions = [
    "deleteOne",
    "save",
    "validate",
    "remove",
    "updateOne",
    "init"
];
/*!
 * ignore
 */ const alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap((fn)=>[
        fn,
        `$__${fn}`
    ]));
/**
 * Register hooks for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 * @param {Object} options
 * @api private
 */ function applyHooks(model, schema, options) {
    options = options || {};
    const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true,
        contextParameter: true
    };
    const objToDecorate = options.decorateDoc ? model : model.prototype;
    model.$appliedHooks = true;
    for (const key of Object.keys(schema.paths)){
        const type = schema.paths[key];
        let childModel = null;
        if (type.$isSingleNested) {
            childModel = type.caster;
        } else if (type.$isMongooseDocumentArray) {
            childModel = type.Constructor;
        } else {
            continue;
        }
        if (childModel.$appliedHooks) {
            continue;
        }
        applyHooks(childModel, type.schema, options);
        if (childModel.discriminators != null) {
            const keys = Object.keys(childModel.discriminators);
            for (const key of keys){
                applyHooks(childModel.discriminators[key], childModel.discriminators[key].schema, options);
            }
        }
    }
    // Built-in hooks rely on hooking internal functions in order to support
    // promises and make it so that `doc.save.toString()` provides meaningful
    // information.
    const middleware = schema.s.hooks.filter((hook)=>{
        if (hook.name === "updateOne" || hook.name === "deleteOne") {
            return !!hook["document"];
        }
        if (hook.name === "remove" || hook.name === "init") {
            return hook["document"] == null || !!hook["document"];
        }
        if (hook.query != null || hook.document != null) {
            return hook.document !== false;
        }
        return true;
    }).filter((hook)=>{
        // If user has overwritten the method, don't apply built-in middleware
        if (schema.methods[hook.name]) {
            return !hook.fn[symbols.builtInMiddleware];
        }
        return true;
    });
    model._middleware = middleware;
    objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
    for (const method of [
        "save",
        "validate",
        "remove",
        "deleteOne"
    ]){
        const toWrap = method === "validate" ? "$__originalValidate" : `$__${method}`;
        const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
        objToDecorate[`$__${method}`] = wrapped;
    }
    objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
    // Support hooks for custom methods
    const customMethods = Object.keys(schema.methods);
    const customMethodOptions = Object.assign({}, kareemOptions, {
        // Only use `checkForPromise` for custom methods, because mongoose
        // query thunks are not as consistent as I would like about returning
        // a nullish value rather than the query. If a query thunk returns
        // a query, `checkForPromise` causes infinite recursion
        checkForPromise: true
    });
    for (const method of customMethods){
        if (alreadyHookedFunctions.has(method)) {
            continue;
        }
        if (!middleware.hasHooks(method)) {
            continue;
        }
        const originalMethod = objToDecorate[method];
        objToDecorate[method] = function() {
            const args = Array.prototype.slice.call(arguments);
            const cb = args.slice(-1).pop();
            const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
            return promiseOrCallback(cb, (callback)=>{
                return this[`$__${method}`].apply(this, argsWithoutCallback.concat([
                    callback
                ]));
            }, model.events);
        };
        objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
    }
}


/***/ }),

/***/ 81007:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
const utils = __webpack_require__(52100);
/**
 * Register methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 * @api private
 */ module.exports = function applyMethods(model, schema) {
    const Model = __webpack_require__(68389);
    function apply(method, schema) {
        Object.defineProperty(model.prototype, method, {
            get: function() {
                const h = {};
                for(const k in schema.methods[method]){
                    h[k] = schema.methods[method][k].bind(this);
                }
                return h;
            },
            configurable: true
        });
    }
    for (const method of Object.keys(schema.methods)){
        const fn = schema.methods[method];
        if (schema.tree.hasOwnProperty(method)) {
            throw new Error("You have a method and a property in your schema both " + 'named "' + method + '"');
        }
        // Avoid making custom methods if user sets a method to itself, e.g.
        // `schema.method(save, Document.prototype.save)`. Can happen when
        // calling `loadClass()` with a class that `extends Document`. See gh-12254
        if (typeof fn === "function" && Model.prototype[method] === fn) {
            delete schema.methods[method];
            continue;
        }
        if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
            utils.warn(`mongoose: the method name "${method}" is used by mongoose ` + "internally, overwriting it may cause bugs. If you're sure you know " + "what you're doing, you can suppress this error by using " + `\`schema.method('${method}', fn, { suppressWarning: true })\`.`);
        }
        if (typeof fn === "function") {
            model.prototype[method] = fn;
        } else {
            apply(method, schema);
        }
    }
    // Recursively call `applyMethods()` on child schemas
    model.$appliedMethods = true;
    for (const key of Object.keys(schema.paths)){
        const type = schema.paths[key];
        if (type.$isSingleNested && !type.caster.$appliedMethods) {
            applyMethods(type.caster, type.schema);
        }
        if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
            applyMethods(type.Constructor, type.schema);
        }
    }
};


/***/ }),

/***/ 95583:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const middlewareFunctions = (__webpack_require__(94135).middlewareFunctions);
const promiseOrCallback = __webpack_require__(83593);
module.exports = function applyStaticHooks(model, hooks, statics) {
    const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1
    };
    hooks = hooks.filter((hook)=>{
        // If the custom static overwrites an existing query middleware, don't apply
        // middleware to it by default. This avoids a potential backwards breaking
        // change with plugins like `mongoose-delete` that use statics to overwrite
        // built-in Mongoose functions.
        if (middlewareFunctions.indexOf(hook.name) !== -1) {
            return !!hook.model;
        }
        return hook.model !== false;
    });
    model.$__insertMany = hooks.createWrapper("insertMany", model.$__insertMany, model, kareemOptions);
    for (const key of Object.keys(statics)){
        if (hooks.hasHooks(key)) {
            const original = model[key];
            model[key] = function() {
                const numArgs = arguments.length;
                const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
                const cb = typeof lastArg === "function" ? lastArg : null;
                const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
                // Special case: can't use `Kareem#wrap()` because it doesn't currently
                // support wrapped functions that return a promise.
                return promiseOrCallback(cb, (callback)=>{
                    hooks.execPre(key, model, args, function(err) {
                        if (err != null) {
                            return callback(err);
                        }
                        let postCalled = 0;
                        const ret = original.apply(model, args.concat(post));
                        if (ret != null && typeof ret.then === "function") {
                            ret.then((res)=>post(null, res), (err)=>post(err));
                        }
                        function post(error, res) {
                            if (postCalled++ > 0) {
                                return;
                            }
                            if (error != null) {
                                return callback(error);
                            }
                            hooks.execPost(key, model, [
                                res
                            ], function(error) {
                                if (error != null) {
                                    return callback(error);
                                }
                                callback(null, res);
                            });
                        }
                    });
                }, model.events);
            };
        }
    }
};


/***/ }),

/***/ 58256:
/***/ ((module) => {

"use strict";

/**
 * Register statics for this model
 * @param {Model} model
 * @param {Schema} schema
 * @api private
 */ module.exports = function applyStatics(model, schema) {
    for(const i in schema.statics){
        model[i] = schema.statics[i];
    }
};


/***/ }),

/***/ 9881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const getDiscriminatorByValue = __webpack_require__(17492);
const applyTimestampsToChildren = __webpack_require__(67592);
const applyTimestampsToUpdate = __webpack_require__(36234);
const cast = __webpack_require__(54749);
const castUpdate = __webpack_require__(54795);
const setDefaultsOnInsert = __webpack_require__(55426);
/**
 * Given a model and a bulkWrite op, return a thunk that handles casting and
 * validating the individual op.
 * @param {Model} originalModel
 * @param {Object} op
 * @param {Object} [options]
 * @api private
 */ module.exports = function castBulkWrite(originalModel, op, options) {
    const now = originalModel.base.now();
    if (op["insertOne"]) {
        return (callback)=>{
            const model = decideModelByObject(originalModel, op["insertOne"]["document"]);
            const doc = new model(op["insertOne"]["document"]);
            if (model.schema.options.timestamps && options.timestamps !== false) {
                doc.initializeTimestamps();
            }
            if (options.session != null) {
                doc.$session(options.session);
            }
            op["insertOne"]["document"] = doc;
            if (options.skipValidation || op["insertOne"].skipValidation) {
                callback(null);
                return;
            }
            op["insertOne"]["document"].$validate({
                __noPromise: true
            }, function(error) {
                if (error) {
                    return callback(error, null);
                }
                callback(null);
            });
        };
    } else if (op["updateOne"]) {
        return (callback)=>{
            try {
                if (!op["updateOne"]["filter"]) {
                    throw new Error("Must provide a filter object.");
                }
                if (!op["updateOne"]["update"]) {
                    throw new Error("Must provide an update object.");
                }
                const model = decideModelByObject(originalModel, op["updateOne"]["filter"]);
                const schema = model.schema;
                const strict = options.strict != null ? options.strict : model.schema.options.strict;
                _addDiscriminatorToObject(schema, op["updateOne"]["filter"]);
                if (model.schema.$timestamps != null && op["updateOne"].timestamps !== false) {
                    const createdAt = model.schema.$timestamps.createdAt;
                    const updatedAt = model.schema.$timestamps.updatedAt;
                    applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateOne"]["update"], {});
                }
                applyTimestampsToChildren(now, op["updateOne"]["update"], model.schema);
                if (op["updateOne"].setDefaultsOnInsert !== false) {
                    setDefaultsOnInsert(op["updateOne"]["filter"], model.schema, op["updateOne"]["update"], {
                        setDefaultsOnInsert: true,
                        upsert: op["updateOne"].upsert
                    });
                }
                op["updateOne"]["filter"] = cast(model.schema, op["updateOne"]["filter"], {
                    strict: strict,
                    upsert: op["updateOne"].upsert
                });
                op["updateOne"]["update"] = castUpdate(model.schema, op["updateOne"]["update"], {
                    strict: strict,
                    overwrite: false,
                    upsert: op["updateOne"].upsert
                }, model, op["updateOne"]["filter"]);
            } catch (error) {
                return callback(error, null);
            }
            callback(null);
        };
    } else if (op["updateMany"]) {
        return (callback)=>{
            try {
                if (!op["updateMany"]["filter"]) {
                    throw new Error("Must provide a filter object.");
                }
                if (!op["updateMany"]["update"]) {
                    throw new Error("Must provide an update object.");
                }
                const model = decideModelByObject(originalModel, op["updateMany"]["filter"]);
                const schema = model.schema;
                const strict = options.strict != null ? options.strict : model.schema.options.strict;
                if (op["updateMany"].setDefaultsOnInsert !== false) {
                    setDefaultsOnInsert(op["updateMany"]["filter"], model.schema, op["updateMany"]["update"], {
                        setDefaultsOnInsert: true,
                        upsert: op["updateMany"].upsert
                    });
                }
                if (model.schema.$timestamps != null && op["updateMany"].timestamps !== false) {
                    const createdAt = model.schema.$timestamps.createdAt;
                    const updatedAt = model.schema.$timestamps.updatedAt;
                    applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateMany"]["update"], {});
                }
                applyTimestampsToChildren(now, op["updateMany"]["update"], model.schema);
                _addDiscriminatorToObject(schema, op["updateMany"]["filter"]);
                op["updateMany"]["filter"] = cast(model.schema, op["updateMany"]["filter"], {
                    strict: strict,
                    upsert: op["updateMany"].upsert
                });
                op["updateMany"]["update"] = castUpdate(model.schema, op["updateMany"]["update"], {
                    strict: strict,
                    overwrite: false,
                    upsert: op["updateMany"].upsert
                }, model, op["updateMany"]["filter"]);
            } catch (error) {
                return callback(error, null);
            }
            callback(null);
        };
    } else if (op["replaceOne"]) {
        return (callback)=>{
            const model = decideModelByObject(originalModel, op["replaceOne"]["filter"]);
            const schema = model.schema;
            const strict = options.strict != null ? options.strict : model.schema.options.strict;
            _addDiscriminatorToObject(schema, op["replaceOne"]["filter"]);
            try {
                op["replaceOne"]["filter"] = cast(model.schema, op["replaceOne"]["filter"], {
                    strict: strict,
                    upsert: op["replaceOne"].upsert
                });
            } catch (error) {
                return callback(error, null);
            }
            // set `skipId`, otherwise we get "_id field cannot be changed"
            const doc = new model(op["replaceOne"]["replacement"], strict, true);
            if (model.schema.options.timestamps) {
                doc.initializeTimestamps();
            }
            if (options.session != null) {
                doc.$session(options.session);
            }
            op["replaceOne"]["replacement"] = doc;
            if (options.skipValidation || op["replaceOne"].skipValidation) {
                op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
                callback(null);
                return;
            }
            op["replaceOne"]["replacement"].$validate({
                __noPromise: true
            }, function(error) {
                if (error) {
                    return callback(error, null);
                }
                op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
                callback(null);
            });
        };
    } else if (op["deleteOne"]) {
        return (callback)=>{
            const model = decideModelByObject(originalModel, op["deleteOne"]["filter"]);
            const schema = model.schema;
            _addDiscriminatorToObject(schema, op["deleteOne"]["filter"]);
            try {
                op["deleteOne"]["filter"] = cast(model.schema, op["deleteOne"]["filter"]);
            } catch (error) {
                return callback(error, null);
            }
            callback(null);
        };
    } else if (op["deleteMany"]) {
        return (callback)=>{
            const model = decideModelByObject(originalModel, op["deleteMany"]["filter"]);
            const schema = model.schema;
            _addDiscriminatorToObject(schema, op["deleteMany"]["filter"]);
            try {
                op["deleteMany"]["filter"] = cast(model.schema, op["deleteMany"]["filter"]);
            } catch (error) {
                return callback(error, null);
            }
            callback(null);
        };
    } else {
        return (callback)=>{
            callback(new Error("Invalid op passed to `bulkWrite()`"), null);
        };
    }
};
function _addDiscriminatorToObject(schema, obj) {
    if (schema == null) {
        return;
    }
    if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
}
/**
 * gets discriminator model if discriminator key is present in object
 * @api private
 */ function decideModelByObject(model, object) {
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (object != null && object.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
    }
    return model;
}


/***/ }),

/***/ 47683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Mixed = __webpack_require__(76541);
const applyBuiltinPlugins = __webpack_require__(76622);
const defineKey = (__webpack_require__(35772)/* .defineKey */ .c);
const get = __webpack_require__(39223);
const utils = __webpack_require__(52100);
const mergeDiscriminatorSchema = __webpack_require__(25959);
const CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
    toJSON: true,
    toObject: true,
    _id: true,
    id: true,
    virtuals: true,
    methods: true
};
/*!
 * ignore
 */ module.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {
    if (!(schema && schema.instanceOfSchema)) {
        throw new Error("You must pass a valid discriminator Schema");
    }
    mergeHooks = mergeHooks == null ? true : mergeHooks;
    if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
        throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
    }
    if (applyPlugins) {
        const applyPluginsToDiscriminators = get(model.base, "options.applyPluginsToDiscriminators", false) || !mergeHooks;
        // Even if `applyPluginsToDiscriminators` isn't set, we should still apply
        // global plugins to schemas embedded in the discriminator schema (gh-7370)
        model.base._applyPlugins(schema, {
            skipTopLevel: !applyPluginsToDiscriminators
        });
    } else if (!mergeHooks) {
        applyBuiltinPlugins(schema);
    }
    const key = model.schema.options.discriminatorKey;
    const existingPath = model.schema.path(key);
    if (existingPath != null) {
        if (!utils.hasUserDefinedProperty(existingPath.options, "select")) {
            existingPath.options.select = true;
        }
        existingPath.options.$skipDiscriminatorCheck = true;
    } else {
        const baseSchemaAddition = {};
        baseSchemaAddition[key] = {
            default: void 0,
            select: true,
            $skipDiscriminatorCheck: true
        };
        baseSchemaAddition[key][model.schema.options.typeKey] = String;
        model.schema.add(baseSchemaAddition);
        defineKey({
            prop: key,
            prototype: model.prototype,
            options: model.schema.options
        });
    }
    if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
        throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
    }
    let value = name;
    if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
        value = tiedValue;
    }
    function merge(schema, baseSchema) {
        // Retain original schema before merging base schema
        schema._baseSchema = baseSchema;
        if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
            schema.remove("_id");
        }
        // Find conflicting paths: if something is a path in the base schema
        // and a nested path in the child schema, overwrite the base schema path.
        // See gh-6076
        const baseSchemaPaths = Object.keys(baseSchema.paths);
        const conflictingPaths = [];
        for (const path of baseSchemaPaths){
            if (schema.nested[path]) {
                conflictingPaths.push(path);
                continue;
            }
            if (path.indexOf(".") === -1) {
                continue;
            }
            const sp = path.split(".").slice(0, -1);
            let cur = "";
            for (const piece of sp){
                cur += (cur.length ? "." : "") + piece;
                if (schema.paths[cur] instanceof Mixed || schema.singleNestedPaths[cur] instanceof Mixed) {
                    conflictingPaths.push(path);
                }
            }
        }
        mergeDiscriminatorSchema(schema, baseSchema, {
            omit: {
                discriminators: true,
                base: true,
                _applyDiscriminators: true
            },
            omitNested: conflictingPaths.reduce((cur, path)=>{
                cur["tree." + path] = true;
                return cur;
            }, {})
        });
        // Clean up conflicting paths _after_ merging re: gh-6076
        for (const conflictingPath of conflictingPaths){
            delete schema.paths[conflictingPath];
        }
        // Rebuild schema models because schemas may have been merged re: #7884
        schema.childSchemas.forEach((obj)=>{
            obj.model.prototype.$__setSchema(obj.schema);
        });
        const obj = {};
        obj[key] = {
            default: value,
            select: true,
            set: function(newName) {
                if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
                    return value;
                }
                throw new Error("Can't set discriminator key \"" + key + '"');
            },
            $skipDiscriminatorCheck: true
        };
        obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;
        schema.add(obj);
        schema.discriminatorMapping = {
            key: key,
            value: value,
            isRoot: false
        };
        if (baseSchema.options.collection) {
            schema.options.collection = baseSchema.options.collection;
        }
        const toJSON = schema.options.toJSON;
        const toObject = schema.options.toObject;
        const _id = schema.options._id;
        const id = schema.options.id;
        const keys = Object.keys(schema.options);
        schema.options.discriminatorKey = baseSchema.options.discriminatorKey;
        for (const _key of keys){
            if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
                // Special case: compiling a model sets `pluralization = true` by default. Avoid throwing an error
                // for that case. See gh-9238
                if (_key === "pluralization" && schema.options[_key] == true && baseSchema.options[_key] == null) {
                    continue;
                }
                if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {
                    throw new Error("Can't customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
                }
            }
        }
        schema.options = utils.clone(baseSchema.options);
        if (toJSON) schema.options.toJSON = toJSON;
        if (toObject) schema.options.toObject = toObject;
        if (typeof _id !== "undefined") {
            schema.options._id = _id;
        }
        schema.options.id = id;
        if (mergeHooks) {
            schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);
        }
        if (applyPlugins) {
            schema.plugins = Array.prototype.slice.call(baseSchema.plugins);
        }
        schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);
        delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema
    }
    // merges base schema into new discriminator schema and sets new type field.
    merge(schema, model.schema);
    if (!model.discriminators) {
        model.discriminators = {};
    }
    if (!model.schema.discriminatorMapping) {
        model.schema.discriminatorMapping = {
            key: key,
            value: null,
            isRoot: true
        };
    }
    if (!model.schema.discriminators) {
        model.schema.discriminators = {};
    }
    model.schema.discriminators[name] = schema;
    if (model.discriminators[name] && !schema.options.overwriteModels) {
        throw new Error('Discriminator with name "' + name + '" already exists');
    }
    return schema;
};


/***/ }),

/***/ 49477:
/***/ ((module) => {

"use strict";

module.exports = function pushNestedArrayPaths(paths, nestedArray, path) {
    if (nestedArray == null) {
        return;
    }
    for(let i = 0; i < nestedArray.length; ++i){
        if (Array.isArray(nestedArray[i])) {
            pushNestedArrayPaths(paths, nestedArray[i], path + "." + i);
        } else {
            paths.push(path + "." + i);
        }
    }
};


/***/ }),

/***/ 5623:
/***/ ((module) => {

"use strict";

module.exports = parallelLimit;
/*!
 * ignore
 */ function parallelLimit(fns, limit, callback) {
    let numInProgress = 0;
    let numFinished = 0;
    let error = null;
    if (limit <= 0) {
        throw new Error("Limit must be positive");
    }
    if (fns.length === 0) {
        return callback(null, []);
    }
    for(let i = 0; i < fns.length && i < limit; ++i){
        _start();
    }
    function _start() {
        fns[numFinished + numInProgress](_done(numFinished + numInProgress));
        ++numInProgress;
    }
    const results = [];
    function _done(index) {
        return (err, res)=>{
            --numInProgress;
            ++numFinished;
            if (error != null) {
                return;
            }
            if (err != null) {
                error = err;
                return callback(error);
            }
            results[index] = res;
            if (numFinished === fns.length) {
                return callback(null, results);
            } else if (numFinished + numInProgress < fns.length) {
                _start();
            }
        };
    }
}


/***/ }),

/***/ 26961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MongooseError = __webpack_require__(51520);
const isMongooseObject = __webpack_require__(36569);
const setDottedPath = __webpack_require__(73479);
const util = __webpack_require__(73837);
/**
 * Given an object that may contain dotted paths, flatten the paths out.
 * For example: `flattenObjectWithDottedPaths({ a: { 'b.c': 42 } })` => `{ a: { b: { c: 42 } } }`
 */ module.exports = function flattenObjectWithDottedPaths(obj) {
    if (obj == null || typeof obj !== "object" || Array.isArray(obj)) {
        return;
    }
    // Avoid Mongoose docs, like docs and maps, because these may cause infinite recursion
    if (isMongooseObject(obj)) {
        return;
    }
    const keys = Object.keys(obj);
    for (const key of keys){
        const val = obj[key];
        if (key.indexOf(".") !== -1) {
            try {
                delete obj[key];
                setDottedPath(obj, key, val);
            } catch (err) {
                if (!(err instanceof TypeError)) {
                    throw err;
                }
                throw new MongooseError(`Conflicting dotted paths when setting document path, key: "${key}", value: ${util.inspect(val)}`);
            }
            continue;
        }
        flattenObjectWithDottedPaths(obj[key]);
    }
};


/***/ }),

/***/ 79478:
/***/ ((module) => {

"use strict";

const dotRE = /\./g;
module.exports = function parentPaths(path) {
    if (path.indexOf(".") === -1) {
        return [
            path
        ];
    }
    const pieces = path.split(dotRE);
    const len = pieces.length;
    const ret = new Array(len);
    let cur = "";
    for(let i = 0; i < len; ++i){
        cur += cur.length !== 0 ? "." + pieces[i] : pieces[i];
        ret[i] = cur;
    }
    return ret;
};


/***/ }),

/***/ 73479:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const specialProperties = __webpack_require__(36848);
module.exports = function setDottedPath(obj, path, val) {
    if (path.indexOf(".") === -1) {
        if (specialProperties.has(path)) {
            return;
        }
        obj[path] = val;
        return;
    }
    const parts = path.split(".");
    const last = parts.pop();
    let cur = obj;
    for (const part of parts){
        if (specialProperties.has(part)) {
            continue;
        }
        if (cur[part] == null) {
            cur[part] = {};
        }
        cur = cur[part];
    }
    if (!specialProperties.has(last)) {
        cur[last] = val;
    }
};


/***/ }),

/***/ 31668:
/***/ ((module, exports) => {

"use strict";

module.exports = pluralize;
/**
 * Pluralization rules.
 */ exports.pluralization = [
    [
        /(m)an$/gi,
        "$1en"
    ],
    [
        /(pe)rson$/gi,
        "$1ople"
    ],
    [
        /(child)$/gi,
        "$1ren"
    ],
    [
        /^(ox)$/gi,
        "$1en"
    ],
    [
        /(ax|test)is$/gi,
        "$1es"
    ],
    [
        /(octop|vir)us$/gi,
        "$1i"
    ],
    [
        /(alias|status)$/gi,
        "$1es"
    ],
    [
        /(bu)s$/gi,
        "$1ses"
    ],
    [
        /(buffal|tomat|potat)o$/gi,
        "$1oes"
    ],
    [
        /([ti])um$/gi,
        "$1a"
    ],
    [
        /sis$/gi,
        "ses"
    ],
    [
        /(?:([^f])fe|([lr])f)$/gi,
        "$1$2ves"
    ],
    [
        /(hive)$/gi,
        "$1s"
    ],
    [
        /([^aeiouy]|qu)y$/gi,
        "$1ies"
    ],
    [
        /(x|ch|ss|sh)$/gi,
        "$1es"
    ],
    [
        /(matr|vert|ind)ix|ex$/gi,
        "$1ices"
    ],
    [
        /([m|l])ouse$/gi,
        "$1ice"
    ],
    [
        /(kn|w|l)ife$/gi,
        "$1ives"
    ],
    [
        /(quiz)$/gi,
        "$1zes"
    ],
    [
        /^goose$/i,
        "geese"
    ],
    [
        /s$/gi,
        "s"
    ],
    [
        /([^a-z])$/,
        "$1"
    ],
    [
        /$/gi,
        "s"
    ]
];
const rules = exports.pluralization;
/**
 * Uncountable words.
 *
 * These words are applied while processing the argument to `toCollectionName`.
 * @api public
 */ exports.uncountables = [
    "advice",
    "energy",
    "excretion",
    "digestion",
    "cooperation",
    "health",
    "justice",
    "labour",
    "machinery",
    "equipment",
    "information",
    "pollution",
    "sewage",
    "paper",
    "money",
    "species",
    "series",
    "rain",
    "rice",
    "fish",
    "sheep",
    "moose",
    "deer",
    "news",
    "expertise",
    "status",
    "media"
];
const uncountables = exports.uncountables;
/**
 * Pluralize function.
 *
 * @author TJ Holowaychuk (extracted from _ext.js_)
 * @param {String} string to pluralize
 * @api private
 */ function pluralize(str) {
    let found;
    str = str.toLowerCase();
    if (!~uncountables.indexOf(str)) {
        found = rules.filter(function(rule) {
            return str.match(rule[0]);
        });
        if (found[0]) {
            return str.replace(found[0][0], found[0][1]);
        }
    }
    return str;
}


/***/ }),

/***/ 95375:
/***/ ((module) => {

"use strict";

module.exports = function SkipPopulateValue(val) {
    if (!(this instanceof SkipPopulateValue)) {
        return new SkipPopulateValue(val);
    }
    this.val = val;
    return this;
};


/***/ }),

/***/ 45483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const leanPopulateMap = __webpack_require__(25747);
const modelSymbol = (__webpack_require__(5089).modelSymbol);
const utils = __webpack_require__(52100);
module.exports = assignRawDocsToIdStructure;
const kHasArray = Symbol("assignRawDocsToIdStructure.hasArray");
/**
 * Assign `vals` returned by mongo query to the `rawIds`
 * structure returned from utils.getVals() honoring
 * query sort order if specified by user.
 *
 * This can be optimized.
 *
 * Rules:
 *
 *   if the value of the path is not an array, use findOne rules, else find.
 *   for findOne the results are assigned directly to doc path (including null results).
 *   for find, if user specified sort order, results are assigned directly
 *   else documents are put back in original order of array if found in results
 *
 * @param {Array} rawIds
 * @param {Array} resultDocs
 * @param {Array} resultOrder
 * @param {Object} options
 * @param {Boolean} recursed
 * @api private
 */ function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {
    // honor user specified sort order
    const newOrder = [];
    const sorting = options.sort && rawIds.length > 1;
    const nullIfNotFound = options.$nullIfNotFound;
    let doc;
    let sid;
    let id;
    if (utils.isMongooseArray(rawIds)) {
        rawIds = rawIds.__array;
    }
    let i = 0;
    const len = rawIds.length;
    if (sorting && recursed && options[kHasArray] === undefined) {
        options[kHasArray] = false;
        for(const key in resultOrder){
            if (Array.isArray(resultOrder[key])) {
                options[kHasArray] = true;
                break;
            }
        }
    }
    for(i = 0; i < len; ++i){
        id = rawIds[i];
        if (Array.isArray(id)) {
            // handle [ [id0, id2], [id3] ]
            assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
            newOrder.push(id);
            continue;
        }
        if (id === null && sorting === false) {
            // keep nulls for findOne unless sorting, which always
            // removes them (backward compat)
            newOrder.push(id);
            continue;
        }
        sid = String(id);
        doc = resultDocs[sid];
        // If user wants separate copies of same doc, use this option
        if (options.clone && doc != null) {
            if (options.lean) {
                const _model = leanPopulateMap.get(doc);
                doc = utils.clone(doc);
                leanPopulateMap.set(doc, _model);
            } else {
                doc = doc.constructor.hydrate(doc._doc);
            }
        }
        if (recursed) {
            if (doc) {
                if (sorting) {
                    const _resultOrder = resultOrder[sid];
                    if (options[kHasArray]) {
                        // If result arrays, rely on the MongoDB server response for ordering
                        newOrder.push(doc);
                    } else {
                        newOrder[_resultOrder] = doc;
                    }
                } else {
                    newOrder.push(doc);
                }
            } else if (id != null && id[modelSymbol] != null) {
                newOrder.push(id);
            } else {
                newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
            }
        } else {
            // apply findOne behavior - if document in results, assign, else assign null
            newOrder[i] = doc || null;
        }
    }
    rawIds.length = 0;
    if (newOrder.length) {
        // reassign the documents based on corrected order
        // forEach skips over sparse entries in arrays so we
        // can safely use this to our advantage dealing with sorted
        // result sets too.
        newOrder.forEach(function(doc, i) {
            rawIds[i] = doc;
        });
    }
}


/***/ }),

/***/ 83970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MongooseMap = __webpack_require__(58269);
const SkipPopulateValue = __webpack_require__(95375);
const assignRawDocsToIdStructure = __webpack_require__(45483);
const get = __webpack_require__(39223);
const getVirtual = __webpack_require__(97712);
const leanPopulateMap = __webpack_require__(25747);
const lookupLocalFields = __webpack_require__(82791);
const markArraySubdocsPopulated = __webpack_require__(53768);
const mpath = __webpack_require__(52988);
const sift = (__webpack_require__(53115)["default"]);
const utils = __webpack_require__(52100);
const { populateModelSymbol  } = __webpack_require__(5089);
module.exports = function assignVals(o) {
    // Options that aren't explicitly listed in `populateOptions`
    const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
    // `o.options` contains options explicitly listed in `populateOptions`, like
    // `match` and `limit`.
    const populateOptions = Object.assign({}, o.options, userOptions, {
        justOne: o.justOne
    });
    populateOptions.$nullIfNotFound = o.isVirtual;
    const populatedModel = o.populatedModel;
    const originalIds = [].concat(o.rawIds);
    // replace the original ids in our intermediate _ids structure
    // with the documents found by query
    o.allIds = [].concat(o.allIds);
    assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
    // now update the original documents being populated using the
    // result structure that contains real documents.
    const docs = o.docs;
    const rawIds = o.rawIds;
    const options = o.options;
    const count = o.count && o.isVirtual;
    let i;
    function setValue(val) {
        if (count) {
            return val;
        }
        if (val instanceof SkipPopulateValue) {
            return val.val;
        }
        if (val === void 0) {
            return val;
        }
        const _allIds = o.allIds[i];
        if (o.path.endsWith(".$*")) {
            // Skip maps re: gh-12494
            return valueFilter(val, options, populateOptions, _allIds);
        }
        if (o.justOne === true && Array.isArray(val)) {
            // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right
            // model before assigning.
            const ret = [];
            for (const doc of val){
                const _docPopulatedModel = leanPopulateMap.get(doc);
                if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
                    ret.push(doc);
                }
            }
            // Since we don't want to have to create a new mongoosearray, make sure to
            // modify the array in place
            while(val.length > ret.length){
                Array.prototype.pop.apply(val, []);
            }
            for(let i = 0; i < ret.length; ++i){
                val[i] = ret[i];
            }
            return valueFilter(val[0], options, populateOptions, _allIds);
        } else if (o.justOne === false && !Array.isArray(val)) {
            return valueFilter([
                val
            ], options, populateOptions, _allIds);
        }
        return valueFilter(val, options, populateOptions, _allIds);
    }
    for(i = 0; i < docs.length; ++i){
        const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
        const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
        if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
            continue;
        }
        let valueToSet;
        if (count) {
            valueToSet = numDocs(rawIds[i]);
        } else if (Array.isArray(o.match)) {
            valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [
                rawIds[i]
            ].filter(sift(o.match[i]))[0];
        } else {
            valueToSet = rawIds[i];
        }
        // If we're populating a map, the existing value will be an object, so
        // we need to transform again
        const originalSchema = o.originalModel.schema;
        const isDoc = get(docs[i], "$__", null) != null;
        let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);
        // If we pass the first check, also make sure the local field's schematype
        // is map (re: gh-6460)
        isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
        if (!o.isVirtual && isMap) {
            const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
            valueToSet = valueToSet.reduce((cur, v, i)=>{
                cur.set(_keys[i], v);
                return cur;
            }, new Map());
        }
        if (isDoc && Array.isArray(valueToSet)) {
            for (const val of valueToSet){
                if (val != null && val.$__ != null) {
                    val.$__.parent = docs[i];
                }
            }
        } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
            valueToSet.$__.parent = docs[i];
        }
        if (o.isVirtual && isDoc) {
            docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
            // If virtual populate and doc is already init-ed, need to walk through
            // the actual doc to set rather than setting `_doc` directly
            if (Array.isArray(valueToSet)) {
                valueToSet = valueToSet.map((v)=>v == null ? void 0 : v);
            }
            mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);
            continue;
        }
        const parts = _path.split(".");
        let cur = docs[i];
        const curPath = parts[0];
        for(let j = 0; j < parts.length - 1; ++j){
            // If we get to an array with a dotted path, like `arr.foo`, don't set
            // `foo` on the array.
            if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
                break;
            }
            if (parts[j] === "$*") {
                break;
            }
            if (cur[parts[j]] == null) {
                // If nothing to set, avoid creating an unnecessary array. Otherwise
                // we'll end up with a single doc in the array with only defaults.
                // See gh-8342, gh-8455
                const schematype = originalSchema._getSchema(curPath);
                if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
                    break;
                }
                cur[parts[j]] = {};
            }
            cur = cur[parts[j]];
            // If the property in MongoDB is a primitive, we won't be able to populate
            // the nested path, so skip it. See gh-7545
            if (typeof cur !== "object") {
                break;
            }
        }
        if (docs[i].$__) {
            o.allOptions.options[populateModelSymbol] = o.allOptions.model;
            docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);
            if (valueToSet != null && valueToSet.$__ != null) {
                valueToSet.$__.wasPopulated = {
                    value: o.unpopulatedValues[i]
                };
            }
            if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {
                valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);
            }
        }
        // If lean, need to check that each individual virtual respects
        // `justOne`, because you may have a populated virtual with `justOne`
        // underneath an array. See gh-6867
        mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
        if (docs[i].$__) {
            markArraySubdocsPopulated(docs[i], [
                o.allOptions.options
            ]);
        }
    }
};
function numDocs(v) {
    if (Array.isArray(v)) {
        // If setting underneath an array of populated subdocs, we may have an
        // array of arrays. See gh-7573
        if (v.some((el)=>Array.isArray(el) || el === null)) {
            return v.map((el)=>{
                if (el == null) {
                    return 0;
                }
                if (Array.isArray(el)) {
                    return el.filter((el)=>el != null).length;
                }
                return 1;
            });
        }
        return v.filter((el)=>el != null).length;
    }
    return v == null ? 0 : 1;
}
/**
 * 1) Apply backwards compatible find/findOne behavior to sub documents
 *
 *    find logic:
 *      a) filter out non-documents
 *      b) remove _id from sub docs when user specified
 *
 *    findOne
 *      a) if no doc found, set to null
 *      b) remove _id from sub docs when user specified
 *
 * 2) Remove _ids when specified by users query.
 *
 * background:
 * _ids are left in the query even when user excludes them so
 * that population mapping can occur.
 * @param {Any} val
 * @param {Object} assignmentOpts
 * @param {Object} populateOptions
 * @param {Function} [populateOptions.transform]
 * @param {Boolean} allIds
 * @api private
 */ function valueFilter(val, assignmentOpts, populateOptions, allIds) {
    const userSpecifiedTransform = typeof populateOptions.transform === "function";
    const transform = userSpecifiedTransform ? populateOptions.transform : noop;
    if (Array.isArray(val)) {
        // find logic
        const ret = [];
        const numValues = val.length;
        for(let i = 0; i < numValues; ++i){
            let subdoc = val[i];
            const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;
            if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
                continue;
            } else if (!populateOptions.retainNullValues && subdoc == null) {
                continue;
            } else if (userSpecifiedTransform) {
                subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
            }
            maybeRemoveId(subdoc, assignmentOpts);
            ret.push(subdoc);
            if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {
                break;
            }
        }
        const rLen = ret.length;
        // Since we don't want to have to create a new mongoosearray, make sure to
        // modify the array in place
        while(val.length > rLen){
            Array.prototype.pop.apply(val, []);
        }
        let i = 0;
        if (utils.isMongooseArray(val)) {
            for(i = 0; i < rLen; ++i){
                val.set(i, ret[i], true);
            }
        } else {
            for(i = 0; i < rLen; ++i){
                val[i] = ret[i];
            }
        }
        return val;
    }
    // findOne
    if (isPopulatedObject(val) || utils.isPOJO(val)) {
        maybeRemoveId(val, assignmentOpts);
        return transform(val, allIds);
    }
    if (val instanceof Map) {
        return val;
    }
    if (populateOptions.justOne === false) {
        return [];
    }
    return val == null ? transform(val, allIds) : transform(null, allIds);
}
/**
 * Remove _id from `subdoc` if user specified "lean" query option
 * @param {Document} subdoc
 * @param {Object} assignmentOpts
 * @api private
 */ function maybeRemoveId(subdoc, assignmentOpts) {
    if (subdoc != null && assignmentOpts.excludeId) {
        if (typeof subdoc.$__setValue === "function") {
            delete subdoc._doc._id;
        } else {
            delete subdoc._id;
        }
    }
}
/**
 * Determine if `obj` is something we can set a populated path to. Can be a
 * document, a lean document, or an array/map that contains docs.
 * @param {Any} obj
 * @api private
 */ function isPopulatedObject(obj) {
    if (obj == null) {
        return false;
    }
    return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
}
function noop(v) {
    return v;
}


/***/ }),

/***/ 57851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SkipPopulateValue = __webpack_require__(95375);
const parentPaths = __webpack_require__(79478);
const { trusted  } = __webpack_require__(79657);
const hasDollarKeys = __webpack_require__(11029);
module.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
    const match = _formatMatch(_match);
    if (_foreignField.size === 1) {
        const foreignField = Array.from(_foreignField)[0];
        const foreignSchemaType = model.schema.path(foreignField);
        if (foreignField !== "_id" || !match["_id"]) {
            ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
            match[foreignField] = trusted({
                $in: ids
            });
        } else if (foreignField === "_id" && match["_id"]) {
            const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : {
                $eq: match[foreignField]
            };
            match[foreignField] = {
                ...trusted({
                    $in: ids
                }),
                ...userSpecifiedMatch
            };
        }
        const _parentPaths = parentPaths(foreignField);
        for(let i = 0; i < _parentPaths.length - 1; ++i){
            const cur = _parentPaths[i];
            if (match[cur] != null && match[cur].$elemMatch != null) {
                match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({
                    $in: ids
                });
                delete match[foreignField];
                break;
            }
        }
    } else {
        const $or = [];
        if (Array.isArray(match.$or)) {
            match.$and = [
                {
                    $or: match.$or
                },
                {
                    $or: $or
                }
            ];
            delete match.$or;
        } else {
            match.$or = $or;
        }
        for (const foreignField of _foreignField){
            if (foreignField !== "_id" || !match["_id"]) {
                const foreignSchemaType = model.schema.path(foreignField);
                ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
                $or.push({
                    [foreignField]: {
                        $in: ids
                    }
                });
            } else if (foreignField === "_id" && match["_id"]) {
                const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : {
                    $eq: match[foreignField]
                };
                match[foreignField] = {
                    ...trusted({
                        $in: ids
                    }),
                    ...userSpecifiedMatch
                };
            }
        }
    }
    return match;
};
/**
 * Optionally filter out invalid ids that don't conform to foreign field's schema
 * to avoid cast errors (gh-7706)
 * @param {Array} ids
 * @param {SchemaType} foreignSchemaType
 * @param {Boolean} [skipInvalidIds]
 * @api private
 */ function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
    ids = ids.filter((v)=>!(v instanceof SkipPopulateValue));
    if (!skipInvalidIds) {
        return ids;
    }
    return ids.filter((id)=>{
        try {
            foreignSchemaType.cast(id);
            return true;
        } catch (err) {
            return false;
        }
    });
}
/**
 * Format `mod.match` given that it may be an array that we need to $or if
 * the client has multiple docs with match functions
 * @param {Array|Any} match
 * @api private
 */ function _formatMatch(match) {
    if (Array.isArray(match)) {
        if (match.length > 1) {
            return {
                $or: [].concat(match.map((m)=>Object.assign({}, m)))
            };
        }
        return Object.assign({}, match[0]);
    }
    return Object.assign({}, match);
}


/***/ }),

/***/ 87839:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MongooseError = __webpack_require__(40413);
const SkipPopulateValue = __webpack_require__(95375);
const get = __webpack_require__(39223);
const getDiscriminatorByValue = __webpack_require__(17492);
const getConstructorName = __webpack_require__(4065);
const getSchemaTypes = __webpack_require__(25511);
const getVirtual = __webpack_require__(97712);
const lookupLocalFields = __webpack_require__(82791);
const mpath = __webpack_require__(52988);
const modelNamesFromRefPath = __webpack_require__(68360);
const utils = __webpack_require__(52100);
const modelSymbol = (__webpack_require__(5089).modelSymbol);
const populateModelSymbol = (__webpack_require__(5089).populateModelSymbol);
const schemaMixedSymbol = (__webpack_require__(36825).schemaMixedSymbol);
const StrictPopulate = __webpack_require__(96546);
module.exports = function getModelsMapForPopulate(model, docs, options) {
    let doc;
    const len = docs.length;
    const map = [];
    const modelNameFromQuery = options.model && options.model.modelName || options.model;
    let schema;
    let refPath;
    let modelNames;
    const available = {};
    const modelSchema = model.schema;
    // Populating a nested path should always be a no-op re: #9073.
    // People shouldn't do this, but apparently they do.
    if (options._localModel != null && options._localModel.schema.nested[options.path]) {
        return [];
    }
    const _virtualRes = getVirtual(model.schema, options.path);
    const virtual = _virtualRes == null ? null : _virtualRes.virtual;
    if (virtual != null) {
        return _virtualPopulate(model, docs, options, _virtualRes);
    }
    let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);
    allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [
        allSchemaTypes
    ].filter((v)=>v != null);
    if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {
        return new StrictPopulate(options._fullPath || options.path);
    }
    for(let i = 0; i < len; i++){
        doc = docs[i];
        let justOne = null;
        const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;
        schema = getSchemaTypes(model, docSchema, doc, options.path);
        // Special case: populating a path that's a DocumentArray unless
        // there's an explicit `ref` or `refPath` re: gh-8946
        if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
            continue;
        }
        const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
        if (isUnderneathDocArray && get(options, "options.sort") != null) {
            return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
        }
        modelNames = null;
        let isRefPath = false;
        let normalizedRefPath = null;
        let schemaOptions = null;
        let modelNamesInOrder = null;
        if (schema != null && schema.instance === "Embedded") {
            if (schema.options.ref) {
                const data = {
                    localField: options.path + "._id",
                    foreignField: "_id",
                    justOne: true
                };
                const res = _getModelNames(doc, schema, modelNameFromQuery, model);
                const unpopulatedValue = mpath.get(options.path, doc);
                const id = mpath.get("_id", unpopulatedValue);
                addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);
            }
            continue;
        }
        if (Array.isArray(schema)) {
            const schemasArray = schema;
            for (const _schema of schemasArray){
                let _modelNames;
                let res;
                try {
                    res = _getModelNames(doc, _schema, modelNameFromQuery, model);
                    _modelNames = res.modelNames;
                    isRefPath = isRefPath || res.isRefPath;
                    normalizedRefPath = normalizedRefPath || res.refPath;
                    justOne = res.justOne;
                } catch (error) {
                    return error;
                }
                if (isRefPath && !res.isRefPath) {
                    continue;
                }
                if (!_modelNames) {
                    continue;
                }
                modelNames = modelNames || [];
                for (const modelName of _modelNames){
                    if (modelNames.indexOf(modelName) === -1) {
                        modelNames.push(modelName);
                    }
                }
            }
        } else {
            try {
                const res = _getModelNames(doc, schema, modelNameFromQuery, model);
                modelNames = res.modelNames;
                isRefPath = res.isRefPath;
                normalizedRefPath = normalizedRefPath || res.refPath;
                justOne = res.justOne;
                schemaOptions = get(schema, "options.populate", null);
                // Dedupe, because `refPath` can return duplicates of the same model name,
                // and that causes perf issues.
                if (isRefPath) {
                    modelNamesInOrder = modelNames;
                    modelNames = Array.from(new Set(modelNames));
                }
            } catch (error) {
                return error;
            }
            if (!modelNames) {
                continue;
            }
        }
        const data = {};
        const localField = options.path;
        const foreignField = "_id";
        // `justOne = null` means we don't know from the schema whether the end
        // result should be an array or a single doc. This can result from
        // populating a POJO using `Model.populate()`
        if ("justOne" in options && options.justOne !== void 0) {
            justOne = options.justOne;
        } else if (schema && !schema[schemaMixedSymbol]) {
            // Skip Mixed types because we explicitly don't do casting on those.
            if (options.path.endsWith("." + schema.path) || options.path === schema.path) {
                justOne = Array.isArray(schema) ? schema.every((schema)=>!schema.$isMongooseArray) : !schema.$isMongooseArray;
            }
        }
        if (!modelNames) {
            continue;
        }
        data.isVirtual = false;
        data.justOne = justOne;
        data.localField = localField;
        data.foreignField = foreignField;
        // Get local fields
        const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);
        const id = String(utils.getValue(foreignField, doc));
        options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
        let match = get(options, "match", null);
        const hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
            match = match.call(doc, doc);
        }
        data.match = match;
        data.hasMatchFunction = hasMatchFunction;
        data.isRefPath = isRefPath;
        data.modelNamesInOrder = modelNamesInOrder;
        if (isRefPath) {
            const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);
            modelNames = embeddedDiscriminatorModelNames || modelNames;
        }
        try {
            addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);
        } catch (err) {
            return err;
        }
    }
    return map;
    function _getModelNames(doc, schema, modelNameFromQuery, model) {
        let modelNames;
        let isRefPath = false;
        let justOne = null;
        const originalSchema = schema;
        if (schema && schema.instance === "Array") {
            schema = schema.caster;
        }
        if (schema && schema.$isSchemaMap) {
            schema = schema.$__schemaType;
        }
        const ref = schema && schema.options && schema.options.ref;
        refPath = schema && schema.options && schema.options.refPath;
        if (schema != null && schema[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {
            return {
                modelNames: null
            };
        }
        if (modelNameFromQuery) {
            modelNames = [
                modelNameFromQuery
            ]; // query options
        } else if (refPath != null) {
            if (typeof refPath === "function") {
                const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);
                const vals = mpath.get(subdocPath, doc, lookupLocalFields);
                const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [
                    vals
                ] : [];
                modelNames = new Set();
                for (const subdoc of subdocsBeingPopulated){
                    refPath = refPath.call(subdoc, subdoc, options.path);
                    modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach((name)=>modelNames.add(name));
                }
                modelNames = Array.from(modelNames);
            } else {
                modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);
            }
            isRefPath = true;
        } else {
            let ref;
            let refPath;
            let schemaForCurrentDoc;
            let discriminatorValue;
            let modelForCurrentDoc = model;
            const discriminatorKey = model.schema.options.discriminatorKey;
            if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {
                // `modelNameForFind` is the discriminator value, so we might need
                // find the discriminated model name
                const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;
                if (discriminatorModel != null) {
                    modelForCurrentDoc = discriminatorModel;
                } else {
                    try {
                        modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);
                    } catch (error) {
                        return error;
                    }
                }
                schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
                if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
                    schemaForCurrentDoc = schemaForCurrentDoc.caster;
                }
            } else {
                schemaForCurrentDoc = schema;
            }
            if (originalSchema && originalSchema.path.endsWith(".$*")) {
                justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;
            } else if (schemaForCurrentDoc != null) {
                justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
            }
            if ((ref = get(schemaForCurrentDoc, "options.ref")) != null) {
                if (schemaForCurrentDoc != null && typeof ref === "function" && options.path.endsWith("." + schemaForCurrentDoc.path)) {
                    // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469
                    modelNames = new Set();
                    const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
                    const vals = mpath.get(subdocPath, doc, lookupLocalFields);
                    const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [
                        vals
                    ] : [];
                    for (const subdoc of subdocsBeingPopulated){
                        modelNames.add(handleRefFunction(ref, subdoc));
                    }
                    if (subdocsBeingPopulated.length === 0) {
                        modelNames = [
                            handleRefFunction(ref, doc)
                        ];
                    } else {
                        modelNames = Array.from(modelNames);
                    }
                } else {
                    ref = handleRefFunction(ref, doc);
                    modelNames = [
                        ref
                    ];
                }
            } else if ((schemaForCurrentDoc = get(schema, "options.refPath")) != null) {
                isRefPath = true;
                if (typeof refPath === "function") {
                    const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
                    const vals = mpath.get(subdocPath, doc, lookupLocalFields);
                    const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [
                        vals
                    ] : [];
                    modelNames = new Set();
                    for (const subdoc of subdocsBeingPopulated){
                        refPath = refPath.call(subdoc, subdoc, options.path);
                        modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach((name)=>modelNames.add(name));
                    }
                    modelNames = Array.from(modelNames);
                } else {
                    modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);
                }
            }
        }
        if (!modelNames) {
            // `Model.populate()` on a POJO with no known local model. Default to using the `Model`
            if (options._localModel == null) {
                modelNames = [
                    model.modelName
                ];
            } else {
                return {
                    modelNames: modelNames,
                    justOne: justOne,
                    isRefPath: isRefPath,
                    refPath: refPath
                };
            }
        }
        if (!Array.isArray(modelNames)) {
            modelNames = [
                modelNames
            ];
        }
        return {
            modelNames: modelNames,
            justOne: justOne,
            isRefPath: isRefPath,
            refPath: refPath
        };
    }
};
/*!
 * ignore
 */ function _virtualPopulate(model, docs, options, _virtualRes) {
    const map = [];
    const available = {};
    const virtual = _virtualRes.virtual;
    for (const doc of docs){
        let modelNames = null;
        const data = {};
        // localField and foreignField
        let localField;
        const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
        if (typeof options.localField === "string") {
            localField = options.localField;
        } else if (typeof virtual.options.localField === "function") {
            localField = virtualPrefix + virtual.options.localField.call(doc, doc);
        } else if (Array.isArray(virtual.options.localField)) {
            localField = virtual.options.localField.map((field)=>virtualPrefix + field);
        } else {
            localField = virtualPrefix + virtual.options.localField;
        }
        data.count = virtual.options.count;
        if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
            options.skip = virtual.options.skip;
        }
        if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
            options.limit = virtual.options.limit;
        }
        if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
            options.perDocumentLimit = virtual.options.perDocumentLimit;
        }
        let foreignField = virtual.options.foreignField;
        if (!localField || !foreignField) {
            return new MongooseError("If you are populating a virtual, you must set the " + "localField and foreignField options");
        }
        if (typeof localField === "function") {
            localField = localField.call(doc, doc);
        }
        if (typeof foreignField === "function") {
            foreignField = foreignField.call(doc, doc);
        }
        data.isRefPath = false;
        // `justOne = null` means we don't know from the schema whether the end
        // result should be an array or a single doc. This can result from
        // populating a POJO using `Model.populate()`
        let justOne = null;
        if ("justOne" in options && options.justOne !== void 0) {
            justOne = options.justOne;
        }
        if (virtual.options.refPath) {
            modelNames = modelNamesFromRefPath(virtual.options.refPath, doc, options.path);
            justOne = !!virtual.options.justOne;
            data.isRefPath = true;
        } else if (virtual.options.ref) {
            let normalizedRef;
            if (typeof virtual.options.ref === "function" && !virtual.options.ref[modelSymbol]) {
                normalizedRef = virtual.options.ref.call(doc, doc);
            } else {
                normalizedRef = virtual.options.ref;
            }
            justOne = !!virtual.options.justOne;
            // When referencing nested arrays, the ref should be an Array
            // of modelNames.
            if (Array.isArray(normalizedRef)) {
                modelNames = normalizedRef;
            } else {
                modelNames = [
                    normalizedRef
                ];
            }
        }
        data.isVirtual = true;
        data.virtual = virtual;
        data.justOne = justOne;
        // `match`
        let match = get(options, "match", null) || get(data, "virtual.options.match", null) || get(data, "virtual.options.options.match", null);
        let hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
            match = match.call(doc, doc);
        }
        if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
            match = Object.assign({}, match);
            for(let i = 1; i < localField.length; ++i){
                match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);
                hasMatchFunction = true;
            }
            localField = localField[0];
            foreignField = foreignField[0];
        }
        data.localField = localField;
        data.foreignField = foreignField;
        data.match = match;
        data.hasMatchFunction = hasMatchFunction;
        // Get local fields
        const ret = _getLocalFieldValues(doc, localField, model, options, virtual);
        try {
            addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);
        } catch (err) {
            return err;
        }
    }
    return map;
}
/*!
 * ignore
 */ function addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {
    // `PopulateOptions#connection`: if the model is passed as a string, the
    // connection matters because different connections have different models.
    const connection = options.connection != null ? options.connection : model.db;
    unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;
    if (Array.isArray(unpopulatedValue)) {
        unpopulatedValue = utils.cloneArrays(unpopulatedValue);
    }
    if (modelNames == null) {
        return;
    }
    let k = modelNames.length;
    while(k--){
        const modelName = modelNames[k];
        if (modelName == null) {
            continue;
        }
        let Model;
        if (options.model && options.model[modelSymbol]) {
            Model = options.model;
        } else if (modelName[modelSymbol]) {
            Model = modelName;
        } else {
            try {
                Model = _getModelFromConn(connection, modelName);
            } catch (err) {
                if (ret !== void 0) {
                    throw err;
                }
                Model = null;
            }
        }
        let ids = ret;
        const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];
        const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;
        if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {
            ids = flat.filter((val, i)=>modelNamesForRefPath[i] === modelName);
        }
        const perDocumentLimit = options.perDocumentLimit == null ? get(options, "options.perDocumentLimit", null) : options.perDocumentLimit;
        if (!available[modelName] || perDocumentLimit != null) {
            const currentOptions = {
                model: Model
            };
            if (data.isVirtual && get(data.virtual, "options.options")) {
                currentOptions.options = utils.clone(data.virtual.options.options);
            } else if (schemaOptions != null) {
                currentOptions.options = Object.assign({}, schemaOptions);
            }
            utils.merge(currentOptions, options);
            // Used internally for checking what model was used to populate this
            // path.
            options[populateModelSymbol] = Model;
            available[modelName] = {
                model: Model,
                options: currentOptions,
                match: data.hasMatchFunction ? [
                    data.match
                ] : data.match,
                docs: [
                    doc
                ],
                ids: [
                    ids
                ],
                allIds: [
                    ret
                ],
                unpopulatedValues: [
                    unpopulatedValue
                ],
                localField: new Set([
                    data.localField
                ]),
                foreignField: new Set([
                    data.foreignField
                ]),
                justOne: data.justOne,
                isVirtual: data.isVirtual,
                virtual: data.virtual,
                count: data.count,
                [populateModelSymbol]: Model
            };
            map.push(available[modelName]);
        } else {
            available[modelName].localField.add(data.localField);
            available[modelName].foreignField.add(data.foreignField);
            available[modelName].docs.push(doc);
            available[modelName].ids.push(ids);
            available[modelName].allIds.push(ret);
            available[modelName].unpopulatedValues.push(unpopulatedValue);
            if (data.hasMatchFunction) {
                available[modelName].match.push(data.match);
            }
        }
    }
}
function _getModelFromConn(conn, modelName) {
    /* If this connection has a parent from `useDb()`, bubble up to parent's models */ if (conn.models[modelName] == null && conn._parent != null) {
        return _getModelFromConn(conn._parent, modelName);
    }
    return conn.model(modelName);
}
/*!
 * ignore
 */ function handleRefFunction(ref, doc) {
    if (typeof ref === "function" && !ref[modelSymbol]) {
        return ref.call(doc, doc);
    }
    return ref;
}
/*!
 * ignore
 */ function _getLocalFieldValues(doc, localField, model, options, virtual, schema) {
    // Get Local fields
    const localFieldPathType = model.schema._getPathType(localField);
    const localFieldPath = localFieldPathType === "real" ? model.schema.path(localField) : localFieldPathType.schema;
    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
    localField = localFieldPath != null && localFieldPath.instance === "Embedded" ? localField + "._id" : localField;
    const _populateOptions = get(options, "options", {});
    const getters = "getters" in _populateOptions ? _populateOptions.getters : get(virtual, "options.getters", false);
    if (localFieldGetters.length !== 0 && getters) {
        const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
        const localFieldValue = utils.getValue(localField, doc);
        if (Array.isArray(localFieldValue)) {
            const localFieldHydratedValue = utils.getValue(localField.split(".").slice(0, -1), hydratedDoc);
            return localFieldValue.map((localFieldArrVal, localFieldArrIndex)=>localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
        } else {
            return localFieldPath.applyGetters(localFieldValue, hydratedDoc);
        }
    } else {
        return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
    }
}
/**
 * Retrieve the _id of `val` if a Document or Array of Documents.
 *
 * @param {Array|Document|Any} val
 * @param {Schema} schema
 * @return {Array|Document|Any}
 * @api private
 */ function convertTo_id(val, schema) {
    if (val != null && val.$__ != null) {
        return val._id;
    }
    if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
        return val._id;
    }
    if (Array.isArray(val)) {
        const rawVal = val.__array != null ? val.__array : val;
        for(let i = 0; i < rawVal.length; ++i){
            if (rawVal[i] != null && rawVal[i].$__ != null) {
                rawVal[i] = rawVal[i]._id;
            }
        }
        if (utils.isMongooseArray(val) && val.$schema()) {
            return val.$schema()._castForPopulate(val, val.$parent());
        }
        return [].concat(val);
    }
    // `populate('map')` may be an object if populating on a doc that hasn't
    // been hydrated yet
    if (getConstructorName(val) === "Object" && // The intent here is we should only flatten the object if we expect
    // to get a Map in the end. Avoid doing this for mixed types.
    (schema == null || schema[schemaMixedSymbol] == null)) {
        const ret = [];
        for (const key of Object.keys(val)){
            ret.push(val[key]);
        }
        return ret;
    }
    // If doc has already been hydrated, e.g. `doc.populate('map')`
    // then `val` will already be a map
    if (val instanceof Map) {
        return Array.from(val.values());
    }
    return val;
}
/*!
 * ignore
 */ function _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {
    // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear
    // out embedded discriminator docs that don't have a `refPath` on the
    // populated path.
    if (!data.isRefPath || normalizedRefPath == null) {
        return;
    }
    const pieces = normalizedRefPath.split(".");
    let cur = "";
    let modelNames = void 0;
    for(let i = 0; i < pieces.length; ++i){
        const piece = pieces[i];
        cur = cur + (cur.length === 0 ? "" : ".") + piece;
        const schematype = modelSchema.path(cur);
        if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {
            const subdocs = utils.getValue(cur, doc);
            const remnant = options.path.substring(cur.length + 1);
            const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
            modelNames = [];
            for (const subdoc of subdocs){
                const discriminatorName = utils.getValue(discriminatorKey, subdoc);
                const discriminator = schematype.caster.discriminators[discriminatorName];
                const discriminatorSchema = discriminator && discriminator.schema;
                if (discriminatorSchema == null) {
                    continue;
                }
                const _path = discriminatorSchema.path(remnant);
                if (_path == null || _path.options.refPath == null) {
                    const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);
                    ret.forEach((v, i)=>{
                        if (v === docValue) {
                            ret[i] = SkipPopulateValue(v);
                        }
                    });
                    continue;
                }
                const modelName = utils.getValue(pieces.slice(i + 1).join("."), subdoc);
                modelNames.push(modelName);
            }
        }
    }
    return modelNames;
}


/***/ }),

/***/ 25511:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * ignore
 */ const Mixed = __webpack_require__(76541);
const get = __webpack_require__(39223);
const getDiscriminatorByValue = __webpack_require__(17492);
const leanPopulateMap = __webpack_require__(25747);
const mpath = __webpack_require__(52988);
const populateModelSymbol = (__webpack_require__(5089).populateModelSymbol);
/**
 * Given a model and its schema, find all possible schema types for `path`,
 * including searching through discriminators. If `doc` is specified, will
 * use the doc's values for discriminator keys when searching, otherwise
 * will search all discriminators.
 *
 * @param {Model} model
 * @param {Schema} schema
 * @param {Object} doc POJO
 * @param {string} path
 * @api private
 */ module.exports = function getSchemaTypes(model, schema, doc, path) {
    const pathschema = schema.path(path);
    const topLevelDoc = doc;
    if (pathschema) {
        return pathschema;
    }
    const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;
    if (discriminatorKey && model != null) {
        if (doc != null && doc[discriminatorKey] != null) {
            const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
            schema = discriminator ? discriminator.schema : schema;
        } else if (model.discriminators != null) {
            return Object.keys(model.discriminators).reduce((arr, name)=>{
                const disc = model.discriminators[name];
                return arr.concat(getSchemaTypes(disc, disc.schema, null, path));
            }, []);
        }
    }
    function search(parts, schema, subdoc, nestedPath) {
        let p = parts.length + 1;
        let foundschema;
        let trypath;
        while(p--){
            trypath = parts.slice(0, p).join(".");
            foundschema = schema.path(trypath);
            if (foundschema == null) {
                continue;
            }
            if (foundschema.caster) {
                // array of Mixed?
                if (foundschema.caster instanceof Mixed) {
                    return foundschema.caster;
                }
                let schemas = null;
                if (foundschema.schema != null && foundschema.schema.discriminators != null) {
                    const discriminators = foundschema.schema.discriminators;
                    const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
                    const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
                    schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
                        const tiedValue = discriminators[discriminator].discriminatorMapping.value;
                        if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                            cur.push(discriminators[discriminator]);
                        }
                        return cur;
                    }, []);
                }
                // Now that we found the array, we need to check if there
                // are remaining document paths to look up for casting.
                // Also we need to handle array.$.path since schema.path
                // doesn't work for that.
                // If there is no foundschema.schema we are dealing with
                // a path like array.$
                if (p !== parts.length && foundschema.schema) {
                    let ret;
                    if (parts[p] === "$") {
                        if (p + 1 === parts.length) {
                            // comments.$
                            return foundschema;
                        }
                        // comments.$.comments.$.title
                        ret = search(parts.slice(p + 1), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));
                        if (ret) {
                            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                        }
                        return ret;
                    }
                    if (schemas != null && schemas.length > 0) {
                        ret = [];
                        for (const schema of schemas){
                            const _ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));
                            if (_ret != null) {
                                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                                if (_ret.$isUnderneathDocArray) {
                                    ret.$isUnderneathDocArray = true;
                                }
                                ret.push(_ret);
                            }
                        }
                        return ret;
                    } else {
                        ret = search(parts.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));
                        if (ret) {
                            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                        }
                        return ret;
                    }
                } else if (p !== parts.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
                    // Nested arrays. Drill down to the bottom of the nested array.
                    let type = foundschema;
                    while(type.$isMongooseArray && !type.$isMongooseDocumentArray){
                        type = type.casterConstructor;
                    }
                    const ret = search(parts.slice(p), type.schema, null, nestedPath.concat(parts.slice(0, p)));
                    if (ret != null) {
                        return ret;
                    }
                    if (type.schema.discriminators) {
                        const discriminatorPaths = [];
                        for (const discriminatorName of Object.keys(type.schema.discriminators)){
                            const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                            const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));
                            if (ret != null) {
                                discriminatorPaths.push(ret);
                            }
                        }
                        if (discriminatorPaths.length > 0) {
                            return discriminatorPaths;
                        }
                    }
                }
            } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {
                return foundschema.$__schemaType;
            }
            const fullPath = nestedPath.concat([
                trypath
            ]).join(".");
            if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {
                const model = doc.$__.populated[fullPath].options[populateModelSymbol];
                if (model != null) {
                    const ret = search(parts.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));
                    if (ret) {
                        ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !model.schema.$isSingleNested;
                    }
                    return ret;
                }
            }
            const _val = get(topLevelDoc, trypath);
            if (_val != null) {
                const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
                // Populated using lean, `leanPopulateMap` value is the foreign model
                const schema = model != null ? model.schema : null;
                if (schema != null) {
                    const ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));
                    if (ret != null) {
                        ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !schema.$isSingleNested;
                        return ret;
                    }
                }
            }
            return foundschema;
        }
    }
    // look for arrays
    const parts = path.split(".");
    for(let i = 0; i < parts.length; ++i){
        if (parts[i] === "$") {
            // Re: gh-5628, because `schema.path()` doesn't take $ into account.
            parts[i] = "0";
        }
    }
    return search(parts, schema, doc, []);
};


/***/ }),

/***/ 97712:
/***/ ((module) => {

"use strict";

module.exports = getVirtual;
/*!
 * ignore
 */ function getVirtual(schema, name) {
    if (schema.virtuals[name]) {
        return {
            virtual: schema.virtuals[name],
            path: void 0
        };
    }
    const parts = name.split(".");
    let cur = "";
    let nestedSchemaPath = "";
    for(let i = 0; i < parts.length; ++i){
        cur += (cur.length > 0 ? "." : "") + parts[i];
        if (schema.virtuals[cur]) {
            if (i === parts.length - 1) {
                return {
                    virtual: schema.virtuals[cur],
                    path: nestedSchemaPath
                };
            }
            continue;
        }
        if (schema.nested[cur]) {
            continue;
        }
        if (schema.paths[cur] && schema.paths[cur].schema) {
            schema = schema.paths[cur].schema;
            const rest = parts.slice(i + 1).join(".");
            if (schema.virtuals[rest]) {
                if (i === parts.length - 2) {
                    return {
                        virtual: schema.virtuals[rest],
                        nestedSchemaPath: [
                            nestedSchemaPath,
                            cur
                        ].filter((v)=>!!v).join(".")
                    };
                }
                continue;
            }
            if (i + 1 < parts.length && schema.discriminators) {
                for (const key of Object.keys(schema.discriminators)){
                    const res = getVirtual(schema.discriminators[key], rest);
                    if (res != null) {
                        const _path = [
                            nestedSchemaPath,
                            cur,
                            res.nestedSchemaPath
                        ].filter((v)=>!!v).join(".");
                        return {
                            virtual: res.virtual,
                            nestedSchemaPath: _path
                        };
                    }
                }
            }
            nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
            cur = "";
            continue;
        }
        if (schema.discriminators) {
            for (const discriminatorKey of Object.keys(schema.discriminators)){
                const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
                if (virtualFromDiscriminator) return virtualFromDiscriminator;
            }
        }
        return null;
    }
}


/***/ }),

/***/ 25747:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = new WeakMap();


/***/ }),

/***/ 82791:
/***/ ((module) => {

"use strict";

module.exports = function lookupLocalFields(cur, path, val) {
    if (cur == null) {
        return cur;
    }
    if (cur._doc != null) {
        cur = cur._doc;
    }
    if (arguments.length >= 3) {
        if (typeof cur !== "object") {
            return void 0;
        }
        if (val === void 0) {
            return void 0;
        }
        if (cur instanceof Map) {
            cur.set(path, val);
        } else {
            cur[path] = val;
        }
        return val;
    }
    // Support populating paths under maps using `map.$*.subpath`
    if (path === "$*") {
        return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key)=>cur[key]);
    }
    if (cur instanceof Map) {
        return cur.get(path);
    }
    return cur[path];
};


/***/ }),

/***/ 53768:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(52100);
/**
 * If populating a path within a document array, make sure each
 * subdoc within the array knows its subpaths are populated.
 *
 * #### Example:
 *
 *     const doc = await Article.findOne().populate('comments.author');
 *     doc.comments[0].populated('author'); // Should be set
 *
 * @param {Document} doc
 * @param {Object} [populated]
 * @api private
 */ module.exports = function markArraySubdocsPopulated(doc, populated) {
    if (doc._id == null || populated == null || populated.length === 0) {
        return;
    }
    const id = String(doc._id);
    for (const item of populated){
        if (item.isVirtual) {
            continue;
        }
        const path = item.path;
        const pieces = path.split(".");
        for(let i = 0; i < pieces.length - 1; ++i){
            const subpath = pieces.slice(0, i + 1).join(".");
            const rest = pieces.slice(i + 1).join(".");
            const val = doc.get(subpath);
            if (val == null) {
                continue;
            }
            if (utils.isMongooseDocumentArray(val)) {
                for(let j = 0; j < val.length; ++j){
                    val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);
                }
                break;
            }
        }
    }
};


/***/ }),

/***/ 68360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MongooseError = __webpack_require__(51520);
const isPathExcluded = __webpack_require__(55862);
const lookupLocalFields = __webpack_require__(82791);
const mpath = __webpack_require__(52988);
const util = __webpack_require__(73837);
const utils = __webpack_require__(52100);
const hasNumericPropRE = /(\.\d+$|\.\d+\.)/g;
module.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {
    if (refPath == null) {
        return [];
    }
    if (typeof refPath === "string" && queryProjection != null && isPathExcluded(queryProjection, refPath)) {
        throw new MongooseError("refPath `" + refPath + "` must not be excluded in projection, got " + util.inspect(queryProjection));
    }
    // If populated path has numerics, the end `refPath` should too. For example,
    // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we
    // should return `a.0.c` for the refPath.
    if (hasNumericPropRE.test(populatedPath)) {
        const chunks = populatedPath.split(hasNumericPropRE);
        if (chunks[chunks.length - 1] === "") {
            throw new Error("Can't populate individual element in an array");
        }
        let _refPath = "";
        let _remaining = refPath;
        // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`
        for(let i = 0; i < chunks.length; i += 2){
            const chunk = chunks[i];
            if (_remaining.startsWith(chunk + ".")) {
                _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];
                _remaining = _remaining.substring(chunk.length + 1);
            } else if (i === chunks.length - 1) {
                _refPath += _remaining;
                _remaining = "";
                break;
            } else {
                throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
            }
        }
        const refValue = mpath.get(_refPath, doc, lookupLocalFields);
        let modelNames = Array.isArray(refValue) ? refValue : [
            refValue
        ];
        modelNames = utils.array.flatten(modelNames);
        return modelNames;
    }
    const refValue = mpath.get(refPath, doc, lookupLocalFields);
    let modelNames;
    if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {
        modelNames = [
            modelSchema.virtuals[refPath].applyGetters(void 0, doc)
        ];
    } else {
        modelNames = Array.isArray(refValue) ? refValue : [
            refValue
        ];
    }
    modelNames = utils.array.flatten(modelNames);
    return modelNames;
};


/***/ }),

/***/ 11289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
const mpath = __webpack_require__(52988);
const parseProjection = __webpack_require__(77034);
/*!
 * ignore
 */ module.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
    const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
    if (projection == null) {
        return;
    }
    for (const foreignField of foreignFields){
        if (!projection.hasOwnProperty("-" + foreignField)) {
            continue;
        }
        for (const val of docs){
            if (val.$__ != null) {
                mpath.unset(foreignField, val._doc);
            } else {
                mpath.unset(foreignField, val);
            }
        }
    }
};


/***/ }),

/***/ 38988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MongooseError = __webpack_require__(51520);
const util = __webpack_require__(73837);
module.exports = validateRef;
function validateRef(ref, path) {
    if (typeof ref === "string") {
        return;
    }
    if (typeof ref === "function") {
        return;
    }
    throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util.inspect(ref, {
        depth: 0
    }));
}


/***/ }),

/***/ 89426:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(52100);
if (typeof jest !== "undefined" && "undefined" !== "undefined") {}
if (typeof jest !== "undefined" && setTimeout.clock != null && typeof setTimeout.clock.Date === "function") {
    utils.warn("Mongoose: looks like you're trying to test a Mongoose app " + "with Jest's mock timers enabled. Please make sure you read " + "Mongoose's docs on configuring Jest to test Node.js apps: " + "https://mongoosejs.com/docs/jest.html");
}


/***/ }),

/***/ 9378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const util = __webpack_require__(73837);
module.exports = util.deprecate(function() {}, "Mongoose: the `strictQuery` option will be switched back to `false` by default " + "in Mongoose 7. Use `mongoose.set('strictQuery', false);` if you want to prepare " + "for this change. Or use `mongoose.set('strictQuery', true);` to suppress this warning.", "MONGOOSE");


/***/ }),

/***/ 74976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const clone = __webpack_require__(99889);
const MongooseError = __webpack_require__(40413);
function processConnectionOptions(uri, options) {
    const opts = options ? options : {};
    const readPreference = opts.readPreference ? opts.readPreference : getUriReadPreference(uri);
    const resolvedOpts = readPreference && readPreference !== "primary" && readPreference !== "primaryPreferred" ? resolveOptsConflicts(readPreference, opts) : opts;
    return clone(resolvedOpts);
}
function resolveOptsConflicts(pref, opts) {
    // don't silently override user-provided indexing options
    if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {
        throwReadPreferenceError();
    } else {
        return defaultIndexOptsToFalse(opts);
    }
}
function setsIndexOptions(opts) {
    const configIdx = opts.config && opts.config.autoIndex;
    const { autoCreate , autoIndex  } = opts;
    return !!(configIdx || autoCreate || autoIndex);
}
function setsSecondaryRead(prefString) {
    return !!(prefString === "secondary" || prefString === "secondaryPreferred");
}
function getUriReadPreference(connectionString) {
    const exp = /(?:&|\?)readPreference=(\w+)(?:&|$)/;
    const match = exp.exec(connectionString);
    return match ? match[1] : null;
}
function defaultIndexOptsToFalse(opts) {
    opts.config = {
        autoIndex: false
    };
    opts.autoCreate = false;
    opts.autoIndex = false;
    return opts;
}
function throwReadPreferenceError() {
    throw new MongooseError("MongoDB prohibits index creation on connections that read from " + 'non-primary replicas.  Connections that set "readPreference" to "secondary" or ' + '"secondaryPreferred" may not opt-in to the following connection options: ' + "autoCreate, autoIndex");
}
module.exports = processConnectionOptions;


/***/ }),

/***/ 73077:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const hasIncludedChildren = __webpack_require__(90970);
const isExclusive = __webpack_require__(12374);
const isInclusive = __webpack_require__(34423);
const isPOJO = (__webpack_require__(52100).isPOJO);
module.exports = function applyProjection(doc, projection, _hasIncludedChildren) {
    if (projection == null) {
        return doc;
    }
    if (doc == null) {
        return doc;
    }
    let exclude = null;
    if (isInclusive(projection)) {
        exclude = false;
    } else if (isExclusive(projection)) {
        exclude = true;
    }
    if (exclude == null) {
        return doc;
    } else if (exclude) {
        _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
        return applyExclusiveProjection(doc, projection, _hasIncludedChildren);
    } else {
        _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
        return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
    }
};
function applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
        return doc;
    }
    const ret = {
        ...doc
    };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)){
        const fullPath = prefix ? prefix + "." + key : key;
        if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
            if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
                ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
            } else {
                delete ret[key];
            }
        } else if (hasIncludedChildren[fullPath]) {
            ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
        }
    }
    return ret;
}
function applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
        return doc;
    }
    const ret = {
        ...doc
    };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)){
        const fullPath = prefix ? prefix + "." + key : key;
        if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
            if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
                ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
            }
            continue;
        } else if (hasIncludedChildren[fullPath]) {
            ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
        } else {
            delete ret[key];
        }
    }
    return ret;
}


/***/ }),

/***/ 90970:
/***/ ((module) => {

"use strict";

/**
 * Creates an object that precomputes whether a given path has child fields in
 * the projection.
 *
 * #### Example:
 *
 *     const res = hasIncludedChildren({ 'a.b.c': 0 });
 *     res.a; // 1
 *     res['a.b']; // 1
 *     res['a.b.c']; // 1
 *     res['a.c']; // undefined
 *
 * @param {Object} fields
 * @api private
 */ module.exports = function hasIncludedChildren(fields) {
    const hasIncludedChildren = {};
    const keys = Object.keys(fields);
    for (const key of keys){
        if (key.indexOf(".") === -1) {
            hasIncludedChildren[key] = 1;
            continue;
        }
        const parts = key.split(".");
        let c = parts[0];
        for(let i = 0; i < parts.length; ++i){
            hasIncludedChildren[c] = 1;
            if (i + 1 < parts.length) {
                c = c + "." + parts[i + 1];
            }
        }
    }
    return hasIncludedChildren;
};


/***/ }),

/***/ 5281:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function isDefiningProjection(val) {
    if (val == null) {
        // `undefined` or `null` become exclusive projections
        return true;
    }
    if (typeof val === "object") {
        // Only cases where a value does **not** define whether the whole projection
        // is inclusive or exclusive are `$meta` and `$slice`.
        return !("$meta" in val) && !("$slice" in val);
    }
    return true;
};


/***/ }),

/***/ 12374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isDefiningProjection = __webpack_require__(5281);
/*!
 * ignore
 */ module.exports = function isExclusive(projection) {
    if (projection == null) {
        return null;
    }
    const keys = Object.keys(projection);
    let ki = keys.length;
    let exclude = null;
    if (ki === 1 && keys[0] === "_id") {
        exclude = !projection._id;
    } else {
        while(ki--){
            // Does this projection explicitly define inclusion/exclusion?
            // Explicitly avoid `$meta` and `$slice`
            const key = keys[ki];
            if (key !== "_id" && isDefiningProjection(projection[key])) {
                exclude = projection[key] != null && typeof projection[key] === "object" ? isExclusive(projection[key]) : !projection[key];
                break;
            }
        }
    }
    return exclude;
};


/***/ }),

/***/ 34423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isDefiningProjection = __webpack_require__(5281);
/*!
 * ignore
 */ module.exports = function isInclusive(projection) {
    if (projection == null) {
        return false;
    }
    const props = Object.keys(projection);
    const numProps = props.length;
    if (numProps === 0) {
        return false;
    }
    for(let i = 0; i < numProps; ++i){
        const prop = props[i];
        // Plus paths can't define the projection (see gh-7050)
        if (prop.startsWith("+")) {
            continue;
        }
        // If field is truthy (1, true, etc.) and not an object, then this
        // projection must be inclusive. If object, assume its $meta, $slice, etc.
        if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
            if (projection[prop] != null && typeof projection[prop] === "object") {
                return isInclusive(projection[prop]);
            } else {
                return !!projection[prop];
            }
        }
    }
    return false;
};


/***/ }),

/***/ 55862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isDefiningProjection = __webpack_require__(5281);
/**
 * Determines if `path` is excluded by `projection`
 *
 * @param {Object} projection
 * @param {String} path
 * @return {Boolean}
 * @api private
 */ module.exports = function isPathExcluded(projection, path) {
    if (projection == null) {
        return false;
    }
    if (path === "_id") {
        return projection._id === 0;
    }
    const paths = Object.keys(projection);
    let type = null;
    for (const _path of paths){
        if (isDefiningProjection(projection[_path])) {
            type = projection[path] === 1 ? "inclusive" : "exclusive";
            break;
        }
    }
    if (type === "inclusive") {
        return projection[path] !== 1;
    }
    if (type === "exclusive") {
        return projection[path] === 0;
    }
    return false;
};


/***/ }),

/***/ 53282:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function isPathSelectedInclusive(fields, path) {
    const chunks = path.split(".");
    let cur = "";
    let j;
    let keys;
    let numKeys;
    for(let i = 0; i < chunks.length; ++i){
        cur += cur.length ? "." : "" + chunks[i];
        if (fields[cur]) {
            keys = Object.keys(fields);
            numKeys = keys.length;
            for(j = 0; j < numKeys; ++j){
                if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
                    continue;
                }
            }
            return true;
        }
    }
    return false;
};


/***/ }),

/***/ 32381:
/***/ ((module) => {

"use strict";

/**
 * Determines if `path2` is a subpath of or equal to `path1`
 *
 * @param {string} path1
 * @param {string} path2
 * @return {Boolean}
 * @api private
 */ module.exports = function isSubpath(path1, path2) {
    return path1 === path2 || path2.startsWith(path1 + ".");
};


/***/ }),

/***/ 77034:
/***/ ((module) => {

"use strict";

/**
 * Convert a string or array into a projection object, retaining all
 * `-` and `+` paths.
 */ module.exports = function parseProjection(v, retainMinusPaths) {
    const type = typeof v;
    if (type === "string") {
        v = v.split(/\s+/);
    }
    if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
        return v;
    }
    const len = v.length;
    const ret = {};
    for(let i = 0; i < len; ++i){
        let field = v[i];
        if (!field) {
            continue;
        }
        const include = "-" == field[0] ? 0 : 1;
        if (!retainMinusPaths && include === 0) {
            field = field.substring(1);
        }
        ret[field] = include;
    }
    return ret;
};


/***/ }),

/***/ 83593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const PromiseProvider = __webpack_require__(46433);
const immediate = __webpack_require__(96621);
const emittedSymbol = Symbol("mongoose:emitted");
module.exports = function promiseOrCallback(callback, fn, ee, Promise) {
    if (typeof callback === "function") {
        try {
            return fn(function(error) {
                if (error != null) {
                    if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
                        error[emittedSymbol] = true;
                        ee.emit("error", error);
                    }
                    try {
                        callback(error);
                    } catch (error) {
                        return immediate(()=>{
                            throw error;
                        });
                    }
                    return;
                }
                callback.apply(this, arguments);
            });
        } catch (error) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
                error[emittedSymbol] = true;
                ee.emit("error", error);
            }
            return callback(error);
        }
    }
    Promise = Promise || PromiseProvider.get();
    return new Promise((resolve, reject)=>{
        fn(function(error, res) {
            if (error != null) {
                if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
                    error[emittedSymbol] = true;
                    ee.emit("error", error);
                }
                return reject(error);
            }
            if (arguments.length > 2) {
                return resolve(Array.prototype.slice.call(arguments, 1));
            }
            resolve(res);
        });
    });
};


/***/ }),

/***/ 73111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(52100);
function applyGlobalMaxTimeMS(options, model) {
    applyGlobalOption(options, model, "maxTimeMS");
}
function applyGlobalDiskUse(options, model) {
    applyGlobalOption(options, model, "allowDiskUse");
}
module.exports = {
    applyGlobalMaxTimeMS,
    applyGlobalDiskUse
};
function applyGlobalOption(options, model, optionName) {
    if (utils.hasUserDefinedProperty(options, optionName)) {
        return;
    }
    if (utils.hasUserDefinedProperty(model.db.options, optionName)) {
        options[optionName] = model.db.options[optionName];
    } else if (utils.hasUserDefinedProperty(model.base.options, optionName)) {
        options[optionName] = model.base.options[optionName];
    }
}


/***/ }),

/***/ 94135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * ignore
 */ module.exports = applyQueryMiddleware;
const validOps = __webpack_require__(19928);
/*!
 * ignore
 */ applyQueryMiddleware.middlewareFunctions = validOps.concat([
    "validate"
]);
/**
 * Apply query middleware
 *
 * @param {Query} Query constructor
 * @param {Model} model
 * @api private
 */ function applyQueryMiddleware(Query, model) {
    const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true
    };
    const middleware = model.hooks.filter((hook)=>{
        const contexts = _getContexts(hook);
        if (hook.name === "updateOne") {
            return contexts.query == null || !!contexts.query;
        }
        if (hook.name === "deleteOne") {
            return !!contexts.query || Object.keys(contexts).length === 0;
        }
        if (hook.name === "validate" || hook.name === "remove") {
            return !!contexts.query;
        }
        if (hook.query != null || hook.document != null) {
            return !!hook.query;
        }
        return true;
    });
    // `update()` thunk has a different name because `_update` was already taken
    Query.prototype._execUpdate = middleware.createWrapper("update", Query.prototype._execUpdate, null, kareemOptions);
    // `distinct()` thunk has a different name because `_distinct` was already taken
    Query.prototype.__distinct = middleware.createWrapper("distinct", Query.prototype.__distinct, null, kareemOptions);
    // `validate()` doesn't have a thunk because it doesn't execute a query.
    Query.prototype.validate = middleware.createWrapper("validate", Query.prototype.validate, null, kareemOptions);
    applyQueryMiddleware.middlewareFunctions.filter((v)=>v !== "update" && v !== "distinct" && v !== "validate").forEach((fn)=>{
        Query.prototype[`_${fn}`] = middleware.createWrapper(fn, Query.prototype[`_${fn}`], null, kareemOptions);
    });
}
function _getContexts(hook) {
    const ret = {};
    if (hook.hasOwnProperty("query")) {
        ret.query = hook.query;
    }
    if (hook.hasOwnProperty("document")) {
        ret.document = hook.document;
    }
    return ret;
}


/***/ }),

/***/ 17153:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CastError = __webpack_require__(96996);
const StrictModeError = __webpack_require__(51016);
const castNumber = __webpack_require__(71155);
const booleanComparison = new Set([
    "$and",
    "$or"
]);
const comparisonOperator = new Set([
    "$cmp",
    "$eq",
    "$lt",
    "$lte",
    "$gt",
    "$gte"
]);
const arithmeticOperatorArray = new Set([
    // avoid casting '$add' or '$subtract', because expressions can be either number or date,
    // and we don't have a good way of inferring which arguments should be numbers and which should
    // be dates.
    "$multiply",
    "$divide",
    "$log",
    "$mod",
    "$trunc",
    "$avg",
    "$max",
    "$min",
    "$stdDevPop",
    "$stdDevSamp",
    "$sum"
]);
const arithmeticOperatorNumber = new Set([
    "$abs",
    "$exp",
    "$ceil",
    "$floor",
    "$ln",
    "$log10",
    "$round",
    "$sqrt",
    "$sin",
    "$cos",
    "$tan",
    "$asin",
    "$acos",
    "$atan",
    "$atan2",
    "$asinh",
    "$acosh",
    "$atanh",
    "$sinh",
    "$cosh",
    "$tanh",
    "$degreesToRadians",
    "$radiansToDegrees"
]);
const arrayElementOperators = new Set([
    "$arrayElemAt",
    "$first",
    "$last"
]);
const dateOperators = new Set([
    "$year",
    "$month",
    "$week",
    "$dayOfMonth",
    "$dayOfYear",
    "$hour",
    "$minute",
    "$second",
    "$isoDayOfWeek",
    "$isoWeekYear",
    "$isoWeek",
    "$millisecond"
]);
const expressionOperator = new Set([
    "$not"
]);
module.exports = function cast$expr(val, schema, strictQuery) {
    if (typeof val !== "object" || val === null) {
        throw new Error("`$expr` must be an object");
    }
    return _castExpression(val, schema, strictQuery);
};
function _castExpression(val, schema, strictQuery) {
    // Preserve the value if it represents a path or if it's null
    if (isPath(val) || val === null) {
        return val;
    }
    if (val.$cond != null) {
        if (Array.isArray(val.$cond)) {
            val.$cond = val.$cond.map((expr)=>_castExpression(expr, schema, strictQuery));
        } else {
            val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);
            val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);
            val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);
        }
    } else if (val.$ifNull != null) {
        val.$ifNull.map((v)=>_castExpression(v, schema, strictQuery));
    } else if (val.$switch != null) {
        val.branches.map((v)=>_castExpression(v, schema, strictQuery));
        val.default = _castExpression(val.default, schema, strictQuery);
    }
    const keys = Object.keys(val);
    for (const key of keys){
        if (booleanComparison.has(key)) {
            val[key] = val[key].map((v)=>_castExpression(v, schema, strictQuery));
        } else if (comparisonOperator.has(key)) {
            val[key] = castComparison(val[key], schema, strictQuery);
        } else if (arithmeticOperatorArray.has(key)) {
            val[key] = castArithmetic(val[key], schema, strictQuery);
        } else if (arithmeticOperatorNumber.has(key)) {
            val[key] = castNumberOperator(val[key], schema, strictQuery);
        } else if (expressionOperator.has(key)) {
            val[key] = _castExpression(val[key], schema, strictQuery);
        }
    }
    if (val.$in) {
        val.$in = castIn(val.$in, schema, strictQuery);
    }
    if (val.$size) {
        val.$size = castNumberOperator(val.$size, schema, strictQuery);
    }
    _omitUndefined(val);
    return val;
}
function _omitUndefined(val) {
    const keys = Object.keys(val);
    for(let i = 0, len = keys.length; i < len; ++i){
        val[keys[i]] === void 0 && delete val[keys[i]];
    }
}
// { $op: <number> }
function castNumberOperator(val) {
    if (!isLiteral(val)) {
        return val;
    }
    try {
        return castNumber(val);
    } catch (err) {
        throw new CastError("Number", val);
    }
}
function castIn(val, schema, strictQuery) {
    const path = val[1];
    if (!isPath(path)) {
        return val;
    }
    const search = val[0];
    const schematype = schema.path(path.slice(1));
    if (schematype === null) {
        if (strictQuery === false) {
            return val;
        } else if (strictQuery === "throw") {
            throw new StrictModeError("$in");
        }
        return void 0;
    }
    if (!schematype.$isMongooseArray) {
        throw new Error("Path must be an array for $in");
    }
    return [
        schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),
        path
    ];
}
// { $op: [<number>, <number>] }
function castArithmetic(val) {
    if (!Array.isArray(val)) {
        if (!isLiteral(val)) {
            return val;
        }
        try {
            return castNumber(val);
        } catch (err) {
            throw new CastError("Number", val);
        }
    }
    return val.map((v)=>{
        if (!isLiteral(v)) {
            return v;
        }
        try {
            return castNumber(v);
        } catch (err) {
            throw new CastError("Number", v);
        }
    });
}
// { $op: [expression, expression] }
function castComparison(val, schema, strictQuery) {
    if (!Array.isArray(val) || val.length !== 2) {
        throw new Error("Comparison operator must be an array of length 2");
    }
    val[0] = _castExpression(val[0], schema, strictQuery);
    const lhs = val[0];
    if (isLiteral(val[1])) {
        let path = null;
        let schematype = null;
        let caster = null;
        if (isPath(lhs)) {
            path = lhs.slice(1);
            schematype = schema.path(path);
        } else if (typeof lhs === "object" && lhs != null) {
            for (const key of Object.keys(lhs)){
                if (dateOperators.has(key) && isPath(lhs[key])) {
                    path = lhs[key].slice(1) + "." + key;
                    caster = castNumber;
                } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {
                    path = lhs[key].slice(1) + "." + key;
                    schematype = schema.path(lhs[key].slice(1));
                    if (schematype != null) {
                        if (schematype.$isMongooseDocumentArray) {
                            schematype = schematype.$embeddedSchemaType;
                        } else if (schematype.$isMongooseArray) {
                            schematype = schematype.caster;
                        }
                    }
                }
            }
        }
        const is$literal = typeof val[1] === "object" && val[1] != null && val[1].$literal != null;
        if (schematype != null) {
            if (is$literal) {
                val[1] = {
                    $literal: schematype.cast(val[1].$literal)
                };
            } else {
                val[1] = schematype.cast(val[1]);
            }
        } else if (caster != null) {
            if (is$literal) {
                try {
                    val[1] = {
                        $literal: caster(val[1].$literal)
                    };
                } catch (err) {
                    throw new CastError(caster.name.replace(/^cast/, ""), val[1], path + ".$literal");
                }
            } else {
                try {
                    val[1] = caster(val[1]);
                } catch (err) {
                    throw new CastError(caster.name.replace(/^cast/, ""), val[1], path);
                }
            }
        } else if (path != null && strictQuery === true) {
            return void 0;
        } else if (path != null && strictQuery === "throw") {
            throw new StrictModeError(path);
        }
    } else {
        val[1] = _castExpression(val[1]);
    }
    return val;
}
function isPath(val) {
    return typeof val === "string" && val[0] === "$";
}
function isLiteral(val) {
    if (typeof val === "string" && val[0] === "$") {
        return false;
    }
    if (typeof val === "object" && val !== null && Object.keys(val).find((key)=>key[0] === "$")) {
        // The `$literal` expression can make an object a literal
        // https://docs.mongodb.com/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal
        return val.$literal != null;
    }
    return true;
}


/***/ }),

/***/ 15708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isOperator = __webpack_require__(75831);
module.exports = function castFilterPath(query, schematype, val) {
    const ctx = query;
    const any$conditionals = Object.keys(val).some(isOperator);
    if (!any$conditionals) {
        return schematype.castForQueryWrapper({
            val: val,
            context: ctx
        });
    }
    const ks = Object.keys(val);
    let k = ks.length;
    while(k--){
        const $cond = ks[k];
        const nested = val[$cond];
        if ($cond === "$not") {
            if (nested && schematype && !schematype.caster) {
                const _keys = Object.keys(nested);
                if (_keys.length && isOperator(_keys[0])) {
                    for (const key of Object.keys(nested)){
                        nested[key] = schematype.castForQueryWrapper({
                            $conditional: key,
                            val: nested[key],
                            context: ctx
                        });
                    }
                } else {
                    val[$cond] = schematype.castForQueryWrapper({
                        $conditional: $cond,
                        val: nested,
                        context: ctx
                    });
                }
                continue;
            }
        } else {
            val[$cond] = schematype.castForQueryWrapper({
                $conditional: $cond,
                val: nested,
                context: ctx
            });
        }
    }
    return val;
};


/***/ }),

/***/ 54795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CastError = __webpack_require__(96996);
const MongooseError = __webpack_require__(51520);
const StrictModeError = __webpack_require__(51016);
const ValidationError = __webpack_require__(13837);
const castNumber = __webpack_require__(71155);
const cast = __webpack_require__(54749);
const getConstructorName = __webpack_require__(4065);
const getEmbeddedDiscriminatorPath = __webpack_require__(87045);
const handleImmutable = __webpack_require__(77420);
const moveImmutableProperties = __webpack_require__(19960);
const schemaMixedSymbol = (__webpack_require__(36825).schemaMixedSymbol);
const setDottedPath = __webpack_require__(73479);
const utils = __webpack_require__(52100);
/**
 * Casts an update op based on the given schema
 *
 * @param {Schema} schema
 * @param {Object} obj
 * @param {Object} [options]
 * @param {Boolean} [options.overwrite] defaults to false
 * @param {Boolean|String} [options.strict] defaults to true
 * @param {Query} context passed to setters
 * @return {Boolean} true iff the update is non-empty
 * @api private
 */ module.exports = function castUpdate(schema, obj, options, context, filter) {
    if (obj == null) {
        return undefined;
    }
    options = options || {};
    // Update pipeline
    if (Array.isArray(obj)) {
        const len = obj.length;
        for(let i = 0; i < len; ++i){
            const ops = Object.keys(obj[i]);
            for (const op of ops){
                obj[i][op] = castPipelineOperator(op, obj[i][op]);
            }
        }
        return obj;
    }
    if (options.upsert && !options.overwrite) {
        moveImmutableProperties(schema, obj, context);
    }
    const ops = Object.keys(obj);
    let i = ops.length;
    const ret = {};
    let val;
    let hasDollarKey = false;
    const overwrite = options.overwrite;
    filter = filter || {};
    while(i--){
        const op = ops[i];
        // if overwrite is set, don't do any of the special $set stuff
        if (op[0] !== "$" && !overwrite) {
            // fix up $set sugar
            if (!ret.$set) {
                if (obj.$set) {
                    ret.$set = obj.$set;
                } else {
                    ret.$set = {};
                }
            }
            ret.$set[op] = obj[op];
            ops.splice(i, 1);
            if (!~ops.indexOf("$set")) ops.push("$set");
        } else if (op === "$set") {
            if (!ret.$set) {
                ret[op] = obj[op];
            }
        } else {
            ret[op] = obj[op];
        }
    }
    // cast each value
    i = ops.length;
    while(i--){
        const op = ops[i];
        val = ret[op];
        hasDollarKey = hasDollarKey || op.startsWith("$");
        const toUnset = {};
        if (val != null) {
            for (const key of Object.keys(val)){
                if (val[key] === undefined) {
                    toUnset[key] = 1;
                }
            }
        }
        if (val && typeof val === "object" && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {
            walkUpdatePath(schema, val, op, options, context, filter);
        } else if (overwrite && ret && typeof ret === "object") {
            walkUpdatePath(schema, ret, "$set", options, context, filter);
        } else {
            const msg = "Invalid atomic update value for " + op + ". " + "Expected an object, received " + typeof val;
            throw new Error(msg);
        }
        if (op.startsWith("$") && utils.isEmptyObject(val)) {
            delete ret[op];
            if (op === "$set" && !utils.isEmptyObject(toUnset)) {
                // Unset all undefined values
                ret["$unset"] = toUnset;
            }
        }
    }
    if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {
        // Trick the driver into allowing empty upserts to work around
        // https://github.com/mongodb/node-mongodb-native/pull/2490
        return {
            $setOnInsert: filter
        };
    }
    return ret;
};
/*!
 * ignore
 */ function castPipelineOperator(op, val) {
    if (op === "$unset") {
        if (typeof val !== "string" && (!Array.isArray(val) || val.find((v)=>typeof v !== "string"))) {
            throw new MongooseError("Invalid $unset in pipeline, must be " + " a string or an array of strings");
        }
        return val;
    }
    if (op === "$project") {
        if (val == null || typeof val !== "object") {
            throw new MongooseError("Invalid $project in pipeline, must be an object");
        }
        return val;
    }
    if (op === "$addFields" || op === "$set") {
        if (val == null || typeof val !== "object") {
            throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
    } else if (op === "$replaceRoot" || op === "$replaceWith") {
        if (val == null || typeof val !== "object") {
            throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
    }
    throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
}
/**
 * Walk each path of obj and cast its values
 * according to its schema.
 *
 * @param {Schema} schema
 * @param {Object} obj part of a query
 * @param {String} op the atomic operator ($pull, $set, etc)
 * @param {Object} [options]
 * @param {Boolean|String} [options.strict]
 * @param {Query} context
 * @param {Object} filter
 * @param {String} pref path prefix (internal only)
 * @return {Bool} true if this path has keys to update
 * @api private
 */ function walkUpdatePath(schema, obj, op, options, context, filter, pref) {
    const strict = options.strict;
    const prefix = pref ? pref + "." : "";
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys = false;
    let schematype;
    let key;
    let val;
    let aggregatedError = null;
    const strictMode = strict != null ? strict : schema.options.strict;
    while(i--){
        key = keys[i];
        val = obj[key];
        // `$pull` is special because we need to cast the RHS as a query, not as
        // an update.
        if (op === "$pull") {
            schematype = schema._getSchema(prefix + key);
            if (schematype != null && schematype.schema != null) {
                obj[key] = cast(schematype.schema, obj[key], options, context);
                hasKeys = true;
                continue;
            }
        }
        const discriminatorKey = prefix ? prefix + key : key;
        if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && !options.overwriteDiscriminatorKey) {
            if (strictMode === "throw") {
                const err = new Error("Can't modify discriminator key \"" + discriminatorKey + '" on discriminator model');
                aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);
                continue;
            } else if (strictMode) {
                delete obj[key];
                continue;
            }
        }
        if (getConstructorName(val) === "Object") {
            // watch for embedded doc schemas
            schematype = schema._getSchema(prefix + key);
            if (schematype == null) {
                const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
                if (_res.schematype != null) {
                    schematype = _res.schematype;
                }
            }
            if (op !== "$setOnInsert" && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
                continue;
            }
            if (schematype && schematype.caster && op in castOps) {
                // embedded doc schema
                if ("$each" in val) {
                    hasKeys = true;
                    try {
                        obj[key] = {
                            $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
                        };
                    } catch (error) {
                        aggregatedError = _appendError(error, context, key, aggregatedError);
                    }
                    if (val.$slice != null) {
                        obj[key].$slice = val.$slice | 0;
                    }
                    if (val.$sort) {
                        obj[key].$sort = val.$sort;
                    }
                    if (val.$position != null) {
                        obj[key].$position = castNumber(val.$position);
                    }
                } else {
                    if (schematype != null && schematype.$isSingleNested) {
                        const _strict = strict == null ? schematype.schema.options.strict : strict;
                        try {
                            obj[key] = schematype.castForQuery(val, context, {
                                strict: _strict
                            });
                        } catch (error) {
                            aggregatedError = _appendError(error, context, key, aggregatedError);
                        }
                    } else {
                        try {
                            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                        } catch (error) {
                            aggregatedError = _appendError(error, context, key, aggregatedError);
                        }
                    }
                    if (obj[key] === void 0) {
                        delete obj[key];
                        continue;
                    }
                    hasKeys = true;
                }
            } else if (op === "$currentDate" || op in castOps && schematype) {
                // $currentDate can take an object
                try {
                    obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                } catch (error) {
                    aggregatedError = _appendError(error, context, key, aggregatedError);
                }
                if (obj[key] === void 0) {
                    delete obj[key];
                    continue;
                }
                hasKeys = true;
            } else {
                const pathToCheck = prefix + key;
                const v = schema._getPathType(pathToCheck);
                let _strict = strict;
                if (v && v.schema && _strict == null) {
                    _strict = v.schema.options.strict;
                }
                if (v.pathType === "undefined") {
                    if (_strict === "throw") {
                        throw new StrictModeError(pathToCheck);
                    } else if (_strict) {
                        delete obj[key];
                        continue;
                    }
                }
                // gh-2314
                // we should be able to set a schema-less field
                // to an empty object literal
                hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
            }
        } else {
            const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
            schematype = schema._getSchema(checkPath);
            // You can use `$setOnInsert` with immutable keys
            if (op !== "$setOnInsert" && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
                continue;
            }
            let pathDetails = schema._getPathType(checkPath);
            // If no schema type, check for embedded discriminators because the
            // filter or update may imply an embedded discriminator type. See #8378
            if (schematype == null) {
                const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);
                if (_res.schematype != null) {
                    schematype = _res.schematype;
                    pathDetails = _res.type;
                }
            }
            let isStrict = strict;
            if (pathDetails && pathDetails.schema && strict == null) {
                isStrict = pathDetails.schema.options.strict;
            }
            const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
            if (skip) {
                // Even if strict is `throw`, avoid throwing an error because of
                // virtuals because of #6731
                if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
                    throw new StrictModeError(prefix + key);
                } else {
                    delete obj[key];
                }
            } else {
                // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking
                // improving this.
                if (op === "$rename") {
                    hasKeys = true;
                    continue;
                }
                try {
                    if (prefix.length === 0 || key.indexOf(".") === -1) {
                        obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                    } else {
                        // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in
                        // a schema, so replace the dotted path with a nested object to avoid ending up with
                        // dotted properties in the updated object. See (gh-10200)
                        setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
                        delete obj[key];
                    }
                } catch (error) {
                    aggregatedError = _appendError(error, context, key, aggregatedError);
                }
                if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
                    if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {
                        obj[key] = {
                            $each: obj[key]
                        };
                    }
                }
                if (obj[key] === void 0) {
                    delete obj[key];
                    continue;
                }
                hasKeys = true;
            }
        }
    }
    if (aggregatedError != null) {
        throw aggregatedError;
    }
    return hasKeys;
}
/*!
 * ignore
 */ function _appendError(error, query, key, aggregatedError) {
    if (typeof query !== "object" || !query.options.multipleCastError) {
        throw error;
    }
    aggregatedError = aggregatedError || new ValidationError();
    aggregatedError.addError(key, error);
    return aggregatedError;
}
/**
 * These operators should be cast to numbers instead
 * of their path schema type.
 * @api private
 */ const numberOps = {
    $pop: 1,
    $inc: 1
};
/**
 * These ops require no casting because the RHS doesn't do anything.
 * @api private
 */ const noCastOps = {
    $unset: 1
};
/**
 * These operators require casting docs
 * to real Documents for Update operations.
 * @api private
 */ const castOps = {
    $push: 1,
    $addToSet: 1,
    $set: 1,
    $setOnInsert: 1
};
/*!
 * ignore
 */ const overwriteOps = {
    $set: 1,
    $setOnInsert: 1
};
/**
 * Casts `val` according to `schema` and atomic `op`.
 *
 * @param {SchemaType} schema
 * @param {Object} val
 * @param {String} op the atomic operator ($pull, $set, etc)
 * @param {String} $conditional
 * @param {Query} context
 * @param {String} path
 * @api private
 */ function castUpdateVal(schema, val, op, $conditional, context, path) {
    if (!schema) {
        // non-existing schema path
        if (op in numberOps) {
            try {
                return castNumber(val);
            } catch (err) {
                throw new CastError("number", val, path);
            }
        }
        return val;
    }
    // console.log('CastUpdateVal', path, op, val, schema);
    const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));
    if (cond && !overwriteOps[op]) {
        // Cast values for ops that add data to MongoDB.
        // Ensures embedded documents get ObjectIds etc.
        let schemaArrayDepth = 0;
        let cur = schema;
        while(cur.$isMongooseArray){
            ++schemaArrayDepth;
            cur = cur.caster;
        }
        let arrayDepth = 0;
        let _val = val;
        while(Array.isArray(_val)){
            ++arrayDepth;
            _val = _val[0];
        }
        const additionalNesting = schemaArrayDepth - arrayDepth;
        while(arrayDepth < schemaArrayDepth){
            val = [
                val
            ];
            ++arrayDepth;
        }
        let tmp = schema.applySetters(Array.isArray(val) ? val : [
            val
        ], context);
        for(let i = 0; i < additionalNesting; ++i){
            tmp = tmp[0];
        }
        return tmp;
    }
    if (op in noCastOps) {
        return val;
    }
    if (op in numberOps) {
        // Null and undefined not allowed for $pop, $inc
        if (val == null) {
            throw new CastError("number", val, schema.path);
        }
        if (op === "$inc") {
            // Support `$inc` with long, int32, etc. (gh-4283)
            return schema.castForQueryWrapper({
                val: val,
                context: context
            });
        }
        try {
            return castNumber(val);
        } catch (error) {
            throw new CastError("number", val, schema.path);
        }
    }
    if (op === "$currentDate") {
        if (typeof val === "object") {
            return {
                $type: val.$type
            };
        }
        return Boolean(val);
    }
    if (/^\$/.test($conditional)) {
        return schema.castForQueryWrapper({
            $conditional: $conditional,
            val: val,
            context: context
        });
    }
    if (overwriteOps[op]) {
        return schema.castForQueryWrapper({
            val: val,
            context: context,
            $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/),
            $applySetters: schema[schemaMixedSymbol] != null
        });
    }
    return schema.castForQueryWrapper({
        val: val,
        context: context
    });
}


/***/ }),

/***/ 58347:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const helpers = __webpack_require__(83524);
const immediate = __webpack_require__(96621);
module.exports = completeMany;
/**
 * Given a model and an array of docs, hydrates all the docs to be instances
 * of the model. Used to initialize docs returned from the db from `find()`
 *
 * @param {Model} model
 * @param {Array} docs
 * @param {Object} fields the projection used, including `select` from schemas
 * @param {Object} userProvidedFields the user-specified projection
 * @param {Object} [opts]
 * @param {Array} [opts.populated]
 * @param {ClientSession} [opts.session]
 * @param {Function} callback
 * @api private
 */ function completeMany(model, docs, fields, userProvidedFields, opts, callback) {
    const arr = [];
    let count = docs.length;
    const len = count;
    let error = null;
    function init(_error) {
        if (_error != null) {
            error = error || _error;
        }
        if (error != null) {
            --count || immediate(()=>callback(error));
            return;
        }
        --count || immediate(()=>callback(error, arr));
    }
    for(let i = 0; i < len; ++i){
        arr[i] = helpers.createModel(model, docs[i], fields, userProvidedFields);
        try {
            arr[i].$init(docs[i], opts, init);
        } catch (error) {
            init(error);
        }
        if (opts.session != null) {
            arr[i].$session(opts.session);
        }
    }
}


/***/ }),

/***/ 87045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const cleanPositionalOperators = __webpack_require__(35845);
const get = __webpack_require__(39223);
const getDiscriminatorByValue = __webpack_require__(17492);
const updatedPathsByArrayFilter = __webpack_require__(12695);
/**
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 * @param {Schema} schema
 * @param {Object} [update]
 * @param {Object} [filter]
 * @param {String} path
 * @param {Object} [options]
 * @api private
 */ module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
    const parts = path.split(".");
    let schematype = null;
    let type = "adhocOrUndefined";
    filter = filter || {};
    update = update || {};
    const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    for(let i = 0; i < parts.length; ++i){
        const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join("."));
        schematype = schema.path(subpath);
        if (schematype == null) {
            continue;
        }
        type = schema.pathType(subpath);
        if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
            const key = get(schematype, "schema.options.discriminatorKey");
            const discriminatorValuePath = subpath + "." + key;
            const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
            let discriminatorKey = null;
            if (discriminatorValuePath in filter) {
                discriminatorKey = filter[discriminatorValuePath];
            }
            if (discriminatorFilterPath in filter) {
                discriminatorKey = filter[discriminatorFilterPath];
            }
            const wrapperPath = subpath.replace(/\.\d+$/, "");
            if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
                discriminatorKey = filter[wrapperPath].$elemMatch[key];
            }
            if (discriminatorValuePath in update) {
                discriminatorKey = update[discriminatorValuePath];
            }
            for (const filterKey of Object.keys(updatedPathsByFilter)){
                const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
                const arrayFilterKey = filterKey + "." + key;
                if (schemaKey === discriminatorFilterPath) {
                    const filter = arrayFilters.find((filter)=>filter.hasOwnProperty(arrayFilterKey));
                    if (filter != null) {
                        discriminatorKey = filter[arrayFilterKey];
                    }
                }
            }
            if (discriminatorKey == null) {
                continue;
            }
            const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;
            const rest = parts.slice(i + 1).join(".");
            schematype = discriminatorSchema.path(rest);
            if (schematype != null) {
                type = discriminatorSchema._getPathType(rest);
                break;
            }
        }
    }
    return {
        type: type,
        schematype: schematype
    };
};


/***/ }),

/***/ 77420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const StrictModeError = __webpack_require__(51016);
module.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {
    if (schematype == null || !schematype.options || !schematype.options.immutable) {
        return false;
    }
    let immutable = schematype.options.immutable;
    if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
        return false;
    }
    if (strict === false) {
        return false;
    }
    if (strict === "throw") {
        throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);
    }
    delete obj[key];
    return true;
};


/***/ }),

/***/ 11029:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function hasDollarKeys(obj) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    for(let i = 0; i < len; ++i){
        if (keys[i][0] === "$") {
            return true;
        }
    }
    return false;
};


/***/ }),

/***/ 75831:
/***/ ((module) => {

"use strict";

const specialKeys = new Set([
    "$ref",
    "$id",
    "$db"
]);
module.exports = function isOperator(path) {
    return path[0] === "$" && !specialKeys.has(path);
};


/***/ }),

/***/ 66501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const hasDollarKeys = __webpack_require__(11029);
const { trustedSymbol  } = __webpack_require__(79657);
module.exports = function sanitizeFilter(filter) {
    if (filter == null || typeof filter !== "object") {
        return filter;
    }
    if (Array.isArray(filter)) {
        for (const subfilter of filter){
            sanitizeFilter(subfilter);
        }
        return filter;
    }
    const filterKeys = Object.keys(filter);
    for (const key of filterKeys){
        const value = filter[key];
        if (value != null && value[trustedSymbol]) {
            continue;
        }
        if (key === "$and" || key === "$or") {
            sanitizeFilter(value);
            continue;
        }
        if (hasDollarKeys(value)) {
            const keys = Object.keys(value);
            if (keys.length === 1 && keys[0] === "$eq") {
                continue;
            }
            filter[key] = {
                $eq: filter[key]
            };
        }
    }
    return filter;
};


/***/ }),

/***/ 58063:
/***/ ((module) => {

"use strict";

module.exports = function sanitizeProjection(projection) {
    if (projection == null) {
        return;
    }
    const keys = Object.keys(projection);
    for(let i = 0; i < keys.length; ++i){
        if (typeof projection[keys[i]] === "string") {
            projection[keys[i]] = 1;
        }
    }
};


/***/ }),

/***/ 63795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isExclusive = __webpack_require__(12374);
const isInclusive = __webpack_require__(34423);
/*!
 * ignore
 */ module.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
    if (populateOptions == null) {
        return;
    }
    const paths = Object.keys(populateOptions);
    userProvidedFields = userProvidedFields || {};
    if (isInclusive(fields)) {
        for (const path of paths){
            if (!isPathInFields(userProvidedFields, path)) {
                fields[path] = 1;
            } else if (userProvidedFields[path] === 0) {
                delete fields[path];
            }
        }
    } else if (isExclusive(fields)) {
        for (const path of paths){
            if (userProvidedFields[path] == null) {
                delete fields[path];
            }
        }
    }
};
/*!
 * ignore
 */ function isPathInFields(userProvidedFields, path) {
    const pieces = path.split(".");
    const len = pieces.length;
    let cur = pieces[0];
    for(let i = 1; i < len; ++i){
        if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
            return true;
        }
        cur += "." + pieces[i];
    }
    return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
}


/***/ }),

/***/ 79657:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const trustedSymbol = Symbol("mongoose#trustedSymbol");
exports.trustedSymbol = trustedSymbol;
exports.trusted = function trusted(obj) {
    if (obj == null || typeof obj !== "object") {
        return obj;
    }
    obj[trustedSymbol] = true;
    return obj;
};


/***/ }),

/***/ 19928:
/***/ ((module) => {

"use strict";

module.exports = Object.freeze([
    // Read
    "count",
    "countDocuments",
    "distinct",
    "estimatedDocumentCount",
    "find",
    "findOne",
    // Update
    "findOneAndReplace",
    "findOneAndUpdate",
    "replaceOne",
    "update",
    "updateMany",
    "updateOne",
    // Delete
    "deleteMany",
    "deleteOne",
    "findOneAndDelete",
    "findOneAndRemove",
    "remove"
]);


/***/ }),

/***/ 10712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const MongooseError = __webpack_require__(51520);
/**
 * A query thunk is the function responsible for sending the query to MongoDB,
 * like `Query#_findOne()` or `Query#_execUpdate()`. The `Query#exec()` function
 * calls a thunk. The term "thunk" here is the traditional Node.js definition:
 * a function that takes exactly 1 parameter, a callback.
 *
 * This function defines common behavior for all query thunks.
 * @param {Function} fn
 * @api private
 */ module.exports = function wrapThunk(fn) {
    return function _wrappedThunk(cb) {
        if (this._executionStack != null) {
            let str = this.toString();
            if (str.length > 60) {
                str = str.slice(0, 60) + "...";
            }
            const err = new MongooseError("Query was already executed: " + str);
            err.originalStack = this._executionStack.stack;
            return cb(err);
        }
        this._executionStack = new Error();
        fn.call(this, cb);
    };
};


/***/ }),

/***/ 40238:
/***/ ((module) => {

"use strict";

module.exports = function addAutoId(schema) {
    const _obj = {
        _id: {
            auto: true
        }
    };
    _obj._id[schema.options.typeKey] = "ObjectId";
    schema.add(_obj);
};


/***/ }),

/***/ 76622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const builtinPlugins = __webpack_require__(51276);
module.exports = function applyBuiltinPlugins(schema) {
    for (const plugin of Object.values(builtinPlugins)){
        plugin(schema, {
            deduplicate: true
        });
    }
    schema.plugins = Object.values(builtinPlugins).map((fn)=>({
            fn,
            opts: {
                deduplicate: true
            }
        })).concat(schema.plugins);
};


/***/ }),

/***/ 36573:
/***/ ((module) => {

"use strict";

module.exports = function applyPlugins(schema, plugins, options, cacheKey) {
    if (schema[cacheKey]) {
        return;
    }
    schema[cacheKey] = true;
    if (!options || !options.skipTopLevel) {
        let pluginTags = null;
        for (const plugin of plugins){
            const tags = plugin[1] == null ? null : plugin[1].tags;
            if (!Array.isArray(tags)) {
                schema.plugin(plugin[0], plugin[1]);
                continue;
            }
            pluginTags = pluginTags || new Set(schema.options.pluginTags || []);
            if (!tags.find((tag)=>pluginTags.has(tag))) {
                continue;
            }
            schema.plugin(plugin[0], plugin[1]);
        }
    }
    options = Object.assign({}, options);
    delete options.skipTopLevel;
    if (options.applyPluginsToChildSchemas !== false) {
        for (const path of Object.keys(schema.paths)){
            const type = schema.paths[path];
            if (type.schema != null) {
                applyPlugins(type.schema, plugins, options, cacheKey);
                // Recompile schema because plugins may have changed it, see gh-7572
                type.caster.prototype.$__setSchema(type.schema);
            }
        }
    }
    const discriminators = schema.discriminators;
    if (discriminators == null) {
        return;
    }
    const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
    const keys = Object.keys(discriminators);
    for (const discriminatorKey of keys){
        const discriminatorSchema = discriminators[discriminatorKey];
        applyPlugins(discriminatorSchema, plugins, {
            skipTopLevel: !applyPluginsToDiscriminators
        }, cacheKey);
    }
};


/***/ }),

/***/ 75103:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
module.exports = function applyWriteConcern(schema, options) {
    const writeConcern = get(schema, "options.writeConcern", {});
    if (Object.keys(writeConcern).length != 0) {
        options.writeConcern = {};
        if (!("w" in options) && writeConcern.w != null) {
            options.writeConcern.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
            options.writeConcern.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
            options.writeConcern.wtimeout = writeConcern.wtimeout;
        }
    } else {
        if (!("w" in options) && writeConcern.w != null) {
            options.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
            options.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
            options.wtimeout = writeConcern.wtimeout;
        }
    }
};


/***/ }),

/***/ 35845:
/***/ ((module) => {

"use strict";

/**
 * For consistency's sake, we replace positional operator `$` and array filters
 * `$[]` and `$[foo]` with `0` when looking up schema paths.
 */ module.exports = function cleanPositionalOperators(path) {
    return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
};


/***/ }),

/***/ 43459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
const helperIsObject = __webpack_require__(89026);
const decorateDiscriminatorIndexOptions = __webpack_require__(23846);
/**
 * Gather all indexes defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 * @param {Schema} schema
 * @api private
 */ module.exports = function getIndexes(schema) {
    let indexes = [];
    const schemaStack = new WeakMap();
    const indexTypes = schema.constructor.indexTypes;
    const indexByName = new Map();
    collectIndexes(schema);
    return indexes;
    function collectIndexes(schema, prefix, baseSchema) {
        // Ignore infinitely nested schemas, if we've already seen this schema
        // along this path there must be a cycle
        if (schemaStack.has(schema)) {
            return;
        }
        schemaStack.set(schema, true);
        prefix = prefix || "";
        const keys = Object.keys(schema.paths);
        for (const key of keys){
            const path = schema.paths[key];
            if (baseSchema != null && baseSchema.paths[key]) {
                continue;
            }
            if (path.$isMongooseDocumentArray || path.$isSingleNested) {
                if (get(path, "options.excludeIndexes") !== true && get(path, "schemaOptions.excludeIndexes") !== true && get(path, "schema.options.excludeIndexes") !== true) {
                    collectIndexes(path.schema, prefix + key + ".");
                }
                if (path.schema.discriminators != null) {
                    const discriminators = path.schema.discriminators;
                    const discriminatorKeys = Object.keys(discriminators);
                    for (const discriminatorKey of discriminatorKeys){
                        collectIndexes(discriminators[discriminatorKey], prefix + key + ".", path.schema);
                    }
                }
                // Retained to minimize risk of backwards breaking changes due to
                // gh-6113
                if (path.$isMongooseDocumentArray) {
                    continue;
                }
            }
            const index = path._index || path.caster && path.caster._index;
            if (index !== false && index !== null && index !== undefined) {
                const field = {};
                const isObject = helperIsObject(index);
                const options = isObject ? index : {};
                const type = typeof index === "string" ? index : isObject ? index.type : false;
                if (type && indexTypes.indexOf(type) !== -1) {
                    field[prefix + key] = type;
                } else if (options.text) {
                    field[prefix + key] = "text";
                    delete options.text;
                } else {
                    const isDescendingIndex = Number(index) === -1;
                    field[prefix + key] = isDescendingIndex ? -1 : 1;
                }
                delete options.type;
                if (!("background" in options)) {
                    options.background = true;
                }
                if (schema.options.autoIndex != null) {
                    options._autoIndex = schema.options.autoIndex;
                }
                const indexName = options && options.name;
                if (typeof indexName === "string") {
                    if (indexByName.has(indexName)) {
                        Object.assign(indexByName.get(indexName), field);
                    } else {
                        indexes.push([
                            field,
                            options
                        ]);
                        indexByName.set(indexName, field);
                    }
                } else {
                    indexes.push([
                        field,
                        options
                    ]);
                    indexByName.set(indexName, field);
                }
            }
        }
        schemaStack.delete(schema);
        if (prefix) {
            fixSubIndexPaths(schema, prefix);
        } else {
            schema._indexes.forEach(function(index) {
                const options = index[1];
                if (!("background" in options)) {
                    options.background = true;
                }
                decorateDiscriminatorIndexOptions(schema, options);
            });
            indexes = indexes.concat(schema._indexes);
        }
    }
    /**
   * Checks for indexes added to subdocs using Schema.index().
   * These indexes need their paths prefixed properly.
   *
   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
   * @param {Schema} schema
   * @param {String} prefix
   * @api private
   */ function fixSubIndexPaths(schema, prefix) {
        const subindexes = schema._indexes;
        const len = subindexes.length;
        for(let i = 0; i < len; ++i){
            const indexObj = subindexes[i][0];
            const indexOptions = subindexes[i][1];
            const keys = Object.keys(indexObj);
            const klen = keys.length;
            const newindex = {};
            // use forward iteration, order matters
            for(let j = 0; j < klen; ++j){
                const key = keys[j];
                newindex[prefix + key] = indexObj[key];
            }
            const newIndexOptions = Object.assign({}, indexOptions);
            if (indexOptions != null && indexOptions.partialFilterExpression != null) {
                newIndexOptions.partialFilterExpression = {};
                const partialFilterExpression = indexOptions.partialFilterExpression;
                for (const key of Object.keys(partialFilterExpression)){
                    newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
                }
            }
            indexes.push([
                newindex,
                newIndexOptions
            ]);
        }
    }
};


/***/ }),

/***/ 26618:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
module.exports = function getKeysInSchemaOrder(schema, val, path) {
    const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);
    const valKeys = new Set(Object.keys(val));
    let keys;
    if (valKeys.size > 1) {
        keys = new Set();
        for (const key of schemaKeys){
            if (valKeys.has(key)) {
                keys.add(key);
            }
        }
        for (const key of valKeys){
            if (!keys.has(key)) {
                keys.add(key);
            }
        }
        keys = Array.from(keys);
    } else {
        keys = Array.from(valKeys);
    }
    return keys;
};


/***/ }),

/***/ 42094:
/***/ ((module) => {

"use strict";

const numberRE = /^\d+$/;
/**
 * Behaves like `Schema#path()`, except for it also digs into arrays without
 * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.
 * @api private
 */ module.exports = function getPath(schema, path) {
    let schematype = schema.path(path);
    if (schematype != null) {
        return schematype;
    }
    const pieces = path.split(".");
    let cur = "";
    let isArray = false;
    for (const piece of pieces){
        if (isArray && numberRE.test(piece)) {
            continue;
        }
        cur = cur.length === 0 ? piece : cur + "." + piece;
        schematype = schema.path(cur);
        if (schematype != null && schematype.schema) {
            schema = schematype.schema;
            cur = "";
            if (!isArray && schematype.$isMongooseDocumentArray) {
                isArray = true;
            }
        }
    }
    return schematype;
};


/***/ }),

/***/ 61688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const addAutoId = __webpack_require__(40238);
module.exports = function handleIdOption(schema, options) {
    if (options == null || options._id == null) {
        return schema;
    }
    schema = schema.clone();
    if (!options._id) {
        schema.remove("_id");
        schema.options._id = false;
    } else if (!schema.paths["_id"]) {
        addAutoId(schema);
        schema.options._id = true;
    }
    return schema;
};


/***/ }),

/***/ 13226:
/***/ ((module) => {

"use strict";

module.exports = handleTimestampOption;
/*!
 * ignore
 */ function handleTimestampOption(arg, prop) {
    if (arg == null) {
        return null;
    }
    if (typeof arg === "boolean") {
        return prop;
    }
    if (typeof arg[prop] === "boolean") {
        return arg[prop] ? prop : null;
    }
    if (!(prop in arg)) {
        return prop;
    }
    return arg[prop];
}


/***/ }),

/***/ 28899:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function addIdGetter(schema) {
    // ensure the documents receive an id getter unless disabled
    const autoIdGetter = !schema.paths["id"] && schema.paths["_id"] && schema.options.id;
    if (!autoIdGetter) {
        return schema;
    }
    schema.virtual("id").get(idGetter);
    return schema;
};
/**
 * Returns this documents _id cast to a string.
 * @api private
 */ function idGetter() {
    if (this._id != null) {
        return String(this._id);
    }
    return null;
}


/***/ }),

/***/ 38359:
/***/ ((module) => {

"use strict";

module.exports = function merge(s1, s2, skipConflictingPaths) {
    const paths = Object.keys(s2.tree);
    const pathsToAdd = {};
    for (const key of paths){
        if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
            continue;
        }
        pathsToAdd[key] = s2.tree[key];
    }
    s1.add(pathsToAdd);
    s1.callQueue = s1.callQueue.concat(s2.callQueue);
    s1.method(s2.methods);
    s1.static(s2.statics);
    for(const query in s2.query){
        s1.query[query] = s2.query[query];
    }
    for(const virtual in s2.virtuals){
        s1.virtuals[virtual] = s2.virtuals[virtual].clone();
    }
    s1._indexes = s1._indexes.concat(s2._indexes || []);
    s1.s.hooks.merge(s2.s.hooks, false);
};


/***/ }),

/***/ 82819:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const StrictModeError = __webpack_require__(51016);
/*!
 * ignore
 */ module.exports = function(schematype) {
    if (schematype.$immutable) {
        schematype.$immutableSetter = createImmutableSetter(schematype.path, schematype.options.immutable);
        schematype.set(schematype.$immutableSetter);
    } else if (schematype.$immutableSetter) {
        schematype.setters = schematype.setters.filter((fn)=>fn !== schematype.$immutableSetter);
        delete schematype.$immutableSetter;
    }
};
function createImmutableSetter(path, immutable) {
    return function immutableSetter(v, _priorVal, _doc, options) {
        if (this == null || this.$__ == null) {
            return v;
        }
        if (this.isNew) {
            return v;
        }
        if (options && options.overwriteImmutable) {
            return v;
        }
        const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
        if (!_immutable) {
            return v;
        }
        const _value = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(path) : this.$__getValue(path);
        if (this.$__.strictMode === "throw" && v !== _value) {
            throw new StrictModeError(path, "Path `" + path + "` is immutable " + "and strict mode is set to throw.", true);
        }
        return _value;
    };
}


/***/ }),

/***/ 55426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const modifiedPaths = (__webpack_require__(26170)/* .modifiedPaths */ .M);
const get = __webpack_require__(39223);
/**
 * Applies defaults to update and findOneAndUpdate operations.
 *
 * @param {Object} filter
 * @param {Schema} schema
 * @param {Object} castedDoc
 * @param {Object} options
 * @method setDefaultsOnInsert
 * @api private
 */ module.exports = function(filter, schema, castedDoc, options) {
    options = options || {};
    const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
    if (!options.upsert || shouldSetDefaultsOnInsert === false) {
        return castedDoc;
    }
    const keys = Object.keys(castedDoc || {});
    const updatedKeys = {};
    const updatedValues = {};
    const numKeys = keys.length;
    const modified = {};
    let hasDollarUpdate = false;
    for(let i = 0; i < numKeys; ++i){
        if (keys[i].startsWith("$")) {
            modifiedPaths(castedDoc[keys[i]], "", modified);
            hasDollarUpdate = true;
        }
    }
    if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
    }
    const paths = Object.keys(filter);
    const numPaths = paths.length;
    for(let i = 0; i < numPaths; ++i){
        const path = paths[i];
        const condition = filter[path];
        if (condition && typeof condition === "object") {
            const conditionKeys = Object.keys(condition);
            const numConditionKeys = conditionKeys.length;
            let hasDollarKey = false;
            for(let j = 0; j < numConditionKeys; ++j){
                if (conditionKeys[j].startsWith("$")) {
                    hasDollarKey = true;
                    break;
                }
            }
            if (hasDollarKey) {
                continue;
            }
        }
        updatedKeys[path] = true;
        modified[path] = true;
    }
    if (options && options.overwrite && !hasDollarUpdate) {
        // Defaults will be set later, since we're overwriting we'll cast
        // the whole update to a document
        return castedDoc;
    }
    schema.eachPath(function(path, schemaType) {
        // Skip single nested paths if underneath a map
        if (schemaType.path === "_id" && schemaType.options.auto) {
            return;
        }
        const def = schemaType.getDefault(null, true);
        if (isModified(modified, path)) {
            return;
        }
        if (typeof def === "undefined") {
            return;
        }
        if (schemaType.splitPath().includes("$*")) {
            // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`
            return;
        }
        castedDoc = castedDoc || {};
        castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
        if (get(castedDoc, path) == null) {
            castedDoc.$setOnInsert[path] = def;
        }
        updatedValues[path] = def;
    });
    return castedDoc;
};
function isModified(modified, path) {
    if (modified[path]) {
        return true;
    }
    // Is any parent path of `path` modified?
    const sp = path.split(".");
    let cur = sp[0];
    for(let i = 1; i < sp.length; ++i){
        if (modified[cur]) {
            return true;
        }
        cur += "." + sp[i];
    }
    // Is any child of `path` modified?
    const modifiedKeys = Object.keys(modified);
    if (modifiedKeys.length) {
        const parentPath = path + ".";
        for (const modifiedPath of modifiedKeys){
            if (modifiedPath.slice(0, path.length + 1) === parentPath) {
                return true;
            }
        }
    }
    return false;
}


/***/ }),

/***/ 36848:
/***/ ((module) => {

"use strict";

module.exports = new Set([
    "__proto__",
    "constructor",
    "prototype"
]);


/***/ }),

/***/ 5089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup");
exports.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
exports.arrayParentSymbol = Symbol("mongoose#Array#_parent");
exports.arrayPathSymbol = Symbol("mongoose#Array#_path");
exports.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
exports.documentArrayParent = Symbol("mongoose:documentArrayParent");
exports.documentIsSelected = Symbol("mongoose#Document#isSelected");
exports.documentIsModified = Symbol("mongoose#Document#isModified");
exports.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
exports.documentSchemaSymbol = Symbol("mongoose#Document#schema");
exports.getSymbol = Symbol("mongoose#Document#get");
exports.modelSymbol = Symbol("mongoose#Model");
exports.objectIdSymbol = Symbol("mongoose#ObjectId");
exports.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model");
exports.schemaTypeSymbol = Symbol("mongoose#schemaType");
exports.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments");
exports.scopeSymbol = Symbol("mongoose#Document#scope");
exports.validatorErrorSymbol = Symbol("mongoose:validatorError");


/***/ }),

/***/ 29660:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.i = setTimeout;


/***/ }),

/***/ 94942:
/***/ ((module) => {

"use strict";

module.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {
    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
    const defaultTimestamp = currentTime != null ? currentTime() : doc.ownerDocument().constructor.base.now();
    if (!skipCreatedAt && (doc.isNew || doc.$isSubdocument) && createdAt && !doc.$__getValue(createdAt) && doc.$__isSelected(createdAt)) {
        doc.$set(createdAt, defaultTimestamp, undefined, {
            overwriteImmutable: true
        });
    }
    if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {
        let ts = defaultTimestamp;
        if (doc.isNew && createdAt != null) {
            ts = doc.$__getValue(createdAt);
        }
        doc.$set(updatedAt, ts);
    }
};


/***/ }),

/***/ 78099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const applyTimestampsToChildren = __webpack_require__(67592);
const applyTimestampsToUpdate = __webpack_require__(36234);
const get = __webpack_require__(39223);
const handleTimestampOption = __webpack_require__(13226);
const setDocumentTimestamps = __webpack_require__(94942);
const symbols = __webpack_require__(36825);
module.exports = function setupTimestamps(schema, timestamps) {
    const childHasTimestamp = schema.childSchemas.find(withTimestamp);
    function withTimestamp(s) {
        const ts = s.schema.options.timestamps;
        return !!ts;
    }
    if (!timestamps && !childHasTimestamp) {
        return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
    const schemaAdditions = {};
    schema.$timestamps = {
        createdAt: createdAt,
        updatedAt: updatedAt
    };
    if (createdAt && !schema.paths[createdAt]) {
        const baseImmutableCreatedAt = schema.base != null ? schema.base.get("timestamps.createdAt.immutable") : null;
        const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
        schemaAdditions[createdAt] = {
            [schema.options.typeKey || "type"]: Date,
            immutable
        };
    }
    if (updatedAt && !schema.paths[updatedAt]) {
        schemaAdditions[updatedAt] = Date;
    }
    schema.add(schemaAdditions);
    schema.pre("save", function timestampsPreSave(next) {
        const timestampOption = get(this, "$__.saveOptions.timestamps");
        if (timestampOption === false) {
            return next();
        }
        setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
        next();
    });
    schema.methods.initializeTimestamps = function() {
        const ts = currentTime != null ? currentTime() : this.constructor.base.now();
        if (createdAt && !this.get(createdAt)) {
            this.$set(createdAt, ts);
        }
        if (updatedAt && !this.get(updatedAt)) {
            this.$set(updatedAt, ts);
        }
        if (this.$isSubdocument) {
            return this;
        }
        const subdocs = this.$getAllSubdocs();
        for (const subdoc of subdocs){
            if (subdoc.initializeTimestamps) {
                subdoc.initializeTimestamps();
            }
        }
        return this;
    };
    _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
    const opts = {
        query: true,
        model: false
    };
    schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
    schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
    schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
    schema.pre("update", opts, _setTimestampsOnUpdate);
    schema.pre("updateOne", opts, _setTimestampsOnUpdate);
    schema.pre("updateMany", opts, _setTimestampsOnUpdate);
    function _setTimestampsOnUpdate(next) {
        const now = currentTime != null ? currentTime() : this.model.base.now();
        // Replacing with null update should still trigger timestamps
        if (this.op === "findOneAndReplace" && this.getUpdate() == null) {
            this.setUpdate({});
        }
        applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this.options, this.schema);
        applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
        next();
    }
};


/***/ }),

/***/ 42934:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const getConstructorName = __webpack_require__(4065);
module.exports = function allServersUnknown(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
    }
    const servers = Array.from(topologyDescription.servers.values());
    return servers.length > 0 && servers.every((server)=>server.type === "Unknown");
};


/***/ }),

/***/ 44592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const getConstructorName = __webpack_require__(4065);
/**
 * @typedef { import('mongodb').TopologyDescription } TopologyDescription
 */ /**
 * Checks if topologyDescription contains servers connected to an atlas instance
 *
 * @param  {TopologyDescription} topologyDescription
 * @returns {boolean}
 */ module.exports = function isAtlas(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
    }
    if (topologyDescription.servers.size === 0) {
        return false;
    }
    for (const server of topologyDescription.servers.values()){
        if (server.host.endsWith(".mongodb.net") === false || server.port !== 27017) {
            return false;
        }
    }
    return true;
};


/***/ }),

/***/ 72520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const getConstructorName = __webpack_require__(4065);
const nonSSLMessage = "Client network socket disconnected before secure TLS " + "connection was established";
module.exports = function isSSLError(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
    }
    const descriptions = Array.from(topologyDescription.servers.values());
    return descriptions.length > 0 && descriptions.every((descr)=>descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
};


/***/ }),

/***/ 67592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const cleanPositionalOperators = __webpack_require__(35845);
const handleTimestampOption = __webpack_require__(13226);
module.exports = applyTimestampsToChildren;
/*!
 * ignore
 */ function applyTimestampsToChildren(now, update, schema) {
    if (update == null) {
        return;
    }
    const keys = Object.keys(update);
    const hasDollarKey = keys.some((key)=>key[0] === "$");
    if (hasDollarKey) {
        if (update.$push) {
            _applyTimestampToUpdateOperator(update.$push);
        }
        if (update.$addToSet) {
            _applyTimestampToUpdateOperator(update.$addToSet);
        }
        if (update.$set != null) {
            const keys = Object.keys(update.$set);
            for (const key of keys){
                applyTimestampsToUpdateKey(schema, key, update.$set, now);
            }
        }
        if (update.$setOnInsert != null) {
            const keys = Object.keys(update.$setOnInsert);
            for (const key of keys){
                applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
            }
        }
    }
    const updateKeys = Object.keys(update).filter((key)=>key[0] !== "$");
    for (const key of updateKeys){
        applyTimestampsToUpdateKey(schema, key, update, now);
    }
    function _applyTimestampToUpdateOperator(op) {
        for (const key of Object.keys(op)){
            const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
            if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
                const timestamps = $path.schema.options.timestamps;
                const createdAt = handleTimestampOption(timestamps, "createdAt");
                const updatedAt = handleTimestampOption(timestamps, "updatedAt");
                if (op[key].$each) {
                    op[key].$each.forEach(function(subdoc) {
                        if (updatedAt != null) {
                            subdoc[updatedAt] = now;
                        }
                        if (createdAt != null) {
                            subdoc[createdAt] = now;
                        }
                        applyTimestampsToChildren(now, subdoc, $path.schema);
                    });
                } else {
                    if (updatedAt != null) {
                        op[key][updatedAt] = now;
                    }
                    if (createdAt != null) {
                        op[key][createdAt] = now;
                    }
                    applyTimestampsToChildren(now, op[key], $path.schema);
                }
            }
        }
    }
}
function applyTimestampsToDocumentArray(arr, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    const len = arr.length;
    if (!timestamps) {
        for(let i = 0; i < len; ++i){
            applyTimestampsToChildren(now, arr[i], schematype.schema);
        }
        return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    for(let i = 0; i < len; ++i){
        if (updatedAt != null) {
            arr[i][updatedAt] = now;
        }
        if (createdAt != null) {
            arr[i][createdAt] = now;
        }
        applyTimestampsToChildren(now, arr[i], schematype.schema);
    }
}
function applyTimestampsToSingleNested(subdoc, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    if (!timestamps) {
        applyTimestampsToChildren(now, subdoc, schematype.schema);
        return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    if (updatedAt != null) {
        subdoc[updatedAt] = now;
    }
    if (createdAt != null) {
        subdoc[createdAt] = now;
    }
    applyTimestampsToChildren(now, subdoc, schematype.schema);
}
function applyTimestampsToUpdateKey(schema, key, update, now) {
    // Replace positional operator `$` and array filters `$[]` and `$[.*]`
    const keyToSearch = cleanPositionalOperators(key);
    const path = schema.path(keyToSearch);
    if (!path) {
        return;
    }
    const parentSchemaTypes = [];
    const pieces = keyToSearch.split(".");
    for(let i = pieces.length - 1; i > 0; --i){
        const s = schema.path(pieces.slice(0, i).join("."));
        if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
            parentSchemaTypes.push({
                parentPath: key.split(".").slice(0, i).join("."),
                parentSchemaType: s
            });
        }
    }
    if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
        applyTimestampsToDocumentArray(update[key], path, now);
    } else if (update[key] && path.$isSingleNested) {
        applyTimestampsToSingleNested(update[key], path, now);
    } else if (parentSchemaTypes.length > 0) {
        for (const item of parentSchemaTypes){
            const parentPath = item.parentPath;
            const parentSchemaType = item.parentSchemaType;
            const timestamps = parentSchemaType.schema.options.timestamps;
            const updatedAt = handleTimestampOption(timestamps, "updatedAt");
            if (!timestamps || updatedAt == null) {
                continue;
            }
            if (parentSchemaType.$isSingleNested) {
                // Single nested is easy
                update[parentPath + "." + updatedAt] = now;
            } else if (parentSchemaType.$isMongooseDocumentArray) {
                let childPath = key.substring(parentPath.length + 1);
                if (/^\d+$/.test(childPath)) {
                    update[parentPath + "." + childPath][updatedAt] = now;
                    continue;
                }
                const firstDot = childPath.indexOf(".");
                childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;
                update[parentPath + "." + childPath + "." + updatedAt] = now;
            }
        }
    } else if (path.schema != null && path.schema != schema && update[key]) {
        const timestamps = path.schema.options.timestamps;
        const createdAt = handleTimestampOption(timestamps, "createdAt");
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps) {
            return;
        }
        if (updatedAt != null) {
            update[key][updatedAt] = now;
        }
        if (createdAt != null) {
            update[key][createdAt] = now;
        }
    }
}


/***/ }),

/***/ 36234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * ignore
 */ const get = __webpack_require__(39223);
module.exports = applyTimestampsToUpdate;
/*!
 * ignore
 */ function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {
    const updates = currentUpdate;
    let _updates = updates;
    const overwrite = get(options, "overwrite", false);
    const timestamps = get(options, "timestamps", true);
    // Support skipping timestamps at the query level, see gh-6980
    if (!timestamps || updates == null) {
        return currentUpdate;
    }
    const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
    const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
    if (overwrite) {
        if (currentUpdate && currentUpdate.$set) {
            currentUpdate = currentUpdate.$set;
            updates.$set = {};
            _updates = updates.$set;
        }
        if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
            _updates[updatedAt] = now;
        }
        if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
            _updates[createdAt] = now;
        }
        return updates;
    }
    currentUpdate = currentUpdate || {};
    if (Array.isArray(updates)) {
        // Update with aggregation pipeline
        updates.push({
            $set: {
                [updatedAt]: now
            }
        });
        return updates;
    }
    updates.$set = updates.$set || {};
    if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
        let timestampSet = false;
        if (updatedAt.indexOf(".") !== -1) {
            const pieces = updatedAt.split(".");
            for(let i = 1; i < pieces.length; ++i){
                const remnant = pieces.slice(-i).join(".");
                const start = pieces.slice(0, -i).join(".");
                if (currentUpdate[start] != null) {
                    currentUpdate[start][remnant] = now;
                    timestampSet = true;
                    break;
                } else if (currentUpdate.$set && currentUpdate.$set[start]) {
                    currentUpdate.$set[start][remnant] = now;
                    timestampSet = true;
                    break;
                }
            }
        }
        if (!timestampSet) {
            updates.$set[updatedAt] = now;
        }
        if (updates.hasOwnProperty(updatedAt)) {
            delete updates[updatedAt];
        }
    }
    if (!skipCreatedAt && createdAt) {
        if (currentUpdate[createdAt]) {
            delete currentUpdate[createdAt];
        }
        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
            delete currentUpdate.$set[createdAt];
        }
        let timestampSet = false;
        if (createdAt.indexOf(".") !== -1) {
            const pieces = createdAt.split(".");
            for(let i = 1; i < pieces.length; ++i){
                const remnant = pieces.slice(-i).join(".");
                const start = pieces.slice(0, -i).join(".");
                if (currentUpdate[start] != null) {
                    currentUpdate[start][remnant] = now;
                    timestampSet = true;
                    break;
                } else if (currentUpdate.$set && currentUpdate.$set[start]) {
                    currentUpdate.$set[start][remnant] = now;
                    timestampSet = true;
                    break;
                }
            }
        }
        if (!timestampSet) {
            updates.$setOnInsert = updates.$setOnInsert || {};
            updates.$setOnInsert[createdAt] = now;
        }
    }
    if (Object.keys(updates.$set).length === 0) {
        delete updates.$set;
    }
    return updates;
}


/***/ }),

/***/ 78545:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const castFilterPath = __webpack_require__(15708);
const cleanPositionalOperators = __webpack_require__(35845);
const getPath = __webpack_require__(42094);
const updatedPathsByArrayFilter = __webpack_require__(12695);
module.exports = function castArrayFilters(query) {
    const arrayFilters = query.options.arrayFilters;
    const update = query.getUpdate();
    const schema = query.schema;
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    let strictQuery = schema.options.strict;
    if (query._mongooseOptions.strict != null) {
        strictQuery = query._mongooseOptions.strict;
    }
    if (query.model && query.model.base.options.strictQuery != null) {
        strictQuery = query.model.base.options.strictQuery;
    }
    if (schema._userProvidedOptions.strictQuery != null) {
        strictQuery = schema._userProvidedOptions.strictQuery;
    }
    if (query._mongooseOptions.strictQuery != null) {
        strictQuery = query._mongooseOptions.strictQuery;
    }
    _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);
};
function _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {
    if (!Array.isArray(arrayFilters)) {
        return;
    }
    for (const filter of arrayFilters){
        if (filter == null) {
            throw new Error(`Got null array filter in ${arrayFilters}`);
        }
        const keys = Object.keys(filter).filter((key)=>filter[key] != null);
        if (keys.length === 0) {
            continue;
        }
        const firstKey = keys[0];
        if (firstKey === "$and" || firstKey === "$or") {
            for (const key of keys){
                _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);
            }
            continue;
        }
        const dot = firstKey.indexOf(".");
        const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);
        if (updatedPathsByFilter[filterWildcardPath] == null) {
            continue;
        }
        const baseFilterPath = cleanPositionalOperators(updatedPathsByFilter[filterWildcardPath]);
        const baseSchematype = getPath(schema, baseFilterPath);
        let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;
        if (filterBaseSchema != null && filterBaseSchema.discriminators != null && filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]) {
            filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;
        }
        for (const key of keys){
            if (updatedPathsByFilter[key] === null) {
                continue;
            }
            if (Object.keys(updatedPathsByFilter).length === 0) {
                continue;
            }
            const dot = key.indexOf(".");
            let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);
            let schematype;
            if (filterPathRelativeToBase == null || filterBaseSchema == null) {
                schematype = baseSchematype;
            } else {
                // If there are multiple array filters in the path being updated, make sure
                // to replace them so we can get the schema path.
                filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);
                schematype = getPath(filterBaseSchema, filterPathRelativeToBase);
            }
            if (schematype == null) {
                if (!strictQuery) {
                    return;
                }
                const filterPath = filterPathRelativeToBase == null ? baseFilterPath + ".0" : baseFilterPath + ".0" + filterPathRelativeToBase;
                // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as
                // equivalent for casting array filters. `strictQuery = true` doesn't
                // quite work in this context because we never want to silently strip out
                // array filters, even if the path isn't in the schema.
                throw new Error(`Could not find path "${filterPath}" in schema`);
            }
            if (typeof filter[key] === "object") {
                filter[key] = castFilterPath(query, schematype, filter[key]);
            } else {
                filter[key] = schematype.castForQuery(filter[key]);
            }
        }
    }
}


/***/ }),

/***/ 72835:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _modifiedPaths = (__webpack_require__(26170)/* .modifiedPaths */ .M);
/**
 * Given an update document with potential update operators (`$set`, etc.)
 * returns an object whose keys are the directly modified paths.
 *
 * If there are any top-level keys that don't start with `$`, we assume those
 * will get wrapped in a `$set`. The Mongoose Query is responsible for wrapping
 * top-level keys in `$set`.
 *
 * @param {Object} update
 * @return {Object} modified
 */ module.exports = function modifiedPaths(update) {
    const keys = Object.keys(update);
    const res = {};
    const withoutDollarKeys = {};
    for (const key of keys){
        if (key.startsWith("$")) {
            _modifiedPaths(update[key], "", res);
            continue;
        }
        withoutDollarKeys[key] = update[key];
    }
    _modifiedPaths(withoutDollarKeys, "", res);
    return res;
};


/***/ }),

/***/ 19960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const get = __webpack_require__(39223);
/**
 * Given an update, move all $set on immutable properties to $setOnInsert.
 * This should only be called for upserts, because $setOnInsert bypasses the
 * strictness check for immutable properties.
 */ module.exports = function moveImmutableProperties(schema, update, ctx) {
    if (update == null) {
        return;
    }
    const keys = Object.keys(update);
    for (const key of keys){
        const isDollarKey = key.startsWith("$");
        if (key === "$set") {
            const updatedPaths = Object.keys(update[key]);
            for (const path of updatedPaths){
                _walkUpdatePath(schema, update[key], path, update, ctx);
            }
        } else if (!isDollarKey) {
            _walkUpdatePath(schema, update, key, update, ctx);
        }
    }
};
function _walkUpdatePath(schema, op, path, update, ctx) {
    const schematype = schema.path(path);
    if (schematype == null) {
        return;
    }
    let immutable = get(schematype, "options.immutable", null);
    if (immutable == null) {
        return;
    }
    if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
        return;
    }
    update.$setOnInsert = update.$setOnInsert || {};
    update.$setOnInsert[path] = op[path];
    delete op[path];
}


/***/ }),

/***/ 54696:
/***/ ((module) => {

"use strict";

/**
 * MongoDB throws an error if there's unused array filters. That is, if `options.arrayFilters` defines
 * a filter, but none of the `update` keys use it. This should be enough to filter out all unused array
 * filters.
 */ module.exports = function removeUnusedArrayFilters(update, arrayFilters) {
    const updateKeys = Object.keys(update).map((key)=>Object.keys(update[key])).reduce((cur, arr)=>cur.concat(arr), []);
    return arrayFilters.filter((obj)=>{
        return _checkSingleFilterKey(obj, updateKeys);
    });
};
function _checkSingleFilterKey(arrayFilter, updateKeys) {
    const firstKey = Object.keys(arrayFilter)[0];
    if (firstKey === "$and" || firstKey === "$or") {
        if (!Array.isArray(arrayFilter[firstKey])) {
            return false;
        }
        return arrayFilter[firstKey].find((filter)=>_checkSingleFilterKey(filter, updateKeys)) != null;
    }
    const firstDot = firstKey.indexOf(".");
    const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
    return updateKeys.find((key)=>key.includes("$[" + arrayFilterKey + "]")) != null;
}


/***/ }),

/***/ 12695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const modifiedPaths = __webpack_require__(72835);
module.exports = function updatedPathsByArrayFilter(update) {
    if (update == null) {
        return {};
    }
    const updatedPaths = modifiedPaths(update);
    return Object.keys(updatedPaths).reduce((cur, path)=>{
        const matches = path.match(/\$\[[^\]]+\]/g);
        if (matches == null) {
            return cur;
        }
        for (const match of matches){
            const firstMatch = path.indexOf(match);
            if (firstMatch !== path.lastIndexOf(match)) {
                throw new Error(`Path '${path}' contains the same array filter multiple times`);
            }
            cur[match.substring(2, match.length - 1)] = path.substring(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
        }
        return cur;
    }, {});
};


/***/ }),

/***/ 72413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const ValidationError = __webpack_require__(13837);
const cleanPositionalOperators = __webpack_require__(35845);
const flatten = (__webpack_require__(26170)/* .flatten */ .x);
const modifiedPaths = (__webpack_require__(26170)/* .modifiedPaths */ .M);
/**
 * Applies validators and defaults to update and findOneAndUpdate operations,
 * specifically passing a null doc as `this` to validators and defaults
 *
 * @param {Query} query
 * @param {Schema} schema
 * @param {Object} castedDoc
 * @param {Object} options
 * @method runValidatorsOnUpdate
 * @api private
 */ module.exports = function(query, schema, castedDoc, options, callback) {
    const keys = Object.keys(castedDoc || {});
    let updatedKeys = {};
    let updatedValues = {};
    const isPull = {};
    const arrayAtomicUpdates = {};
    const numKeys = keys.length;
    let hasDollarUpdate = false;
    const modified = {};
    let currentUpdate;
    let key;
    let i;
    for(i = 0; i < numKeys; ++i){
        if (keys[i].startsWith("$")) {
            hasDollarUpdate = true;
            if (keys[i] === "$push" || keys[i] === "$addToSet") {
                const _keys = Object.keys(castedDoc[keys[i]]);
                for(let ii = 0; ii < _keys.length; ++ii){
                    currentUpdate = castedDoc[keys[i]][_keys[ii]];
                    if (currentUpdate && currentUpdate.$each) {
                        arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
                    } else {
                        arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([
                            currentUpdate
                        ]);
                    }
                }
                continue;
            }
            modifiedPaths(castedDoc[keys[i]], "", modified);
            const flat = flatten(castedDoc[keys[i]], null, null, schema);
            const paths = Object.keys(flat);
            const numPaths = paths.length;
            for(let j = 0; j < numPaths; ++j){
                const updatedPath = cleanPositionalOperators(paths[j]);
                key = keys[i];
                // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`
                // for the rest of the logic, it will get handled later.
                if (updatedPath.includes("$")) {
                    continue;
                }
                if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
                    updatedValues[updatedPath] = flat[paths[j]];
                    isPull[updatedPath] = key === "$pull" || key === "$pullAll";
                } else if (key === "$unset") {
                    updatedValues[updatedPath] = undefined;
                }
                updatedKeys[updatedPath] = true;
            }
        }
    }
    if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
        updatedValues = flatten(castedDoc, null, null, schema);
        updatedKeys = Object.keys(updatedValues);
    }
    const updates = Object.keys(updatedValues);
    const numUpdates = updates.length;
    const validatorsToExecute = [];
    const validationErrors = [];
    const alreadyValidated = [];
    const context = query;
    function iter(i, v) {
        const schemaPath = schema._getSchema(updates[i]);
        if (schemaPath == null) {
            return;
        }
        if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i]) {
            return;
        }
        if (v && Array.isArray(v.$in)) {
            v.$in.forEach((v, i)=>{
                validatorsToExecute.push(function(callback) {
                    schemaPath.doValidate(v, function(err) {
                        if (err) {
                            err.path = updates[i] + ".$in." + i;
                            validationErrors.push(err);
                        }
                        callback(null);
                    }, context, {
                        updateValidator: true
                    });
                });
            });
        } else {
            if (isPull[updates[i]] && schemaPath.$isMongooseArray) {
                return;
            }
            if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
                alreadyValidated.push(updates[i]);
                validatorsToExecute.push(function(callback) {
                    schemaPath.doValidate(v, function(err) {
                        if (err) {
                            if (err.errors) {
                                for (const key of Object.keys(err.errors)){
                                    const _err = err.errors[key];
                                    _err.path = updates[i] + "." + key;
                                    validationErrors.push(_err);
                                }
                            } else {
                                err.path = updates[i];
                                validationErrors.push(err);
                            }
                        }
                        return callback(null);
                    }, context, {
                        updateValidator: true
                    });
                });
            } else {
                validatorsToExecute.push(function(callback) {
                    for (const path of alreadyValidated){
                        if (updates[i].startsWith(path + ".")) {
                            return callback(null);
                        }
                    }
                    schemaPath.doValidate(v, function(err) {
                        if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
                            return callback(null);
                        }
                        if (err) {
                            err.path = updates[i];
                            validationErrors.push(err);
                        }
                        callback(null);
                    }, context, {
                        updateValidator: true
                    });
                });
            }
        }
    }
    for(i = 0; i < numUpdates; ++i){
        iter(i, updatedValues[updates[i]]);
    }
    const arrayUpdates = Object.keys(arrayAtomicUpdates);
    for (const arrayUpdate of arrayUpdates){
        let schemaPath = schema._getSchema(arrayUpdate);
        if (schemaPath && schemaPath.$isMongooseDocumentArray) {
            validatorsToExecute.push(function(callback) {
                schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === "query" ? query : null);
            });
        } else {
            schemaPath = schema._getSchema(arrayUpdate + ".0");
            for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]){
                validatorsToExecute.push(function(callback) {
                    schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback), options && options.context === "query" ? query : null, {
                        updateValidator: true
                    });
                });
            }
        }
    }
    if (callback != null) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
            return _done(callback);
        }
        for (const validator of validatorsToExecute){
            validator(function() {
                if (--numValidators <= 0) {
                    _done(callback);
                }
            });
        }
        return;
    }
    return function(callback) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
            return _done(callback);
        }
        for (const validator of validatorsToExecute){
            validator(function() {
                if (--numValidators <= 0) {
                    _done(callback);
                }
            });
        }
    };
    function _done(callback) {
        if (validationErrors.length) {
            const err = new ValidationError(null);
            for (const validationError of validationErrors){
                err.addError(validationError.path, validationError);
            }
            return callback(err);
        }
        callback(null);
    }
    function getValidationCallback(arrayUpdate, validationErrors, callback) {
        return function(err) {
            if (err) {
                err.path = arrayUpdate;
                validationErrors.push(err);
            }
            callback(null);
        };
    }
};


/***/ }),

/***/ 18070:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ (__webpack_require__(67085).set)(__webpack_require__(26544));
const Document = __webpack_require__(14001);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const Kareem = __webpack_require__(9840);
const Schema = __webpack_require__(74951);
const SchemaType = __webpack_require__(98878);
const SchemaTypes = __webpack_require__(20042);
const VirtualType = __webpack_require__(3596);
const STATES = __webpack_require__(25840);
const VALID_OPTIONS = __webpack_require__(4365);
const Types = __webpack_require__(35836);
const Query = __webpack_require__(42921);
const Model = __webpack_require__(68389);
const applyPlugins = __webpack_require__(36573);
const builtinPlugins = __webpack_require__(51276);
const driver = __webpack_require__(67085);
const promiseOrCallback = __webpack_require__(83593);
const legacyPluralize = __webpack_require__(31668);
const utils = __webpack_require__(52100);
const pkg = __webpack_require__(13991);
const cast = __webpack_require__(54749);
const Aggregate = __webpack_require__(7545);
const PromiseProvider = __webpack_require__(46433);
const printStrictQueryWarning = __webpack_require__(9378);
const trusted = (__webpack_require__(79657).trusted);
const sanitizeFilter = __webpack_require__(66501);
const isBsonType = __webpack_require__(85847);
const MongooseError = __webpack_require__(51520);
const SetOptionError = __webpack_require__(46608);
const defaultMongooseSymbol = Symbol.for("mongoose:default");
__webpack_require__(89426);
const objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;
/**
 * Mongoose constructor.
 *
 * The exports object of the `mongoose` module is an instance of this class.
 * Most apps will only use this one instance.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     mongoose instanceof mongoose.Mongoose; // true
 *
 *     // Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.
 *     const m = new mongoose.Mongoose();
 *
 * @api public
 * @param {Object} options see [`Mongoose#set()` docs](/docs/api/mongoose.html#mongoose_Mongoose-set)
 */ function Mongoose(options) {
    this.connections = [];
    this.nextConnectionId = 0;
    this.models = {};
    this.events = new EventEmitter();
    this.__driver = driver.get();
    // default global options
    this.options = Object.assign({
        pluralization: true,
        autoIndex: true,
        autoCreate: true
    }, options);
    const conn = this.createConnection(); // default connection
    conn.models = this.models;
    if (this.options.pluralization) {
        this._pluralize = legacyPluralize;
    }
    // If a user creates their own Mongoose instance, give them a separate copy
    // of the `Schema` constructor so they get separate custom types. (gh-6933)
    if (!options || !options[defaultMongooseSymbol]) {
        const _this = this;
        this.Schema = function() {
            this.base = _this;
            return Schema.apply(this, arguments);
        };
        this.Schema.prototype = Object.create(Schema.prototype);
        Object.assign(this.Schema, Schema);
        this.Schema.base = this;
        this.Schema.Types = Object.assign({}, Schema.Types);
    } else {
        // Hack to work around babel's strange behavior with
        // `import mongoose, { Schema } from 'mongoose'`. Because `Schema` is not
        // an own property of a Mongoose global, Schema will be undefined. See gh-5648
        for (const key of [
            "Schema",
            "model"
        ]){
            this[key] = Mongoose.prototype[key];
        }
    }
    this.Schema.prototype.base = this;
    Object.defineProperty(this, "plugins", {
        configurable: false,
        enumerable: true,
        writable: false,
        value: Object.values(builtinPlugins).map((plugin)=>[
                plugin,
                {
                    deduplicate: true
                }
            ])
    });
}
Mongoose.prototype.cast = cast;
/**
 * Expose connection states for user-land
 *
 * @memberOf Mongoose
 * @property STATES
 * @api public
 */ Mongoose.prototype.STATES = STATES;
/**
 * Expose connection states for user-land
 *
 * @memberOf Mongoose
 * @property ConnectionStates
 * @api public
 */ Mongoose.prototype.ConnectionStates = STATES;
/**
 * Object with `get()` and `set()` containing the underlying driver this Mongoose instance
 * uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions
 * like `find()`.
 *
 * @deprecated
 * @memberOf Mongoose
 * @property driver
 * @api public
 */ Mongoose.prototype.driver = driver;
/**
 * Overwrites the current driver used by this Mongoose instance. A driver is a
 * Mongoose-specific interface that defines functions like `find()`.
 *
 * @memberOf Mongoose
 * @method setDriver
 * @api public
 */ Mongoose.prototype.setDriver = function setDriver(driver) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (_mongoose.__driver === driver) {
        return _mongoose;
    }
    const openConnection = _mongoose.connections && _mongoose.connections.find((conn)=>conn.readyState !== STATES.disconnected);
    if (openConnection) {
        const msg = "Cannot modify Mongoose driver if a connection is already open. " + "Call `mongoose.disconnect()` before modifying the driver";
        throw new MongooseError(msg);
    }
    _mongoose.__driver = driver;
    const Connection = driver.getConnection();
    _mongoose.connections = [
        new Connection(_mongoose)
    ];
    _mongoose.connections[0].models = _mongoose.models;
    return _mongoose;
};
/**
 * Sets mongoose options
 *
 * `key` can be used a object to set multiple options at once.
 * If a error gets thrown for one option, other options will still be evaluated.
 *
 * #### Example:
 *
 *     mongoose.set('test', value) // sets the 'test' option to `value`
 *
 *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console/file
 *
 *     mongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments
 *
 *     mongoose.set({ debug: true, autoIndex: false }); // set multiple options at once
 *
 * Currently supported options are:
 * - `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.
 * - `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas
 * - `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.
 * - `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](/docs/api/model.html#model_Model-createCollection) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.
 * - `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.
 * - `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models
 * - `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).
 * - `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.
 * - `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.
 * - `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.
 * - `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](https://mongoosejs.com/docs/api/schematype.html#schematype_SchemaType-immutable) which means you can update the `createdAt`
 * - `maxTimeMS`: If set, attaches [maxTimeMS](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/) to every query
 * - `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.
 * - `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.
 * - `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](/docs/tutorials/findoneandupdate.html) for more information.
 * - `runValidators`: `false` by default. Set to true to enable [update validators](/docs/validation.html#update-validators) for all validators by default.
 * - `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](/docs/api/mongoose.html#mongoose_Mongoose-sanitizeFilter) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.
 * - `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.
 * - `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.
 * - `strictQuery`: same value as 'strict' by default (`true`), may be `false`, `true`, or `'throw'`. Sets the default [strictQuery](/docs/guide.html#strictQuery) mode for schemas. The default value will be switched back to `false` in Mongoose 7, use `mongoose.set('strictQuery', false);` if you want to prepare for the change.
 * - `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](/docs/api/document.html#document_Document-toJSON), for determining how Mongoose documents get serialized by `JSON.stringify()`
 * - `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](/docs/api/document.html#document_Document-toObject)
 *
 * @param {String|Object} key The name of the option or a object of multiple key-value pairs
 * @param {String|Function|Boolean} value The value of the option, unused if "key" is a object
 * @returns {Mongoose} The used Mongoose instnace
 * @api public
 */ Mongoose.prototype.set = function(key, value) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length === 1 && typeof key !== "object") {
        if (VALID_OPTIONS.indexOf(key) === -1) {
            const error = new SetOptionError();
            error.addError(key, new SetOptionError.SetOptionInnerError(key));
            throw error;
        }
        return _mongoose.options[key];
    }
    let options = {};
    if (arguments.length === 2) {
        options = {
            [key]: value
        };
    }
    if (arguments.length === 1 && typeof key === "object") {
        options = key;
    }
    // array for errors to collect all errors for all key-value pairs, like ".validate"
    let error = undefined;
    for (const [optionKey, optionValue] of Object.entries(options)){
        if (VALID_OPTIONS.indexOf(optionKey) === -1) {
            if (!error) {
                error = new SetOptionError();
            }
            error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));
            continue;
        }
        _mongoose.options[optionKey] = optionValue;
        if (optionKey === "objectIdGetter") {
            if (optionValue) {
                Object.defineProperty(mongoose.Types.ObjectId.prototype, "_id", {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return this;
                    }
                });
            } else {
                delete mongoose.Types.ObjectId.prototype._id;
            }
        }
    }
    if (error) {
        throw error;
    }
    return _mongoose;
};
/**
 * Gets mongoose options
 *
 * #### Example:
 *
 *     mongoose.get('test') // returns the 'test' value
 *
 * @param {String} key
 * @method get
 * @api public
 */ Mongoose.prototype.get = Mongoose.prototype.set;
/**
 * Creates a Connection instance.
 *
 * Each `connection` instance maps to a single database. This method is helpful when managing multiple db connections.
 *
 *
 * _Options passed take precedence over options included in connection strings._
 *
 * #### Example:
 *
 *     // with mongodb:// URI
 *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');
 *
 *     // and options
 *     const opts = { db: { native_parser: true }}
 *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);
 *
 *     // replica sets
 *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');
 *
 *     // and options
 *     const opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}
 *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);
 *
 *     // initialize now, connect later
 *     db = mongoose.createConnection();
 *     db.openUri('127.0.0.1', 'database', port, [opts]);
 *
 * @param {String} uri mongodb URI to connect to
 * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.
 * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.
 * @param {String} [options.dbName] The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.
 * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.
 * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.
 * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.
 * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).
 * @param {Number} [options.maxPoolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).
 * @param {Number} [options.minPoolSize=1] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).
 * @param {Number} [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _during initial connection_. Defaults to 30000. This option is passed transparently to [Node.js' `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback).
 * @param {Number} [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. This is set to `30000` by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.
 * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.
 * @return {Connection} the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.
 * @api public
 */ Mongoose.prototype.createConnection = function(uri, options, callback) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const Connection = _mongoose.__driver.getConnection();
    const conn = new Connection(_mongoose);
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    _mongoose.connections.push(conn);
    _mongoose.nextConnectionId++;
    _mongoose.events.emit("createConnection", conn);
    if (arguments.length > 0) {
        conn.openUri(uri, options, callback);
    }
    return conn;
};
/**
 * Opens the default mongoose connection.
 *
 * #### Example:
 *
 *     mongoose.connect('mongodb://user:pass@127.0.0.1:port/database');
 *
 *     // replica sets
 *     const uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';
 *     mongoose.connect(uri);
 *
 *     // with options
 *     mongoose.connect(uri, options);
 *
 *     // optional callback that gets fired when initial connection completed
 *     const uri = 'mongodb://nonexistent.domain:27000';
 *     mongoose.connect(uri, function(error) {
 *       // if error is truthy, the initial connection failed.
 *     })
 *
 * @param {String} uri mongodb URI to connect to
 * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.
 * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.
 * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.
 * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.
 * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.
 * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.
 * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).
 * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection.
 * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).
 * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.
 * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.
 * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).
 * @param {Number} [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _during initial connection_. Defaults to 30000. This option is passed transparently to [Node.js' `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback).
 * @param {Number} [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. This is set to `30000` by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.
 * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.
 * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.
 * @param {Function} [callback]
 * @see Mongoose#createConnection /docs/api/mongoose.html#mongoose_Mongoose-createConnection
 * @api public
 * @return {Promise} resolves to `this` if connection succeeded
 */ Mongoose.prototype.connect = function(uri, options, callback) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const conn = _mongoose.connection;
    if (_mongoose.options.strictQuery === undefined) {
        printStrictQueryWarning();
    }
    return _mongoose._promiseOrCallback(callback, (cb)=>{
        conn.openUri(uri, options, (err)=>{
            if (err != null) {
                return cb(err);
            }
            return cb(null, _mongoose);
        });
    });
};
/**
 * Runs `.close()` on all connections in parallel.
 *
 * @param {Function} [callback] called after all connection close, or when first error occurred.
 * @return {Promise} resolves when all connections are closed, or rejects with the first error that occurred.
 * @api public
 */ Mongoose.prototype.disconnect = function(callback) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose._promiseOrCallback(callback, (cb)=>{
        let remaining = _mongoose.connections.length;
        if (remaining <= 0) {
            return cb(null);
        }
        _mongoose.connections.forEach((conn)=>{
            conn.close(function(error) {
                if (error) {
                    return cb(error);
                }
                if (!--remaining) {
                    cb(null);
                }
            });
        });
    });
};
/**
 * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)
 * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),
 * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).
 *
 * Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`.
 * Sessions are scoped to a connection, so calling `mongoose.startSession()`
 * starts a session on the [default mongoose connection](/docs/api/mongoose.html#mongoose_Mongoose-connection).
 *
 * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)
 * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency
 * @param {Function} [callback]
 * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`
 * @api public
 */ Mongoose.prototype.startSession = function() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
};
/**
 * Getter/setter around function for pluralizing collection names.
 *
 * @param {Function|null} [fn] overwrites the function used to pluralize collection names
 * @return {Function|null} the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.
 * @api public
 */ Mongoose.prototype.pluralize = function(fn) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length > 0) {
        _mongoose._pluralize = fn;
    }
    return _mongoose._pluralize;
};
/**
 * Defines a model or retrieves it.
 *
 * Models defined on the `mongoose` instance are available to all connection
 * created by the same `mongoose` instance.
 *
 * If you call `mongoose.model()` with twice the same name but a different schema,
 * you will get an `OverwriteModelError`. If you call `mongoose.model()` with
 * the same name and same schema, you'll get the same schema back.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *
 *     // define an Actor model with this mongoose instance
 *     const schema = new Schema({ name: String });
 *     mongoose.model('Actor', schema);
 *
 *     // create a new connection
 *     const conn = mongoose.createConnection(..);
 *
 *     // create Actor model
 *     const Actor = conn.model('Actor', schema);
 *     conn.model('Actor') === Actor; // true
 *     conn.model('Actor', schema) === Actor; // true, same schema
 *     conn.model('Actor', schema, 'actors') === Actor; // true, same schema and collection name
 *
 *     // This throws an `OverwriteModelError` because the schema is different.
 *     conn.model('Actor', new Schema({ name: String }));
 *
 * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String }, { collection: 'actor' });
 *
 *     // or
 *
 *     schema.set('collection', 'actor');
 *
 *     // or
 *
 *     const collectionName = 'actor'
 *     const M = mongoose.model('Actor', schema, collectionName)
 *
 * @param {String|Function} name model name or class extending Model
 * @param {Schema} [schema] the schema to use.
 * @param {String} [collection] name (optional, inferred from model name)
 * @return {Model} The model associated with `name`. Mongoose will create the model if it doesn't already exist.
 * @api public
 */ Mongoose.prototype.model = function(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (typeof schema === "string") {
        collection = schema;
        schema = false;
    }
    if (arguments.length === 1) {
        const model = _mongoose.models[name];
        if (!model) {
            throw new MongooseError.MissingSchemaError(name);
        }
        return model;
    }
    if (utils.isObject(schema) && !(schema instanceof Schema)) {
        schema = new Schema(schema);
    }
    if (schema && !(schema instanceof Schema)) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a " + "schema or a POJO");
    }
    // handle internal options from connection.model()
    options = options || {};
    const originalSchema = schema;
    if (schema) {
        if (_mongoose.get("cloneSchemas")) {
            schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
    }
    // connection.model() may be passing a different schema for
    // an existing model name. in this case don't read from cache.
    const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
    if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {
        if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
            throw new _mongoose.Error.OverwriteModelError(name);
        }
        if (collection && collection !== _mongoose.models[name].collection.name) {
            // subclass current model with alternate collection
            const model = _mongoose.models[name];
            schema = model.prototype.schema;
            const sub = model.__subclass(_mongoose.connection, schema, collection);
            // do not cache the sub model
            return sub;
        }
        return _mongoose.models[name];
    }
    if (schema == null) {
        throw new _mongoose.Error.MissingSchemaError(name);
    }
    const model = _mongoose._model(name, schema, collection, options);
    _mongoose.connection.models[name] = model;
    _mongoose.models[name] = model;
    return model;
};
/*!
 * ignore
 */ Mongoose.prototype._model = function(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    let model;
    if (typeof name === "function") {
        model = name;
        name = model.name;
        if (!(model.prototype instanceof Model)) {
            throw new _mongoose.Error("The provided class " + name + " must extend Model");
        }
    }
    if (schema) {
        if (_mongoose.get("cloneSchemas")) {
            schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
    }
    // Apply relevant "global" options to the schema
    if (schema == null || !("pluralization" in schema.options)) {
        schema.options.pluralization = _mongoose.options.pluralization;
    }
    if (!collection) {
        collection = schema.get("collection") || utils.toCollectionName(name, _mongoose.pluralize());
    }
    const connection = options.connection || _mongoose.connection;
    model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
    // Errors handled internally, so safe to ignore error
    model.init(function $modelInitNoop() {});
    connection.emit("model", model);
    if (schema._applyDiscriminators != null) {
        for (const disc of Object.keys(schema._applyDiscriminators)){
            model.discriminator(disc, schema._applyDiscriminators[disc]);
        }
    }
    return model;
};
/**
 * Removes the model named `name` from the default connection, if it exists.
 * You can use this function to clean up any models you created in your tests to
 * prevent OverwriteModelErrors.
 *
 * Equivalent to `mongoose.connection.deleteModel(name)`.
 *
 * #### Example:
 *
 *     mongoose.model('User', new Schema({ name: String }));
 *     console.log(mongoose.model('User')); // Model object
 *     mongoose.deleteModel('User');
 *     console.log(mongoose.model('User')); // undefined
 *
 *     // Usually useful in a Mocha `afterEach()` hook
 *     afterEach(function() {
 *       mongoose.deleteModel(/.+/); // Delete every model
 *     });
 *
 * @api public
 * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.
 * @return {Mongoose} this
 */ Mongoose.prototype.deleteModel = function(name) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.connection.deleteModel(name);
    delete _mongoose.models[name];
    return _mongoose;
};
/**
 * Returns an array of model names created on this instance of Mongoose.
 *
 * #### Note:
 *
 * _Does not include names of models created using `connection.model()`._
 *
 * @api public
 * @return {Array}
 */ Mongoose.prototype.modelNames = function() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const names = Object.keys(_mongoose.models);
    return names;
};
/**
 * Applies global plugins to `schema`.
 *
 * @param {Schema} schema
 * @api private
 */ Mongoose.prototype._applyPlugins = function(schema, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    options = options || {};
    options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;
    options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToDiscriminators) === "boolean" ? _mongoose.options.applyPluginsToDiscriminators : true;
    applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
};
/**
 * Declares a global plugin executed on all Schemas.
 *
 * Equivalent to calling `.plugin(fn)` on each Schema you create.
 *
 * @param {Function} fn plugin callback
 * @param {Object} [opts] optional options
 * @return {Mongoose} this
 * @see plugins /docs/plugins
 * @api public
 */ Mongoose.prototype.plugin = function(fn, opts) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.plugins.push([
        fn,
        opts
    ]);
    return _mongoose;
};
/**
 * The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](#mongoose_Mongoose-connections).
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     mongoose.connect(...);
 *     mongoose.connection.on('error', cb);
 *
 * This is the connection used by default for every model created using [mongoose.model](#index_Mongoose-model).
 *
 * To create a new connection, use [`createConnection()`](#mongoose_Mongoose-createConnection).
 *
 * @memberOf Mongoose
 * @instance
 * @property {Connection} connection
 * @api public
 */ Mongoose.prototype.__defineGetter__("connection", function() {
    return this.connections[0];
});
Mongoose.prototype.__defineSetter__("connection", function(v) {
    if (v instanceof this.__driver.getConnection()) {
        this.connections[0] = v;
        this.models = v.models;
    }
});
/**
 * An array containing all [connections](connections.html) associated with this
 * Mongoose instance. By default, there is 1 connection. Calling
 * [`createConnection()`](#mongoose_Mongoose-createConnection) adds a connection
 * to this array.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     mongoose.connections.length; // 1, just the default connection
 *     mongoose.connections[0] === mongoose.connection; // true
 *
 *     mongoose.createConnection('mongodb://127.0.0.1:27017/test');
 *     mongoose.connections.length; // 2
 *
 * @memberOf Mongoose
 * @instance
 * @property {Array} connections
 * @api public
 */ Mongoose.prototype.connections;
/**
 * An integer containing the value of the next connection id. Calling
 * [`createConnection()`](#mongoose_Mongoose-createConnection) increments
 * this value.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     mongoose.createConnection(); // id `0`, `nextConnectionId` becomes `1`
 *     mongoose.createConnection(); // id `1`, `nextConnectionId` becomes `2`
 *     mongoose.connections[0].destroy() // Removes connection with id `0`
 *     mongoose.createConnection(); // id `2`, `nextConnectionId` becomes `3`
 *
 * @memberOf Mongoose
 * @instance
 * @property {Number} nextConnectionId
 * @api private
 */ Mongoose.prototype.nextConnectionId;
/**
 * The Mongoose Aggregate constructor
 *
 * @method Aggregate
 * @api public
 */ Mongoose.prototype.Aggregate = Aggregate;
/**
 * The Mongoose Collection constructor
 *
 * @memberOf Mongoose
 * @instance
 * @method Collection
 * @api public
 */ Object.defineProperty(Mongoose.prototype, "Collection", {
    get: function() {
        return this.__driver.Collection;
    },
    set: function(Collection) {
        this.__driver.Collection = Collection;
    }
});
/**
 * The Mongoose [Connection](#connection_Connection) constructor
 *
 * @memberOf Mongoose
 * @instance
 * @method Connection
 * @api public
 */ Object.defineProperty(Mongoose.prototype, "Connection", {
    get: function() {
        return this.__driver.getConnection();
    },
    set: function(Connection) {
        if (Connection === this.__driver.getConnection()) {
            return;
        }
        this.__driver.getConnection = ()=>Connection;
    }
});
/**
 * The Mongoose version
 *
 * #### Example:
 *
 *     console.log(mongoose.version); // '5.x.x'
 *
 * @property version
 * @api public
 */ Mongoose.prototype.version = pkg.version;
/**
 * The Mongoose constructor
 *
 * The exports of the mongoose module is an instance of this class.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     const mongoose2 = new mongoose.Mongoose();
 *
 * @method Mongoose
 * @api public
 */ Mongoose.prototype.Mongoose = Mongoose;
/**
 * The Mongoose [Schema](#schema_Schema) constructor
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     const Schema = mongoose.Schema;
 *     const CatSchema = new Schema(..);
 *
 * @method Schema
 * @api public
 */ Mongoose.prototype.Schema = Schema;
/**
 * The Mongoose [SchemaType](#schematype_SchemaType) constructor
 *
 * @method SchemaType
 * @api public
 */ Mongoose.prototype.SchemaType = SchemaType;
/**
 * The various Mongoose SchemaTypes.
 *
 * #### Note:
 *
 * _Alias of mongoose.Schema.Types for backwards compatibility._
 *
 * @property SchemaTypes
 * @see Schema.SchemaTypes /docs/schematypes
 * @api public
 */ Mongoose.prototype.SchemaTypes = Schema.Types;
/**
 * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor
 *
 * @method VirtualType
 * @api public
 */ Mongoose.prototype.VirtualType = VirtualType;
/**
 * The various Mongoose Types.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     const array = mongoose.Types.Array;
 *
 * #### Types:
 *
 * - [Array](/docs/schematypes.html#arrays)
 * - [Buffer](/docs/schematypes.html#buffers)
 * - [Embedded](/docs/schematypes.html#schemas)
 * - [DocumentArray](/docs/api/documentarraypath.html)
 * - [Decimal128](/docs/api/mongoose.html#mongoose_Mongoose-Decimal128)
 * - [ObjectId](/docs/schematypes.html#objectids)
 * - [Map](/docs/schematypes.html#maps)
 * - [Subdocument](/docs/schematypes.html#schemas)
 *
 * Using this exposed access to the `ObjectId` type, we can construct ids on demand.
 *
 *     const ObjectId = mongoose.Types.ObjectId;
 *     const id1 = new ObjectId;
 *
 * @property Types
 * @api public
 */ Mongoose.prototype.Types = Types;
/**
 * The Mongoose [Query](#query_Query) constructor.
 *
 * @method Query
 * @api public
 */ Mongoose.prototype.Query = Query;
/**
 * The Mongoose [Promise](#promise_Promise) constructor.
 *
 * @memberOf Mongoose
 * @instance
 * @property Promise
 * @api public
 */ Object.defineProperty(Mongoose.prototype, "Promise", {
    get: function() {
        return PromiseProvider.get();
    },
    set: function(lib) {
        PromiseProvider.set(lib);
    }
});
/**
 * Storage layer for mongoose promises
 *
 * @method PromiseProvider
 * @api public
 */ Mongoose.prototype.PromiseProvider = PromiseProvider;
/**
 * The Mongoose [Model](#model_Model) constructor.
 *
 * @method Model
 * @api public
 */ Mongoose.prototype.Model = Model;
/**
 * The Mongoose [Document](/docs/api/document.html#Document) constructor.
 *
 * @method Document
 * @api public
 */ Mongoose.prototype.Document = Document;
/**
 * The Mongoose DocumentProvider constructor. Mongoose users should not have to
 * use this directly
 *
 * @method DocumentProvider
 * @api public
 */ Mongoose.prototype.DocumentProvider = __webpack_require__(17660);
/**
 * The Mongoose ObjectId [SchemaType](/docs/schematypes.html). Used for
 * declaring paths in your schema that should be
 * [MongoDB ObjectIds](https://docs.mongodb.com/manual/reference/method/ObjectId/).
 * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`
 * instead.
 *
 * #### Example:
 *
 *     const childSchema = new Schema({ parentId: mongoose.ObjectId });
 *
 * @property ObjectId
 * @api public
 */ Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
/**
 * Returns true if Mongoose can cast the given value to an ObjectId, or
 * false otherwise.
 *
 * #### Example:
 *
 *     mongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true
 *     mongoose.isValidObjectId('0123456789ab'); // true
 *     mongoose.isValidObjectId(6); // true
 *     mongoose.isValidObjectId(new User({ name: 'test' })); // true
 *
 *     mongoose.isValidObjectId({ test: 42 }); // false
 *
 * @method isValidObjectId
 * @param {Any} v
 * @returns {boolean} true if `v` is something Mongoose can coerce to an ObjectId
 * @api public
 */ Mongoose.prototype.isValidObjectId = function(v) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.Types.ObjectId.isValid(v);
};
/**
 * Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the
 * given value is a 24 character hex string, which is the most commonly used string representation
 * of an ObjectId.
 *
 * This function is similar to `isValidObjectId()`, but considerably more strict, because
 * `isValidObjectId()` will return `true` for _any_ value that Mongoose can convert to an
 * ObjectId. That includes Mongoose documents, any string of length 12, and any number.
 * `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex
 * strings, and will return false for numbers, documents, and strings of length 12.
 *
 * #### Example:
 *
 *     mongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true
 *     mongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true
 *
 *     mongoose.isObjectIdOrHexString('0123456789ab'); // false
 *     mongoose.isObjectIdOrHexString(6); // false
 *     mongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false
 *     mongoose.isObjectIdOrHexString({ test: 42 }); // false
 *
 * @method isObjectIdOrHexString
 * @param {Any} v
 * @returns {boolean} true if `v` is an ObjectId instance _or_ a 24 char hex string
 * @api public
 */ Mongoose.prototype.isObjectIdOrHexString = function(v) {
    return isBsonType(v, "ObjectID") || typeof v === "string" && objectIdHexRegexp.test(v);
};
/**
 *
 * Syncs all the indexes for the models registered with this connection.
 *
 * @param {Object} options
 * @param {Boolean} options.continueOnError `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.
 * @return {Promise} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.
 */ Mongoose.prototype.syncIndexes = function(options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.syncIndexes(options);
};
/**
 * The Mongoose Decimal128 [SchemaType](/docs/schematypes.html). Used for
 * declaring paths in your schema that should be
 * [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).
 * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`
 * instead.
 *
 * #### Example:
 *
 *     const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });
 *
 * @property Decimal128
 * @api public
 */ Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
/**
 * The Mongoose Mixed [SchemaType](/docs/schematypes.html). Used for
 * declaring paths in your schema that Mongoose's change tracking, casting,
 * and validation should ignore.
 *
 * #### Example:
 *
 *     const schema = new Schema({ arbitrary: mongoose.Mixed });
 *
 * @property Mixed
 * @api public
 */ Mongoose.prototype.Mixed = SchemaTypes.Mixed;
/**
 * The Mongoose Date [SchemaType](/docs/schematypes.html).
 *
 * #### Example:
 *
 *     const schema = new Schema({ test: Date });
 *     schema.path('test') instanceof mongoose.Date; // true
 *
 * @property Date
 * @api public
 */ Mongoose.prototype.Date = SchemaTypes.Date;
/**
 * The Mongoose Number [SchemaType](/docs/schematypes.html). Used for
 * declaring paths in your schema that Mongoose should cast to numbers.
 *
 * #### Example:
 *
 *     const schema = new Schema({ num: mongoose.Number });
 *     // Equivalent to:
 *     const schema = new Schema({ num: 'number' });
 *
 * @property Number
 * @api public
 */ Mongoose.prototype.Number = SchemaTypes.Number;
/**
 * The [MongooseError](#error_MongooseError) constructor.
 *
 * @method Error
 * @api public
 */ Mongoose.prototype.Error = __webpack_require__(40413);
/**
 * Mongoose uses this function to get the current time when setting
 * [timestamps](/docs/guide.html#timestamps). You may stub out this function
 * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.
 *
 * @method now
 * @returns Date the current time
 * @api public
 */ Mongoose.prototype.now = function now() {
    return new Date();
};
/**
 * The Mongoose CastError constructor
 *
 * @method CastError
 * @param {String} type The name of the type
 * @param {Any} value The value that failed to cast
 * @param {String} path The path `a.b.c` in the doc where this cast error occurred
 * @param {Error} [reason] The original error that was thrown
 * @api public
 */ Mongoose.prototype.CastError = __webpack_require__(96996);
/**
 * The constructor used for schematype options
 *
 * @method SchemaTypeOptions
 * @api public
 */ Mongoose.prototype.SchemaTypeOptions = __webpack_require__(84252);
/**
 * The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.
 *
 * @property mongo
 * @api public
 */ Mongoose.prototype.mongo = __webpack_require__(38013);
/**
 * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.
 *
 * @property mquery
 * @api public
 */ Mongoose.prototype.mquery = __webpack_require__(66908);
/**
 * Sanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html)
 * by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.
 *
 * ```javascript
 * const obj = { username: 'val', pwd: { $ne: null } };
 * sanitizeFilter(obj);
 * obj; // { username: 'val', pwd: { $eq: { $ne: null } } });
 * ```
 *
 * @method sanitizeFilter
 * @param {Object} filter
 * @returns Object the sanitized object
 * @api public
 */ Mongoose.prototype.sanitizeFilter = sanitizeFilter;
/**
 * Tells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html).
 * Use this method when you have a known query selector that you want to use.
 *
 * ```javascript
 * const obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };
 * sanitizeFilter(obj);
 *
 * // Note that `sanitizeFilter()` did not add `$eq` around `$type`.
 * obj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });
 * ```
 *
 * @method trusted
 * @param {Object} obj
 * @returns Object the passed in object
 * @api public
 */ Mongoose.prototype.trusted = trusted;
/*!
 * ignore
 */ Mongoose.prototype._promiseOrCallback = function(callback, fn, ee) {
    return promiseOrCallback(callback, fn, ee, this.Promise);
};
/**
 * Use this function in `pre()` middleware to skip calling the wrapped function.
 *
 * #### Example:
 *
 *     schema.pre('save', function() {
 *       // Will skip executing `save()`, but will execute post hooks as if
 *       // `save()` had executed with the result `{ matchedCount: 0 }`
 *       return mongoose.skipMiddlewareFunction({ matchedCount: 0 });
 *     });
 *
 * @method skipMiddlewareFunction
 * @param {any} result
 * @api public
 */ Mongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;
/**
 * Use this function in `post()` middleware to replace the result
 *
 * #### Example:
 *
 *     schema.post('find', function(res) {
 *       // Normally you have to modify `res` in place. But with
 *       // `overwriteMiddlewarResult()`, you can make `find()` return a
 *       // completely different value.
 *       return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));
 *     });
 *
 * @method overwriteMiddlewareResult
 * @param {any} result
 * @api public
 */ Mongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;
/**
 * The exports object is an instance of Mongoose.
 *
 * @api private
 */ const mongoose = module.exports = exports = new Mongoose({
    [defaultMongooseSymbol]: true
});


/***/ }),

/***/ 16897:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * Dependencies
 */ 
const StateMachine = __webpack_require__(4455);
const ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
module.exports = exports = InternalCache;
function InternalCache() {
    this.activePaths = new ActiveRoster();
}
InternalCache.prototype.strictMode = true;
InternalCache.prototype.fullPath = undefined;
InternalCache.prototype.selected = undefined;
InternalCache.prototype.shardval = undefined;
InternalCache.prototype.saveError = undefined;
InternalCache.prototype.validationError = undefined;
InternalCache.prototype.adhocPaths = undefined;
InternalCache.prototype.removing = undefined;
InternalCache.prototype.inserting = undefined;
InternalCache.prototype.saving = undefined;
InternalCache.prototype.version = undefined;
InternalCache.prototype._id = undefined;
InternalCache.prototype.ownerDocument = undefined;
InternalCache.prototype.populate = undefined; // what we want to populate in this doc
InternalCache.prototype.populated = undefined; // the _ids that have been populated
InternalCache.prototype.primitiveAtomics = undefined;
/**
 * If `false`, this document was not the result of population.
 * If `true`, this document is a populated doc underneath another doc
 * If an object, this document is a populated doc and the `value` property of the
 * object contains the original depopulated value.
 */ InternalCache.prototype.wasPopulated = false;
InternalCache.prototype.scope = undefined;
InternalCache.prototype.session = null;
InternalCache.prototype.pathsToScopes = null;
InternalCache.prototype.cachedRequired = null;


/***/ }),

/***/ 68389:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const Aggregate = __webpack_require__(7545);
const ChangeStream = __webpack_require__(67659);
const Document = __webpack_require__(14001);
const DocumentNotFoundError = __webpack_require__(8671);
const DivergentArrayError = __webpack_require__(33182);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const MongooseBuffer = __webpack_require__(77784);
const MongooseError = __webpack_require__(40413);
const OverwriteModelError = __webpack_require__(13034);
const PromiseProvider = __webpack_require__(46433);
const Query = __webpack_require__(42921);
const RemoveOptions = __webpack_require__(51483);
const SaveOptions = __webpack_require__(22277);
const Schema = __webpack_require__(74951);
const ServerSelectionError = __webpack_require__(76027);
const ValidationError = __webpack_require__(13837);
const VersionError = __webpack_require__(19096);
const ParallelSaveError = __webpack_require__(45254);
const applyDefaultsHelper = __webpack_require__(1796);
const applyDefaultsToPOJO = __webpack_require__(70126);
const applyQueryMiddleware = __webpack_require__(94135);
const applyHooks = __webpack_require__(13202);
const applyMethods = __webpack_require__(81007);
const applyProjection = __webpack_require__(73077);
const applySchemaCollation = __webpack_require__(3447);
const applyStaticHooks = __webpack_require__(95583);
const applyStatics = __webpack_require__(58256);
const applyWriteConcern = __webpack_require__(75103);
const assignVals = __webpack_require__(83970);
const castBulkWrite = __webpack_require__(9881);
const createPopulateQueryFilter = __webpack_require__(57851);
const getDefaultBulkwriteResult = __webpack_require__(54883);
const getSchemaDiscriminatorByValue = __webpack_require__(16049);
const discriminator = __webpack_require__(47683);
const firstKey = __webpack_require__(12163);
const each = __webpack_require__(60233);
const get = __webpack_require__(39223);
const getConstructorName = __webpack_require__(4065);
const getDiscriminatorByValue = __webpack_require__(17492);
const getModelsMapForPopulate = __webpack_require__(87839);
const immediate = __webpack_require__(96621);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const isDefaultIdIndex = __webpack_require__(92465);
const isIndexEqual = __webpack_require__(65147);
const { getRelatedDBIndexes , getRelatedSchemaIndexes  } = __webpack_require__(7896);
const isPathExcluded = __webpack_require__(55862);
const decorateDiscriminatorIndexOptions = __webpack_require__(23846);
const isPathSelectedInclusive = __webpack_require__(53282);
const leanPopulateMap = __webpack_require__(25747);
const modifiedPaths = __webpack_require__(72835);
const parallelLimit = __webpack_require__(5623);
const parentPaths = __webpack_require__(79478);
const prepareDiscriminatorPipeline = __webpack_require__(52409);
const pushNestedArrayPaths = __webpack_require__(49477);
const removeDeselectedForeignField = __webpack_require__(11289);
const setDottedPath = __webpack_require__(73479);
const util = __webpack_require__(73837);
const utils = __webpack_require__(52100);
const VERSION_WHERE = 1;
const VERSION_INC = 2;
const VERSION_ALL = VERSION_WHERE | VERSION_INC;
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const modelCollectionSymbol = Symbol("mongoose#Model#collection");
const modelDbSymbol = Symbol("mongoose#Model#db");
const modelSymbol = (__webpack_require__(5089).modelSymbol);
const subclassedSymbol = Symbol("mongoose#Model#subclassed");
const saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
    bson: true
});
/**
 * A Model is a class that's your primary tool for interacting with MongoDB.
 * An instance of a Model is called a [Document](./api/document.html#Document).
 *
 * In Mongoose, the term "Model" refers to subclasses of the `mongoose.Model`
 * class. You should not use the `mongoose.Model` class directly. The
 * [`mongoose.model()`](./api/mongoose.html#mongoose_Mongoose-model) and
 * [`connection.model()`](./api/connection.html#connection_Connection-model) functions
 * create subclasses of `mongoose.Model` as shown below.
 *
 * #### Example:
 *
 *     // `UserModel` is a "Model", a subclass of `mongoose.Model`.
 *     const UserModel = mongoose.model('User', new Schema({ name: String }));
 *
 *     // You can use a Model to create new documents using `new`:
 *     const userDoc = new UserModel({ name: 'Foo' });
 *     await userDoc.save();
 *
 *     // You also use a model to create queries:
 *     const userFromDb = await UserModel.findOne({ name: 'Foo' });
 *
 * @param {Object} doc values for initial set
 * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](./api/query.html#query_Query-select).
 * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.
 * @inherits Document https://mongoosejs.com/docs/api/document.html
 * @event `error`: If listening to this event, 'error' is emitted when a document was saved without passing a callback and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.
 * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.
 * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.
 * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.
 * @api public
 */ function Model(doc, fields, skipId) {
    if (fields instanceof Schema) {
        throw new TypeError("2nd argument to `Model` must be a POJO or string, " + "**not** a schema. Make sure you're calling `mongoose.model()`, not " + "`mongoose.Model()`.");
    }
    Document.call(this, doc, fields, skipId);
}
/**
 * Inherits from Document.
 *
 * All Model.prototype features are available on
 * top level (non-sub) documents.
 * @api private
 */ Object.setPrototypeOf(Model.prototype, Document.prototype);
Model.prototype.$isMongooseModelPrototype = true;
/**
 * Connection the model uses.
 *
 * @api public
 * @property db
 * @memberOf Model
 * @instance
 */ Model.prototype.db;
/**
 * Collection the model uses.
 *
 * This property is read-only. Modifying this property is a no-op.
 *
 * @api public
 * @property collection
 * @memberOf Model
 * @instance
 */ Model.prototype.collection;
/**
 * Internal collection the model uses.
 *
 * This property is read-only. Modifying this property is a no-op.
 *
 * @api private
 * @property collection
 * @memberOf Model
 * @instance
 */ Model.prototype.$__collection;
/**
 * The name of the model
 *
 * @api public
 * @property modelName
 * @memberOf Model
 * @instance
 */ Model.prototype.modelName;
/**
 * Additional properties to attach to the query when calling `save()` and
 * `isNew` is false.
 *
 * @api public
 * @property $where
 * @memberOf Model
 * @instance
 */ Model.prototype.$where;
/**
 * If this is a discriminator model, `baseModelName` is the name of
 * the base model.
 *
 * @api public
 * @property baseModelName
 * @memberOf Model
 * @instance
 */ Model.prototype.baseModelName;
/**
 * Event emitter that reports any errors that occurred. Useful for global error
 * handling.
 *
 * #### Example:
 *
 *     MyModel.events.on('error', err => console.log(err.message));
 *
 *     // Prints a 'CastError' because of the above handler
 *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);
 *
 * @api public
 * @property events
 * @fires error whenever any query or model function errors
 * @memberOf Model
 * @static
 */ Model.events;
/**
 * Compiled middleware for this model. Set in `applyHooks()`.
 *
 * @api private
 * @property _middleware
 * @memberOf Model
 * @static
 */ Model._middleware;
/*!
 * ignore
 */ function _applyCustomWhere(doc, where) {
    if (doc.$where == null) {
        return;
    }
    for (const key of Object.keys(doc.$where)){
        where[key] = doc.$where[key];
    }
}
/*!
 * ignore
 */ Model.prototype.$__handleSave = function(options, callback) {
    const saveOptions = {};
    applyWriteConcern(this.$__schema, options);
    if (typeof options.writeConcern !== "undefined") {
        saveOptions.writeConcern = {};
        if ("w" in options.writeConcern) {
            saveOptions.writeConcern.w = options.writeConcern.w;
        }
        if ("j" in options.writeConcern) {
            saveOptions.writeConcern.j = options.writeConcern.j;
        }
        if ("wtimeout" in options.writeConcern) {
            saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
        }
    } else {
        if ("w" in options) {
            saveOptions.w = options.w;
        }
        if ("j" in options) {
            saveOptions.j = options.j;
        }
        if ("wtimeout" in options) {
            saveOptions.wtimeout = options.wtimeout;
        }
    }
    if ("checkKeys" in options) {
        saveOptions.checkKeys = options.checkKeys;
    }
    if (!saveOptions.hasOwnProperty("session")) {
        saveOptions.session = this.$session();
    }
    if (this.$isNew) {
        // send entire doc
        const obj = this.toObject(saveToObjectOptions);
        if ((obj || {})._id === void 0) {
            // documents must have an _id else mongoose won't know
            // what to update later if more changes are made. the user
            // wouldn't know what _id was generated by mongodb either
            // nor would the ObjectId generated by mongodb necessarily
            // match the schema definition.
            immediate(function() {
                callback(new MongooseError("document must have an _id before saving"));
            });
            return;
        }
        this.$__version(true, obj);
        this[modelCollectionSymbol].insertOne(obj, saveOptions, (err, ret)=>{
            if (err) {
                _setIsNew(this, true);
                callback(err, null);
                return;
            }
            callback(null, ret);
        });
        this.$__reset();
        _setIsNew(this, false);
        // Make it possible to retry the insert
        this.$__.inserting = true;
        return;
    }
    // Make sure we don't treat it as a new object on error,
    // since it already exists
    this.$__.inserting = false;
    const delta = this.$__delta();
    if (delta) {
        if (delta instanceof MongooseError) {
            callback(delta);
            return;
        }
        const where = this.$__where(delta[0]);
        if (where instanceof MongooseError) {
            callback(where);
            return;
        }
        _applyCustomWhere(this, where);
        this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret)=>{
            if (err) {
                this.$__undoReset();
                callback(err);
                return;
            }
            ret.$where = where;
            callback(null, ret);
        });
    } else {
        const optionsWithCustomValues = Object.assign({}, options, saveOptions);
        const where = this.$__where();
        const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
        if (optimisticConcurrency) {
            const key = this.$__schema.options.versionKey;
            const val = this.$__getValue(key);
            if (val != null) {
                where[key] = val;
            }
        }
        this.constructor.exists(where, optionsWithCustomValues).then((documentExists)=>{
            const matchedCount = !documentExists ? 0 : 1;
            callback(null, {
                $where: where,
                matchedCount
            });
        }).catch(callback);
        return;
    }
    // store the modified paths before the document is reset
    this.$__.modifiedPaths = this.modifiedPaths();
    this.$__reset();
    _setIsNew(this, false);
};
/*!
 * ignore
 */ Model.prototype.$__save = function(options, callback) {
    this.$__handleSave(options, (error, result)=>{
        if (error) {
            const hooks = this.$__schema.s.hooks;
            return hooks.execPost("save:error", this, [
                this
            ], {
                error: error
            }, (error)=>{
                callback(error, this);
            });
        }
        let numAffected = 0;
        const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;
        if (writeConcern !== 0) {
            // Skip checking if write succeeded if writeConcern is set to
            // unacknowledged writes, because otherwise `numAffected` will always be 0
            if (result != null) {
                if (Array.isArray(result)) {
                    numAffected = result.length;
                } else if (result.matchedCount != null) {
                    numAffected = result.matchedCount;
                } else {
                    numAffected = result;
                }
            }
            const versionBump = this.$__.version;
            // was this an update that required a version bump?
            if (versionBump && !this.$__.inserting) {
                const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
                this.$__.version = undefined;
                const key = this.$__schema.options.versionKey;
                const version = this.$__getValue(key) || 0;
                if (numAffected <= 0) {
                    // the update failed. pass an error back
                    this.$__undoReset();
                    const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
                    return callback(err);
                }
                // increment version if was successful
                if (doIncrement) {
                    this.$__setValue(key, version + 1);
                }
            }
            if (result != null && numAffected <= 0) {
                this.$__undoReset();
                error = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);
                const hooks = this.$__schema.s.hooks;
                return hooks.execPost("save:error", this, [
                    this
                ], {
                    error: error
                }, (error)=>{
                    callback(error, this);
                });
            }
        }
        this.$__.saving = undefined;
        this.$__.savedState = {};
        this.$emit("save", this, numAffected);
        this.constructor.emit("save", this, numAffected);
        callback(null, this);
    });
};
/*!
 * ignore
 */ function generateVersionError(doc, modifiedPaths) {
    const key = doc.$__schema.options.versionKey;
    if (!key) {
        return null;
    }
    const version = doc.$__getValue(key) || 0;
    return new VersionError(doc, version, modifiedPaths);
}
/**
 * Saves this document by inserting a new document into the database if [document.isNew](/docs/api/document.html#document_Document-isNew) is `true`,
 * or sends an [updateOne](/docs/api/document.html#document_Document-updateOne) operation with just the modified paths if `isNew` is `false`.
 *
 * #### Example:
 *
 *     product.sold = Date.now();
 *     product = await product.save();
 *
 * If save is successful, the returned promise will fulfill with the document
 * saved.
 *
 * #### Example:
 *
 *     const newProduct = await product.save();
 *     newProduct === product; // true
 *
 * @param {Object} [options] options optional options
 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api/document.html#document_Document-$session).
 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.
 * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.
 * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.
 * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)
 * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).
 * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)
 * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.
 * @param {Function} [fn] optional callback
 * @throws {DocumentNotFoundError} if this [save updates an existing document](api/document.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).
 * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.
 * @api public
 * @see middleware https://mongoosejs.com/docs/middleware.html
 */ Model.prototype.save = function(options, fn) {
    let parallelSave;
    this.$op = "save";
    if (this.$__.saving) {
        parallelSave = new ParallelSaveError(this);
    } else {
        this.$__.saving = new ParallelSaveError(this);
    }
    if (typeof options === "function") {
        fn = options;
        options = undefined;
    }
    options = new SaveOptions(options);
    if (options.hasOwnProperty("session")) {
        this.$session(options.session);
    }
    if (this.$__.timestamps != null) {
        options.timestamps = this.$__.timestamps;
    }
    this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
    fn = this.constructor.$handleCallbackError(fn);
    return this.constructor.db.base._promiseOrCallback(fn, (cb)=>{
        cb = this.constructor.$wrapCallback(cb);
        if (parallelSave) {
            this.$__handleReject(parallelSave);
            return cb(parallelSave);
        }
        this.$__.saveOptions = options;
        this.$__save(options, (error)=>{
            this.$__.saving = null;
            this.$__.saveOptions = null;
            this.$__.$versionError = null;
            this.$op = null;
            if (error) {
                this.$__handleReject(error);
                return cb(error);
            }
            cb(null, this);
        });
    }, this.constructor.events);
};
Model.prototype.$save = Model.prototype.save;
/**
 * Determines whether versioning should be skipped for the given path
 *
 * @param {Document} self
 * @param {String} path
 * @return {Boolean} true if versioning should be skipped for the given path
 * @api private
 */ function shouldSkipVersioning(self, path) {
    const skipVersioning = self.$__schema.options.skipVersioning;
    if (!skipVersioning) return false;
    // Remove any array indexes from the path
    path = path.replace(/\.\d+\./, ".");
    return skipVersioning[path];
}
/**
 * Apply the operation to the delta (update) clause as
 * well as track versioning for our where clause.
 *
 * @param {Document} self
 * @param {Object} where Unused
 * @param {Object} delta
 * @param {Object} data
 * @param {Mixed} val
 * @param {String} [op]
 * @api private
 */ function operand(self, where, delta, data, val, op) {
    // delta
    op || (op = "$set");
    if (!delta[op]) delta[op] = {};
    delta[op][data.path] = val;
    // disabled versioning?
    if (self.$__schema.options.versionKey === false) return;
    // path excluded from versioning?
    if (shouldSkipVersioning(self, data.path)) return;
    // already marked for versioning?
    if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;
    if (self.$__schema.options.optimisticConcurrency) {
        return;
    }
    switch(op){
        case "$set":
        case "$unset":
        case "$pop":
        case "$pull":
        case "$pullAll":
        case "$push":
        case "$addToSet":
        case "$inc":
            break;
        default:
            // nothing to do
            return;
    }
    // ensure updates sent with positional notation are
    // editing the correct array element.
    // only increment the version if an array position changes.
    // modifying elements of an array is ok if position does not change.
    if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
        if (/\.\d+\.|\.\d+$/.test(data.path)) {
            increment.call(self);
        } else {
            self.$__.version = VERSION_INC;
        }
    } else if (/^\$p/.test(op)) {
        // potentially changing array positions
        increment.call(self);
    } else if (Array.isArray(val)) {
        // $set an array
        increment.call(self);
    } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
        // now handling $set, $unset
        // subpath of array
        self.$__.version = VERSION_WHERE;
    }
}
/**
 * Compiles an update and where clause for a `val` with _atomics.
 *
 * @param {Document} self
 * @param {Object} where
 * @param {Object} delta
 * @param {Object} data
 * @param {Array} value
 * @api private
 */ function handleAtomics(self, where, delta, data, value) {
    if (delta.$set && delta.$set[data.path]) {
        // $set has precedence over other atomics
        return;
    }
    if (typeof value.$__getAtomics === "function") {
        value.$__getAtomics().forEach(function(atomic) {
            const op = atomic[0];
            const val = atomic[1];
            operand(self, where, delta, data, val, op);
        });
        return;
    }
    // legacy support for plugins
    const atomics = value[arrayAtomicsSymbol];
    const ops = Object.keys(atomics);
    let i = ops.length;
    let val;
    let op;
    if (i === 0) {
        // $set
        if (utils.isMongooseObject(value)) {
            value = value.toObject({
                depopulate: 1,
                _isNested: true
            });
        } else if (value.valueOf) {
            value = value.valueOf();
        }
        return operand(self, where, delta, data, value);
    }
    function iter(mem) {
        return utils.isMongooseObject(mem) ? mem.toObject({
            depopulate: 1,
            _isNested: true
        }) : mem;
    }
    while(i--){
        op = ops[i];
        val = atomics[op];
        if (utils.isMongooseObject(val)) {
            val = val.toObject({
                depopulate: true,
                transform: false,
                _isNested: true
            });
        } else if (Array.isArray(val)) {
            val = val.map(iter);
        } else if (val.valueOf) {
            val = val.valueOf();
        }
        if (op === "$addToSet") {
            val = {
                $each: val
            };
        }
        operand(self, where, delta, data, val, op);
    }
}
/**
 * Produces a special query document of the modified properties used in updates.
 *
 * @api private
 * @method $__delta
 * @memberOf Model
 * @instance
 */ Model.prototype.$__delta = function() {
    const dirty = this.$__dirty();
    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
    if (optimisticConcurrency) {
        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
    }
    if (!dirty.length && VERSION_ALL !== this.$__.version) {
        return;
    }
    const where = {};
    const delta = {};
    const len = dirty.length;
    const divergent = [];
    let d = 0;
    where._id = this._doc._id;
    // If `_id` is an object, need to depopulate, but also need to be careful
    // because `_id` can technically be null (see gh-6406)
    if ((where && where._id && where._id.$__ || null) != null) {
        where._id = where._id.toObject({
            transform: false,
            depopulate: true
        });
    }
    for(; d < len; ++d){
        const data = dirty[d];
        let value = data.value;
        const match = checkDivergentArray(this, data.path, value);
        if (match) {
            divergent.push(match);
            continue;
        }
        const pop = this.$populated(data.path, true);
        if (!pop && this.$__.selected) {
            // If any array was selected using an $elemMatch projection, we alter the path and where clause
            // NOTE: MongoDB only supports projected $elemMatch on top level array.
            const pathSplit = data.path.split(".");
            const top = pathSplit[0];
            if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
                // If the selected array entry was modified
                if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
                    where[top] = this.$__.selected[top];
                    pathSplit[1] = "$";
                    data.path = pathSplit.join(".");
                } else {
                    divergent.push(data.path);
                    continue;
                }
            }
        }
        // If this path is set to default, and either this path or one of
        // its parents is excluded, don't treat this path as dirty.
        if (this.$isDefault(data.path) && this.$__.selected) {
            if (data.path.indexOf(".") === -1 && isPathExcluded(this.$__.selected, data.path)) {
                continue;
            }
            const pathsToCheck = parentPaths(data.path);
            if (pathsToCheck.find((path)=>isPathExcluded(this.$__.isSelected, path))) {
                continue;
            }
        }
        if (divergent.length) continue;
        if (value === undefined) {
            operand(this, where, delta, data, 1, "$unset");
        } else if (value === null) {
            operand(this, where, delta, data, null);
        } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {
            // arrays and other custom types (support plugins etc)
            handleAtomics(this, where, delta, data, value);
        } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
            // MongooseBuffer
            value = value.toObject();
            operand(this, where, delta, data, value);
        } else {
            if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {
                const val = this.$__.primitiveAtomics[data.path];
                const op = firstKey(val);
                operand(this, where, delta, data, val[op], op);
            } else {
                value = utils.clone(value, {
                    depopulate: true,
                    transform: false,
                    virtuals: false,
                    getters: false,
                    omitUndefined: true,
                    _isNested: true
                });
                operand(this, where, delta, data, value);
            }
        }
    }
    if (divergent.length) {
        return new DivergentArrayError(divergent);
    }
    if (this.$__.version) {
        this.$__version(where, delta);
    }
    if (Object.keys(delta).length === 0) {
        return [
            where,
            null
        ];
    }
    return [
        where,
        delta
    ];
};
/**
 * Determine if array was populated with some form of filter and is now
 * being updated in a manner which could overwrite data unintentionally.
 *
 * @see https://github.com/Automattic/mongoose/issues/1334
 * @param {Document} doc
 * @param {String} path
 * @param {Any} array
 * @return {String|undefined}
 * @api private
 */ function checkDivergentArray(doc, path, array) {
    // see if we populated this path
    const pop = doc.$populated(path, true);
    if (!pop && doc.$__.selected) {
        // If any array was selected using an $elemMatch projection, we deny the update.
        // NOTE: MongoDB only supports projected $elemMatch on top level array.
        const top = path.split(".")[0];
        if (doc.$__.selected[top + ".$"]) {
            return top;
        }
    }
    if (!(pop && utils.isMongooseArray(array))) return;
    // If the array was populated using options that prevented all
    // documents from being returned (match, skip, limit) or they
    // deselected the _id field, $pop and $set of the array are
    // not safe operations. If _id was deselected, we do not know
    // how to remove elements. $pop will pop off the _id from the end
    // of the array in the db which is not guaranteed to be the
    // same as the last element we have here. $set of the entire array
    // would be similarly destructive as we never received all
    // elements of the array and potentially would overwrite data.
    const check = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, "limit") || // 0 is not permitted
    pop.options.options && pop.options.options.skip || // 0 is permitted
    pop.options.select && // deselected _id?
    (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
    if (check) {
        const atomics = array[arrayAtomicsSymbol];
        if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
            return path;
        }
    }
}
/**
 * Appends versioning to the where and update clauses.
 *
 * @api private
 * @method $__version
 * @memberOf Model
 * @instance
 */ Model.prototype.$__version = function(where, delta) {
    const key = this.$__schema.options.versionKey;
    if (where === true) {
        // this is an insert
        if (key) {
            setDottedPath(delta, key, 0);
            this.$__setValue(key, 0);
        }
        return;
    }
    if (key === false) {
        return;
    }
    // updates
    // only apply versioning if our versionKey was selected. else
    // there is no way to select the correct version. we could fail
    // fast here and force them to include the versionKey but
    // thats a bit intrusive. can we do this automatically?
    if (!this.$__isSelected(key)) {
        return;
    }
    // $push $addToSet don't need the where clause set
    if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
        const value = this.$__getValue(key);
        if (value != null) where[key] = value;
    }
    if (VERSION_INC === (VERSION_INC & this.$__.version)) {
        if (get(delta.$set, key, null) != null) {
            // Version key is getting set, means we'll increment the doc's version
            // after a successful save, so we should set the incremented version so
            // future saves don't fail (gh-5779)
            ++delta.$set[key];
        } else {
            delta.$inc = delta.$inc || {};
            delta.$inc[key] = 1;
        }
    }
};
/*!
 * ignore
 */ function increment() {
    this.$__.version = VERSION_ALL;
    return this;
}
/**
 * Signal that we desire an increment of this documents version.
 *
 * #### Example:
 *
 *     const doc = await Model.findById(id);
 *     doc.increment();
 *     await doc.save();
 *
 * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey
 * @memberOf Model
 * @method increment
 * @api public
 */ Model.prototype.increment = increment;
/**
 * Returns a query object
 *
 * @api private
 * @method $__where
 * @memberOf Model
 * @instance
 */ Model.prototype.$__where = function _where(where) {
    where || (where = {});
    if (!where._id) {
        where._id = this._doc._id;
    }
    if (this._doc._id === void 0) {
        return new MongooseError("No _id found on document!");
    }
    return where;
};
/**
 * Removes this document from the db.
 *
 * #### Example:
 *
 *     const product = await product.remove().catch(function (err) {
 *        assert.ok(err);
 *     });
 *     const foundProduct = await Product.findById(product._id);
 *     console.log(foundProduct) // null
 *
 * @param {Object} [options]
 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this operation. If not specified, defaults to the [document's associated session](api/document.html#document_Document-$session).
 * @param {function(err,product)} [fn] optional callback
 * @return {Promise} Promise
 * @api public
 */ Model.prototype.remove = function remove(options, fn) {
    if (typeof options === "function") {
        fn = options;
        options = undefined;
    }
    options = new RemoveOptions(options);
    if (options.hasOwnProperty("session")) {
        this.$session(options.session);
    }
    this.$op = "remove";
    fn = this.constructor.$handleCallbackError(fn);
    return this.constructor.db.base._promiseOrCallback(fn, (cb)=>{
        cb = this.constructor.$wrapCallback(cb);
        this.$__remove(options, (err, res)=>{
            this.$op = null;
            cb(err, res);
        });
    }, this.constructor.events);
};
/**
 * Alias for remove
 *
 * @method $remove
 * @memberOf Model
 * @instance
 * @api public
 * @see Model.remove #model_Model-remove
 */ Model.prototype.$remove = Model.prototype.remove;
Model.prototype.delete = Model.prototype.remove;
/**
 * Removes this document from the db. Equivalent to `.remove()`.
 *
 * #### Example:
 *
 *     product = await product.deleteOne();
 *     await Product.findById(product._id); // null
 *
 * @param {function(err,product)} [fn] optional callback
 * @return {Promise} Promise
 * @api public
 */ Model.prototype.deleteOne = function deleteOne(options, fn) {
    if (typeof options === "function") {
        fn = options;
        options = undefined;
    }
    if (!options) {
        options = {};
    }
    fn = this.constructor.$handleCallbackError(fn);
    return this.constructor.db.base._promiseOrCallback(fn, (cb)=>{
        cb = this.constructor.$wrapCallback(cb);
        this.$__deleteOne(options, cb);
    }, this.constructor.events);
};
/*!
 * ignore
 */ Model.prototype.$__remove = function $__remove(options, cb) {
    if (this.$__.isDeleted) {
        return immediate(()=>cb(null, this));
    }
    const where = this.$__where();
    if (where instanceof MongooseError) {
        return cb(where);
    }
    _applyCustomWhere(this, where);
    const session = this.$session();
    if (!options.hasOwnProperty("session")) {
        options.session = session;
    }
    this[modelCollectionSymbol].deleteOne(where, options, (err)=>{
        if (!err) {
            this.$__.isDeleted = true;
            this.$emit("remove", this);
            this.constructor.emit("remove", this);
            return cb(null, this);
        }
        this.$__.isDeleted = false;
        cb(err);
    });
};
/*!
 * ignore
 */ Model.prototype.$__deleteOne = Model.prototype.$__remove;
/**
 * Returns another Model instance.
 *
 * #### Example:
 *
 *     const doc = new Tank;
 *     doc.model('User').findById(id, callback);
 *
 * @param {String} name model name
 * @method model
 * @api public
 * @return {Model}
 */ Model.prototype.model = function model(name) {
    return this[modelDbSymbol].model(name);
};
/**
 * Returns another Model instance.
 *
 * #### Example:
 *
 *     const doc = new Tank;
 *     doc.model('User').findById(id, callback);
 *
 * @param {String} name model name
 * @method $model
 * @api public
 * @return {Model}
 */ Model.prototype.$model = function $model(name) {
    return this[modelDbSymbol].model(name);
};
/**
 * Returns a document with `_id` only if at least one document exists in the database that matches
 * the given `filter`, and `null` otherwise.
 *
 * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to
 * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`
 *
 * #### Example:
 *
 *     await Character.deleteMany({});
 *     await Character.create({ name: 'Jean-Luc Picard' });
 *
 *     await Character.exists({ name: /picard/i }); // { _id: ... }
 *     await Character.exists({ name: /riker/i }); // null
 *
 * This function triggers the following middleware.
 *
 * - `findOne()`
 *
 * @param {Object} filter
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback] callback
 * @return {Query}
 */ Model.exists = function exists(filter, options, callback) {
    _checkContext(this, "exists");
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const query = this.findOne(filter).select({
        _id: 1
    }).lean().setOptions(options);
    if (typeof callback === "function") {
        return query.exec(callback);
    }
    return query;
};
/**
 * Adds a discriminator type.
 *
 * #### Example:
 *
 *     function BaseSchema() {
 *       Schema.apply(this, arguments);
 *
 *       this.add({
 *         name: String,
 *         createdAt: Date
 *       });
 *     }
 *     util.inherits(BaseSchema, Schema);
 *
 *     const PersonSchema = new BaseSchema();
 *     const BossSchema = new BaseSchema({ department: String });
 *
 *     const Person = mongoose.model('Person', PersonSchema);
 *     const Boss = Person.discriminator('Boss', BossSchema);
 *     new Boss().__t; // "Boss". `__t` is the default `discriminatorKey`
 *
 *     const employeeSchema = new Schema({ boss: ObjectId });
 *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');
 *     new Employee().__t; // "staff" because of 3rd argument above
 *
 * @param {String} name discriminator model name
 * @param {Schema} schema discriminator model schema
 * @param {Object|String} [options] If string, same as `options.value`.
 * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.
 * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.
 * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.
 * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.
 * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.
 * @return {Model} The newly created discriminator model
 * @api public
 */ Model.discriminator = function(name, schema, options) {
    let model;
    if (typeof name === "function") {
        model = name;
        name = utils.getFunctionName(model);
        if (!(model.prototype instanceof Model)) {
            throw new MongooseError("The provided class " + name + " must extend Model");
        }
    }
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    const mergePlugins = typeof options.mergePlugins === "boolean" ? options.mergePlugins : true;
    _checkContext(this, "discriminator");
    if (utils.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
    }
    if (schema instanceof Schema && clone) {
        schema = schema.clone();
    }
    schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);
    if (this.db.models[name] && !schema.options.overwriteModels) {
        throw new OverwriteModelError(name);
    }
    schema.$isRootDiscriminator = true;
    schema.$globalPluginsApplied = true;
    model = this.db.model(model || name, schema, this.$__collection.name);
    this.discriminators[name] = model;
    const d = this.discriminators[name];
    Object.setPrototypeOf(d.prototype, this.prototype);
    Object.defineProperty(d, "baseModelName", {
        value: this.modelName,
        configurable: true,
        writable: false
    });
    // apply methods and statics
    applyMethods(d, schema);
    applyStatics(d, schema);
    if (this[subclassedSymbol] != null) {
        for (const submodel of this[subclassedSymbol]){
            submodel.discriminators = submodel.discriminators || {};
            submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
        }
    }
    return d;
};
/**
 * Make sure `this` is a model
 * @api private
 */ function _checkContext(ctx, fnName) {
    // Check context, because it is easy to mistakenly type
    // `new Model.discriminator()` and get an incomprehensible error
    if (ctx == null || ctx === global) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a " + "model as `this`. Make sure you are calling `MyModel." + fnName + "()` " + "where `MyModel` is a Mongoose model.");
    } else if (ctx[modelSymbol] == null) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a " + "model as `this`. Make sure you are not calling " + "`new Model." + fnName + "()`");
    }
}
// Model (class) features
/*!
 * Give the constructor the ability to emit events.
 */ for(const i in EventEmitter.prototype){
    Model[i] = EventEmitter.prototype[i];
}
/**
 * This function is responsible for building [indexes](https://docs.mongodb.com/manual/indexes/),
 * unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) is turned off.
 *
 * Mongoose calls this function automatically when a model is created using
 * [`mongoose.model()`](/docs/api/mongoose.html#mongoose_Mongoose-model) or
 * [`connection.model()`](/docs/api/connection.html#connection_Connection-model), so you
 * don't need to call it. This function is also idempotent, so you may call it
 * to get back a promise that will resolve when your indexes are finished
 * building as an alternative to [`MyModel.on('index')`](/docs/guide.html#indexes)
 *
 * #### Example:
 *
 *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })
 *     // This calls `Event.init()` implicitly, so you don't need to call
 *     // `Event.init()` on your own.
 *     const Event = mongoose.model('Event', eventSchema);
 *
 *     Event.init().then(function(Event) {
 *       // You can also use `Event.on('index')` if you prefer event emitters
 *       // over promises.
 *       console.log('Indexes are done building!');
 *     });
 *
 * @api public
 * @param {Function} [callback]
 * @returns {Promise}
 */ Model.init = function init(callback) {
    _checkContext(this, "init");
    this.schema.emit("init", this);
    if (this.$init != null) {
        if (callback) {
            this.$init.then(()=>callback(), (err)=>callback(err));
            return null;
        }
        return this.$init;
    }
    const Promise1 = PromiseProvider.get();
    const autoIndex = utils.getOption("autoIndex", this.schema.options, this.db.config, this.db.base.options);
    const autoCreate = utils.getOption("autoCreate", this.schema.options, this.db.config, this.db.base.options);
    const _ensureIndexes = autoIndex ? (cb)=>this.ensureIndexes({
            _automatic: true
        }, cb) : (cb)=>cb();
    const _createCollection = autoCreate ? (cb)=>this.createCollection({}, cb) : (cb)=>cb();
    this.$init = new Promise1((resolve, reject)=>{
        _createCollection((error)=>{
            if (error) {
                return reject(error);
            }
            _ensureIndexes((error)=>{
                if (error) {
                    return reject(error);
                }
                resolve(this);
            });
        });
    });
    if (callback) {
        this.$init.then(()=>callback(), (err)=>callback(err));
        this.$caught = true;
        return null;
    } else {
        const _catch = this.$init.catch;
        const _this = this;
        this.$init.catch = function() {
            this.$caught = true;
            return _catch.apply(_this.$init, arguments);
        };
    }
    return this.$init;
};
/**
 * Create the collection for this model. By default, if no indexes are specified,
 * mongoose will not create the collection for the model until any documents are
 * created. Use this method to create the collection explicitly.
 *
 * Note 1: You may need to call this before starting a transaction
 * See https://docs.mongodb.com/manual/core/transactions/#transactions-and-operations
 *
 * Note 2: You don't have to call this if your schema contains index or unique field.
 * In that case, just use `Model.init()`
 *
 * #### Example:
 *
 *     const userSchema = new Schema({ name: String })
 *     const User = mongoose.model('User', userSchema);
 *
 *     User.createCollection().then(function(collection) {
 *       console.log('Collection is created!');
 *     });
 *
 * @api public
 * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)
 * @param {Function} [callback]
 * @returns {Promise}
 */ Model.createCollection = function createCollection(options, callback) {
    _checkContext(this, "createCollection");
    if (typeof options === "string") {
        throw new MongooseError("You can't specify a new collection name in Model.createCollection." + "This is not like Connection.createCollection. Only options are accepted here.");
    } else if (typeof options === "function") {
        callback = options;
        options = void 0;
    }
    const schemaCollation = this && this.schema && this.schema.options && this.schema.options.collation;
    if (schemaCollation != null) {
        options = Object.assign({
            collation: schemaCollation
        }, options);
    }
    const capped = this && this.schema && this.schema.options && this.schema.options.capped;
    if (capped != null) {
        if (typeof capped === "number") {
            options = Object.assign({
                capped: true,
                size: capped
            }, options);
        } else if (typeof capped === "object") {
            options = Object.assign({
                capped: true
            }, capped, options);
        }
    }
    const timeseries = this && this.schema && this.schema.options && this.schema.options.timeseries;
    if (timeseries != null) {
        options = Object.assign({
            timeseries
        }, options);
        if (options.expireAfterSeconds != null) {
        // do nothing
        } else if (options.expires != null) {
            utils.expires(options);
        } else if (this.schema.options.expireAfterSeconds != null) {
            options.expireAfterSeconds = this.schema.options.expireAfterSeconds;
        } else if (this.schema.options.expires != null) {
            options.expires = this.schema.options.expires;
            utils.expires(options);
        }
    }
    callback = this.$handleCallbackError(callback);
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        cb = this.$wrapCallback(cb);
        this.db.createCollection(this.$__collection.collectionName, options, utils.tick((err)=>{
            if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
                return cb(err);
            }
            this.$__collection = this.db.collection(this.$__collection.collectionName, options);
            cb(null, this.$__collection);
        }));
    }, this.events);
};
/**
 * Makes the indexes in MongoDB match the indexes defined in this model's
 * schema. This function will drop any indexes that are not defined in
 * the model's schema except the `_id` index, and build any indexes that
 * are in your schema but not in MongoDB.
 *
 * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)
 * for more information.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: { type: String, unique: true } });
 *     const Customer = mongoose.model('Customer', schema);
 *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema
 *     // Will drop the 'age' index and create an index on `name`
 *     await Customer.syncIndexes();
 *
 * @param {Object} [options] options to pass to `ensureIndexes()`
 * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property
 * @param {Function} [callback] optional callback
 * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback, when the Promise resolves the value is a list of the dropped indexes.
 * @api public
 */ Model.syncIndexes = function syncIndexes(options, callback) {
    _checkContext(this, "syncIndexes");
    const model = this;
    callback = model.$handleCallbackError(callback);
    return model.db.base._promiseOrCallback(callback, (cb)=>{
        cb = model.$wrapCallback(cb);
        model.createCollection((err)=>{
            if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
                return cb(err);
            }
            model.diffIndexes(err, (err, diffIndexesResult)=>{
                if (err != null) {
                    return cb(err);
                }
                model.cleanIndexes({
                    ...options,
                    toDrop: diffIndexesResult.toDrop
                }, (err, dropped)=>{
                    if (err != null) {
                        return cb(err);
                    }
                    model.createIndexes({
                        ...options,
                        toCreate: diffIndexesResult.toCreate
                    }, (err)=>{
                        if (err != null) {
                            return cb(err);
                        }
                        cb(null, dropped);
                    });
                });
            });
        });
    }, this.events);
};
/**
 * Does a dry-run of Model.syncIndexes(), meaning that
 * the result of this function would be the result of
 * Model.syncIndexes().
 *
 * @param {Object} [options]
 * @param {Function} [callback] optional callback
 * @returns {Promise} which contains an object, {toDrop, toCreate}, which
 * are indexes that would be dropped in MongoDB and indexes that would be created in MongoDB.
 */ Model.diffIndexes = function diffIndexes(options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const model = this;
    callback = model.$handleCallbackError(callback);
    return model.db.base._promiseOrCallback(callback, (cb)=>{
        cb = model.$wrapCallback(cb);
        model.listIndexes((err, dbIndexes)=>{
            if (dbIndexes === undefined) {
                dbIndexes = [];
            }
            dbIndexes = getRelatedDBIndexes(model, dbIndexes);
            const schema = model.schema;
            const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());
            const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);
            const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);
            cb(null, {
                toDrop,
                toCreate
            });
        });
    });
};
function getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {
    const toCreate = [];
    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes){
        let found = false;
        const options = decorateDiscriminatorIndexOptions(schema, utils.clone(schemaIndexOptions));
        for (const index of dbIndexes){
            if (isDefaultIdIndex(index)) {
                continue;
            }
            if (isIndexEqual(schemaIndexKeysObject, options, index) && !toDrop.includes(index.name)) {
                found = true;
                break;
            }
        }
        if (!found) {
            toCreate.push(schemaIndexKeysObject);
        }
    }
    return toCreate;
}
function getIndexesToDrop(schema, schemaIndexes, dbIndexes) {
    const toDrop = [];
    for (const dbIndex of dbIndexes){
        let found = false;
        // Never try to drop `_id` index, MongoDB server doesn't allow it
        if (isDefaultIdIndex(dbIndex)) {
            continue;
        }
        for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes){
            const options = decorateDiscriminatorIndexOptions(schema, utils.clone(schemaIndexOptions));
            applySchemaCollation(schemaIndexKeysObject, options, schema.options);
            if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {
                found = true;
                break;
            }
        }
        if (!found) {
            toDrop.push(dbIndex.name);
        }
    }
    return toDrop;
}
/**
 * Deletes all indexes that aren't defined in this model's schema. Used by
 * `syncIndexes()`.
 *
 * The returned promise resolves to a list of the dropped indexes' names as an array
 *
 * @param {Function} [callback] optional callback
 * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.
 * @api public
 */ Model.cleanIndexes = function cleanIndexes(options, callback) {
    _checkContext(this, "cleanIndexes");
    const model = this;
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    callback = model.$handleCallbackError(callback);
    return model.db.base._promiseOrCallback(callback, (cb)=>{
        const collection = model.$__collection;
        if (Array.isArray(options && options.toDrop)) {
            _dropIndexes(options.toDrop, collection, cb);
            return;
        }
        return model.diffIndexes((err, res)=>{
            if (err != null) {
                return cb(err);
            }
            const toDrop = res.toDrop;
            _dropIndexes(toDrop, collection, cb);
        });
    });
};
function _dropIndexes(toDrop, collection, cb) {
    if (toDrop.length === 0) {
        return cb(null, []);
    }
    let remaining = toDrop.length;
    let error = false;
    toDrop.forEach((indexName)=>{
        collection.dropIndex(indexName, (err)=>{
            if (err != null) {
                error = true;
                return cb(err);
            }
            if (!error) {
                --remaining || cb(null, toDrop);
            }
        });
    });
}
/**
 * Lists the indexes currently defined in MongoDB. This may or may not be
 * the same as the indexes defined in your schema depending on whether you
 * use the [`autoIndex` option](/docs/guide.html#autoIndex) and if you
 * build indexes manually.
 *
 * @param {Function} [cb] optional callback
 * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.
 * @api public
 */ Model.listIndexes = function init(callback) {
    _checkContext(this, "listIndexes");
    const _listIndexes = (cb)=>{
        this.$__collection.listIndexes().toArray(cb);
    };
    callback = this.$handleCallbackError(callback);
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        cb = this.$wrapCallback(cb);
        // Buffering
        if (this.$__collection.buffer) {
            this.$__collection.addQueue(_listIndexes, [
                cb
            ]);
        } else {
            _listIndexes(cb);
        }
    }, this.events);
};
/**
 * Sends `createIndex` commands to mongo for each index declared in the schema.
 * The `createIndex` commands are sent in series.
 *
 * #### Example:
 *
 *     Event.ensureIndexes(function (err) {
 *       if (err) return handleError(err);
 *     });
 *
 * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.
 *
 * #### Example:
 *
 *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })
 *     const Event = mongoose.model('Event', eventSchema);
 *
 *     Event.on('index', function (err) {
 *       if (err) console.error(err); // error occurred during index creation
 *     })
 *
 * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._
 *
 * @param {Object} [options] internal options
 * @param {Function} [cb] optional callback
 * @return {Promise}
 * @api public
 */ Model.ensureIndexes = function ensureIndexes(options, callback) {
    _checkContext(this, "ensureIndexes");
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    callback = this.$handleCallbackError(callback);
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        cb = this.$wrapCallback(cb);
        _ensureIndexes(this, options || {}, (error)=>{
            if (error) {
                return cb(error);
            }
            cb(null);
        });
    }, this.events);
};
/**
 * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)
 * function.
 *
 * @param {Object} [options] internal options
 * @param {Function} [cb] optional callback
 * @return {Promise}
 * @api public
 */ Model.createIndexes = function createIndexes(options, callback) {
    _checkContext(this, "createIndexes");
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    callback = this.$handleCallbackError(callback);
    options = options || {};
    return this.ensureIndexes(options, callback);
};
/*!
 * ignore
 */ function _ensureIndexes(model, options, callback) {
    const indexes = model.schema.indexes();
    let indexError;
    options = options || {};
    const done = function(err) {
        if (err && !model.$caught) {
            model.emit("error", err);
        }
        model.emit("index", err || indexError);
        callback && callback(err || indexError);
    };
    for (const index of indexes){
        if (isDefaultIdIndex(index)) {
            utils.warn("mongoose: Cannot specify a custom index on `_id` for " + 'model name "' + model.modelName + '", ' + "MongoDB does not allow overwriting the default `_id` index. See " + "https://bit.ly/mongodb-id-index");
        }
    }
    if (!indexes.length) {
        immediate(function() {
            done();
        });
        return;
    }
    // Indexes are created one-by-one to support how MongoDB < 2.4 deals
    // with background indexes.
    const indexSingleDone = function(err, fields, options, name) {
        model.emit("index-single-done", err, fields, options, name);
    };
    const indexSingleStart = function(fields, options) {
        model.emit("index-single-start", fields, options);
    };
    const baseSchema = model.schema._baseSchema;
    const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
    immediate(function() {
        // If buffering is off, do this manually.
        if (options._automatic && !model.collection.collection) {
            model.collection.addQueue(create, []);
        } else {
            create();
        }
    });
    function create() {
        if (options._automatic) {
            if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
                return done();
            }
        }
        const index = indexes.shift();
        if (!index) {
            return done();
        }
        if (options._automatic && index[1]._autoIndex === false) {
            return create();
        }
        if (baseSchemaIndexes.find((i)=>utils.deepEqual(i, index))) {
            return create();
        }
        const indexFields = utils.clone(index[0]);
        const indexOptions = utils.clone(index[1]);
        delete indexOptions._autoIndex;
        decorateDiscriminatorIndexOptions(model.schema, indexOptions);
        applyWriteConcern(model.schema, indexOptions);
        applySchemaCollation(indexFields, indexOptions, model.schema.options);
        indexSingleStart(indexFields, options);
        if ("background" in options) {
            indexOptions.background = options.background;
        }
        if ("toCreate" in options) {
            if (options.toCreate.length === 0) {
                return done();
            }
        }
        model.collection.createIndex(indexFields, indexOptions, utils.tick(function(err, name) {
            indexSingleDone(err, indexFields, indexOptions, name);
            if (err) {
                if (!indexError) {
                    indexError = err;
                }
                if (!model.$caught) {
                    model.emit("error", err);
                }
            }
            create();
        }));
    }
}
/**
 * Schema the model uses.
 *
 * @property schema
 * @static
 * @api public
 * @memberOf Model
 */ Model.schema;
/**
 * Connection instance the model uses.
 *
 * @property db
 * @static
 * @api public
 * @memberOf Model
 */ Model.db;
/**
 * Collection the model uses.
 *
 * @property collection
 * @api public
 * @memberOf Model
 */ Model.collection;
/**
 * Internal collection the model uses.
 *
 * @property collection
 * @api private
 * @memberOf Model
 */ Model.$__collection;
/**
 * Base Mongoose instance the model uses.
 *
 * @property base
 * @api public
 * @memberOf Model
 */ Model.base;
/**
 * Registered discriminators for this model.
 *
 * @property discriminators
 * @api public
 * @memberOf Model
 */ Model.discriminators;
/**
 * Translate any aliases fields/conditions so the final query or document object is pure
 *
 * #### Example:
 *
 *     Character
 *       .find(Character.translateAliases({
 *         '名': 'Eddard Stark' // Alias for 'name'
 *       })
 *       .exec(function(err, characters) {})
 *
 * #### Note:
 *
 * Only translate arguments of object type anything else is returned raw
 *
 * @param {Object} fields fields/conditions that may contain aliased keys
 * @return {Object} the translated 'pure' fields/conditions
 */ Model.translateAliases = function translateAliases(fields) {
    _checkContext(this, "translateAliases");
    const translate = (key, value)=>{
        let alias;
        const translated = [];
        const fieldKeys = key.split(".");
        let currentSchema = this.schema;
        for(const i in fieldKeys){
            const name = fieldKeys[i];
            if (currentSchema && currentSchema.aliases[name]) {
                alias = currentSchema.aliases[name];
                // Alias found,
                translated.push(alias);
            } else {
                alias = name;
                // Alias not found, so treat as un-aliased key
                translated.push(name);
            }
            // Check if aliased path is a schema
            if (currentSchema && currentSchema.paths[alias]) {
                currentSchema = currentSchema.paths[alias].schema;
            } else currentSchema = null;
        }
        const translatedKey = translated.join(".");
        if (fields instanceof Map) fields.set(translatedKey, value);
        else fields[translatedKey] = value;
        if (translatedKey !== key) {
            // We'll be using the translated key instead
            if (fields instanceof Map) {
                // Delete from map
                fields.delete(key);
            } else {
                // Delete from object
                delete fields[key]; // We'll be using the translated key instead
            }
        }
        return fields;
    };
    if (typeof fields === "object") {
        // Fields is an object (query conditions or document fields)
        if (fields instanceof Map) {
            // A Map was supplied
            for (const field of new Map(fields)){
                fields = translate(field[0], field[1]);
            }
        } else {
            // Infer a regular object was supplied
            for (const key of Object.keys(fields)){
                fields = translate(key, fields[key]);
                if (key[0] === "$") {
                    if (Array.isArray(fields[key])) {
                        for(const i in fields[key]){
                            // Recursively translate nested queries
                            fields[key][i] = this.translateAliases(fields[key][i]);
                        }
                    }
                }
            }
        }
        return fields;
    } else {
        // Don't know typeof fields
        return fields;
    }
};
/**
 * Removes all documents that match `conditions` from the collection.
 * To remove just the first document that matches `conditions`, set the `single`
 * option to true.
 *
 * This method is deprecated. See [Deprecation Warnings](../deprecations.html#remove) for details.
 *
 * #### Example:
 *
 *     const res = await Character.remove({ name: 'Eddard Stark' });
 *     res.deletedCount; // Number of documents removed
 *
 * #### Note:
 *
 * This method sends a remove command directly to MongoDB, no Mongoose documents
 * are involved. Because no Mongoose documents are involved, Mongoose does
 * not execute [document middleware](/docs/middleware.html#types-of-middleware).
 *
 * @deprecated
 * @param {Object} conditions
 * @param {Object} [options]
 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this operation.
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.remove = function remove(conditions, options, callback) {
    _checkContext(this, "remove");
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    }
    // get the mongodb collection object
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    callback = this.$handleCallbackError(callback);
    return mq.remove(conditions, callback);
};
/**
 * Deletes the first document that matches `conditions` from the collection.
 * It returns an object with the property `deletedCount` indicating how many documents were deleted.
 * Behaves like `remove()`, but deletes at most one document regardless of the
 * `single` option.
 *
 * #### Example:
 *
 *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}
 *
 * #### Note:
 *
 * This function triggers `deleteOne` query hooks. Read the
 * [middleware docs](/docs/middleware.html#naming) to learn more.
 *
 * @param {Object} conditions
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.deleteOne = function deleteOne(conditions, options, callback) {
    _checkContext(this, "deleteOne");
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    callback = this.$handleCallbackError(callback);
    return mq.deleteOne(conditions, callback);
};
/**
 * Deletes all of the documents that match `conditions` from the collection.
 * It returns an object with the property `deletedCount` containing the number of documents deleted.
 * Behaves like `remove()`, but deletes all documents that match `conditions`
 * regardless of the `single` option.
 *
 * #### Example:
 *
 *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.
 *
 * #### Note:
 *
 * This function triggers `deleteMany` query hooks. Read the
 * [middleware docs](/docs/middleware.html#naming) to learn more.
 *
 * @param {Object} conditions
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.deleteMany = function deleteMany(conditions, options, callback) {
    _checkContext(this, "deleteMany");
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    callback = this.$handleCallbackError(callback);
    return mq.deleteMany(conditions, callback);
};
/**
 * Finds documents.
 *
 * Mongoose casts the `filter` to match the model's schema before the command is sent.
 * See our [query casting tutorial](/docs/tutorials/query_casting.html) for
 * more information on how Mongoose casts `filter`.
 *
 * #### Example:
 *
 *     // find all documents
 *     await MyModel.find({});
 *
 *     // find all documents named john and at least 18
 *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();
 *
 *     // executes, passing results to callback
 *     MyModel.find({ name: 'john', age: { $gte: 18 }}, function (err, docs) {});
 *
 *     // executes, name LIKE john and only selecting the "name" and "friends" fields
 *     await MyModel.find({ name: /john/i }, 'name friends').exec();
 *
 *     // passing options
 *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();
 *
 * @param {Object|ObjectId} filter
 * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#query_Query-select)
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback]
 * @return {Query}
 * @see field selection #query_Query-select
 * @see query casting /docs/tutorials/query_casting.html
 * @api public
 */ Model.find = function find(conditions, projection, options, callback) {
    _checkContext(this, "find");
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
    } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    callback = this.$handleCallbackError(callback);
    return mq.find(conditions, callback);
};
/**
 * Finds a single document by its _id field. `findById(id)` is almost*
 * equivalent to `findOne({ _id: id })`. If you want to query by a document's
 * `_id`, use `findById()` instead of `findOne()`.
 *
 * The `id` is cast based on the Schema before sending the command.
 *
 * This function triggers the following middleware.
 *
 * - `findOne()`
 *
 * \* Except for how it treats `undefined`. If you use `findOne()`, you'll see
 * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent
 * to `findOne({})` and return arbitrary documents. However, mongoose
 * translates `findById(undefined)` into `findOne({ _id: null })`.
 *
 * #### Example:
 *
 *     // Find the adventure with the given `id`, or `null` if not found
 *     await Adventure.findById(id).exec();
 *
 *     // using callback
 *     Adventure.findById(id, function (err, adventure) {});
 *
 *     // select only the adventures name and length
 *     await Adventure.findById(id, 'name length').exec();
 *
 * @param {Any} id value of `_id` to query by
 * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback]
 * @return {Query}
 * @see field selection #query_Query-select
 * @see lean queries /docs/tutorials/lean.html
 * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id
 * @api public
 */ Model.findById = function findById(id, projection, options, callback) {
    _checkContext(this, "findById");
    if (typeof id === "undefined") {
        id = null;
    }
    callback = this.$handleCallbackError(callback);
    return this.findOne({
        _id: id
    }, projection, options, callback);
};
/**
 * Finds one document.
 *
 * The `conditions` are cast to their respective SchemaTypes before the command is sent.
 *
 * *Note:* `conditions` is optional, and if `conditions` is null or undefined,
 * mongoose will send an empty `findOne` command to MongoDB, which will return
 * an arbitrary document. If you're querying by `_id`, use `findById()` instead.
 *
 * #### Example:
 *
 *     // Find one adventure whose `country` is 'Croatia', otherwise `null`
 *     await Adventure.findOne({ country: 'Croatia' }).exec();
 *
 *     // using callback
 *     Adventure.findOne({ country: 'Croatia' }, function (err, adventure) {});
 *
 *     // select only the adventures name and length
 *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();
 *
 * @param {Object} [conditions]
 * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback]
 * @return {Query}
 * @see field selection #query_Query-select
 * @see lean queries /docs/tutorials/lean.html
 * @api public
 */ Model.findOne = function findOne(conditions, projection, options, callback) {
    _checkContext(this, "findOne");
    if (typeof options === "function") {
        callback = options;
        options = null;
    } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
    } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    callback = this.$handleCallbackError(callback);
    return mq.findOne(conditions, callback);
};
/**
 * Estimates the number of documents in the MongoDB collection. Faster than
 * using `countDocuments()` for large collections because
 * `estimatedDocumentCount()` uses collection metadata rather than scanning
 * the entire collection.
 *
 * #### Example:
 *
 *     const numAdventures = await Adventure.estimatedDocumentCount();
 *
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.estimatedDocumentCount = function estimatedDocumentCount(options, callback) {
    _checkContext(this, "estimatedDocumentCount");
    const mq = new this.Query({}, {}, this, this.$__collection);
    callback = this.$handleCallbackError(callback);
    return mq.estimatedDocumentCount(options, callback);
};
/**
 * Counts number of documents matching `filter` in a database collection.
 *
 * #### Example:
 *
 *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {
 *       console.log('there are %d jungle adventures', count);
 *     });
 *
 * If you want to count all documents in a large collection,
 * use the [`estimatedDocumentCount()` function](/docs/api/model.html#model_Model-estimatedDocumentCount)
 * instead. If you call `countDocuments({})`, MongoDB will always execute
 * a full collection scan and **not** use any indexes.
 *
 * The `countDocuments()` function is similar to `count()`, but there are a
 * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).
 * Below are the operators that `count()` supports but `countDocuments()` does not,
 * and the suggested replacement:
 *
 * - `$where`: [`$expr`](https://docs.mongodb.com/manual/reference/operator/query/expr/)
 * - `$near`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$center`](https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center)
 * - `$nearSphere`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere)
 *
 * @param {Object} filter
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.countDocuments = function countDocuments(conditions, options, callback) {
    _checkContext(this, "countDocuments");
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
    }
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (options != null) {
        mq.setOptions(options);
    }
    callback = this.$handleCallbackError(callback);
    return mq.countDocuments(conditions, callback);
};
/**
 * Counts number of documents that match `filter` in a database collection.
 *
 * This method is deprecated. If you want to count the number of documents in
 * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](/docs/api/model.html#model_Model-estimatedDocumentCount)
 * instead. Otherwise, use the [`countDocuments()`](/docs/api/model.html#model_Model-countDocuments) function instead.
 *
 * #### Example:
 *
 *     const count = await Adventure.count({ type: 'jungle' });
 *     console.log('there are %d jungle adventures', count);
 *
 * @deprecated
 * @param {Object} filter
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.count = function count(conditions, callback) {
    _checkContext(this, "count");
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    callback = this.$handleCallbackError(callback);
    return mq.count(conditions, callback);
};
/**
 * Creates a Query for a `distinct` operation.
 *
 * Passing a `callback` executes the query.
 *
 * #### Example:
 *
 *     Link.distinct('url', { clicks: { $gt: 100 } }, function (err, result) {
 *       if (err) return handleError(err);
 *
 *       assert(Array.isArray(result));
 *       console.log('unique urls with more than 100 clicks', result);
 *     })
 *
 *     const query = Link.distinct('url');
 *     query.exec(callback);
 *
 * @param {String} field
 * @param {Object} [conditions] optional
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.distinct = function distinct(field, conditions, callback) {
    _checkContext(this, "distinct");
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
    }
    callback = this.$handleCallbackError(callback);
    return mq.distinct(field, conditions, callback);
};
/**
 * Creates a Query, applies the passed conditions, and returns the Query.
 *
 * For example, instead of writing:
 *
 *     User.find({ age: { $gte: 21, $lte: 65 } }, callback);
 *
 * we can instead write:
 *
 *     User.where('age').gte(21).lte(65).exec(callback);
 *
 * Since the Query class also supports `where` you can continue chaining
 *
 *     User
 *     .where('age').gte(21).lte(65)
 *     .where('name', /^b/i)
 *     ... etc
 *
 * @param {String} path
 * @param {Object} [val] optional value
 * @return {Query}
 * @api public
 */ Model.where = function where(path, val) {
    _checkContext(this, "where");
    void val; // eslint
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.where.apply(mq, arguments);
};
/**
 * Creates a `Query` and specifies a `$where` condition.
 *
 * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.
 *
 *     Blog.$where('this.username.indexOf("val") !== -1').exec(function (err, docs) {});
 *
 * @param {String|Function} argument is a javascript string or anonymous function
 * @method $where
 * @memberOf Model
 * @return {Query}
 * @see Query.$where #query_Query-%24where
 * @api public
 */ Model.$where = function $where() {
    _checkContext(this, "$where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.$where.apply(mq, arguments);
};
/**
 * Issues a mongodb findAndModify update command.
 *
 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.
 *
 * #### Example:
 *
 *     A.findOneAndUpdate(conditions, update, options, callback) // executes
 *     A.findOneAndUpdate(conditions, update, options)  // returns Query
 *     A.findOneAndUpdate(conditions, update, callback) // executes
 *     A.findOneAndUpdate(conditions, update)           // returns Query
 *     A.findOneAndUpdate()                             // returns Query
 *
 * #### Note:
 *
 * All top level update keys which are not `atomic` operation names are treated as set operations:
 *
 * #### Example:
 *
 *     const query = { name: 'borne' };
 *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options, callback)
 *
 *     // is sent as
 *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options, callback)
 *
 * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.
 * To prevent this behaviour, see the `overwrite` option
 *
 * #### Note:
 *
 * `findOneAndX` and `findByIdAndX` functions support limited validation that
 * you can enable by setting the `runValidators` option.
 *
 * If you need full-fledged validation, use the traditional approach of first
 * retrieving the document.
 *
 *     const doc = await Model.findById(id);
 *     doc.name = 'jason bourne';
 *     await doc.save();
 *
 * @param {Object} [conditions]
 * @param {Object} [update]
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and [the Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://docs.mongodb.com/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace(conditions, update, options, callback)](https://mongoosejs.com/docs/api/model.html#model_Model-findOneAndReplace).
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {Boolean} [options.new=false] if true, return the modified document rather than the original
 * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`
 * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0
 * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.
 * @param {Boolean} [options.runValidators] if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema
 * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Function} [callback]
 * @return {Query}
 * @see Tutorial /docs/tutorials/findoneandupdate.html
 * @see mongodb https://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */ Model.findOneAndUpdate = function(conditions, update, options, callback) {
    _checkContext(this, "findOneAndUpdate");
    if (typeof options === "function") {
        callback = options;
        options = null;
    } else if (arguments.length === 1) {
        if (typeof conditions === "function") {
            const msg = "Model.findOneAndUpdate(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findOneAndUpdate(conditions, update, options, callback)\n" + "  " + this.modelName + ".findOneAndUpdate(conditions, update, options)\n" + "  " + this.modelName + ".findOneAndUpdate(conditions, update)\n" + "  " + this.modelName + ".findOneAndUpdate(update)\n" + "  " + this.modelName + ".findOneAndUpdate()\n";
            throw new TypeError(msg);
        }
        update = conditions;
        conditions = undefined;
    }
    callback = this.$handleCallbackError(callback);
    let fields;
    if (options) {
        fields = options.fields || options.projection;
    }
    update = utils.clone(update, {
        depopulate: true,
        _isNested: true
    });
    _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndUpdate(conditions, update, options, callback);
};
/**
 * Decorate the update with a version key, if necessary
 * @api private
 */ function _decorateUpdateWithVersionKey(update, options, versionKey) {
    if (!versionKey || !(options && options.upsert || false)) {
        return;
    }
    const updatedPaths = modifiedPaths(update);
    if (!updatedPaths[versionKey]) {
        if (options.overwrite) {
            update[versionKey] = 0;
        } else {
            if (!update.$setOnInsert) {
                update.$setOnInsert = {};
            }
            update.$setOnInsert[versionKey] = 0;
        }
    }
}
/**
 * Issues a mongodb findAndModify update command by a document's _id field.
 * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.
 *
 * Finds a matching document, updates it according to the `update` arg,
 * passing any `options`, and returns the found document (if any) to the
 * callback. The query executes if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndUpdate()`
 *
 * #### Example:
 *
 *     A.findByIdAndUpdate(id, update, options, callback) // executes
 *     A.findByIdAndUpdate(id, update, options)  // returns Query
 *     A.findByIdAndUpdate(id, update, callback) // executes
 *     A.findByIdAndUpdate(id, update)           // returns Query
 *     A.findByIdAndUpdate()                     // returns Query
 *
 * #### Note:
 *
 * All top level update keys which are not `atomic` operation names are treated as set operations:
 *
 * #### Example:
 *
 *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)
 *
 *     // is sent as
 *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)
 *
 * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.
 * To prevent this behaviour, see the `overwrite` option
 *
 * #### Note:
 *
 * `findOneAndX` and `findByIdAndX` functions support limited validation. You can
 * enable validation by setting the `runValidators` option.
 *
 * If you need full-fledged validation, use the traditional approach of first
 * retrieving the document.
 *
 *     const doc = await Model.findById(id)
 *     doc.name = 'jason bourne';
 *     await doc.save();
 *
 * @param {Object|Number|String} id value of `_id` to query by
 * @param {Object} [update]
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and [the Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://docs.mongodb.com/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace({ _id: id }, update, options, callback)](https://mongoosejs.com/docs/api/model.html#model_Model-findOneAndReplace).
 * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.
 * @param {Boolean} [options.runValidators] if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema
 * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Boolean} [options.new=false] if true, return the modified document rather than the original
 * @param {Object|String} [options.select] sets the document fields to return.
 * @param {Function} [callback]
 * @return {Query}
 * @see Model.findOneAndUpdate #model_Model-findOneAndUpdate
 * @see mongodb https://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */ Model.findByIdAndUpdate = function(id, update, options, callback) {
    _checkContext(this, "findByIdAndUpdate");
    callback = this.$handleCallbackError(callback);
    if (arguments.length === 1) {
        if (typeof id === "function") {
            const msg = "Model.findByIdAndUpdate(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findByIdAndUpdate(id, callback)\n" + "  " + this.modelName + ".findByIdAndUpdate(id)\n" + "  " + this.modelName + ".findByIdAndUpdate()\n";
            throw new TypeError(msg);
        }
        return this.findOneAndUpdate({
            _id: id
        }, undefined);
    }
    // if a model is passed in instead of an id
    if (id instanceof Document) {
        id = id._id;
    }
    return this.findOneAndUpdate.call(this, {
        _id: id
    }, update, options, callback);
};
/**
 * Issue a MongoDB `findOneAndDelete()` command.
 *
 * Finds a matching document, removes it, and passes the found document
 * (if any) to the callback.
 *
 * Executes the query if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndDelete()`
 *
 * This function differs slightly from `Model.findOneAndRemove()` in that
 * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/),
 * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,
 * this distinction is purely pedantic. You should use `findOneAndDelete()`
 * unless you have a good reason not to.
 *
 * #### Example:
 *
 *     A.findOneAndDelete(conditions, options, callback) // executes
 *     A.findOneAndDelete(conditions, options)  // return Query
 *     A.findOneAndDelete(conditions, callback) // executes
 *     A.findOneAndDelete(conditions) // returns Query
 *     A.findOneAndDelete()           // returns Query
 *
 * `findOneAndX` and `findByIdAndX` functions support limited validation. You can
 * enable validation by setting the `runValidators` option.
 *
 * If you need full-fledged validation, use the traditional approach of first
 * retrieving the document.
 *
 *     const doc = await Model.findById(id)
 *     doc.name = 'jason bourne';
 *     await doc.save();
 *
 * @param {Object} conditions
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.
 * @param {Object|String} [options.select] sets the document fields to return.
 * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.findOneAndDelete = function(conditions, options, callback) {
    _checkContext(this, "findOneAndDelete");
    if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndDelete(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findOneAndDelete(conditions, callback)\n" + "  " + this.modelName + ".findOneAndDelete(conditions)\n" + "  " + this.modelName + ".findOneAndDelete()\n";
        throw new TypeError(msg);
    }
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    callback = this.$handleCallbackError(callback);
    let fields;
    if (options) {
        fields = options.select;
        options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndDelete(conditions, options, callback);
};
/**
 * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.
 * In other words, `findByIdAndDelete(id)` is a shorthand for
 * `findOneAndDelete({ _id: id })`.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndDelete()`
 *
 * @param {Object|Number|String} id value of `_id` to query by
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Function} [callback]
 * @return {Query}
 * @see Model.findOneAndRemove #model_Model-findOneAndRemove
 * @see mongodb https://www.mongodb.org/display/DOCS/findAndModify+Command
 */ Model.findByIdAndDelete = function(id, options, callback) {
    _checkContext(this, "findByIdAndDelete");
    if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndDelete(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findByIdAndDelete(id, callback)\n" + "  " + this.modelName + ".findByIdAndDelete(id)\n" + "  " + this.modelName + ".findByIdAndDelete()\n";
        throw new TypeError(msg);
    }
    callback = this.$handleCallbackError(callback);
    return this.findOneAndDelete({
        _id: id
    }, options, callback);
};
/**
 * Issue a MongoDB `findOneAndReplace()` command.
 *
 * Finds a matching document, replaces it with the provided doc, and passes the
 * returned doc to the callback.
 *
 * Executes the query if `callback` is passed.
 *
 * This function triggers the following query middleware.
 *
 * - `findOneAndReplace()`
 *
 * #### Example:
 *
 *     A.findOneAndReplace(filter, replacement, options, callback) // executes
 *     A.findOneAndReplace(filter, replacement, options)  // return Query
 *     A.findOneAndReplace(filter, replacement, callback) // executes
 *     A.findOneAndReplace(filter, replacement) // returns Query
 *     A.findOneAndReplace()                    // returns Query
 *
 * @param {Object} filter Replace the first document that matches this filter
 * @param {Object} [replacement] Replace with this document
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and [the Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Object|String} [options.select] sets the document fields to return.
 * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0
 * @param {Function} [callback]
 * @return {Query}
 * @api public
 */ Model.findOneAndReplace = function(filter, replacement, options, callback) {
    _checkContext(this, "findOneAndReplace");
    if (arguments.length === 1 && typeof filter === "function") {
        const msg = "Model.findOneAndReplace(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findOneAndReplace(filter, replacement, options, callback)\n" + "  " + this.modelName + ".findOneAndReplace(filter, replacement, callback)\n" + "  " + this.modelName + ".findOneAndReplace(filter, replacement)\n" + "  " + this.modelName + ".findOneAndReplace(filter, callback)\n" + "  " + this.modelName + ".findOneAndReplace()\n";
        throw new TypeError(msg);
    }
    if (arguments.length === 3 && typeof options === "function") {
        callback = options;
        options = replacement;
        replacement = void 0;
    }
    if (arguments.length === 2 && typeof replacement === "function") {
        callback = replacement;
        replacement = void 0;
        options = void 0;
    }
    callback = this.$handleCallbackError(callback);
    let fields;
    if (options) {
        fields = options.select;
        options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndReplace(filter, replacement, options, callback);
};
/**
 * Issue a mongodb findAndModify remove command.
 *
 * Finds a matching document, removes it, passing the found document (if any) to the callback.
 *
 * Executes the query if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndRemove()`
 *
 * #### Example:
 *
 *     A.findOneAndRemove(conditions, options, callback) // executes
 *     A.findOneAndRemove(conditions, options)  // return Query
 *     A.findOneAndRemove(conditions, callback) // executes
 *     A.findOneAndRemove(conditions) // returns Query
 *     A.findOneAndRemove()           // returns Query
 *
 * `findOneAndX` and `findByIdAndX` functions support limited validation. You can
 * enable validation by setting the `runValidators` option.
 *
 * If you need full-fledged validation, use the traditional approach of first
 * retrieving the document.
 *
 *     const doc = await Model.findById(id);
 *     doc.name = 'jason bourne';
 *     await doc.save();
 *
 * @param {Object} conditions
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Object|String} [options.select] sets the document fields to return.
 * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0
 * @param {Function} [callback]
 * @return {Query}
 * @see mongodb https://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */ Model.findOneAndRemove = function(conditions, options, callback) {
    _checkContext(this, "findOneAndRemove");
    if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndRemove(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findOneAndRemove(conditions, callback)\n" + "  " + this.modelName + ".findOneAndRemove(conditions)\n" + "  " + this.modelName + ".findOneAndRemove()\n";
        throw new TypeError(msg);
    }
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    callback = this.$handleCallbackError(callback);
    let fields;
    if (options) {
        fields = options.select;
        options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndRemove(conditions, options, callback);
};
/**
 * Issue a mongodb findAndModify remove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.
 *
 * Finds a matching document, removes it, passing the found document (if any) to the callback.
 *
 * Executes the query if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndRemove()`
 *
 * #### Example:
 *
 *     A.findByIdAndRemove(id, options, callback) // executes
 *     A.findByIdAndRemove(id, options)  // return Query
 *     A.findByIdAndRemove(id, callback) // executes
 *     A.findByIdAndRemove(id) // returns Query
 *     A.findByIdAndRemove()           // returns Query
 *
 * @param {Object|Number|String} id value of `_id` to query by
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)
 * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Object|String} [options.select] sets the document fields to return.
 * @param {Function} [callback]
 * @return {Query}
 * @see Model.findOneAndRemove #model_Model-findOneAndRemove
 * @see mongodb https://www.mongodb.org/display/DOCS/findAndModify+Command
 */ Model.findByIdAndRemove = function(id, options, callback) {
    _checkContext(this, "findByIdAndRemove");
    if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndRemove(): First argument must not be a function.\n\n" + "  " + this.modelName + ".findByIdAndRemove(id, callback)\n" + "  " + this.modelName + ".findByIdAndRemove(id)\n" + "  " + this.modelName + ".findByIdAndRemove()\n";
        throw new TypeError(msg);
    }
    callback = this.$handleCallbackError(callback);
    return this.findOneAndRemove({
        _id: id
    }, options, callback);
};
/**
 * Shortcut for saving one or more documents to the database.
 * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in
 * docs.
 *
 * This function triggers the following middleware.
 *
 * - `save()`
 *
 * #### Example:
 *
 *     // Insert one new `Character` document
 *     await Character.create({ name: 'Jean-Luc Picard' });
 *
 *     // Insert multiple new `Character` documents
 *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);
 *
 *     // Create a new character within a transaction. Note that you **must**
 *     // pass an array as the first parameter to `create()` if you want to
 *     // specify options.
 *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });
 *
 * @param {Array|Object} docs Documents to insert, as a spread or array
 * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](#model_Model-save) for available options.
 * @param {Function} [callback] callback
 * @return {Promise}
 * @api public
 */ Model.create = function create(doc, options, callback) {
    _checkContext(this, "create");
    let args;
    let cb;
    const discriminatorKey = this.schema.options.discriminatorKey;
    if (Array.isArray(doc)) {
        args = doc;
        cb = typeof options === "function" ? options : callback;
        options = options != null && typeof options === "object" ? options : {};
    } else {
        const last = arguments[arguments.length - 1];
        options = {};
        // Handle falsy callbacks re: #5061
        if (typeof last === "function" || arguments.length > 1 && !last) {
            args = [
                ...arguments
            ];
            cb = args.pop();
        } else {
            args = [
                ...arguments
            ];
        }
        if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
            // Probably means the user is running into the common mistake of trying
            // to use a spread to specify options, see gh-7535
            utils.warn("WARNING: to pass a `session` to `Model.create()` in " + "Mongoose, you **must** pass an array as the first argument. See: " + "https://mongoosejs.com/docs/api/model.html#model_Model-create");
        }
    }
    return this.db.base._promiseOrCallback(cb, (cb)=>{
        cb = this.$wrapCallback(cb);
        if (args.length === 0) {
            if (Array.isArray(doc)) {
                return cb(null, []);
            } else {
                return cb(null);
            }
        }
        const toExecute = [];
        let firstError;
        args.forEach((doc)=>{
            toExecute.push((callback)=>{
                const Model = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;
                if (Model == null) {
                    throw new MongooseError(`Discriminator "${doc[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
                }
                let toSave = doc;
                const callbackWrapper = (error, doc)=>{
                    if (error) {
                        if (!firstError) {
                            firstError = error;
                        }
                        return callback(null, {
                            error: error
                        });
                    }
                    callback(null, {
                        doc: doc
                    });
                };
                if (!(toSave instanceof Model)) {
                    try {
                        toSave = new Model(toSave);
                    } catch (error) {
                        return callbackWrapper(error);
                    }
                }
                toSave.$save(options, callbackWrapper);
            });
        });
        let numFns = toExecute.length;
        if (numFns === 0) {
            return cb(null, []);
        }
        const _done = (error, res)=>{
            const savedDocs = [];
            for (const val of res){
                if (val.doc) {
                    savedDocs.push(val.doc);
                }
            }
            if (firstError) {
                return cb(firstError, savedDocs);
            }
            if (Array.isArray(doc)) {
                cb(null, savedDocs);
            } else {
                cb.apply(this, [
                    null
                ].concat(savedDocs));
            }
        };
        const _res = [];
        toExecute.forEach((fn, i)=>{
            fn((err, res)=>{
                _res[i] = res;
                if (--numFns <= 0) {
                    return _done(null, _res);
                }
            });
        });
    }, this.events);
};
/**
 * _Requires a replica set running MongoDB >= 3.6.0._ Watches the
 * underlying collection for changes using
 * [MongoDB change streams](https://docs.mongodb.com/manual/changeStreams/).
 *
 * This function does **not** trigger any middleware. In particular, it
 * does **not** trigger aggregate middleware.
 *
 * The ChangeStream object is an event emitter that emits the following events:
 *
 * - 'change': A change occurred, see below example
 * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.
 * - 'end': Emitted if the underlying stream is closed
 * - 'close': Emitted if the underlying stream is closed
 *
 * #### Example:
 *
 *     const doc = await Person.create({ name: 'Ned Stark' });
 *     const changeStream = Person.watch().on('change', change => console.log(change));
 *     // Will print from the above `console.log()`:
 *     // { _id: { _data: ... },
 *     //   operationType: 'delete',
 *     //   ns: { db: 'mydb', coll: 'Person' },
 *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }
 *     await doc.remove();
 *
 * @param {Array} [pipeline]
 * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)
 * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document
 * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter
 * @api public
 */ Model.watch = function(pipeline, options) {
    _checkContext(this, "watch");
    const changeStreamThunk = (cb)=>{
        pipeline = pipeline || [];
        prepareDiscriminatorPipeline(pipeline, this.schema, "fullDocument");
        if (this.$__collection.buffer) {
            this.$__collection.addQueue(()=>{
                if (this.closed) {
                    return;
                }
                const driverChangeStream = this.$__collection.watch(pipeline, options);
                cb(null, driverChangeStream);
            });
        } else {
            const driverChangeStream = this.$__collection.watch(pipeline, options);
            cb(null, driverChangeStream);
        }
    };
    options = options || {};
    options.model = this;
    return new ChangeStream(changeStreamThunk, pipeline, options);
};
/**
 * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)
 * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),
 * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).
 *
 * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.
 *
 * This function does not trigger any middleware.
 *
 * #### Example:
 *
 *     const session = await Person.startSession();
 *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });
 *     await doc.remove();
 *     // `doc` will always be null, even if reading from a replica set
 *     // secondary. Without causal consistency, it is possible to
 *     // get a doc back from the below query if the query reads from a
 *     // secondary that is experiencing replication lag.
 *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });
 *
 * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)
 * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency
 * @param {Function} [callback]
 * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`
 * @api public
 */ Model.startSession = function() {
    _checkContext(this, "startSession");
    return this.db.startSession.apply(this.db, arguments);
};
/**
 * Shortcut for validating an array of documents and inserting them into
 * MongoDB if they're all valid. This function is faster than `.create()`
 * because it only sends one operation to the server, rather than one for each
 * document.
 *
 * Mongoose always validates each document **before** sending `insertMany`
 * to MongoDB. So if one document has a validation error, no documents will
 * be saved, unless you set
 * [the `ordered` option to false](https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#error-handling).
 *
 * This function does **not** trigger save middleware.
 *
 * This function triggers the following middleware.
 *
 * - `insertMany()`
 *
 * #### Example:
 *
 *     const arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];
 *     Movies.insertMany(arr, function(error, docs) {});
 *
 * @param {Array|Object|*} doc(s)
 * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)
 * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an "unordered" `insertMany()`.
 * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` if this is an unordered `insertMany`.
 * @param {Boolean} [options.lean=false] if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.
 * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.
 * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.
 * @param {Function} [callback] callback
 * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise
 * @api public
 */ Model.insertMany = function(arr, options, callback) {
    _checkContext(this, "insertMany");
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        this.$__insertMany(arr, options, cb);
    }, this.events);
};
/**
 * ignore
 *
 * @param {Array} arr
 * @param {Object} options
 * @param {Function} callback
 * @api private
 * @memberOf Model
 * @method $__insertMany
 * @static
 */ Model.$__insertMany = function(arr, options, callback) {
    const _this = this;
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    if (callback) {
        callback = this.$handleCallbackError(callback);
        callback = this.$wrapCallback(callback);
    }
    callback = callback || utils.noop;
    options = options || {};
    const limit = options.limit || 1000;
    const rawResult = !!options.rawResult;
    const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
    const lean = !!options.lean;
    if (!Array.isArray(arr)) {
        arr = [
            arr
        ];
    }
    const validationErrors = [];
    const validationErrorsToOriginalOrder = new Map();
    const toExecute = arr.map((doc, index)=>(callback)=>{
            if (!(doc instanceof _this)) {
                try {
                    doc = new _this(doc);
                } catch (err) {
                    return callback(err);
                }
            }
            if (options.session != null) {
                doc.$session(options.session);
            }
            // If option `lean` is set to true bypass validation
            if (lean) {
                // we have to execute callback at the nextTick to be compatible
                // with parallelLimit, as `results` variable has TDZ issue if we
                // execute the callback synchronously
                return immediate(()=>callback(null, doc));
            }
            doc.$validate({
                __noPromise: true
            }, function(error) {
                if (error) {
                    // Option `ordered` signals that insert should be continued after reaching
                    // a failing insert. Therefore we delegate "null", meaning the validation
                    // failed. It's up to the next function to filter out all failed models
                    if (ordered === false) {
                        validationErrors.push(error);
                        validationErrorsToOriginalOrder.set(error, index);
                        return callback(null, null);
                    }
                    return callback(error);
                }
                callback(null, doc);
            });
        });
    parallelLimit(toExecute, limit, function(error, docs) {
        if (error) {
            callback(error, null);
            return;
        }
        const originalDocIndex = new Map();
        const validDocIndexToOriginalIndex = new Map();
        for(let i = 0; i < docs.length; ++i){
            originalDocIndex.set(docs[i], i);
        }
        // We filter all failed pre-validations by removing nulls
        const docAttributes = docs.filter(function(doc) {
            return doc != null;
        });
        for(let i = 0; i < docAttributes.length; ++i){
            validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));
        }
        // Make sure validation errors are in the same order as the
        // original documents, so if both doc1 and doc2 both fail validation,
        // `Model.insertMany([doc1, doc2])` will always have doc1's validation
        // error before doc2's. Re: gh-12791.
        if (validationErrors.length > 0) {
            validationErrors.sort((err1, err2)=>{
                return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);
            });
        }
        // Quickly escape while there aren't any valid docAttributes
        if (docAttributes.length === 0) {
            if (rawResult) {
                const res = {
                    acknowledged: true,
                    insertedCount: 0,
                    insertedIds: {},
                    mongoose: {
                        validationErrors: validationErrors
                    }
                };
                return callback(null, res);
            }
            callback(null, []);
            return;
        }
        const docObjects = docAttributes.map(function(doc) {
            if (doc.$__schema.options.versionKey) {
                doc[doc.$__schema.options.versionKey] = 0;
            }
            const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);
            if (shouldSetTimestamps) {
                return doc.initializeTimestamps().toObject(internalToObjectOptions);
            }
            return doc.toObject(internalToObjectOptions);
        });
        _this.$__collection.insertMany(docObjects, options, function(error, res) {
            if (error) {
                // `writeErrors` is a property reported by the MongoDB driver,
                // just not if there's only 1 error.
                if (error.writeErrors == null && (error.result && error.result.result && error.result.result.writeErrors) != null) {
                    error.writeErrors = error.result.result.writeErrors;
                }
                // `insertedDocs` is a Mongoose-specific property
                const erroredIndexes = new Set((error && error.writeErrors || []).map((err)=>err.index));
                for(let i = 0; i < error.writeErrors.length; ++i){
                    error.writeErrors[i] = {
                        ...error.writeErrors[i],
                        index: validDocIndexToOriginalIndex.get(error.writeErrors[i].index)
                    };
                }
                let firstErroredIndex = -1;
                error.insertedDocs = docAttributes.filter((doc, i)=>{
                    const isErrored = erroredIndexes.has(i);
                    if (ordered) {
                        if (firstErroredIndex > -1) {
                            return i < firstErroredIndex;
                        }
                        if (isErrored) {
                            firstErroredIndex = i;
                        }
                    }
                    return !isErrored;
                }).map(function setIsNewForInsertedDoc(doc) {
                    doc.$__reset();
                    _setIsNew(doc, false);
                    return doc;
                });
                if (rawResult && ordered === false) {
                    error.mongoose = {
                        validationErrors: validationErrors
                    };
                }
                callback(error, null);
                return;
            }
            for (const attribute of docAttributes){
                attribute.$__reset();
                _setIsNew(attribute, false);
            }
            if (rawResult) {
                if (ordered === false) {
                    // Decorate with mongoose validation errors in case of unordered,
                    // because then still do `insertMany()`
                    res.mongoose = {
                        validationErrors: validationErrors
                    };
                }
                return callback(null, res);
            }
            if (options.populate != null) {
                return _this.populate(docAttributes, options.populate, (err)=>{
                    if (err != null) {
                        error.insertedDocs = docAttributes;
                        return callback(err);
                    }
                    callback(null, docs);
                });
            }
            callback(null, docAttributes);
        });
    });
};
/*!
 * ignore
 */ function _setIsNew(doc, val) {
    doc.$isNew = val;
    doc.$emit("isNew", val);
    doc.constructor.emit("isNew", val);
    const subdocs = doc.$getAllSubdocs();
    for (const subdoc of subdocs){
        subdoc.$isNew = val;
        subdoc.$emit("isNew", val);
    }
}
/**
 * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,
 * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one
 * command. This is faster than sending multiple independent operations (e.g.
 * if you use `create()`) because with `bulkWrite()` there is only one round
 * trip to MongoDB.
 *
 * Mongoose will perform casting on all operations you provide.
 *
 * This function does **not** trigger any middleware, neither `save()`, nor `update()`.
 * If you need to trigger
 * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#model_Model-create) instead.
 *
 * #### Example:
 *
 *     Character.bulkWrite([
 *       {
 *         insertOne: {
 *           document: {
 *             name: 'Eddard Stark',
 *             title: 'Warden of the North'
 *           }
 *         }
 *       },
 *       {
 *         updateOne: {
 *           filter: { name: 'Eddard Stark' },
 *           // If you were using the MongoDB driver directly, you'd need to do
 *           // `update: { $set: { title: ... } }` but mongoose adds $set for
 *           // you.
 *           update: { title: 'Hand of the King' }
 *         }
 *       },
 *       {
 *         deleteOne: {
 *           filter: { name: 'Eddard Stark' }
 *         }
 *       }
 *     ]).then(res => {
 *      // Prints "1 1 1"
 *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);
 *     });
 *
 * The [supported operations](https://docs.mongodb.com/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:
 *
 * - `insertOne`
 * - `updateOne`
 * - `updateMany`
 * - `deleteOne`
 * - `deleteMany`
 * - `replaceOne`
 *
 * @param {Array} ops
 * @param {Object} [ops.insertOne.document] The document to insert
 * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter
 * @param {Object} [ops.updateOne.update] An object containing [update operators](https://docs.mongodb.com/manual/reference/operator/update/)
 * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match
 * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation
 * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use
 * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`
 * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter
 * @param {Object} [ops.updateMany.update] An object containing [update operators](https://docs.mongodb.com/manual/reference/operator/update/)
 * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`
 * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation
 * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use
 * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`
 * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter
 * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter
 * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter
 * @param {Object} [ops.replaceOne.replacement] The replacement document
 * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`
 * @param {Object} [options]
 * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.
 * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](/docs/transactions.html).
 * @param {String|number} [options.w=1] The [write concern](https://docs.mongodb.com/manual/reference/write-concern/). See [`Query#w()`](/docs/api/query.html#query_Query-w) for more information.
 * @param {number} [options.wtimeout=null] The [write concern timeout](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout).
 * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://docs.mongodb.com/manual/reference/write-concern/#j-option)
 * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.
 * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://docs.mongodb.com/manual/core/schema-validation/) for all writes in this bulk.
 * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.
 * @param {Function} [callback] callback `function(error, bulkWriteOpResult) {}`
 * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds
 * @api public
 */ Model.bulkWrite = function(ops, options, callback) {
    _checkContext(this, "bulkWrite");
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    options = options || {};
    const validations = ops.map((op)=>castBulkWrite(this, op, options));
    callback = this.$handleCallbackError(callback);
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        cb = this.$wrapCallback(cb);
        each(validations, (fn, cb)=>fn(cb), (error)=>{
            if (error) {
                return cb(error);
            }
            if (ops.length === 0) {
                return cb(null, getDefaultBulkwriteResult());
            }
            try {
                this.$__collection.bulkWrite(ops, options, (error, res)=>{
                    if (error) {
                        return cb(error);
                    }
                    cb(null, res);
                });
            } catch (err) {
                return cb(err);
            }
        });
    }, this.events);
};
/**
 *  takes an array of documents, gets the changes and inserts/updates documents in the database
 *  according to whether or not the document is new, or whether it has changes or not.
 *
 * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)
 *
 * @param {Array<Document>} documents
 * @param {Object} [options] options passed to the underlying `bulkWrite()`
 * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.
 * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](/docs/transactions.html).
 * @param {String|number} [options.w=1] The [write concern](https://docs.mongodb.com/manual/reference/write-concern/). See [`Query#w()`](/docs/api/query.html#query_Query-w) for more information.
 * @param {number} [options.wtimeout=null] The [write concern timeout](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout).
 * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://docs.mongodb.com/manual/reference/write-concern/#j-option)
 *
 */ Model.bulkSave = async function(documents, options) {
    options = options || {};
    const writeOperations = this.buildBulkWriteOperations(documents, {
        skipValidation: true,
        timestamps: options.timestamps
    });
    if (options.timestamps != null) {
        for (const document of documents){
            document.$__.saveOptions = document.$__.saveOptions || {};
            document.$__.saveOptions.timestamps = options.timestamps;
        }
    } else {
        for (const document of documents){
            if (document.$__.timestamps != null) {
                document.$__.saveOptions = document.$__.saveOptions || {};
                document.$__.saveOptions.timestamps = document.$__.timestamps;
            }
        }
    }
    await Promise.all(documents.map(buildPreSavePromise));
    const { bulkWriteResult , bulkWriteError  } = await this.bulkWrite(writeOperations, options).then((res)=>({
            bulkWriteResult: res,
            bulkWriteError: null
        }), (err)=>({
            bulkWriteResult: null,
            bulkWriteError: err
        }));
    await Promise.all(documents.map(async (document)=>{
        const documentError = bulkWriteError && bulkWriteError.writeErrors.find((writeError)=>{
            const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
            return writeErrorDocumentId.toString() === document._id.toString();
        });
        if (documentError == null) {
            await handleSuccessfulWrite(document);
        }
    }));
    if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {
        throw bulkWriteError;
    }
    return bulkWriteResult;
};
function buildPreSavePromise(document) {
    return new Promise((resolve, reject)=>{
        document.schema.s.hooks.execPre("save", document, (err)=>{
            if (err) {
                reject(err);
                return;
            }
            resolve();
        });
    });
}
function handleSuccessfulWrite(document) {
    return new Promise((resolve, reject)=>{
        if (document.$isNew) {
            _setIsNew(document, false);
        }
        document.$__reset();
        document.schema.s.hooks.execPost("save", document, {}, (err)=>{
            if (err) {
                reject(err);
                return;
            }
            resolve();
        });
    });
}
/**
 * Apply defaults to the given document or POJO.
 *
 * @param {Object|Document} obj object or document to apply defaults on
 * @returns {Object|Document}
 * @api public
 */ Model.applyDefaults = function applyDefaults(doc) {
    if (doc.$__ != null) {
        applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);
        for (const subdoc of doc.$getAllSubdocs()){
            applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);
        }
        return doc;
    }
    applyDefaultsToPOJO(doc, this.schema);
    return doc;
};
/**
 * Cast the given POJO to the model's schema
 *
 * #### Example:
 *
 *     const Test = mongoose.model('Test', Schema({ num: Number }));
 *
 *     const obj = Test.castObject({ num: '42' });
 *     obj.num; // 42 as a number
 *
 *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError
 *
 * @param {Object} obj object or document to cast
 * @param {Object} options options passed to castObject
 * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.
 * @returns {Object} POJO casted to the model's schema
 * @throws {ValidationError} if casting failed for at least one path
 * @api public
 */ Model.castObject = function castObject(obj, options) {
    options = options || {};
    const ret = {};
    const schema = this.schema;
    const paths = Object.keys(schema.paths);
    for (const path of paths){
        const schemaType = schema.path(path);
        if (!schemaType || !schemaType.$isMongooseArray) {
            continue;
        }
        const val = get(obj, path);
        pushNestedArrayPaths(paths, val, path);
    }
    let error = null;
    for (const path of paths){
        const schemaType = schema.path(path);
        if (schemaType == null) {
            continue;
        }
        let val = get(obj, path, void 0);
        if (val == null) {
            continue;
        }
        const pieces = path.indexOf(".") === -1 ? [
            path
        ] : path.split(".");
        let cur = ret;
        for(let i = 0; i < pieces.length - 1; ++i){
            if (cur[pieces[i]] == null) {
                cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];
            }
            cur = cur[pieces[i]];
        }
        if (schemaType.$isMongooseDocumentArray) {
            continue;
        }
        if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {
            try {
                val = Model.castObject.call(schemaType.caster, val);
            } catch (err) {
                if (!options.ignoreCastErrors) {
                    error = error || new ValidationError();
                    error.addError(path, err);
                }
                continue;
            }
            cur[pieces[pieces.length - 1]] = val;
            continue;
        }
        try {
            val = schemaType.cast(val);
            cur[pieces[pieces.length - 1]] = val;
        } catch (err) {
            if (!options.ignoreCastErrors) {
                error = error || new ValidationError();
                error.addError(path, err);
            }
            continue;
        }
    }
    if (error != null) {
        throw error;
    }
    return ret;
};
/**
 * Build bulk write operations for `bulkSave()`.
 *
 * @param {Array<Document>} documents The array of documents to build write operations of
 * @param {Object} options
 * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.
 * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.
 * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.
 * @api private
 */ Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
    if (!Array.isArray(documents)) {
        throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
    }
    setDefaultOptions();
    const writeOperations = documents.reduce((accumulator, document, i)=>{
        if (!options.skipValidation) {
            if (!(document instanceof Document)) {
                throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
            }
            const validationError = document.validateSync();
            if (validationError) {
                throw validationError;
            }
        }
        const isANewDocument = document.isNew;
        if (isANewDocument) {
            const writeOperation = {
                insertOne: {
                    document
                }
            };
            utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);
            accumulator.push(writeOperation);
            return accumulator;
        }
        const delta = document.$__delta();
        const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);
        if (isDocumentWithChanges) {
            const where = document.$__where(delta[0]);
            const changes = delta[1];
            _applyCustomWhere(document, where);
            document.$__version(where, delta);
            const writeOperation = {
                updateOne: {
                    filter: where,
                    update: changes
                }
            };
            utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);
            accumulator.push(writeOperation);
            return accumulator;
        }
        return accumulator;
    }, []);
    return writeOperations;
    function setDefaultOptions() {
        options = options || {};
        if (options.skipValidation == null) {
            options.skipValidation = false;
        }
    }
};
/**
 * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.
 * The document returned has no paths marked as modified initially.
 *
 * #### Example:
 *
 *     // hydrate previous data into a Mongoose document
 *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });
 *
 * @param {Object} obj
 * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document
 * @param {Object} [options] optional options
 * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating
 * @return {Document} document instance
 * @api public
 */ Model.hydrate = function(obj, projection, options) {
    _checkContext(this, "hydrate");
    if (projection != null) {
        if (obj != null && obj.$__ != null) {
            obj = obj.toObject(internalToObjectOptions);
        }
        obj = applyProjection(obj, projection);
    }
    const document = (__webpack_require__(83524).createModel)(this, obj, projection);
    document.$init(obj, options);
    return document;
};
/**
 * Updates one document in the database without returning it.
 *
 * This function triggers the following middleware.
 *
 * - `update()`
 *
 * This method is deprecated. See [Deprecation Warnings](../deprecations.html#update) for details.
 *
 * #### Example:
 *
 *     MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);
 *
 *     const res = await MyModel.update({ name: 'Tobi' }, { ferret: true });
 *     res.n; // Number of documents that matched `{ name: 'Tobi' }`
 *     // Number of documents that were changed. If every doc matched already
 *     // had `ferret` set to `true`, `nModified` will be 0.
 *     res.nModified;
 *
 * #### Valid options:
 *
 *  - `strict` (boolean): overrides the [schema-level `strict` option](/docs/guide.html#strict) for this update
 *  - `upsert` (boolean): whether to create the doc if it doesn't match (false)
 *  - `writeConcern` (object): sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 *  - `multi` (boolean): whether multiple documents should be updated (false)
 *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
 *  - `setDefaultsOnInsert` (boolean): if this and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
 *  - `timestamps` (boolean): If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 *  - `overwrite` (boolean): disables update-only mode, allowing you to overwrite the doc (false)
 *
 * All `update` values are cast to their appropriate SchemaTypes before being sent.
 *
 * The `callback` function receives `(err, rawResponse)`.
 *
 * - `err` is the error if any occurred
 * - `rawResponse` is the full response from Mongo
 *
 * #### Note:
 *
 * All top level keys which are not `atomic` operation names are treated as set operations:
 *
 * #### Example:
 *
 *     const query = { name: 'borne' };
 *     Model.update(query, { name: 'jason bourne' }, options, callback);
 *
 *     // is sent as
 *     Model.update(query, { $set: { name: 'jason bourne' }}, options, function(err, res));
 *     // if overwrite option is false. If overwrite is true, sent without the $set wrapper.
 *
 * This helps prevent accidentally overwriting all documents in your collection with `{ name: 'jason bourne' }`.
 *
 * #### Note:
 *
 * Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.
 *
 * @deprecated
 * @see strict https://mongoosejs.com/docs/guide.html#strict
 * @see response https://docs.mongodb.org/v2.6/reference/command/update/#output
 * @param {Object} filter
 * @param {Object} doc
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.multi=false] whether multiple documents should be updated or just the first one that matches `filter`.
 * @param {Boolean} [options.runValidators=false] if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
 * @param {Boolean} [options.setDefaultsOnInsert=false] `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Boolean} [options.overwrite=false] By default, if you don't include any [update operators](https://docs.mongodb.com/manual/reference/operator/update/) in `doc`, Mongoose will wrap `doc` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`.
 * @param {Function} [callback] params are (error, [updateWriteOpResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html))
 * @return {Query}
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @api public
 */ Model.update = function update(conditions, doc, options, callback) {
    _checkContext(this, "update");
    return _update(this, "update", conditions, doc, options, callback);
};
/**
 * Same as `update()`, except MongoDB will update _all_ documents that match
 * `filter` (as opposed to just the first one) regardless of the value of
 * the `multi` option.
 *
 * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`
 * and `post('updateMany')` instead.
 *
 * #### Example:
 *
 *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });
 *     res.matchedCount; // Number of documents matched
 *     res.modifiedCount; // Number of documents modified
 *     res.acknowledged; // Boolean indicating everything went smoothly.
 *     res.upsertedId; // null or an id containing a document that had to be upserted.
 *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.
 *
 * This function triggers the following middleware.
 *
 * - `updateMany()`
 *
 * @param {Object} filter
 * @param {Object|Array} update
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] `function(error, res) {}` where `res` has 5 properties: `modifiedCount`, `matchedCount`, `acknowledged`, `upsertedId`, and `upsertedCount`.
 * @return {Query}
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @api public
 */ Model.updateMany = function updateMany(conditions, doc, options, callback) {
    _checkContext(this, "updateMany");
    return _update(this, "updateMany", conditions, doc, options, callback);
};
/**
 * Same as `update()`, except it does not support the `multi` or `overwrite`
 * options.
 *
 * - MongoDB will update _only_ the first document that matches `filter` regardless of the value of the `multi` option.
 * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.
 *
 * #### Example:
 *
 *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });
 *     res.matchedCount; // Number of documents matched
 *     res.modifiedCount; // Number of documents modified
 *     res.acknowledged; // Boolean indicating everything went smoothly.
 *     res.upsertedId; // null or an id containing a document that had to be upserted.
 *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.
 *
 * This function triggers the following middleware.
 *
 * - `updateOne()`
 *
 * @param {Object} filter
 * @param {Object|Array} update
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query}
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @api public
 */ Model.updateOne = function updateOne(conditions, doc, options, callback) {
    _checkContext(this, "updateOne");
    return _update(this, "updateOne", conditions, doc, options, callback);
};
/**
 * Same as `update()`, except MongoDB replace the existing document with the
 * given document (no atomic operators like `$set`).
 *
 * #### Example:
 *
 *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });
 *     res.matchedCount; // Number of documents matched
 *     res.modifiedCount; // Number of documents modified
 *     res.acknowledged; // Boolean indicating everything went smoothly.
 *     res.upsertedId; // null or an id containing a document that had to be upserted.
 *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.
 *
 * This function triggers the following middleware.
 *
 * - `replaceOne()`
 *
 * @param {Object} filter
 * @param {Object} doc
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] `function(error, res) {}` where `res` has 3 properties: `n`, `nModified`, `ok`.
 * @return {Query}
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @return {Query}
 * @api public
 */ Model.replaceOne = function replaceOne(conditions, doc, options, callback) {
    _checkContext(this, "replaceOne");
    const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;
    if (versionKey && !doc[versionKey]) {
        doc[versionKey] = 0;
    }
    return _update(this, "replaceOne", conditions, doc, options, callback);
};
/**
 * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`
 * because they need to do the same thing
 * @api private
 */ function _update(model, op, conditions, doc, options, callback) {
    const mq = new model.Query({}, {}, model, model.collection);
    callback = model.$handleCallbackError(callback);
    // gh-2406
    // make local deep copy of conditions
    if (conditions instanceof Document) {
        conditions = conditions.toObject();
    } else {
        conditions = utils.clone(conditions);
    }
    options = typeof options === "function" ? options : utils.clone(options);
    const versionKey = model && model.schema && model.schema.options && model.schema.options.versionKey || null;
    _decorateUpdateWithVersionKey(doc, options, versionKey);
    return mq[op](conditions, doc, options, callback);
}
/**
 * Executes a mapReduce command.
 *
 * `opts` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#mapReduce) for more detail about options.
 *
 * This function does not trigger any middleware.
 *
 * #### Example:
 *
 *     const opts = {};
 *     // `map()` and `reduce()` are run on the MongoDB server, not Node.js,
 *     // these functions are converted to strings
 *     opts.map = function () { emit(this.name, 1) };
 *     opts.reduce = function (k, vals) { return vals.length };
 *     User.mapReduce(opts, function (err, results) {
 *       console.log(results)
 *     })
 *
 * If `opts.out` is set to `replace`, `merge`, or `reduce`, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the [`lean` option](/docs/tutorials/lean.html); meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).
 *
 * #### Example:
 *
 *     const opts = {};
 *     // You can also define `map()` and `reduce()` as strings if your
 *     // linter complains about `emit()` not being defined
 *     opts.map = 'function () { emit(this.name, 1) }';
 *     opts.reduce = 'function (k, vals) { return vals.length }';
 *     opts.out = { replace: 'createdCollectionNameForResults' }
 *     opts.verbose = true;
 *
 *     User.mapReduce(opts, function (err, model, stats) {
 *       console.log('map reduce took %d ms', stats.processtime)
 *       model.find().where('value').gt(10).exec(function (err, docs) {
 *         console.log(docs);
 *       });
 *     })
 *
 *     // `mapReduce()` returns a promise. However, ES6 promises can only
 *     // resolve to exactly one value,
 *     opts.resolveToObject = true;
 *     const promise = User.mapReduce(opts);
 *     promise.then(function (res) {
 *       const model = res.model;
 *       const stats = res.stats;
 *       console.log('map reduce took %d ms', stats.processtime)
 *       return model.find().where('value').gt(10).exec();
 *     }).then(function (docs) {
 *        console.log(docs);
 *     }).then(null, handleError).end()
 *
 * @param {Object} opts an object specifying map-reduce options
 * @param {Boolean} [opts.verbose=false] provide statistics on job execution time
 * @param {ReadPreference|String} [opts.readPreference] a read-preference string or a read-preference instance
 * @param {Boolean} [opts.jsMode=false] it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X
 * @param {Object} [opts.scope] scope variables exposed to map/reduce/finalize during execution
 * @param {Function} [opts.finalize] finalize function
 * @param {Boolean} [opts.keeptemp=false] keep temporary data
 * @param {Number} [opts.limit] max number of documents
 * @param {Object} [opts.sort] sort input objects using this key
 * @param {Object} [opts.query] query filter object
 * @param {Object} [opts.out] sets the output target for the map reduce job
 * @param {Number} [opts.out.inline=1] the results are returned in an array
 * @param {String} [opts.out.replace] add the results to collectionName: the results replace the collection
 * @param {String} [opts.out.reduce] add the results to collectionName: if dups are detected, uses the reducer / finalize functions
 * @param {String} [opts.out.merge] add the results to collectionName: if dups exist the new docs overwrite the old
 * @param {Function} [callback] optional callback
 * @see MongoDB MapReduce https://www.mongodb.org/display/DOCS/MapReduce
 * @return {Promise}
 * @api public
 */ Model.mapReduce = function mapReduce(opts, callback) {
    _checkContext(this, "mapReduce");
    callback = this.$handleCallbackError(callback);
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        cb = this.$wrapCallback(cb);
        if (!Model.mapReduce.schema) {
            const opts = {
                _id: false,
                id: false,
                strict: false
            };
            Model.mapReduce.schema = new Schema({}, opts);
        }
        if (!opts.out) opts.out = {
            inline: 1
        };
        if (opts.verbose !== false) opts.verbose = true;
        opts.map = String(opts.map);
        opts.reduce = String(opts.reduce);
        if (opts.query) {
            let q = new this.Query(opts.query);
            q.cast(this);
            opts.query = q._conditions;
            q = undefined;
        }
        this.$__collection.mapReduce(null, null, opts, (err, res)=>{
            if (err) {
                return cb(err);
            }
            if (res.collection) {
                // returned a collection, convert to Model
                const model = Model.compile("_mapreduce_" + res.collection.collectionName, Model.mapReduce.schema, res.collection.collectionName, this.db, this.base);
                model._mapreduce = true;
                res.model = model;
                return cb(null, res);
            }
            cb(null, res);
        });
    }, this.events);
};
/**
 * Performs [aggregations](https://docs.mongodb.org/manual/applications/aggregation/) on the models collection.
 *
 * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.
 *
 * This function triggers the following middleware.
 *
 * - `aggregate()`
 *
 * #### Example:
 *
 *     // Find the max balance of all accounts
 *     const res = await Users.aggregate([
 *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},
 *       { $project: { _id: 0, maxBalance: 1 }}
 *     ]);
 *
 *     console.log(res); // [ { maxBalance: 98000 } ]
 *
 *     // Or use the aggregation pipeline builder.
 *     const res = await Users.aggregate().
 *       group({ _id: null, maxBalance: { $max: '$balance' } }).
 *       project('-id maxBalance').
 *       exec();
 *     console.log(res); // [ { maxBalance: 98 } ]
 *
 * #### Note:
 *
 * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.
 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
 *
 * #### More About Aggregations:
 *
 * - [Mongoose `Aggregate`](/docs/api/aggregate.html)
 * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)
 * - [MongoDB Aggregation docs](https://docs.mongodb.org/manual/applications/aggregation/)
 *
 * @see Aggregate #aggregate_Aggregate
 * @see MongoDB https://docs.mongodb.org/manual/applications/aggregation/
 * @param {Array} [pipeline] aggregation pipeline as an array of objects
 * @param {Object} [options] aggregation options
 * @param {Function} [callback]
 * @return {Aggregate}
 * @api public
 */ Model.aggregate = function aggregate(pipeline, options, callback) {
    _checkContext(this, "aggregate");
    if (arguments.length > 3 || (pipeline && pipeline.constructor && pipeline.constructor.name) === "Object") {
        throw new MongooseError("Mongoose 5.x disallows passing a spread of operators " + "to `Model.aggregate()`. Instead of " + "`Model.aggregate({ $match }, { $skip })`, do " + "`Model.aggregate([{ $match }, { $skip }])`");
    }
    if (typeof pipeline === "function") {
        callback = pipeline;
        pipeline = [];
    }
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    const aggregate = new Aggregate(pipeline || []);
    aggregate.model(this);
    if (options != null) {
        aggregate.option(options);
    }
    if (typeof callback === "undefined") {
        return aggregate;
    }
    callback = this.$handleCallbackError(callback);
    callback = this.$wrapCallback(callback);
    aggregate.exec(callback);
    return aggregate;
};
/**
 * Casts and validates the given object against this model's schema, passing the
 * given `context` to custom validators.
 *
 * #### Example:
 *
 *     const Model = mongoose.model('Test', Schema({
 *       name: { type: String, required: true },
 *       age: { type: Number, required: true }
 *     });
 *
 *     try {
 *       await Model.validate({ name: null }, ['name'])
 *     } catch (err) {
 *       err instanceof mongoose.Error.ValidationError; // true
 *       Object.keys(err.errors); // ['name']
 *     }
 *
 * @param {Object} obj
 * @param {Array|String} pathsToValidate
 * @param {Object} [context]
 * @param {Function} [callback]
 * @return {Promise|undefined}
 * @api public
 */ Model.validate = function validate(obj, pathsToValidate, context, callback) {
    if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
        // For convenience, if we're validating a document or an object, make `context` default to
        // the model so users don't have to always pass `context`, re: gh-10132, gh-10346
        context = obj;
    }
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        let schema = this.schema;
        const discriminatorKey = schema.options.discriminatorKey;
        if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
            schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
        }
        let paths = Object.keys(schema.paths);
        if (pathsToValidate != null) {
            const _pathsToValidate = typeof pathsToValidate === "string" ? new Set(pathsToValidate.split(" ")) : new Set(pathsToValidate);
            paths = paths.filter((p)=>{
                const pieces = p.split(".");
                let cur = pieces[0];
                for (const piece of pieces){
                    if (_pathsToValidate.has(cur)) {
                        return true;
                    }
                    cur += "." + piece;
                }
                return _pathsToValidate.has(p);
            });
        }
        for (const path of paths){
            const schemaType = schema.path(path);
            if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {
                continue;
            }
            const val = get(obj, path);
            pushNestedArrayPaths(paths, val, path);
        }
        let remaining = paths.length;
        let error = null;
        for (const path of paths){
            const schemaType = schema.path(path);
            if (schemaType == null) {
                _checkDone();
                continue;
            }
            const pieces = path.indexOf(".") === -1 ? [
                path
            ] : path.split(".");
            let cur = obj;
            for(let i = 0; i < pieces.length - 1; ++i){
                cur = cur[pieces[i]];
            }
            let val = get(obj, path, void 0);
            if (val != null) {
                try {
                    val = schemaType.cast(val);
                    cur[pieces[pieces.length - 1]] = val;
                } catch (err) {
                    error = error || new ValidationError();
                    error.addError(path, err);
                    _checkDone();
                    continue;
                }
            }
            schemaType.doValidate(val, (err)=>{
                if (err) {
                    error = error || new ValidationError();
                    error.addError(path, err);
                }
                _checkDone();
            }, context, {
                path: path
            });
        }
        function _checkDone() {
            if (--remaining <= 0) {
                return cb(error);
            }
        }
    });
};
/**
 * Populates document references.
 *
 * Changed in Mongoose 6: the model you call `populate()` on should be the
 * "local field" model, **not** the "foreign field" model.
 *
 * #### Available top-level options:
 *
 * - path: space delimited path(s) to populate
 * - select: optional fields to select
 * - match: optional query conditions to match
 * - model: optional name of the model to use for population
 * - options: optional query options like sort, limit, etc
 * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.
 * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.
 *
 * #### Example:
 *
 *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));
 *     const Person = mongoose.model('Person', new Schema({
 *       name: String,
 *       pet: { type: mongoose.ObjectId, ref: 'Dog' }
 *     }));
 *
 *     const pets = await Pet.create([
 *       { name: 'Daisy', breed: 'Beagle' },
 *       { name: 'Einstein', breed: 'Catalan Sheepdog' }
 *     ]);
 *
 *     // populate many plain objects
 *     const users = [
 *       { name: 'John Wick', dog: pets[0]._id },
 *       { name: 'Doc Brown', dog: pets[1]._id }
 *     ];
 *     await User.populate(users, { path: 'dog', select: 'name' });
 *     users[0].dog.name; // 'Daisy'
 *     users[0].dog.breed; // undefined because of `select`
 *
 * @param {Document|Array} docs Either a single document or array of documents to populate.
 * @param {Object|String} options Either the paths to populate or an object specifying all parameters
 * @param {string} [options.path=null] The path to populate.
 * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](/docs/populate.html#deep-populate).
 * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.
 * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).
 * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.
 * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.
 * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.
 * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.
 * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.
 * @param {Object} [options.options=null] Additional options like `limit` and `lean`.
 * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.
 * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
 * @return {Promise}
 * @api public
 */ Model.populate = function(docs, paths, callback) {
    _checkContext(this, "populate");
    const _this = this;
    // normalized paths
    paths = utils.populate(paths);
    // data that should persist across subPopulate calls
    const cache = {};
    callback = this.$handleCallbackError(callback);
    return this.db.base._promiseOrCallback(callback, (cb)=>{
        cb = this.$wrapCallback(cb);
        _populate(_this, docs, paths, cache, cb);
    }, this.events);
};
/**
 * Populate helper
 *
 * @param {Model} model the model to use
 * @param {Document|Array} docs Either a single document or array of documents to populate.
 * @param {Object} paths
 * @param {never} cache Unused
 * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
 * @return {Function}
 * @api private
 */ function _populate(model, docs, paths, cache, callback) {
    let pending = paths.length;
    if (paths.length === 0) {
        return callback(null, docs);
    }
    // each path has its own query options and must be executed separately
    for (const path of paths){
        populate(model, docs, path, next);
    }
    function next(err) {
        if (err) {
            return callback(err, null);
        }
        if (--pending) {
            return;
        }
        callback(null, docs);
    }
}
/*!
 * Populates `docs`
 */ const excludeIdReg = /\s?-_id\s?/;
const excludeIdRegGlobal = /\s?-_id\s?/g;
function populate(model, docs, options, callback) {
    const populateOptions = {
        ...options
    };
    if (options.strictPopulate == null) {
        if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {
            populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;
        } else if (options._localModel != null && model.base.options.strictPopulate != null) {
            populateOptions.strictPopulate = model.base.options.strictPopulate;
        } else if (model.base.options.strictPopulate != null) {
            populateOptions.strictPopulate = model.base.options.strictPopulate;
        }
    }
    // normalize single / multiple docs passed
    if (!Array.isArray(docs)) {
        docs = [
            docs
        ];
    }
    if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
        return callback();
    }
    const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);
    if (modelsMap instanceof MongooseError) {
        return immediate(function() {
            callback(modelsMap);
        });
    }
    const len = modelsMap.length;
    let vals = [];
    function flatten(item) {
        // no need to include undefined values in our query
        return undefined !== item;
    }
    let _remaining = len;
    let hasOne = false;
    const params = [];
    for(let i = 0; i < len; ++i){
        const mod = modelsMap[i];
        let select = mod.options.select;
        let ids = utils.array.flatten(mod.ids, flatten);
        ids = utils.array.unique(ids);
        const assignmentOpts = {};
        assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || void 0;
        assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
        // Lean transform may delete `_id`, which would cause assignment
        // to fail. So delay running lean transform until _after_
        // `_assign()`
        if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {
            mod.options.options._leanTransform = mod.options.options.lean.transform;
            mod.options.options.lean = true;
        }
        if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
            // Ensure that we set to 0 or empty array even
            // if we don't actually execute a query to make sure there's a value
            // and we know this path was populated for future sets. See gh-7731, gh-8230
            --_remaining;
            _assign(model, [], mod, assignmentOpts);
            continue;
        }
        hasOne = true;
        if (typeof populateOptions.foreignField === "string") {
            mod.foreignField.clear();
            mod.foreignField.add(populateOptions.foreignField);
        }
        const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
        if (assignmentOpts.excludeId) {
            // override the exclusion from the query so we can use the _id
            // for document matching during assignment. we'll delete the
            // _id back off before returning the result.
            if (typeof select === "string") {
                select = select.replace(excludeIdRegGlobal, " ");
            } else {
                // preserve original select conditions by copying
                select = utils.object.shallowCopy(select);
                delete select._id;
            }
        }
        if (mod.options.options && mod.options.options.limit != null) {
            assignmentOpts.originalLimit = mod.options.options.limit;
        } else if (mod.options.limit != null) {
            assignmentOpts.originalLimit = mod.options.limit;
        }
        params.push([
            mod,
            match,
            select,
            assignmentOpts,
            _next
        ]);
    }
    if (!hasOne) {
        // If models but no docs, skip further deep populate.
        if (modelsMap.length !== 0) {
            return callback();
        }
        // If no models to populate but we have a nested populate,
        // keep trying, re: gh-8946
        if (populateOptions.populate != null) {
            const opts = utils.populate(populateOptions.populate).map((pop)=>Object.assign({}, pop, {
                    path: populateOptions.path + "." + pop.path
                }));
            return model.populate(docs, opts, callback);
        }
        return callback();
    }
    for (const arr of params){
        _execPopulateQuery.apply(null, arr);
    }
    function _next(err, valsFromDb) {
        if (err != null) {
            return callback(err, null);
        }
        vals = vals.concat(valsFromDb);
        if (--_remaining === 0) {
            _done();
        }
    }
    function _done() {
        for (const arr of params){
            const mod = arr[0];
            const assignmentOpts = arr[3];
            for (const val of vals){
                mod.options._childDocs.push(val);
            }
            try {
                _assign(model, vals, mod, assignmentOpts);
            } catch (err) {
                return callback(err);
            }
        }
        for (const arr of params){
            removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
        }
        for (const arr of params){
            const mod = arr[0];
            if (mod.options && mod.options.options && mod.options.options._leanTransform) {
                for (const doc of vals){
                    mod.options.options._leanTransform(doc);
                }
            }
        }
        callback();
    }
}
/*!
 * ignore
 */ function _execPopulateQuery(mod, match, select, assignmentOpts, callback) {
    let subPopulate = utils.clone(mod.options.populate);
    const queryOptions = Object.assign({
        skip: mod.options.skip,
        limit: mod.options.limit,
        perDocumentLimit: mod.options.perDocumentLimit
    }, mod.options.options);
    if (mod.count) {
        delete queryOptions.skip;
    }
    if (queryOptions.perDocumentLimit != null) {
        queryOptions.limit = queryOptions.perDocumentLimit;
        delete queryOptions.perDocumentLimit;
    } else if (queryOptions.limit != null) {
        queryOptions.limit = queryOptions.limit * mod.ids.length;
    }
    const query = mod.model.find(match, select, queryOptions);
    // If we're doing virtual populate and projection is inclusive and foreign
    // field is not selected, automatically select it because mongoose needs it.
    // If projection is exclusive and client explicitly unselected the foreign
    // field, that's the client's fault.
    for (const foreignField of mod.foreignField){
        if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
            query.select(foreignField);
        }
    }
    // If using count, still need the `foreignField` so we can match counts
    // to documents, otherwise we would need a separate `count()` for every doc.
    if (mod.count) {
        for (const foreignField of mod.foreignField){
            query.select(foreignField);
        }
    }
    // If we need to sub-populate, call populate recursively
    if (subPopulate) {
        // If subpopulating on a discriminator, skip check for non-existent
        // paths. Because the discriminator may not have the path defined.
        if (mod.model.baseModelName != null) {
            if (Array.isArray(subPopulate)) {
                subPopulate.forEach((pop)=>{
                    pop.strictPopulate = false;
                });
            } else if (typeof subPopulate === "string") {
                subPopulate = {
                    path: subPopulate,
                    strictPopulate: false
                };
            } else {
                subPopulate.strictPopulate = false;
            }
        }
        const basePath = mod.options._fullPath || mod.options.path;
        if (Array.isArray(subPopulate)) {
            for (const pop of subPopulate){
                pop._fullPath = basePath + "." + pop.path;
            }
        } else if (typeof subPopulate === "object") {
            subPopulate._fullPath = basePath + "." + subPopulate.path;
        }
        query.populate(subPopulate);
    }
    query.exec((err, docs)=>{
        if (err != null) {
            return callback(err);
        }
        for (const val of docs){
            leanPopulateMap.set(val, mod.model);
        }
        callback(null, docs);
    });
}
/*!
 * ignore
 */ function _assign(model, vals, mod, assignmentOpts) {
    const options = mod.options;
    const isVirtual = mod.isVirtual;
    const justOne = mod.justOne;
    let _val;
    const lean = options && options.options && options.options.lean || false;
    const len = vals.length;
    const rawOrder = {};
    const rawDocs = {};
    let key;
    let val;
    // Clone because `assignRawDocsToIdStructure` will mutate the array
    const allIds = utils.clone(mod.allIds);
    // optimization:
    // record the document positions as returned by
    // the query result.
    for(let i = 0; i < len; i++){
        val = vals[i];
        if (val == null) {
            continue;
        }
        for (const foreignField of mod.foreignField){
            _val = utils.getValue(foreignField, val);
            if (Array.isArray(_val)) {
                _val = utils.array.unique(utils.array.flatten(_val));
                for (let __val of _val){
                    if (__val instanceof Document) {
                        __val = __val._id;
                    }
                    key = String(__val);
                    if (rawDocs[key]) {
                        if (Array.isArray(rawDocs[key])) {
                            rawDocs[key].push(val);
                            rawOrder[key].push(i);
                        } else {
                            rawDocs[key] = [
                                rawDocs[key],
                                val
                            ];
                            rawOrder[key] = [
                                rawOrder[key],
                                i
                            ];
                        }
                    } else {
                        if (isVirtual && !justOne) {
                            rawDocs[key] = [
                                val
                            ];
                            rawOrder[key] = [
                                i
                            ];
                        } else {
                            rawDocs[key] = val;
                            rawOrder[key] = i;
                        }
                    }
                }
            } else {
                if (_val instanceof Document) {
                    _val = _val._id;
                }
                key = String(_val);
                if (rawDocs[key]) {
                    if (Array.isArray(rawDocs[key])) {
                        rawDocs[key].push(val);
                        rawOrder[key].push(i);
                    } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {
                        // May need to store multiple docs with the same id if there's multiple models
                        // if we have discriminators or a ref function. But avoid converting to an array
                        // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906
                        rawDocs[key] = [
                            rawDocs[key],
                            val
                        ];
                        rawOrder[key] = [
                            rawOrder[key],
                            i
                        ];
                    }
                } else {
                    rawDocs[key] = val;
                    rawOrder[key] = i;
                }
            }
            // flag each as result of population
            if (!lean) {
                val.$__.wasPopulated = val.$__.wasPopulated || true;
            }
        }
    }
    assignVals({
        originalModel: model,
        // If virtual, make sure to not mutate original field
        rawIds: mod.isVirtual ? allIds : mod.allIds,
        allIds: allIds,
        unpopulatedValues: mod.unpopulatedValues,
        foreignField: mod.foreignField,
        rawDocs: rawDocs,
        rawOrder: rawOrder,
        docs: mod.docs,
        path: options.path,
        options: assignmentOpts,
        justOne: mod.justOne,
        isVirtual: mod.isVirtual,
        allOptions: mod,
        populatedModel: mod.model,
        lean: lean,
        virtual: mod.virtual,
        count: mod.count,
        match: mod.match
    });
}
/**
 * Compiler utility.
 *
 * @param {String|Function} name model name or class extending Model
 * @param {Schema} schema
 * @param {String} collectionName
 * @param {Connection} connection
 * @param {Mongoose} base mongoose instance
 * @api private
 */ Model.compile = function compile(name, schema, collectionName, connection, base) {
    const versioningEnabled = schema.options.versionKey !== false;
    if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
        // add versioning to top level documents only
        const o = {};
        o[schema.options.versionKey] = Number;
        schema.add(o);
    }
    let model;
    if (typeof name === "function" && name.prototype instanceof Model) {
        model = name;
        name = model.name;
        schema.loadClass(model, false);
        model.prototype.$isMongooseModelPrototype = true;
    } else {
        // generate new class
        model = function model(doc, fields, skipId) {
            model.hooks.execPreSync("createModel", doc);
            if (!(this instanceof model)) {
                return new model(doc, fields, skipId);
            }
            const discriminatorKey = model.schema.options.discriminatorKey;
            if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {
                Model.call(this, doc, fields, skipId);
                return;
            }
            // If discriminator key is set, use the discriminator instead (gh-7586)
            const Discriminator = model.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
            if (Discriminator != null) {
                return new Discriminator(doc, fields, skipId);
            }
            // Otherwise, just use the top-level model
            Model.call(this, doc, fields, skipId);
        };
    }
    model.hooks = schema.s.hooks.clone();
    model.base = base;
    model.modelName = name;
    if (!(model.prototype instanceof Model)) {
        Object.setPrototypeOf(model, Model);
        Object.setPrototypeOf(model.prototype, Model.prototype);
    }
    model.model = function model(name) {
        return this.db.model(name);
    };
    model.db = connection;
    model.prototype.db = connection;
    model.prototype[modelDbSymbol] = connection;
    model.discriminators = model.prototype.discriminators = undefined;
    model[modelSymbol] = true;
    model.events = new EventEmitter();
    schema._preCompile();
    model.prototype.$__setSchema(schema);
    const _userProvidedOptions = schema._userProvidedOptions || {};
    const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: schema.options.capped,
        Promise: model.base.Promise,
        modelName: name
    };
    if (schema.options.autoCreate !== void 0) {
        collectionOptions.autoCreate = schema.options.autoCreate;
    }
    model.prototype.collection = connection.collection(collectionName, collectionOptions);
    model.prototype.$collection = model.prototype.collection;
    model.prototype[modelCollectionSymbol] = model.prototype.collection;
    // apply methods and statics
    applyMethods(model, schema);
    applyStatics(model, schema);
    applyHooks(model, schema);
    applyStaticHooks(model, schema.s.hooks, schema.statics);
    model.schema = model.prototype.$__schema;
    model.collection = model.prototype.collection;
    model.$__collection = model.collection;
    // Create custom query constructor
    model.Query = function() {
        Query.apply(this, arguments);
    };
    Object.setPrototypeOf(model.Query.prototype, Query.prototype);
    model.Query.base = Query.base;
    model.Query.prototype.constructor = Query;
    applyQueryMiddleware(model.Query, model);
    applyQueryMethods(model, schema.query);
    return model;
};
/**
 * Register custom query methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 * @api private
 */ function applyQueryMethods(model, methods) {
    for(const i in methods){
        model.Query.prototype[i] = methods[i];
    }
}
/**
 * Subclass this model with `conn`, `schema`, and `collection` settings.
 *
 * @param {Connection} conn
 * @param {Schema} [schema]
 * @param {String} [collection]
 * @return {Model}
 * @api private
 * @memberOf Model
 * @static
 * @method __subclass
 */ Model.__subclass = function subclass(conn, schema, collection) {
    // subclass model using this connection and collection name
    const _this = this;
    const Model = function Model(doc, fields, skipId) {
        if (!(this instanceof Model)) {
            return new Model(doc, fields, skipId);
        }
        _this.call(this, doc, fields, skipId);
    };
    Object.setPrototypeOf(Model, _this);
    Object.setPrototypeOf(Model.prototype, _this.prototype);
    Model.db = conn;
    Model.prototype.db = conn;
    Model.prototype[modelDbSymbol] = conn;
    _this[subclassedSymbol] = _this[subclassedSymbol] || [];
    _this[subclassedSymbol].push(Model);
    if (_this.discriminators != null) {
        Model.discriminators = {};
        for (const key of Object.keys(_this.discriminators)){
            Model.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
        }
    }
    const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
    const options = s.options || {};
    const _userProvidedOptions = s._userProvidedOptions || {};
    if (!collection) {
        collection = _this.prototype.$__schema.get("collection") || utils.toCollectionName(_this.modelName, this.base.pluralize());
    }
    const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: s && options.capped
    };
    Model.prototype.collection = conn.collection(collection, collectionOptions);
    Model.prototype.$collection = Model.prototype.collection;
    Model.prototype[modelCollectionSymbol] = Model.prototype.collection;
    Model.collection = Model.prototype.collection;
    Model.$__collection = Model.collection;
    // Errors handled internally, so ignore
    Model.init(()=>{});
    return Model;
};
Model.$handleCallbackError = function(callback) {
    if (callback == null) {
        return callback;
    }
    if (typeof callback !== "function") {
        throw new MongooseError("Callback must be a function, got " + callback);
    }
    const _this = this;
    return function() {
        immediate(()=>{
            try {
                callback.apply(null, arguments);
            } catch (error) {
                _this.emit("error", error);
            }
        });
    };
};
/**
 * ignore
 *
 * @param {Function} callback
 * @api private
 * @method $wrapCallback
 * @memberOf Model
 * @static
 */ Model.$wrapCallback = function(callback) {
    const serverSelectionError = new ServerSelectionError();
    const _this = this;
    return function(err) {
        if (err != null && err.name === "MongoServerSelectionError") {
            arguments[0] = serverSelectionError.assimilateError(err);
        }
        if (err != null && err.name === "MongoNetworkTimeoutError" && err.message.endsWith("timed out")) {
            _this.db.emit("timeout");
        }
        return callback.apply(null, arguments);
    };
};
/**
 * Helper for console.log. Given a model named 'MyModel', returns the string
 * `'Model { MyModel }'`.
 *
 * #### Example:
 *
 *     const MyModel = mongoose.model('Test', Schema({ name: String }));
 *     MyModel.inspect(); // 'Model { Test }'
 *     console.log(MyModel); // Prints 'Model { Test }'
 *
 * @api public
 */ Model.inspect = function() {
    return `Model { ${this.modelName} }`;
};
if (util.inspect.custom) {
    // Avoid Node deprecation warning DEP0079
    Model[util.inspect.custom] = Model.inspect;
}
/*!
 * Module exports.
 */ module.exports = exports = Model;


/***/ }),

/***/ 82128:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * ignore
 */ exports.h = {
    transform: false,
    virtuals: false,
    getters: false,
    _skipDepopulateTopLevel: true,
    depopulate: true,
    flattenDecimals: false,
    useProjection: false
};


/***/ }),

/***/ 71392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const clone = __webpack_require__(99889);
class PopulateOptions {
    constructor(obj){
        this._docs = {};
        this._childDocs = [];
        if (obj == null) {
            return;
        }
        obj = clone(obj);
        Object.assign(this, obj);
        if (typeof obj.subPopulate === "object") {
            this.populate = obj.subPopulate;
        }
        if (obj.perDocumentLimit != null && obj.limit != null) {
            throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
        }
    }
}
/**
 * The connection used to look up models by name. If not specified, Mongoose
 * will default to using the connection associated with the model in
 * `PopulateOptions#model`.
 *
 * @memberOf PopulateOptions
 * @property {Connection} connection
 * @api public
 */ module.exports = PopulateOptions;


/***/ }),

/***/ 64787:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on an Array schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ tags: [String] });
 *     schema.path('tags').options; // SchemaArrayOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaArrayOptions
 */ class SchemaArrayOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If this is an array of strings, an array of allowed values for this path.
 * Throws an error if this array isn't an array of strings.
 *
 * @api public
 * @property enum
 * @memberOf SchemaArrayOptions
 * @type {Array}
 * @instance
 */ Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
/**
 * If set, specifies the type of this array's values. Equivalent to setting
 * `type` to an array whose first element is `of`.
 *
 * #### Example:
 *
 *     // `arr` is an array of numbers.
 *     new Schema({ arr: [Number] });
 *     // Equivalent way to define `arr` as an array of numbers
 *     new Schema({ arr: { type: Array, of: Number } });
 *
 * @api public
 * @property of
 * @memberOf SchemaArrayOptions
 * @type {Function|String}
 * @instance
 */ Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
/**
 * If set to `false`, will always deactivate casting non-array values to arrays.
 * If set to `true`, will cast non-array values to arrays if `init` and `SchemaArray.options.castNonArrays` are also `true`
 *
 * #### Example:
 *
 *     const Model = db.model('Test', new Schema({ x1: { castNonArrays: false, type: [String] } }));
 *     const doc = new Model({ x1: "some non-array value" });
 *     await doc.validate(); // Errors with "CastError"
 *
 * @api public
 * @property castNonArrays
 * @memberOf SchemaArrayOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(SchemaArrayOptions.prototype, "castNonArrays", opts);
/*!
 * ignore
 */ module.exports = SchemaArrayOptions;


/***/ }),

/***/ 69667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on a Buffer schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ bitmap: Buffer });
 *     schema.path('bitmap').options; // SchemaBufferOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaBufferOptions
 */ class SchemaBufferOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * Set the default subtype for this buffer.
 *
 * @api public
 * @property subtype
 * @memberOf SchemaBufferOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
/*!
 * ignore
 */ module.exports = SchemaBufferOptions;


/***/ }),

/***/ 8628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on a Date schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ startedAt: Date });
 *     schema.path('startedAt').options; // SchemaDateOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaDateOptions
 */ class SchemaDateOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If set, Mongoose adds a validator that checks that this path is after the
 * given `min`.
 *
 * @api public
 * @property min
 * @memberOf SchemaDateOptions
 * @type {Date}
 * @instance
 */ Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
/**
 * If set, Mongoose adds a validator that checks that this path is before the
 * given `max`.
 *
 * @api public
 * @property max
 * @memberOf SchemaDateOptions
 * @type {Date}
 * @instance
 */ Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
/**
 * If set, Mongoose creates a TTL index on this path.
 *
 * mongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.
 *
 * #### Example:
 *
 *     const schema = new Schema({ "expireAt": { type: Date,  expires: 11 } });
 *     // if 'expireAt' is set, then document expires at expireAt + 11 seconds
 *
 * @api public
 * @property expires
 * @memberOf SchemaDateOptions
 * @type {Date}
 * @instance
 */ Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
/*!
 * ignore
 */ module.exports = SchemaDateOptions;


/***/ }),

/***/ 50857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on an Document Array schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ users: [{ name: string }] });
 *     schema.path('users').options; // SchemaDocumentArrayOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaDocumentOptions
 */ class SchemaDocumentArrayOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If `true`, Mongoose will skip building any indexes defined in this array's schema.
 * If not set, Mongoose will build all indexes defined in this array's schema.
 *
 * #### Example:
 *
 *     const childSchema = Schema({ name: { type: String, index: true } });
 *     // If `excludeIndexes` is `true`, Mongoose will skip building an index
 *     // on `arr.name`. Otherwise, Mongoose will build an index on `arr.name`.
 *     const parentSchema = Schema({
 *       arr: { type: [childSchema], excludeIndexes: true }
 *     });
 *
 * @api public
 * @property excludeIndexes
 * @memberOf SchemaDocumentArrayOptions
 * @type {Array}
 * @instance
 */ Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
/**
 * If set, overwrites the child schema's `_id` option.
 *
 * #### Example:
 *
 *     const childSchema = Schema({ name: String });
 *     const parentSchema = Schema({
 *       child: { type: childSchema, _id: false }
 *     });
 *     parentSchema.path('child').schema.options._id; // false
 *
 * @api public
 * @property _id
 * @memberOf SchemaDocumentArrayOptions
 * @type {Array}
 * @instance
 */ Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
/*!
 * ignore
 */ module.exports = SchemaDocumentArrayOptions;


/***/ }),

/***/ 53945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on a Map schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });
 *     schema.path('socialMediaHandles').options; // SchemaMapOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaMapOptions
 */ class SchemaMapOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If set, specifies the type of this map's values. Mongoose will cast
 * this map's values to the given type.
 *
 * If not set, Mongoose will not cast the map's values.
 *
 * #### Example:
 *
 *     // Mongoose will cast `socialMediaHandles` values to strings
 *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });
 *     schema.path('socialMediaHandles').options.of; // String
 *
 * @api public
 * @property of
 * @memberOf SchemaMapOptions
 * @type {Function|string}
 * @instance
 */ Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
module.exports = SchemaMapOptions;


/***/ }),

/***/ 93610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on a Number schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ count: Number });
 *     schema.path('count').options; // SchemaNumberOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaNumberOptions
 */ class SchemaNumberOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If set, Mongoose adds a validator that checks that this path is at least the
 * given `min`.
 *
 * @api public
 * @property min
 * @memberOf SchemaNumberOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
/**
 * If set, Mongoose adds a validator that checks that this path is less than the
 * given `max`.
 *
 * @api public
 * @property max
 * @memberOf SchemaNumberOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
/**
 * If set, Mongoose adds a validator that checks that this path is strictly
 * equal to one of the given values.
 *
 * #### Example:
 *
 *     const schema = new Schema({
 *       favoritePrime: {
 *         type: Number,
 *         enum: [3, 5, 7]
 *       }
 *     });
 *     schema.path('favoritePrime').options.enum; // [3, 5, 7]
 *
 * @api public
 * @property enum
 * @memberOf SchemaNumberOptions
 * @type {Array}
 * @instance
 */ Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
/**
 * Sets default [populate options](/docs/populate.html#query-conditions).
 *
 * #### Example:
 *
 *     const schema = new Schema({
 *       child: {
 *         type: Number,
 *         ref: 'Child',
 *         populate: { select: 'name' }
 *       }
 *     });
 *     const Parent = mongoose.model('Parent', schema);
 *
 *     // Automatically adds `.select('name')`
 *     Parent.findOne().populate('child');
 *
 * @api public
 * @property populate
 * @memberOf SchemaNumberOptions
 * @type {Object}
 * @instance
 */ Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
/*!
 * ignore
 */ module.exports = SchemaNumberOptions;


/***/ }),

/***/ 96782:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on an ObjectId schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ testId: mongoose.ObjectId });
 *     schema.path('testId').options; // SchemaObjectIdOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaObjectIdOptions
 */ class SchemaObjectIdOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If truthy, uses Mongoose's default built-in ObjectId path.
 *
 * @api public
 * @property auto
 * @memberOf SchemaObjectIdOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
/**
 * Sets default [populate options](/docs/populate.html#query-conditions).
 *
 * #### Example:
 *
 *     const schema = new Schema({
 *       child: {
 *         type: 'ObjectId',
 *         ref: 'Child',
 *         populate: { select: 'name' }
 *       }
 *     });
 *     const Parent = mongoose.model('Parent', schema);
 *
 *     // Automatically adds `.select('name')`
 *     Parent.findOne().populate('child');
 *
 * @api public
 * @property populate
 * @memberOf SchemaObjectIdOptions
 * @type {Object}
 * @instance
 */ Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
/*!
 * ignore
 */ module.exports = SchemaObjectIdOptions;


/***/ }),

/***/ 50942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on a string schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String });
 *     schema.path('name').options; // SchemaStringOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaStringOptions
 */ class SchemaStringOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * Array of allowed values for this path
 *
 * @api public
 * @property enum
 * @memberOf SchemaStringOptions
 * @type {Array}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
/**
 * Attach a validator that succeeds if the data string matches the given regular
 * expression, and fails otherwise.
 *
 * @api public
 * @property match
 * @memberOf SchemaStringOptions
 * @type {RegExp}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
/**
 * If truthy, Mongoose will add a custom setter that lowercases this string
 * using JavaScript's built-in `String#toLowerCase()`.
 *
 * @api public
 * @property lowercase
 * @memberOf SchemaStringOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
/**
 * If truthy, Mongoose will add a custom setter that removes leading and trailing
 * whitespace using [JavaScript's built-in `String#trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string).
 *
 * @api public
 * @property trim
 * @memberOf SchemaStringOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
/**
 * If truthy, Mongoose will add a custom setter that uppercases this string
 * using JavaScript's built-in [`String#toUpperCase()`](https://masteringjs.io/tutorials/fundamentals/uppercase).
 *
 * @api public
 * @property uppercase
 * @memberOf SchemaStringOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
/**
 * If set, Mongoose will add a custom validator that ensures the given
 * string's `length` is at least the given number.
 *
 * Mongoose supports two different spellings for this option: `minLength` and `minlength`.
 * `minLength` is the recommended way to specify this option, but Mongoose also supports
 * `minlength` (lowercase "l").
 *
 * @api public
 * @property minLength
 * @memberOf SchemaStringOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
/**
 * If set, Mongoose will add a custom validator that ensures the given
 * string's `length` is at most the given number.
 *
 * Mongoose supports two different spellings for this option: `maxLength` and `maxlength`.
 * `maxLength` is the recommended way to specify this option, but Mongoose also supports
 * `maxlength` (lowercase "l").
 *
 * @api public
 * @property maxLength
 * @memberOf SchemaStringOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
/**
 * Sets default [populate options](/docs/populate.html#query-conditions).
 *
 * @api public
 * @property populate
 * @memberOf SchemaStringOptions
 * @type {Object}
 * @instance
 */ Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
/*!
 * ignore
 */ module.exports = SchemaStringOptions;


/***/ }),

/***/ 27254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SchemaTypeOptions = __webpack_require__(84252);
/**
 * The options defined on a single nested schematype.
 *
 * #### Example:
 *
 *     const schema = Schema({ child: Schema({ name: String }) });
 *     schema.path('child').options; // SchemaSubdocumentOptions instance
 *
 * @api public
 * @inherits SchemaTypeOptions
 * @constructor SchemaSubdocumentOptions
 */ class SchemaSubdocumentOptions extends SchemaTypeOptions {
}
const opts = __webpack_require__(16564);
/**
 * If set, overwrites the child schema's `_id` option.
 *
 * #### Example:
 *
 *     const childSchema = Schema({ name: String });
 *     const parentSchema = Schema({
 *       child: { type: childSchema, _id: false }
 *     });
 *     parentSchema.path('child').schema.options._id; // false
 *
 * @api public
 * @property of
 * @memberOf SchemaSubdocumentOptions
 * @type {Function|string}
 * @instance
 */ Object.defineProperty(SchemaSubdocumentOptions.prototype, "_id", opts);
module.exports = SchemaSubdocumentOptions;


/***/ }),

/***/ 84252:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const clone = __webpack_require__(99889);
/**
 * The options defined on a schematype.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String });
 *     schema.path('name').options instanceof mongoose.SchemaTypeOptions; // true
 *
 * @api public
 * @constructor SchemaTypeOptions
 */ class SchemaTypeOptions {
    constructor(obj){
        if (obj == null) {
            return this;
        }
        Object.assign(this, clone(obj));
    }
}
const opts = __webpack_require__(16564);
/**
 * The type to cast this path to.
 *
 * @api public
 * @property type
 * @memberOf SchemaTypeOptions
 * @type {Function|String|Object}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
/**
 * Function or object describing how to validate this schematype.
 *
 * @api public
 * @property validate
 * @memberOf SchemaTypeOptions
 * @type {Function|Object}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
/**
 * Allows overriding casting logic for this individual path. If a string, the
 * given string overwrites Mongoose's default cast error message.
 *
 * #### Example:
 *
 *     const schema = new Schema({
 *       num: {
 *         type: Number,
 *         cast: '{VALUE} is not a valid number'
 *       }
 *     });
 *
 *     // Throws 'CastError: "bad" is not a valid number'
 *     schema.path('num').cast('bad');
 *
 *     const Model = mongoose.model('Test', schema);
 *     const doc = new Model({ num: 'fail' });
 *     const err = doc.validateSync();
 *
 *     err.errors['num']; // 'CastError: "fail" is not a valid number'
 *
 * @api public
 * @property cast
 * @memberOf SchemaTypeOptions
 * @type {String}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
/**
 * If true, attach a required validator to this path, which ensures this path
 * cannot be set to a nullish value. If a function, Mongoose calls the
 * function and only checks for nullish values if the function returns a truthy value.
 *
 * @api public
 * @property required
 * @memberOf SchemaTypeOptions
 * @type {Function|Boolean}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
/**
 * The default value for this path. If a function, Mongoose executes the function
 * and uses the return value as the default.
 *
 * @api public
 * @property default
 * @memberOf SchemaTypeOptions
 * @type {Function|Any}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
/**
 * The model that `populate()` should use if populating this path.
 *
 * @api public
 * @property ref
 * @memberOf SchemaTypeOptions
 * @type {Function|String}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
/**
 * The path in the document that `populate()` should use to find the model
 * to use.
 *
 * @api public
 * @property ref
 * @memberOf SchemaTypeOptions
 * @type {Function|String}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "refPath", opts);
/**
 * Whether to include or exclude this path by default when loading documents
 * using `find()`, `findOne()`, etc.
 *
 * @api public
 * @property select
 * @memberOf SchemaTypeOptions
 * @type {Boolean|Number}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
/**
 * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will
 * build an index on this path when the model is compiled.
 *
 * @api public
 * @property index
 * @memberOf SchemaTypeOptions
 * @type {Boolean|Number|Object}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
/**
 * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose
 * will build a unique index on this path when the
 * model is compiled. [The `unique` option is **not** a validator](/docs/validation.html#the-unique-option-is-not-a-validator).
 *
 * @api public
 * @property unique
 * @memberOf SchemaTypeOptions
 * @type {Boolean|Number}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
/**
 * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will
 * disallow changes to this path once the document
 * is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).
 *
 * @api public
 * @property immutable
 * @memberOf SchemaTypeOptions
 * @type {Function|Boolean}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
/**
 * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will
 * build a sparse index on this path.
 *
 * @api public
 * @property sparse
 * @memberOf SchemaTypeOptions
 * @type {Boolean|Number}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
/**
 * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose
 * will build a text index on this path.
 *
 * @api public
 * @property text
 * @memberOf SchemaTypeOptions
 * @type {Boolean|Number|Object}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
/**
 * Define a transform function for this individual schema type.
 * Only called when calling `toJSON()` or `toObject()`.
 *
 * #### Example:
 *
 *     const schema = Schema({
 *       myDate: {
 *         type: Date,
 *         transform: v => v.getFullYear()
 *       }
 *     });
 *     const Model = mongoose.model('Test', schema);
 *
 *     const doc = new Model({ myDate: new Date('2019/06/01') });
 *     doc.myDate instanceof Date; // true
 *
 *     const res = doc.toObject({ transform: true });
 *     res.myDate; // 2019
 *
 * @api public
 * @property transform
 * @memberOf SchemaTypeOptions
 * @type {Function}
 * @instance
 */ Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
module.exports = SchemaTypeOptions;


/***/ }),

/***/ 87526:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const opts = __webpack_require__(16564);
class VirtualOptions {
    constructor(obj){
        Object.assign(this, obj);
        if (obj != null && obj.options != null) {
            this.options = Object.assign({}, obj.options);
        }
    }
}
/**
 * Marks this virtual as a populate virtual, and specifies the model to
 * use for populate.
 *
 * @api public
 * @property ref
 * @memberOf VirtualOptions
 * @type {String|Model|Function}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "ref", opts);
/**
 * Marks this virtual as a populate virtual, and specifies the path that
 * contains the name of the model to populate
 *
 * @api public
 * @property refPath
 * @memberOf VirtualOptions
 * @type {String|Function}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
/**
 * The name of the property in the local model to match to `foreignField`
 * in the foreign model.
 *
 * @api public
 * @property localField
 * @memberOf VirtualOptions
 * @type {String|Function}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "localField", opts);
/**
 * The name of the property in the foreign model to match to `localField`
 * in the local model.
 *
 * @api public
 * @property foreignField
 * @memberOf VirtualOptions
 * @type {String|Function}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
/**
 * Whether to populate this virtual as a single document (true) or an
 * array of documents (false).
 *
 * @api public
 * @property justOne
 * @memberOf VirtualOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
/**
 * If true, populate just the number of documents where `localField`
 * matches `foreignField`, as opposed to the documents themselves.
 *
 * If `count` is set, it overrides `justOne`.
 *
 * @api public
 * @property count
 * @memberOf VirtualOptions
 * @type {Boolean}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "count", opts);
/**
 * Add an additional filter to populate, in addition to `localField`
 * matches `foreignField`.
 *
 * @api public
 * @property match
 * @memberOf VirtualOptions
 * @type {Object|Function}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "match", opts);
/**
 * Additional options to pass to the query used to `populate()`:
 *
 * - `sort`
 * - `skip`
 * - `limit`
 *
 * @api public
 * @property options
 * @memberOf VirtualOptions
 * @type {Object}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "options", opts);
/**
 * If true, add a `skip` to the query used to `populate()`.
 *
 * @api public
 * @property skip
 * @memberOf VirtualOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "skip", opts);
/**
 * If true, add a `limit` to the query used to `populate()`.
 *
 * @api public
 * @property limit
 * @memberOf VirtualOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "limit", opts);
/**
 * The `limit` option for `populate()` has [some unfortunate edge cases](/docs/populate.html#query-conditions)
 * when working with multiple documents, like `.find().populate()`. The
 * `perDocumentLimit` option makes `populate()` execute a separate query
 * for each document returned from `find()` to ensure each document
 * gets up to `perDocumentLimit` populated docs if possible.
 *
 * @api public
 * @property perDocumentLimit
 * @memberOf VirtualOptions
 * @type {Number}
 * @instance
 */ Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
module.exports = VirtualOptions;


/***/ }),

/***/ 16564:
/***/ ((module) => {

"use strict";

module.exports = Object.freeze({
    enumerable: true,
    configurable: true,
    writable: true,
    value: void 0
});


/***/ }),

/***/ 51483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const clone = __webpack_require__(99889);
class RemoveOptions {
    constructor(obj){
        if (obj == null) {
            return;
        }
        Object.assign(this, clone(obj));
    }
}
module.exports = RemoveOptions;


/***/ }),

/***/ 22277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const clone = __webpack_require__(99889);
class SaveOptions {
    constructor(obj){
        if (obj == null) {
            return;
        }
        Object.assign(this, clone(obj));
    }
}
module.exports = SaveOptions;


/***/ }),

/***/ 51276:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.removeSubdocs = __webpack_require__(48217);
exports.saveSubdocs = __webpack_require__(65825);
exports.sharding = __webpack_require__(60576);
exports.trackTransaction = __webpack_require__(52444);
exports.validateBeforeSave = __webpack_require__(92607);


/***/ }),

/***/ 48217:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const each = __webpack_require__(60233);
/*!
 * ignore
 */ module.exports = function removeSubdocs(schema) {
    const unshift = true;
    schema.s.hooks.pre("remove", false, function removeSubDocsPreRemove(next) {
        if (this.$isSubdocument) {
            next();
            return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        each(subdocs, function(subdoc, cb) {
            subdoc.$__remove(cb);
        }, function(error) {
            if (error) {
                return _this.$__schema.s.hooks.execPost("remove:error", _this, [
                    _this
                ], {
                    error: error
                }, function(error) {
                    next(error);
                });
            }
            next();
        });
    }, null, unshift);
};


/***/ }),

/***/ 65825:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const each = __webpack_require__(60233);
/*!
 * ignore
 */ module.exports = function saveSubdocs(schema) {
    const unshift = true;
    schema.s.hooks.pre("save", false, function saveSubdocsPreSave(next) {
        if (this.$isSubdocument) {
            next();
            return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
            next();
            return;
        }
        each(subdocs, function(subdoc, cb) {
            subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
                cb(err);
            });
        }, function(error) {
            if (error) {
                return _this.$__schema.s.hooks.execPost("save:error", _this, [
                    _this
                ], {
                    error: error
                }, function(error) {
                    next(error);
                });
            }
            next();
        });
    }, null, unshift);
    schema.s.hooks.post("save", function saveSubdocsPostSave(doc, next) {
        if (this.$isSubdocument) {
            next();
            return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
            next();
            return;
        }
        each(subdocs, function(subdoc, cb) {
            subdoc.$__schema.s.hooks.execPost("save", subdoc, [
                subdoc
            ], function(err) {
                cb(err);
            });
        }, function(error) {
            if (error) {
                return _this.$__schema.s.hooks.execPost("save:error", _this, [
                    _this
                ], {
                    error: error
                }, function(error) {
                    next(error);
                });
            }
            next();
        });
    }, null, unshift);
};


/***/ }),

/***/ 60576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const objectIdSymbol = (__webpack_require__(5089).objectIdSymbol);
const utils = __webpack_require__(52100);
/*!
 * ignore
 */ module.exports = function shardingPlugin(schema) {
    schema.post("init", function shardingPluginPostInit() {
        storeShard.call(this);
        return this;
    });
    schema.pre("save", function shardingPluginPreSave(next) {
        applyWhere.call(this);
        next();
    });
    schema.pre("remove", function shardingPluginPreRemove(next) {
        applyWhere.call(this);
        next();
    });
    schema.post("save", function shardingPluginPostSave() {
        storeShard.call(this);
    });
};
/*!
 * ignore
 */ function applyWhere() {
    let paths;
    let len;
    if (this.$__.shardval) {
        paths = Object.keys(this.$__.shardval);
        len = paths.length;
        this.$where = this.$where || {};
        for(let i = 0; i < len; ++i){
            this.$where[paths[i]] = this.$__.shardval[paths[i]];
        }
    }
}
/*!
 * ignore
 */ module.exports.storeShard = storeShard;
/*!
 * ignore
 */ function storeShard() {
    // backwards compat
    const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
    if (!utils.isPOJO(key)) {
        return;
    }
    const orig = this.$__.shardval = {};
    const paths = Object.keys(key);
    const len = paths.length;
    let val;
    for(let i = 0; i < len; ++i){
        val = this.$__getValue(paths[i]);
        if (val == null) {
            orig[paths[i]] = val;
        } else if (utils.isMongooseObject(val)) {
            orig[paths[i]] = val.toObject({
                depopulate: true,
                _isNested: true
            });
        } else if (val instanceof Date || val[objectIdSymbol]) {
            orig[paths[i]] = val;
        } else if (typeof val.valueOf === "function") {
            orig[paths[i]] = val.valueOf();
        } else {
            orig[paths[i]] = val;
        }
    }
}


/***/ }),

/***/ 52444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const sessionNewDocuments = (__webpack_require__(5089).sessionNewDocuments);
const utils = __webpack_require__(52100);
module.exports = function trackTransaction(schema) {
    schema.pre("save", function trackTransactionPreSave() {
        const session = this.$session();
        if (session == null) {
            return;
        }
        if (session.transaction == null || session[sessionNewDocuments] == null) {
            return;
        }
        if (!session[sessionNewDocuments].has(this)) {
            const initialState = {};
            if (this.isNew) {
                initialState.isNew = true;
            }
            if (this.$__schema.options.versionKey) {
                initialState.versionKey = this.get(this.$__schema.options.versionKey);
            }
            initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify")));
            initialState.atomics = _getAtomics(this);
            session[sessionNewDocuments].set(this, initialState);
        } else {
            const state = session[sessionNewDocuments].get(this);
            for (const path of Object.keys(this.$__.activePaths.getStatePaths("modify"))){
                state.modifiedPaths.add(path);
            }
            state.atomics = _getAtomics(this, state.atomics);
        }
    });
};
function _getAtomics(doc, previous) {
    const pathToAtomics = new Map();
    previous = previous || new Map();
    const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
    for (const path of pathsToCheck){
        const val = doc.$__getValue(path);
        if (val != null && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
            const existing = previous.get(path) || {};
            pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
    }
    const dirty = doc.$__dirty();
    for (const dirt of dirty){
        const path = dirt.path;
        const val = dirt.value;
        if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
            const existing = previous.get(path) || {};
            pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
    }
    return pathToAtomics;
}
function mergeAtomics(destination, source) {
    destination = destination || {};
    if (source.$pullAll != null) {
        destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
    }
    if (source.$push != null) {
        destination.$push = destination.$push || {};
        destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
    }
    if (source.$addToSet != null) {
        destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
    }
    if (source.$set != null) {
        destination.$set = Object.assign(destination.$set || {}, source.$set);
    }
    return destination;
}


/***/ }),

/***/ 92607:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function validateBeforeSave(schema) {
    const unshift = true;
    schema.pre("save", false, function validateBeforeSave(next, options) {
        const _this = this;
        // Nested docs have their own presave
        if (this.$isSubdocument) {
            return next();
        }
        const hasValidateBeforeSaveOption = options && typeof options === "object" && "validateBeforeSave" in options;
        let shouldValidate;
        if (hasValidateBeforeSaveOption) {
            shouldValidate = !!options.validateBeforeSave;
        } else {
            shouldValidate = this.$__schema.options.validateBeforeSave;
        }
        // Validate
        if (shouldValidate) {
            const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
            const validateOptions = hasValidateModifiedOnlyOption ? {
                validateModifiedOnly: options.validateModifiedOnly
            } : null;
            this.$validate(validateOptions, function(error) {
                return _this.$__schema.s.hooks.execPost("save:error", _this, [
                    _this
                ], {
                    error: error
                }, function(error) {
                    _this.$op = "save";
                    next(error);
                });
            });
        } else {
            next();
        }
    }, null, unshift);
};


/***/ }),

/***/ 46433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * ignore
 */ 
const assert = __webpack_require__(39491);
const mquery = __webpack_require__(66908);
/**
 * Helper for multiplexing promise implementations
 *
 * @api private
 */ const store = {
    _promise: null
};
/**
 * Get the current promise constructor
 *
 * @api private
 */ store.get = function() {
    return store._promise;
};
/**
 * Set the current promise constructor
 *
 * @api private
 */ store.set = function(lib) {
    assert.ok(typeof lib === "function", `mongoose.Promise must be a function, got ${lib}`);
    store._promise = lib;
    mquery.Promise = lib;
};
/*!
 * Use native promises by default
 */ store.set(global.Promise);
module.exports = store;


/***/ }),

/***/ 42921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const CastError = __webpack_require__(96996);
const DocumentNotFoundError = __webpack_require__(8671);
const Kareem = __webpack_require__(9840);
const MongooseError = __webpack_require__(51520);
const ObjectParameterError = __webpack_require__(96255);
const QueryCursor = __webpack_require__(93992);
const ReadPreference = (__webpack_require__(67085).get)().ReadPreference;
const ValidationError = __webpack_require__(13837);
const { applyGlobalMaxTimeMS , applyGlobalDiskUse  } = __webpack_require__(73111);
const applyWriteConcern = __webpack_require__(75103);
const cast = __webpack_require__(54749);
const castArrayFilters = __webpack_require__(78545);
const castNumber = __webpack_require__(71155);
const castUpdate = __webpack_require__(54795);
const completeMany = __webpack_require__(58347);
const promiseOrCallback = __webpack_require__(83593);
const getDiscriminatorByValue = __webpack_require__(17492);
const hasDollarKeys = __webpack_require__(11029);
const helpers = __webpack_require__(83524);
const immediate = __webpack_require__(96621);
const isExclusive = __webpack_require__(12374);
const isInclusive = __webpack_require__(34423);
const isSubpath = __webpack_require__(32381);
const mpath = __webpack_require__(52988);
const mquery = __webpack_require__(66908);
const parseProjection = __webpack_require__(77034);
const removeUnusedArrayFilters = __webpack_require__(54696);
const sanitizeFilter = __webpack_require__(66501);
const sanitizeProjection = __webpack_require__(58063);
const selectPopulatedFields = __webpack_require__(63795);
const setDefaultsOnInsert = __webpack_require__(55426);
const updateValidators = __webpack_require__(72413);
const util = __webpack_require__(73837);
const utils = __webpack_require__(52100);
const validOps = __webpack_require__(19928);
const wrapThunk = __webpack_require__(10712);
const queryOptionMethods = new Set([
    "allowDiskUse",
    "batchSize",
    "collation",
    "comment",
    "explain",
    "hint",
    "j",
    "lean",
    "limit",
    "maxScan",
    "maxTimeMS",
    "maxscan",
    "populate",
    "projection",
    "read",
    "select",
    "skip",
    "slice",
    "sort",
    "tailable",
    "w",
    "writeConcern",
    "wtimeout"
]);
/**
 * Query constructor used for building queries. You do not need
 * to instantiate a `Query` directly. Instead use Model functions like
 * [`Model.find()`](/docs/api/find.html#find_find).
 *
 * #### Example:
 *
 *     const query = MyModel.find(); // `query` is an instance of `Query`
 *     query.setOptions({ lean : true });
 *     query.collection(MyModel.collection);
 *     query.where('age').gte(21).exec(callback);
 *
 *     // You can instantiate a query directly. There is no need to do
 *     // this unless you're an advanced user with a very good reason to.
 *     const query = new mongoose.Query();
 *
 * @param {Object} [options]
 * @param {Object} [model]
 * @param {Object} [conditions]
 * @param {Object} [collection] Mongoose collection
 * @api public
 */ function Query(conditions, options, model, collection) {
    // this stuff is for dealing with custom queries created by #toConstructor
    if (!this._mongooseOptions) {
        this._mongooseOptions = {};
    }
    options = options || {};
    this._transforms = [];
    this._hooks = new Kareem();
    this._executionStack = null;
    // this is the case where we have a CustomQuery, we need to check if we got
    // options passed in, and if we did, merge them in
    const keys = Object.keys(options);
    for (const key of keys){
        this._mongooseOptions[key] = options[key];
    }
    if (collection) {
        this.mongooseCollection = collection;
    }
    if (model) {
        this.model = model;
        this.schema = model.schema;
    }
    // this is needed because map reduce returns a model that can be queried, but
    // all of the queries on said model should be lean
    if (this.model && this.model._mapreduce) {
        this.lean();
    }
    // inherit mquery
    mquery.call(this, null, options);
    if (collection) {
        this.collection(collection);
    }
    if (conditions) {
        this.find(conditions);
    }
    this.options = this.options || {};
    // For gh-6880. mquery still needs to support `fields` by default for old
    // versions of MongoDB
    this.$useProjection = true;
    const collation = this && this.schema && this.schema.options && this.schema.options.collation || null;
    if (collation != null) {
        this.options.collation = collation;
    }
}
/*!
 * inherit mquery
 */ Query.prototype = new mquery();
Query.prototype.constructor = Query;
Query.base = mquery.prototype;
/**
 * Flag to opt out of using `$geoWithin`.
 *
 * ```javascript
 * mongoose.Query.use$geoWithin = false;
 * ```
 *
 * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.
 *
 * @see geoWithin https://docs.mongodb.org/manual/reference/operator/geoWithin/
 * @default true
 * @property use$geoWithin
 * @memberOf Query
 * @static
 * @api public
 */ Query.use$geoWithin = mquery.use$geoWithin;
/**
 * Converts this query to a customized, reusable query constructor with all arguments and options retained.
 *
 * #### Example:
 *
 *     // Create a query for adventure movies and read from the primary
 *     // node in the replica-set unless it is down, in which case we'll
 *     // read from a secondary node.
 *     const query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');
 *
 *     // create a custom Query constructor based off these settings
 *     const Adventure = query.toConstructor();
 *
 *     // Adventure is now a subclass of mongoose.Query and works the same way but with the
 *     // default query parameters and options set.
 *     Adventure().exec(callback)
 *
 *     // further narrow down our query results while still using the previous settings
 *     Adventure().where({ name: /^Life/ }).exec(callback);
 *
 *     // since Adventure is a stand-alone constructor we can also add our own
 *     // helper methods and getters without impacting global queries
 *     Adventure.prototype.startsWith = function (prefix) {
 *       this.where({ name: new RegExp('^' + prefix) })
 *       return this;
 *     }
 *     Object.defineProperty(Adventure.prototype, 'highlyRated', {
 *       get: function () {
 *         this.where({ rating: { $gt: 4.5 }});
 *         return this;
 *       }
 *     })
 *     Adventure().highlyRated.startsWith('Life').exec(callback)
 *
 * @return {Query} subclass-of-Query
 * @api public
 */ Query.prototype.toConstructor = function toConstructor() {
    const model = this.model;
    const coll = this.mongooseCollection;
    const CustomQuery = function(criteria, options) {
        if (!(this instanceof CustomQuery)) {
            return new CustomQuery(criteria, options);
        }
        this._mongooseOptions = utils.clone(p._mongooseOptions);
        Query.call(this, criteria, options || null, model, coll);
    };
    util.inherits(CustomQuery, model.Query);
    // set inherited defaults
    const p = CustomQuery.prototype;
    p.options = {};
    // Need to handle `sort()` separately because entries-style `sort()` syntax
    // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.
    // See gh-8159
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
        p.sort(options.sort);
        delete options.sort;
    }
    p.setOptions(options);
    p.op = this.op;
    p._validateOp();
    p._conditions = utils.clone(this._conditions);
    p._fields = utils.clone(this._fields);
    p._update = utils.clone(this._update, {
        flattenDecimals: false
    });
    p._path = this._path;
    p._distinct = this._distinct;
    p._collection = this._collection;
    p._mongooseOptions = this._mongooseOptions;
    return CustomQuery;
};
/**
 * Make a copy of this query so you can re-execute it.
 *
 * #### Example:
 *
 *     const q = Book.findOne({ title: 'Casino Royale' });
 *     await q.exec();
 *     await q.exec(); // Throws an error because you can't execute a query twice
 *
 *     await q.clone().exec(); // Works
 *
 * @method clone
 * @return {Query} copy
 * @memberOf Query
 * @instance
 * @api public
 */ Query.prototype.clone = function clone() {
    const model = this.model;
    const collection = this.mongooseCollection;
    const q = new this.model.Query({}, {}, model, collection);
    // Need to handle `sort()` separately because entries-style `sort()` syntax
    // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.
    // See gh-8159
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
        q.sort(options.sort);
        delete options.sort;
    }
    q.setOptions(options);
    q.op = this.op;
    q._validateOp();
    q._conditions = utils.clone(this._conditions);
    q._fields = utils.clone(this._fields);
    q._update = utils.clone(this._update, {
        flattenDecimals: false
    });
    q._path = this._path;
    q._distinct = this._distinct;
    q._collection = this._collection;
    q._mongooseOptions = this._mongooseOptions;
    return q;
};
/**
 * Specifies a javascript function or expression to pass to MongoDBs query system.
 *
 * #### Example:
 *
 *     query.$where('this.comments.length === 10 || this.name.length === 5')
 *
 *     // or
 *
 *     query.$where(function () {
 *       return this.comments.length === 10 || this.name.length === 5;
 *     })
 *
 * #### Note:
 *
 * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.
 * **Be sure to read about all of [its caveats](https://docs.mongodb.org/manual/reference/operator/where/) before using.**
 *
 * @see $where https://docs.mongodb.org/manual/reference/operator/where/
 * @method $where
 * @param {String|Function} js javascript string or function
 * @return {Query} this
 * @memberOf Query
 * @instance
 * @method $where
 * @api public
 */ /**
 * Specifies a `path` for use with chaining.
 *
 * #### Example:
 *
 *     // instead of writing:
 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
 *
 *     // we can instead write:
 *     User.where('age').gte(21).lte(65);
 *
 *     // passing query conditions is permitted
 *     User.find().where({ name: 'vonderful' })
 *
 *     // chaining
 *     User
 *     .where('age').gte(21).lte(65)
 *     .where('name', /^vonderful/i)
 *     .where('friends').slice(10)
 *     .exec(callback)
 *
 * @method where
 * @memberOf Query
 * @instance
 * @param {String|Object} [path]
 * @param {any} [val]
 * @return {Query} this
 * @api public
 */ /**
 * Specifies a `$slice` projection for an array.
 *
 * #### Example:
 *
 *     query.slice('comments', 5); // Returns the first 5 comments
 *     query.slice('comments', -5); // Returns the last 5 comments
 *     query.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th
 *     query.where('comments').slice(5); // Returns the first 5 comments
 *     query.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last
 *
 * **Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.
 *
 *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *      query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *      query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *
 * **Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.
 *
 *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *      query.slice('arr', [20, 5]); // Returns []
 *
 * **Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.
 *
 *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *      query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]
 *
 * @method slice
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number|Array} val number of elements to slice or array with number of elements to skip and number of elements to slice
 * @return {Query} this
 * @see mongodb https://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
 * @see $slice https://docs.mongodb.org/manual/reference/projection/slice/#prj._S_slice
 * @api public
 */ Query.prototype.slice = function() {
    if (arguments.length === 0) {
        return this;
    }
    this._validate("slice");
    let path;
    let val;
    if (arguments.length === 1) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
            const keys = Object.keys(arg);
            const numKeys = keys.length;
            for(let i = 0; i < numKeys; ++i){
                this.slice(keys[i], arg[keys[i]]);
            }
            return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
    } else if (arguments.length === 2) {
        if ("number" === typeof arguments[0]) {
            this._ensurePath("slice");
            path = this._path;
            val = [
                arguments[0],
                arguments[1]
            ];
        } else {
            path = arguments[0];
            val = arguments[1];
        }
    } else if (arguments.length === 3) {
        path = arguments[0];
        val = [
            arguments[1],
            arguments[2]
        ];
    }
    const p = {};
    p[path] = {
        $slice: val
    };
    this.select(p);
    return this;
};
/*!
 * ignore
 */ const validOpsSet = new Set(validOps);
Query.prototype._validateOp = function() {
    if (this.op != null && !validOpsSet.has(this.op)) {
        this.error(new Error('Query has invalid `op`: "' + this.op + '"'));
    }
};
/**
 * Specifies the complementary comparison value for paths specified with `where()`
 *
 * #### Example:
 *
 *     User.where('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @method equals
 * @memberOf Query
 * @instance
 * @param {Object} val
 * @return {Query} this
 * @api public
 */ /**
 * Specifies arguments for an `$or` condition.
 *
 * #### Example:
 *
 *     query.or([{ color: 'red' }, { status: 'emergency' }]);
 *
 * @see $or https://docs.mongodb.org/manual/reference/operator/or/
 * @method or
 * @memberOf Query
 * @instance
 * @param {Array} array array of conditions
 * @return {Query} this
 * @api public
 */ /**
 * Specifies arguments for a `$nor` condition.
 *
 * #### Example:
 *
 *     query.nor([{ color: 'green' }, { status: 'ok' }]);
 *
 * @see $nor https://docs.mongodb.org/manual/reference/operator/nor/
 * @method nor
 * @memberOf Query
 * @instance
 * @param {Array} array array of conditions
 * @return {Query} this
 * @api public
 */ /**
 * Specifies arguments for a `$and` condition.
 *
 * #### Example:
 *
 *     query.and([{ color: 'green' }, { status: 'ok' }])
 *
 * @method and
 * @memberOf Query
 * @instance
 * @see $and https://docs.mongodb.org/manual/reference/operator/and/
 * @param {Array} array array of conditions
 * @return {Query} this
 * @api public
 */ /**
 * Specifies a `$gt` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * #### Example:
 *
 *     Thing.find().where('age').gt(21);
 *
 *     // or
 *     Thing.find().gt('age', 21);
 *
 * @method gt
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number} val
 * @see $gt https://docs.mongodb.org/manual/reference/operator/gt/
 * @api public
 */ /**
 * Specifies a `$gte` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method gte
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number} val
 * @see $gte https://docs.mongodb.org/manual/reference/operator/gte/
 * @api public
 */ /**
 * Specifies a `$lt` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lt
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number} val
 * @see $lt https://docs.mongodb.org/manual/reference/operator/lt/
 * @api public
 */ /**
 * Specifies a `$lte` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lte
 * @see $lte https://docs.mongodb.org/manual/reference/operator/lte/
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a `$ne` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @see $ne https://docs.mongodb.org/manual/reference/operator/ne/
 * @method ne
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {any} val
 * @api public
 */ /**
 * Specifies an `$in` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @see $in https://docs.mongodb.org/manual/reference/operator/in/
 * @method in
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Array} val
 * @api public
 */ /**
 * Specifies an `$nin` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @see $nin https://docs.mongodb.org/manual/reference/operator/nin/
 * @method nin
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Array} val
 * @api public
 */ /**
 * Specifies an `$all` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * #### Example:
 *
 *     MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);
 *     // Equivalent:
 *     MyModel.find().all('pets', ['dog', 'cat', 'ferret']);
 *
 * @see $all https://docs.mongodb.org/manual/reference/operator/all/
 * @method all
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Array} val
 * @api public
 */ /**
 * Specifies a `$size` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * #### Example:
 *
 *     const docs = await MyModel.where('tags').size(0).exec();
 *     assert(Array.isArray(docs));
 *     console.log('documents with 0 tags', docs);
 *
 * @see $size https://docs.mongodb.org/manual/reference/operator/size/
 * @method size
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a `$regex` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @see $regex https://docs.mongodb.org/manual/reference/operator/regex/
 * @method regex
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {String|RegExp} val
 * @api public
 */ /**
 * Specifies a `maxDistance` query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @see $maxDistance https://docs.mongodb.org/manual/reference/operator/maxDistance/
 * @method maxDistance
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a `$mod` condition, filters documents for documents whose
 * `path` property is a number that is equal to `remainder` modulo `divisor`.
 *
 * #### Example:
 *
 *     // All find products whose inventory is odd
 *     Product.find().mod('inventory', [2, 1]);
 *     Product.find().where('inventory').mod([2, 1]);
 *     // This syntax is a little strange, but supported.
 *     Product.find().where('inventory').mod(2, 1);
 *
 * @method mod
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Array} val must be of length 2, first element is `divisor`, 2nd element is `remainder`.
 * @return {Query} this
 * @see $mod https://docs.mongodb.org/manual/reference/operator/mod/
 * @api public
 */ Query.prototype.mod = function() {
    let val;
    let path;
    if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = [
            arguments[0],
            arguments[1]
        ];
        path = this._path;
    } else if (arguments.length === 3) {
        val = [
            arguments[1],
            arguments[2]
        ];
        path = arguments[0];
    } else {
        val = arguments[1];
        path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
};
/**
 * Specifies an `$exists` condition
 *
 * #### Example:
 *
 *     // { name: { $exists: true }}
 *     Thing.where('name').exists()
 *     Thing.where('name').exists(true)
 *     Thing.find().exists('name')
 *
 *     // { name: { $exists: false }}
 *     Thing.where('name').exists(false);
 *     Thing.find().exists('name', false);
 *
 * @method exists
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Boolean} val
 * @return {Query} this
 * @see $exists https://docs.mongodb.org/manual/reference/operator/exists/
 * @api public
 */ /**
 * Specifies an `$elemMatch` condition
 *
 * #### Example:
 *
 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
 *
 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
 *
 *     query.elemMatch('comment', function (elem) {
 *       elem.where('author').equals('autobot');
 *       elem.where('votes').gte(5);
 *     })
 *
 *     query.where('comment').elemMatch(function (elem) {
 *       elem.where({ author: 'autobot' });
 *       elem.where('votes').gte(5);
 *     })
 *
 * @method elemMatch
 * @memberOf Query
 * @instance
 * @param {String|Object|Function} path
 * @param {Object|Function} filter
 * @return {Query} this
 * @see $elemMatch https://docs.mongodb.org/manual/reference/operator/elemMatch/
 * @api public
 */ /**
 * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.
 *
 * #### Example:
 *
 *     query.where(path).within().box()
 *     query.where(path).within().circle()
 *     query.where(path).within().geometry()
 *
 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
 *     query.where('loc').within({ polygon: [[],[],[],[]] });
 *
 *     query.where('loc').within([], [], []) // polygon
 *     query.where('loc').within([], []) // box
 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
 *
 * **MUST** be used after `where()`.
 *
 * #### Note:
 *
 * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#query_Query-use%2524geoWithin).
 *
 * #### Note:
 *
 * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
 *
 * @method within
 * @see $polygon https://docs.mongodb.org/manual/reference/operator/polygon/
 * @see $box https://docs.mongodb.org/manual/reference/operator/box/
 * @see $geometry https://docs.mongodb.org/manual/reference/operator/geometry/
 * @see $center https://docs.mongodb.org/manual/reference/operator/center/
 * @see $centerSphere https://docs.mongodb.org/manual/reference/operator/centerSphere/
 * @memberOf Query
 * @instance
 * @return {Query} this
 * @api public
 */ /**
 * Specifies the maximum number of documents the query will return.
 *
 * #### Example:
 *
 *     query.limit(20);
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method limit
 * @memberOf Query
 * @instance
 * @param {Number} val
 * @api public
 */ Query.prototype.limit = function limit(v) {
    this._validate("limit");
    if (typeof v === "string") {
        try {
            v = castNumber(v);
        } catch (err) {
            throw new CastError("Number", v, "limit");
        }
    }
    this.options.limit = v;
    return this;
};
/**
 * Specifies the number of documents to skip.
 *
 * #### Example:
 *
 *     query.skip(100).limit(20);
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method skip
 * @memberOf Query
 * @instance
 * @param {Number} val
 * @see cursor.skip https://docs.mongodb.org/manual/reference/method/cursor.skip/
 * @api public
 */ Query.prototype.skip = function skip(v) {
    this._validate("skip");
    if (typeof v === "string") {
        try {
            v = castNumber(v);
        } catch (err) {
            throw new CastError("Number", v, "skip");
        }
    }
    this.options.skip = v;
    return this;
};
/**
 * Specifies the maxScan option.
 *
 * #### Example:
 *
 *     query.maxScan(100);
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method maxScan
 * @memberOf Query
 * @instance
 * @param {Number} val
 * @see maxScan https://docs.mongodb.org/manual/reference/operator/maxScan/
 * @api public
 */ /**
 * Specifies the batchSize option.
 *
 * #### Example:
 *
 *     query.batchSize(100)
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method batchSize
 * @memberOf Query
 * @instance
 * @param {Number} val
 * @see batchSize https://docs.mongodb.org/manual/reference/method/cursor.batchSize/
 * @api public
 */ /**
 * Specifies the `comment` option.
 *
 * #### Example:
 *
 *     query.comment('login query')
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method comment
 * @memberOf Query
 * @instance
 * @param {String} val
 * @see comment https://docs.mongodb.org/manual/reference/operator/comment/
 * @api public
 */ /**
 * Specifies this query as a `snapshot` query.
 *
 * #### Example:
 *
 *     query.snapshot(); // true
 *     query.snapshot(true);
 *     query.snapshot(false);
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method snapshot
 * @memberOf Query
 * @instance
 * @see snapshot https://docs.mongodb.org/manual/reference/operator/snapshot/
 * @return {Query} this
 * @api public
 */ /**
 * Sets query hints.
 *
 * #### Example:
 *
 *     query.hint({ indexA: 1, indexB: -1 });
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @method hint
 * @memberOf Query
 * @instance
 * @param {Object} val a hint object
 * @return {Query} this
 * @see $hint https://docs.mongodb.org/manual/reference/operator/hint/
 * @api public
 */ /**
 * Get/set the current projection (AKA fields). Pass `null` to remove the
 * current projection.
 *
 * Unlike `projection()`, the `select()` function modifies the current
 * projection in place. This function overwrites the existing projection.
 *
 * #### Example:
 *
 *     const q = Model.find();
 *     q.projection(); // null
 *
 *     q.select('a b');
 *     q.projection(); // { a: 1, b: 1 }
 *
 *     q.projection({ c: 1 });
 *     q.projection(); // { c: 1 }
 *
 *     q.projection(null);
 *     q.projection(); // null
 *
 *
 * @method projection
 * @memberOf Query
 * @instance
 * @param {Object|null} arg
 * @return {Object} the current projection
 * @api public
 */ Query.prototype.projection = function(arg) {
    if (arguments.length === 0) {
        return this._fields;
    }
    this._fields = {};
    this._userProvidedFields = {};
    this.select(arg);
    return this._fields;
};
/**
 * Specifies which document fields to include or exclude (also known as the query "projection")
 *
 * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api/schematype.html#schematype_SchemaType-select).
 *
 * A projection _must_ be either inclusive or exclusive. In other words, you must
 * either list the fields to include (which excludes all others), or list the fields
 * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/#suppress-id-field).
 *
 * #### Example:
 *
 *     // include a and b, exclude other fields
 *     query.select('a b');
 *     // Equivalent syntaxes:
 *     query.select(['a', 'b']);
 *     query.select({ a: 1, b: 1 });
 *
 *     // exclude c and d, include other fields
 *     query.select('-c -d');
 *
 *     // Use `+` to override schema-level `select: false` without making the
 *     // projection inclusive.
 *     const schema = new Schema({
 *       foo: { type: String, select: false },
 *       bar: String
 *     });
 *     // ...
 *     query.select('+foo'); // Override foo's `select: false` without excluding `bar`
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     query.select({ a: 1, b: 1 });
 *     query.select({ c: 0, d: 0 });
 *
 *     Additional calls to select can override the previous selection:
 *     query.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }
 *     query.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }
 *
 *
 * @method select
 * @memberOf Query
 * @instance
 * @param {Object|String|String[]} arg
 * @return {Query} this
 * @see SchemaType /docs/api/schematype
 * @api public
 */ Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg) return this;
    if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
    let sanitizeProjection = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
        sanitizeProjection = this.model.db.options.sanitizeProjection;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
        sanitizeProjection = this.model.base.options.sanitizeProjection;
    } else {
        sanitizeProjection = this._mongooseOptions.sanitizeProjection;
    }
    function sanitizeValue(value) {
        return typeof value === "string" && sanitizeProjection ? value = 1 : value;
    }
    arg = parseProjection(arg);
    if (utils.isObject(arg)) {
        if (this.selectedInclusively()) {
            Object.entries(arg).forEach(([key, value])=>{
                if (value) {
                    // Add the field to the projection
                    fields[key] = userProvidedFields[key] = sanitizeValue(value);
                } else {
                    // Remove the field from the projection
                    Object.keys(userProvidedFields).forEach((field)=>{
                        if (isSubpath(key, field)) {
                            delete fields[field];
                            delete userProvidedFields[field];
                        }
                    });
                }
            });
        } else if (this.selectedExclusively()) {
            Object.entries(arg).forEach(([key, value])=>{
                if (!value) {
                    // Add the field to the projection
                    fields[key] = userProvidedFields[key] = sanitizeValue(value);
                } else {
                    // Remove the field from the projection
                    Object.keys(userProvidedFields).forEach((field)=>{
                        if (isSubpath(key, field)) {
                            delete fields[field];
                            delete userProvidedFields[field];
                        }
                    });
                }
            });
        } else {
            const keys = Object.keys(arg);
            for(let i = 0; i < keys.length; ++i){
                const value = arg[keys[i]];
                fields[keys[i]] = sanitizeValue(value);
                userProvidedFields[keys[i]] = sanitizeValue(value);
            }
        }
        return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
};
/**
 * Determines the MongoDB nodes from which to read.
 *
 * #### Preferences:
 *
 * ```
 * primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
 * secondary            Read from secondary if available, otherwise error.
 * primaryPreferred     Read from primary if available, otherwise a secondary.
 * secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
 * nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
 * ```
 *
 * Aliases
 *
 * ```
 * p   primary
 * pp  primaryPreferred
 * s   secondary
 * sp  secondaryPreferred
 * n   nearest
 * ```
 *
 * #### Example:
 *
 *     new Query().read('primary')
 *     new Query().read('p')  // same as primary
 *
 *     new Query().read('primaryPreferred')
 *     new Query().read('pp') // same as primaryPreferred
 *
 *     new Query().read('secondary')
 *     new Query().read('s')  // same as secondary
 *
 *     new Query().read('secondaryPreferred')
 *     new Query().read('sp') // same as secondaryPreferred
 *
 *     new Query().read('nearest')
 *     new Query().read('n')  // same as nearest
 *
 *     // read from secondaries with matching tags
 *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])
 *
 * Read more about how to use read preferences [here](https://docs.mongodb.org/manual/applications/replication/#read-preference).
 *
 * @method read
 * @memberOf Query
 * @instance
 * @param {String} pref one of the listed preference options or aliases
 * @param {Array} [tags] optional tags for this query
 * @see mongodb https://docs.mongodb.org/manual/applications/replication/#read-preference
 * @return {Query} this
 * @api public
 */ Query.prototype.read = function read(pref, tags) {
    // first cast into a ReadPreference object to support tags
    const read = new ReadPreference(pref, tags);
    this.options.readPreference = read;
    return this;
};
/**
 * Overwrite default `.toString` to make logging more useful
 *
 * @memberOf Query
 * @instance
 * @method toString
 * @api private
 */ Query.prototype.toString = function toString() {
    if (this.op === "count" || this.op === "countDocuments" || this.op === "find" || this.op === "findOne" || this.op === "deleteMany" || this.op === "deleteOne" || this.op === "findOneAndDelete" || this.op === "findOneAndRemove" || this.op === "remove") {
        return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;
    }
    if (this.op === "distinct") {
        return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;
    }
    if (this.op === "findOneAndReplace" || this.op === "findOneAndUpdate" || this.op === "replaceOne" || this.op === "update" || this.op === "updateMany" || this.op === "updateOne") {
        return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;
    }
    // 'estimatedDocumentCount' or any others
    return `${this.model.modelName}.${this.op}()`;
};
/**
 * Sets the [MongoDB session](https://docs.mongodb.com/manual/reference/server-sessions/)
 * associated with this query. Sessions are how you mark a query as part of a
 * [transaction](/docs/transactions.html).
 *
 * Calling `session(null)` removes the session from this query.
 *
 * #### Example:
 *
 *     const s = await mongoose.startSession();
 *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);
 *
 * @method session
 * @memberOf Query
 * @instance
 * @param {ClientSession} [session] from `await conn.startSession()`
 * @see Connection.prototype.startSession() /docs/api/connection.html#connection_Connection-startSession
 * @see mongoose.startSession() /docs/api/mongoose.html#mongoose_Mongoose-startSession
 * @return {Query} this
 * @api public
 */ Query.prototype.session = function session(v) {
    if (v == null) {
        delete this.options.session;
    }
    this.options.session = v;
    return this;
};
/**
 * Sets the 3 write concern parameters for this query:
 *
 * - `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.
 * - `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.
 * - `wtimeout`: If [`w > 1`](/docs/api/query.html#query_Query-w), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.
 *
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern` option](/docs/guide.html#writeConcern)
 *
 * #### Example:
 *
 *     // The 'majority' option means the `deleteOne()` promise won't resolve
 *     // until the `deleteOne()` has propagated to the majority of the replica set
 *     await mongoose.model('Person').
 *       deleteOne({ name: 'Ned Stark' }).
 *       writeConcern({ w: 'majority' });
 *
 * @method writeConcern
 * @memberOf Query
 * @instance
 * @param {Object} writeConcern the write concern value to set
 * @see WriteConcernSettings https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html
 * @return {Query} this
 * @api public
 */ Query.prototype.writeConcern = function writeConcern(val) {
    if (val == null) {
        delete this.options.writeConcern;
        return this;
    }
    this.options.writeConcern = val;
    return this;
};
/**
 * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,
 * that must acknowledge this write before this write is considered successful.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern.w` option](/docs/guide.html#writeConcern)
 *
 * #### Example:
 *
 *     // The 'majority' option means the `deleteOne()` promise won't resolve
 *     // until the `deleteOne()` has propagated to the majority of the replica set
 *     await mongoose.model('Person').
 *       deleteOne({ name: 'Ned Stark' }).
 *       w('majority');
 *
 * @method w
 * @memberOf Query
 * @instance
 * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option
 * @return {Query} this
 * @api public
 */ Query.prototype.w = function w(val) {
    if (val == null) {
        delete this.options.w;
    }
    if (this.options.writeConcern != null) {
        this.options.writeConcern.w = val;
    } else {
        this.options.w = val;
    }
    return this;
};
/**
 * Requests acknowledgement that this operation has been persisted to MongoDB's
 * on-disk journal.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern.j` option](/docs/guide.html#writeConcern)
 *
 * #### Example:
 *
 *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);
 *
 * @method j
 * @memberOf Query
 * @instance
 * @param {boolean} val
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option
 * @return {Query} this
 * @api public
 */ Query.prototype.j = function j(val) {
    if (val == null) {
        delete this.options.j;
    }
    if (this.options.writeConcern != null) {
        this.options.writeConcern.j = val;
    } else {
        this.options.j = val;
    }
    return this;
};
/**
 * If [`w > 1`](/docs/api/query.html#query_Query-w), the maximum amount of time to
 * wait for this write to propagate through the replica set before this
 * operation fails. The default is `0`, which means no timeout.
 *
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndReplace()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the schema's [`writeConcern.wtimeout` option](/docs/guide.html#writeConcern)
 *
 * #### Example:
 *
 *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has
 *     // propagated to at least `w = 2` members of the replica set. If it takes
 *     // longer than 1 second, this `deleteOne()` will fail.
 *     await mongoose.model('Person').
 *       deleteOne({ name: 'Ned Stark' }).
 *       w(2).
 *       wtimeout(1000);
 *
 * @method wtimeout
 * @memberOf Query
 * @instance
 * @param {number} ms number of milliseconds to wait
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout
 * @return {Query} this
 * @api public
 */ Query.prototype.wtimeout = function wtimeout(ms) {
    if (ms == null) {
        delete this.options.wtimeout;
    }
    if (this.options.writeConcern != null) {
        this.options.writeConcern.wtimeout = ms;
    } else {
        this.options.wtimeout = ms;
    }
    return this;
};
/**
 * Sets the readConcern option for the query.
 *
 * #### Example:
 *
 *     new Query().readConcern('local')
 *     new Query().readConcern('l')  // same as local
 *
 *     new Query().readConcern('available')
 *     new Query().readConcern('a')  // same as available
 *
 *     new Query().readConcern('majority')
 *     new Query().readConcern('m')  // same as majority
 *
 *     new Query().readConcern('linearizable')
 *     new Query().readConcern('lz') // same as linearizable
 *
 *     new Query().readConcern('snapshot')
 *     new Query().readConcern('s')  // same as snapshot
 *
 *
 * #### Read Concern Level:
 *
 * ```
 * local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 * available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 * majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.
 * linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.
 * snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern "majority", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.
 * ```
 *
 * Aliases
 *
 * ```
 * l   local
 * a   available
 * m   majority
 * lz  linearizable
 * s   snapshot
 * ```
 *
 * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).
 *
 * @memberOf Query
 * @method readConcern
 * @param {String} level one of the listed read concern level or their aliases
 * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/
 * @return {Query} this
 * @api public
 */ /**
 * Gets query options.
 *
 * #### Example:
 *
 *     const query = new Query();
 *     query.limit(10);
 *     query.setOptions({ maxTimeMS: 1000 });
 *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }
 *
 * @return {Object} the options
 * @api public
 */ Query.prototype.getOptions = function() {
    return this.options;
};
/**
 * Sets query options. Some options only make sense for certain operations.
 *
 * #### Options:
 *
 * The following options are only for `find()`:
 *
 * - [tailable](https://www.mongodb.org/display/DOCS/Tailable+Cursors)
 * - [sort](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D)
 * - [limit](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D)
 * - [skip](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D)
 * - [allowDiskUse](https://docs.mongodb.com/manual/reference/method/cursor.allowDiskUse/)
 * - [batchSize](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D)
 * - [readPreference](https://docs.mongodb.org/manual/applications/replication/#read-preference)
 * - [hint](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint)
 * - [comment](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment)
 * - [snapshot](https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D)
 * - [maxscan](https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan)
 *
 * The following options are only for write operations: `update()`, `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:
 *
 * - [upsert](https://docs.mongodb.com/manual/reference/method/db.collection.update/)
 * - [writeConcern](https://docs.mongodb.com/manual/reference/method/db.collection.update/)
 * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.
 * - overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.
 *
 * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:
 *
 * - [lean](./api/query.html#query_Query-lean)
 * - [populate](/docs/populate.html)
 * - [projection](/docs/api/query.html#query_Query-projection)
 * - sanitizeProjection
 *
 * The following options are only for all operations **except** `update()`, `updateOne()`, `updateMany()`, `remove()`, `deleteOne()`, and `deleteMany()`:
 *
 * - [maxTimeMS](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)
 *
 * The following options are for `findOneAndUpdate()` and `findOneAndRemove()`
 *
 * - rawResult
 *
 * The following options are for all operations:
 *
 * - [strict](/docs/guide.html#strict)
 * - [collation](https://docs.mongodb.com/manual/reference/collation/)
 * - [session](https://docs.mongodb.com/manual/reference/server-sessions/)
 * - [explain](https://docs.mongodb.com/manual/reference/method/cursor.explain/)
 *
 * @param {Object} options
 * @return {Query} this
 * @api public
 */ Query.prototype.setOptions = function(options, overwrite) {
    // overwrite is only for internal use
    if (overwrite) {
        // ensure that _mongooseOptions & options are two different objects
        this._mongooseOptions = options && utils.clone(options) || {};
        this.options = options || {};
        if ("populate" in options) {
            this.populate(this._mongooseOptions);
        }
        return this;
    }
    if (options == null) {
        return this;
    }
    if (typeof options !== "object") {
        throw new Error('Options must be an object, got "' + options + '"');
    }
    options = Object.assign({}, options);
    if (Array.isArray(options.populate)) {
        const populate = options.populate;
        delete options.populate;
        const _numPopulate = populate.length;
        for(let i = 0; i < _numPopulate; ++i){
            this.populate(populate[i]);
        }
    }
    if ("setDefaultsOnInsert" in options) {
        this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
        delete options.setDefaultsOnInsert;
    }
    if ("overwriteDiscriminatorKey" in options) {
        this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
        delete options.overwriteDiscriminatorKey;
    }
    if ("sanitizeProjection" in options) {
        if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
            sanitizeProjection(this._fields);
        }
        this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
        delete options.sanitizeProjection;
    }
    if ("sanitizeFilter" in options) {
        this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;
        delete options.sanitizeFilter;
    }
    if ("defaults" in options) {
        this._mongooseOptions.defaults = options.defaults;
    // deleting options.defaults will cause 7287 to fail
    }
    if (options.lean == null && this.schema && "lean" in this.schema.options) {
        this._mongooseOptions.lean = this.schema.options.lean;
    }
    if (typeof options.limit === "string") {
        try {
            options.limit = castNumber(options.limit);
        } catch (err) {
            throw new CastError("Number", options.limit, "limit");
        }
    }
    if (typeof options.skip === "string") {
        try {
            options.skip = castNumber(options.skip);
        } catch (err) {
            throw new CastError("Number", options.skip, "skip");
        }
    }
    // set arbitrary options
    for (const key of Object.keys(options)){
        if (queryOptionMethods.has(key)) {
            const args = Array.isArray(options[key]) ? options[key] : [
                options[key]
            ];
            this[key].apply(this, args);
        } else {
            this.options[key] = options[key];
        }
    }
    return this;
};
/**
 * Sets the [`explain` option](https://docs.mongodb.com/manual/reference/method/cursor.explain/),
 * which makes this query return detailed execution stats instead of the actual
 * query result. This method is useful for determining what index your queries
 * use.
 *
 * Calling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`
 *
 * #### Example:
 *
 *     const query = new Query();
 *     const res = await query.find({ a: 1 }).explain('queryPlanner');
 *     console.log(res);
 *
 * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'
 * @return {Query} this
 * @api public
 */ Query.prototype.explain = function(verbose) {
    if (arguments.length === 0) {
        this.options.explain = true;
    } else if (verbose === false) {
        delete this.options.explain;
    } else {
        this.options.explain = verbose;
    }
    return this;
};
/**
 * Sets the [`allowDiskUse` option](https://docs.mongodb.com/manual/reference/method/cursor.allowDiskUse/),
 * which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can
 * let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.
 *
 * Note that this option requires MongoDB server >= 4.4. Setting this option is a no-op for MongoDB 4.2
 * and earlier.
 *
 * Calling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`
 *
 * #### Example:
 *
 *     await query.find().sort({ name: 1 }).allowDiskUse(true);
 *     // Equivalent:
 *     await query.find().sort({ name: 1 }).allowDiskUse();
 *
 * @param {Boolean} [v] Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`
 * @return {Query} this
 * @api public
 */ Query.prototype.allowDiskUse = function(v) {
    if (arguments.length === 0) {
        this.options.allowDiskUse = true;
    } else if (v === false) {
        delete this.options.allowDiskUse;
    } else {
        this.options.allowDiskUse = v;
    }
    return this;
};
/**
 * Sets the [maxTimeMS](https://docs.mongodb.com/manual/reference/method/cursor.maxTimeMS/)
 * option. This will tell the MongoDB server to abort if the query or write op
 * has been running for more than `ms` milliseconds.
 *
 * Calling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`
 *
 * #### Example:
 *
 *     const query = new Query();
 *     // Throws an error 'operation exceeded time limit' as long as there's
 *     // >= 1 doc in the queried collection
 *     const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);
 *
 * @param {Number} [ms] The number of milliseconds
 * @return {Query} this
 * @api public
 */ Query.prototype.maxTimeMS = function(ms) {
    this.options.maxTimeMS = ms;
    return this;
};
/**
 * Returns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).
 *
 * #### Example:
 *
 *     const query = new Query();
 *     query.find({ a: 1 }).where('b').gt(2);
 *     query.getFilter(); // { a: 1, b: { $gt: 2 } }
 *
 * @return {Object} current query filter
 * @api public
 */ Query.prototype.getFilter = function() {
    return this._conditions;
};
/**
 * Returns the current query filter. Equivalent to `getFilter()`.
 *
 * You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()`
 * will likely be deprecated in a future release.
 *
 * #### Example:
 *
 *     const query = new Query();
 *     query.find({ a: 1 }).where('b').gt(2);
 *     query.getQuery(); // { a: 1, b: { $gt: 2 } }
 *
 * @return {Object} current query filter
 * @api public
 */ Query.prototype.getQuery = function() {
    return this._conditions;
};
/**
 * Sets the query conditions to the provided JSON object.
 *
 * #### Example:
 *
 *     const query = new Query();
 *     query.find({ a: 1 })
 *     query.setQuery({ a: 2 });
 *     query.getQuery(); // { a: 2 }
 *
 * @param {Object} new query conditions
 * @return {undefined}
 * @api public
 */ Query.prototype.setQuery = function(val) {
    this._conditions = val;
};
/**
 * Returns the current update operations as a JSON object.
 *
 * #### Example:
 *
 *     const query = new Query();
 *     query.update({}, { $set: { a: 5 } });
 *     query.getUpdate(); // { $set: { a: 5 } }
 *
 * @return {Object} current update operations
 * @api public
 */ Query.prototype.getUpdate = function() {
    return this._update;
};
/**
 * Sets the current update operation to new value.
 *
 * #### Example:
 *
 *     const query = new Query();
 *     query.update({}, { $set: { a: 5 } });
 *     query.setUpdate({ $set: { b: 6 } });
 *     query.getUpdate(); // { $set: { b: 6 } }
 *
 * @param {Object} new update operation
 * @return {undefined}
 * @api public
 */ Query.prototype.setUpdate = function(val) {
    this._update = val;
};
/**
 * Returns fields selection for this query.
 *
 * @method _fieldsForExec
 * @return {Object}
 * @api private
 * @memberOf Query
 */ Query.prototype._fieldsForExec = function() {
    return utils.clone(this._fields);
};
/**
 * Return an update document with corrected `$set` operations.
 *
 * @method _updateForExec
 * @return {Object}
 * @api private
 * @memberOf Query
 */ Query.prototype._updateForExec = function() {
    const update = utils.clone(this._update, {
        transform: false,
        depopulate: true
    });
    const ops = Object.keys(update);
    let i = ops.length;
    const ret = {};
    while(i--){
        const op = ops[i];
        if (this.options.overwrite) {
            ret[op] = update[op];
            continue;
        }
        if ("$" !== op[0]) {
            // fix up $set sugar
            if (!ret.$set) {
                if (update.$set) {
                    ret.$set = update.$set;
                } else {
                    ret.$set = {};
                }
            }
            ret.$set[op] = update[op];
            ops.splice(i, 1);
            if (!~ops.indexOf("$set")) ops.push("$set");
        } else if ("$set" === op) {
            if (!ret.$set) {
                ret[op] = update[op];
            }
        } else {
            ret[op] = update[op];
        }
    }
    return ret;
};
/**
 * Makes sure _path is set.
 *
 * This method is inherited by `mquery`
 *
 * @method _ensurePath
 * @param {String} method
 * @api private
 * @memberOf Query
 */ /**
 * Determines if `conds` can be merged using `mquery().merge()`
 *
 * @method canMerge
 * @memberOf Query
 * @instance
 * @param {Object} conds
 * @return {Boolean}
 * @api private
 */ /**
 * Returns default options for this query.
 *
 * @param {Model} model
 * @api private
 */ Query.prototype._optionsForExec = function(model) {
    const options = utils.clone(this.options);
    delete options.populate;
    model = model || this.model;
    if (!model) {
        return options;
    }
    // Apply schema-level `writeConcern` option
    applyWriteConcern(model.schema, options);
    const readPreference = model && model.schema && model.schema.options && model.schema.options.read;
    if (!("readPreference" in options) && readPreference) {
        options.readPreference = readPreference;
    }
    if (options.upsert !== void 0) {
        options.upsert = !!options.upsert;
    }
    if (options.writeConcern) {
        if (options.j) {
            options.writeConcern.j = options.j;
            delete options.j;
        }
        if (options.w) {
            options.writeConcern.w = options.w;
            delete options.w;
        }
        if (options.wtimeout) {
            options.writeConcern.wtimeout = options.wtimeout;
            delete options.wtimeout;
        }
    }
    return options;
};
/**
 * Sets the lean option.
 *
 * Documents returned from queries with the `lean` option enabled are plain
 * javascript objects, not [Mongoose Documents](/api/document.html). They have no
 * `save` method, getters/setters, virtuals, or other Mongoose features.
 *
 * #### Example:
 *
 *     new Query().lean() // true
 *     new Query().lean(true)
 *     new Query().lean(false)
 *
 *     const docs = await Model.find().lean();
 *     docs[0] instanceof mongoose.Document; // false
 *
 * [Lean is great for high-performance, read-only cases](/docs/tutorials/lean.html),
 * especially when combined
 * with [cursors](/docs/queries.html#streaming).
 *
 * If you need virtuals, getters/setters, or defaults with `lean()`, you need
 * to use a plugin. See:
 *
 * - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)
 * - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)
 * - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)
 *
 * @param {Boolean|Object} bool defaults to true
 * @return {Query} this
 * @api public
 */ Query.prototype.lean = function(v) {
    this._mongooseOptions.lean = arguments.length ? v : true;
    return this;
};
/**
 * Adds a `$set` to this query's update without changing the operation.
 * This is useful for query middleware so you can add an update regardless
 * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.
 *
 * #### Example:
 *
 *     // Updates `{ $set: { updatedAt: new Date() } }`
 *     new Query().updateOne({}, {}).set('updatedAt', new Date());
 *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });
 *
 * @param {String|Object} path path or object of key/value pairs to set
 * @param {Any} [val] the value to set
 * @return {Query} this
 * @api public
 */ Query.prototype.set = function(path, val) {
    if (typeof path === "object") {
        const keys = Object.keys(path);
        for (const key of keys){
            this.set(key, path[key]);
        }
        return this;
    }
    this._update = this._update || {};
    if (path in this._update) {
        delete this._update[path];
    }
    this._update.$set = this._update.$set || {};
    this._update.$set[path] = val;
    return this;
};
/**
 * For update operations, returns the value of a path in the update's `$set`.
 * Useful for writing getters/setters that can work with both update operations
 * and `save()`.
 *
 * #### Example:
 *
 *     const query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });
 *     query.get('name'); // 'Jean-Luc Picard'
 *
 * @param {String|Object} path path or object of key/value pairs to get
 * @return {Query} this
 * @api public
 */ Query.prototype.get = function get(path) {
    const update = this._update;
    if (update == null) {
        return void 0;
    }
    const $set = update.$set;
    if ($set == null) {
        return update[path];
    }
    if (utils.hasUserDefinedProperty(update, path)) {
        return update[path];
    }
    if (utils.hasUserDefinedProperty($set, path)) {
        return $set[path];
    }
    return void 0;
};
/**
 * Gets/sets the error flag on this query. If this flag is not null or
 * undefined, the `exec()` promise will reject without executing.
 *
 * #### Example:
 *
 *     Query().error(); // Get current error value
 *     Query().error(null); // Unset the current error
 *     Query().error(new Error('test')); // `exec()` will resolve with test
 *     Schema.pre('find', function() {
 *       if (!this.getQuery().userId) {
 *         this.error(new Error('Not allowed to query without setting userId'));
 *       }
 *     });
 *
 * Note that query casting runs **after** hooks, so cast errors will override
 * custom errors.
 *
 * #### Example:
 *
 *     const TestSchema = new Schema({ num: Number });
 *     const TestModel = db.model('Test', TestSchema);
 *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {
 *       // `error` will be a cast error because `num` failed to cast
 *     });
 *
 * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB
 * @return {Query} this
 * @api public
 */ Query.prototype.error = function error(err) {
    if (arguments.length === 0) {
        return this._error;
    }
    this._error = err;
    return this;
};
/**
 * ignore
 * @method _unsetCastError
 * @instance
 * @memberOf Query
 * @api private
 */ Query.prototype._unsetCastError = function _unsetCastError() {
    if (this._error != null && !(this._error instanceof CastError)) {
        return;
    }
    return this.error(null);
};
/**
 * Getter/setter around the current mongoose-specific options for this query
 * Below are the current Mongoose-specific options.
 *
 * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](/docs/api/query.html#query_Query-populate)
 * - `lean`: if truthy, Mongoose will not [hydrate](/docs/api/model.html#model_Model-hydrate) any documents that are returned from this query. See [`Query.prototype.lean()`](/docs/api/query.html#query_Query-lean) for more information.
 * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](/docs/guide.html#strict) for more information.
 * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default for backwards compatibility, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](/docs/guide.html#strictQuery) for more information.
 * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](/docs/api/query.html#query_Query-nearSphere)
 *
 * Mongoose maintains a separate object for internal options because
 * Mongoose sends `Query.prototype.options` to the MongoDB server, and the
 * above options are not relevant for the MongoDB server.
 *
 * @param {Object} options if specified, overwrites the current options
 * @return {Object} the options
 * @api public
 */ Query.prototype.mongooseOptions = function(v) {
    if (arguments.length > 0) {
        this._mongooseOptions = v;
    }
    return this._mongooseOptions;
};
/**
 * ignore
 * @method _castConditions
 * @memberOf Query
 * @api private
 * @instance
 */ Query.prototype._castConditions = function() {
    let sanitizeFilterOpt = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeFilter")) {
        sanitizeFilterOpt = this.model.db.options.sanitizeFilter;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeFilter")) {
        sanitizeFilterOpt = this.model.base.options.sanitizeFilter;
    } else {
        sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;
    }
    if (sanitizeFilterOpt) {
        sanitizeFilter(this._conditions);
    }
    try {
        this.cast(this.model);
        this._unsetCastError();
    } catch (err) {
        this.error(err);
    }
};
/*!
 * ignore
 */ function _castArrayFilters(query) {
    try {
        castArrayFilters(query);
    } catch (err) {
        query.error(err);
    }
}
/**
 * Thunk around find()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */ Query.prototype._find = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error() != null) {
        callback(this.error());
        return null;
    }
    callback = _wrapThunkCallback(this, callback);
    this._applyPaths();
    this._fields = this._castFields(this._fields);
    const fields = this._fieldsForExec();
    const mongooseOptions = this._mongooseOptions;
    const _this = this;
    const userProvidedFields = _this._userProvidedFields || {};
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    // Separate options to pass down to `completeMany()` in case we need to
    // set a session on the document
    const completeManyOptions = Object.assign({}, {
        session: this && this.options && this.options.session || null,
        lean: mongooseOptions.lean || null
    });
    const cb = (err, docs)=>{
        if (err) {
            return callback(err);
        }
        if (docs.length === 0) {
            return callback(null, docs);
        }
        if (this.options.explain) {
            return callback(null, docs);
        }
        if (!mongooseOptions.populate) {
            const versionKey = _this.schema.options.versionKey;
            if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
                docs.forEach((doc)=>{
                    if (versionKey in doc) {
                        delete doc[versionKey];
                    }
                });
            }
            return mongooseOptions.lean ? // call _completeManyLean here?
            _completeManyLean(_this.model.schema, docs, null, completeManyOptions, callback) : // callback(null, docs) :
            completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
        }
        const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
        if (mongooseOptions.lean) {
            return _this.model.populate(docs, pop, callback);
        }
        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, (err, docs)=>{
            if (err != null) {
                return callback(err);
            }
            _this.model.populate(docs, pop, callback);
        });
    };
    const options = this._optionsForExec();
    options.projection = this._fieldsForExec();
    const filter = this._conditions;
    this._collection.collection.find(filter, options, (err, cursor)=>{
        if (err != null) {
            return cb(err);
        }
        if (options.explain) {
            return cursor.explain(cb);
        }
        try {
            return cursor.toArray(cb);
        } catch (err) {
            return cb(err);
        }
    });
});
/**
 * Find all documents that match `selector`. The result will be an array of documents.
 *
 * If there are too many documents in the result to fit in memory, use
 * [`Query.prototype.cursor()`](api/query.html#query_Query-cursor)
 *
 * #### Example:
 *
 *     // Using async/await
 *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });
 *
 *     // Using callbacks
 *     Movie.find({ year: { $gte: 1980, $lte: 1989 } }, function(err, arr) {});
 *
 * @param {Object|ObjectId} [filter] mongodb selector. If not specified, returns all documents.
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.find = function(conditions, callback) {
    this.op = "find";
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
    }
    conditions = utils.toObject(conditions);
    if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "find"));
    }
    // if we don't have a callback, then just return the query object
    if (!callback) {
        return Query.base.find.call(this);
    }
    this.exec(callback);
    return this;
};
/**
 * Merges another Query or conditions object into this one.
 *
 * When a Query is passed, conditions, field selection and options are merged.
 *
 * @param {Query|Object} source
 * @return {Query} this
 */ Query.prototype.merge = function(source) {
    if (!source) {
        return this;
    }
    const opts = {
        overwrite: true
    };
    if (source instanceof Query) {
        // if source has a feature, apply it to ourselves
        if (source._conditions) {
            utils.merge(this._conditions, source._conditions, opts);
        }
        if (source._fields) {
            this._fields || (this._fields = {});
            utils.merge(this._fields, source._fields, opts);
        }
        if (source.options) {
            this.options || (this.options = {});
            utils.merge(this.options, source.options, opts);
        }
        if (source._update) {
            this._update || (this._update = {});
            utils.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
            this._distinct = source._distinct;
        }
        utils.merge(this._mongooseOptions, source._mongooseOptions);
        return this;
    } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {
        utils.merge(this._conditions, {
            _id: source
        }, opts);
        return this;
    }
    // plain object
    utils.merge(this._conditions, source, opts);
    return this;
};
/**
 * Adds a collation to this op (MongoDB 3.4 and up)
 *
 * @param {Object} value
 * @return {Query} this
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation
 * @api public
 */ Query.prototype.collation = function(value) {
    if (this.options == null) {
        this.options = {};
    }
    this.options.collation = value;
    return this;
};
/**
 * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.
 *
 * @api private
 */ Query.prototype._completeOne = function(doc, res, callback) {
    if (!doc && !this.options.rawResult) {
        return callback(null, null);
    }
    const model = this.model;
    const projection = utils.clone(this._fields);
    const userProvidedFields = this._userProvidedFields || {};
    // `populate`, `lean`
    const mongooseOptions = this._mongooseOptions;
    // `rawResult`
    const options = this.options;
    if (!options.lean && mongooseOptions.lean) {
        options.lean = mongooseOptions.lean;
    }
    if (options.explain) {
        return callback(null, doc);
    }
    if (!mongooseOptions.populate) {
        const versionKey = this.schema.options.versionKey;
        if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
            if (versionKey in doc) {
                delete doc[versionKey];
            }
        }
        return mongooseOptions.lean ? _completeOneLean(model.schema, doc, null, res, options, callback) : completeOne(model, doc, res, options, projection, userProvidedFields, null, callback);
    }
    const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
    if (mongooseOptions.lean) {
        return model.populate(doc, pop, (err, doc)=>{
            if (err != null) {
                return callback(err);
            }
            _completeOneLean(model.schema, doc, null, res, options, callback);
        });
    }
    completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc)=>{
        if (err != null) {
            return callback(err);
        }
        model.populate(doc, pop, callback);
    });
};
/**
 * Thunk around findOne()
 *
 * @param {Function} [callback]
 * @see findOne https://docs.mongodb.org/manual/reference/method/db.collection.findOne/
 * @api private
 */ Query.prototype._findOne = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error()) {
        callback(this.error());
        return null;
    }
    this._applyPaths();
    this._fields = this._castFields(this._fields);
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    // don't pass in the conditions because we already merged them in
    Query.base.findOne.call(this, {}, (err, doc)=>{
        if (err) {
            callback(err);
            return null;
        }
        this._completeOne(doc, null, _wrapThunkCallback(this, callback));
    });
});
/**
 * Declares the query a findOne operation. When executed, the first found document is passed to the callback.
 *
 * Passing a `callback` executes the query. The result of the query is a single document.
 *
 * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,
 * mongoose will send an empty `findOne` command to MongoDB, which will return
 * an arbitrary document. If you're querying by `_id`, use `Model.findById()`
 * instead.
 *
 * This function triggers the following middleware.
 *
 * - `findOne()`
 *
 * #### Example:
 *
 *     const query  = Kitten.where({ color: 'white' });
 *     query.findOne(function (err, kitten) {
 *       if (err) return handleError(err);
 *       if (kitten) {
 *         // doc may be null if no document matched
 *       }
 *     });
 *
 * @param {Object} [filter] mongodb selector
 * @param {Object} [projection] optional fields to return
 * @param {Object} [options] see [`setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback] optional params are (error, document)
 * @return {Query} this
 * @see findOne https://docs.mongodb.org/manual/reference/method/db.collection.findOne/
 * @see Query.select #query_Query-select
 * @api public
 */ Query.prototype.findOne = function(conditions, projection, options, callback) {
    this.op = "findOne";
    this._validateOp();
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = null;
        projection = null;
        options = null;
    } else if (typeof projection === "function") {
        callback = projection;
        options = null;
        projection = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    }
    // make sure we don't send in the whole Document to merge()
    conditions = utils.toObject(conditions);
    if (options) {
        this.setOptions(options);
    }
    if (projection) {
        this.select(projection);
    }
    if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "findOne"));
    }
    if (!callback) {
        // already merged in the conditions, don't need to send them in.
        return Query.base.findOne.call(this);
    }
    this.exec(callback);
    return this;
};
/**
 * Thunk around count()
 *
 * @param {Function} [callback]
 * @see count https://docs.mongodb.org/manual/reference/method/db.collection.count/
 * @api private
 */ Query.prototype._count = wrapThunk(function(callback) {
    try {
        this.cast(this.model);
    } catch (err) {
        this.error(err);
    }
    if (this.error()) {
        return callback(this.error());
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const conds = this._conditions;
    const options = this._optionsForExec();
    this._collection.count(conds, options, utils.tick(callback));
});
/**
 * Thunk around countDocuments()
 *
 * @param {Function} [callback]
 * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments
 * @api private
 */ Query.prototype._countDocuments = wrapThunk(function(callback) {
    try {
        this.cast(this.model);
    } catch (err) {
        this.error(err);
    }
    if (this.error()) {
        return callback(this.error());
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const conds = this._conditions;
    const options = this._optionsForExec();
    this._collection.collection.countDocuments(conds, options, utils.tick(callback));
});
/**
 * Thunk around estimatedDocumentCount()
 *
 * @param {Function} [callback]
 * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount
 * @api private
 */ Query.prototype._estimatedDocumentCount = wrapThunk(function(callback) {
    if (this.error()) {
        return callback(this.error());
    }
    const options = this._optionsForExec();
    this._collection.collection.estimatedDocumentCount(options, utils.tick(callback));
});
/**
 * Specifies this query as a `count` query.
 *
 * This method is deprecated. If you want to count the number of documents in
 * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](/docs/api/query.html#query_Query-estimatedDocumentCount)
 * instead. Otherwise, use the [`countDocuments()`](/docs/api/query.html#query_Query-countDocuments) function instead.
 *
 * Passing a `callback` executes the query.
 *
 * This function triggers the following middleware.
 *
 * - `count()`
 *
 * #### Example:
 *
 *     const countQuery = model.where({ 'color': 'black' }).count();
 *
 *     query.count({ color: 'black' }).count(callback)
 *
 *     query.count({ color: 'black' }, callback)
 *
 *     query.where('color', 'black').count(function (err, count) {
 *       if (err) return handleError(err);
 *       console.log('there are %d kittens', count);
 *     })
 *
 * @deprecated
 * @param {Object} [filter] count documents that match this object
 * @param {Function} [callback] optional params are (error, count)
 * @return {Query} this
 * @see count https://docs.mongodb.org/manual/reference/method/db.collection.count/
 * @api public
 */ Query.prototype.count = function(filter, callback) {
    this.op = "count";
    this._validateOp();
    if (typeof filter === "function") {
        callback = filter;
        filter = undefined;
    }
    filter = utils.toObject(filter);
    if (mquery.canMerge(filter)) {
        this.merge(filter);
    }
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Specifies this query as a `estimatedDocumentCount()` query. Faster than
 * using `countDocuments()` for large collections because
 * `estimatedDocumentCount()` uses collection metadata rather than scanning
 * the entire collection.
 *
 * `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()`
 * is equivalent to `Model.find().estimatedDocumentCount()`
 *
 * This function triggers the following middleware.
 *
 * - `estimatedDocumentCount()`
 *
 * #### Example:
 *
 *     await Model.find().estimatedDocumentCount();
 *
 * @param {Object} [options] passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)
 * @param {Function} [callback] optional params are (error, count)
 * @return {Query} this
 * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount
 * @api public
 */ Query.prototype.estimatedDocumentCount = function(options, callback) {
    this.op = "estimatedDocumentCount";
    this._validateOp();
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    if (typeof options === "object" && options != null) {
        this.setOptions(options);
    }
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Specifies this query as a `countDocuments()` query. Behaves like `count()`,
 * except it always does a full collection scan when passed an empty filter `{}`.
 *
 * There are also minor differences in how `countDocuments()` handles
 * [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).
 * versus `count()`.
 *
 * Passing a `callback` executes the query.
 *
 * This function triggers the following middleware.
 *
 * - `countDocuments()`
 *
 * #### Example:
 *
 *     const countQuery = model.where({ 'color': 'black' }).countDocuments();
 *
 *     query.countDocuments({ color: 'black' }).count(callback);
 *
 *     query.countDocuments({ color: 'black' }, callback);
 *
 *     query.where('color', 'black').countDocuments(function(err, count) {
 *       if (err) return handleError(err);
 *       console.log('there are %d kittens', count);
 *     });
 *
 * The `countDocuments()` function is similar to `count()`, but there are a
 * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).
 * Below are the operators that `count()` supports but `countDocuments()` does not,
 * and the suggested replacement:
 *
 * - `$where`: [`$expr`](https://docs.mongodb.com/manual/reference/operator/query/expr/)
 * - `$near`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$center`](https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center)
 * - `$nearSphere`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere)
 *
 * @param {Object} [filter] mongodb selector
 * @param {Object} [options]
 * @param {Function} [callback] optional params are (error, count)
 * @return {Query} this
 * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments
 * @api public
 */ Query.prototype.countDocuments = function(conditions, options, callback) {
    this.op = "countDocuments";
    this._validateOp();
    if (typeof conditions === "function") {
        callback = conditions;
        conditions = undefined;
        options = undefined;
    }
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    conditions = utils.toObject(conditions);
    if (mquery.canMerge(conditions)) {
        this.merge(conditions);
    }
    if (typeof options === "object" && options != null) {
        this.setOptions(options);
    }
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Thunk around distinct()
 *
 * @param {Function} [callback]
 * @see distinct https://docs.mongodb.org/manual/reference/method/db.collection.distinct/
 * @api private
 */ Query.prototype.__distinct = wrapThunk(function __distinct(callback) {
    this._castConditions();
    if (this.error()) {
        callback(this.error());
        return null;
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const options = this._optionsForExec();
    // don't pass in the conditions because we already merged them in
    this._collection.collection.distinct(this._distinct, this._conditions, options, callback);
});
/**
 * Declares or executes a distinct() operation.
 *
 * Passing a `callback` executes the query.
 *
 * This function does not trigger any middleware.
 *
 * #### Example:
 *
 *     distinct(field, conditions, callback)
 *     distinct(field, conditions)
 *     distinct(field, callback)
 *     distinct(field)
 *     distinct(callback)
 *     distinct()
 *
 * @param {String} [field]
 * @param {Object|Query} [filter]
 * @param {Function} [callback] optional params are (error, arr)
 * @return {Query} this
 * @see distinct https://docs.mongodb.org/manual/reference/method/db.collection.distinct/
 * @api public
 */ Query.prototype.distinct = function(field, conditions, callback) {
    this.op = "distinct";
    this._validateOp();
    if (!callback) {
        if (typeof conditions === "function") {
            callback = conditions;
            conditions = undefined;
        } else if (typeof field === "function") {
            callback = field;
            field = undefined;
            conditions = undefined;
        }
    }
    conditions = utils.toObject(conditions);
    if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "distinct"));
    }
    if (field != null) {
        this._distinct = field;
    }
    if (callback != null) {
        this.exec(callback);
    }
    return this;
};
/**
 * Sets the sort order
 *
 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
 *
 * If a string is passed, it must be a space delimited list of path names. The
 * sort order of each path is ascending unless the path name is prefixed with `-`
 * which will be treated as descending.
 *
 * #### Example:
 *
 *     // sort by "field" ascending and "test" descending
 *     query.sort({ field: 'asc', test: -1 });
 *
 *     // equivalent
 *     query.sort('field -test');
 *
 *     // also possible is to use a array with array key-value pairs
 *     query.sort([['field', 'asc']]);
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @param {Object|String|Array<Array<(string | number)>>} arg
 * @return {Query} this
 * @see cursor.sort https://docs.mongodb.org/manual/reference/method/cursor.sort/
 * @api public
 */ Query.prototype.sort = function(arg) {
    if (arguments.length > 1) {
        throw new Error("sort() only takes 1 Argument");
    }
    return Query.base.sort.call(this, arg);
};
/**
 * Declare and/or execute this query as a remove() operation. `remove()` is
 * deprecated, you should use [`deleteOne()`](#query_Query-deleteOne)
 * or [`deleteMany()`](#query_Query-deleteMany) instead.
 *
 * This function does not trigger any middleware
 *
 * #### Example:
 *
 *     Character.remove({ name: /Stark/ }, callback);
 *
 * This function calls the MongoDB driver's [`Collection#remove()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#remove).
 * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an
 * object that contains 3 properties:
 *
 * - `ok`: `1` if no errors occurred
 * - `deletedCount`: the number of documents deleted
 * - `n`: the number of documents deleted. Equal to `deletedCount`.
 *
 * #### Example:
 *
 *     const res = await Character.remove({ name: /Stark/ });
 *     // Number of docs deleted
 *     res.deletedCount;
 *
 * #### Note:
 *
 * Calling `remove()` creates a [Mongoose query](./queries.html), and a query
 * does not execute until you either pass a callback, call [`Query#then()`](#query_Query-then),
 * or call [`Query#exec()`](#query_Query-exec).
 *
 *     // not executed
 *     const query = Character.remove({ name: /Stark/ });
 *
 *     // executed
 *     Character.remove({ name: /Stark/ }, callback);
 *     Character.remove({ name: /Stark/ }).remove(callback);
 *
 *     // executed without a callback
 *     Character.exec();
 *
 * @param {Object|Query} [filter] mongodb selector
 * @param {Function} [callback] optional params are (error, mongooseDeleteResult)
 * @return {Query} this
 * @deprecated
 * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html
 * @see remove https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#remove
 * @api public
 */ Query.prototype.remove = function(filter, callback) {
    this.op = "remove";
    if (typeof filter === "function") {
        callback = filter;
        filter = null;
    }
    filter = utils.toObject(filter);
    if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "remove"));
    }
    if (!callback) {
        return Query.base.remove.call(this);
    }
    this.exec(callback);
    return this;
};
/**
 * ignore
 * @param {Function} callback
 * @method _remove
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._remove = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error() != null) {
        callback(this.error());
        return this;
    }
    callback = _wrapThunkCallback(this, callback);
    return Query.base.remove.call(this, callback);
});
/**
 * Declare and/or execute this query as a `deleteOne()` operation. Works like
 * remove, except it deletes at most one document regardless of the `single`
 * option.
 *
 * This function triggers `deleteOne` middleware.
 *
 * #### Example:
 *
 *     await Character.deleteOne({ name: 'Eddard Stark' });
 *
 *     // Using callbacks:
 *     Character.deleteOne({ name: 'Eddard Stark' }, callback);
 *
 * This function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne).
 * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an
 * object that contains 3 properties:
 *
 * - `ok`: `1` if no errors occurred
 * - `deletedCount`: the number of documents deleted
 * - `n`: the number of documents deleted. Equal to `deletedCount`.
 *
 * #### Example:
 *
 *     const res = await Character.deleteOne({ name: 'Eddard Stark' });
 *     // `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`
 *     res.deletedCount;
 *
 * @param {Object|Query} [filter] mongodb selector
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback] optional params are (error, mongooseDeleteResult)
 * @return {Query} this
 * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html
 * @see deleteOne https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne
 * @api public
 */ Query.prototype.deleteOne = function(filter, options, callback) {
    this.op = "deleteOne";
    if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    } else {
        this.setOptions(options);
    }
    filter = utils.toObject(filter);
    if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
    }
    if (!callback) {
        return Query.base.deleteOne.call(this);
    }
    this.exec.call(this, callback);
    return this;
};
/**
 * Internal thunk for `deleteOne()`
 * @param {Function} callback
 * @method _deleteOne
 * @instance
 * @memberOf Query
 * @api private
 */ Query.prototype._deleteOne = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error() != null) {
        callback(this.error());
        return this;
    }
    callback = _wrapThunkCallback(this, callback);
    return Query.base.deleteOne.call(this, callback);
});
/**
 * Declare and/or execute this query as a `deleteMany()` operation. Works like
 * remove, except it deletes _every_ document that matches `filter` in the
 * collection, regardless of the value of `single`.
 *
 * This function triggers `deleteMany` middleware.
 *
 * #### Example:
 *
 *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });
 *
 *     // Using callbacks:
 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback);
 *
 * This function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany).
 * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an
 * object that contains 3 properties:
 *
 * - `ok`: `1` if no errors occurred
 * - `deletedCount`: the number of documents deleted
 * - `n`: the number of documents deleted. Equal to `deletedCount`.
 *
 * #### Example:
 *
 *     const res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });
 *     // `0` if no docs matched the filter, number of docs deleted otherwise
 *     res.deletedCount;
 *
 * @param {Object|Query} [filter] mongodb selector
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#query_Query-setOptions)
 * @param {Function} [callback] optional params are (error, mongooseDeleteResult)
 * @return {Query} this
 * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html
 * @see deleteMany https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany
 * @api public
 */ Query.prototype.deleteMany = function(filter, options, callback) {
    this.op = "deleteMany";
    if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
    } else if (typeof options === "function") {
        callback = options;
        options = null;
    } else {
        this.setOptions(options);
    }
    filter = utils.toObject(filter);
    if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
    }
    if (!callback) {
        return Query.base.deleteMany.call(this);
    }
    this.exec.call(this, callback);
    return this;
};
/**
 * Internal thunk around `deleteMany()`
 * @param {Function} callback
 * @method _deleteMany
 * @instance
 * @memberOf Query
 * @api private
 */ Query.prototype._deleteMany = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error() != null) {
        callback(this.error());
        return this;
    }
    callback = _wrapThunkCallback(this, callback);
    return Query.base.deleteMany.call(this, callback);
});
/**
 * hydrates a document
 *
 * @param {Model} model
 * @param {Document} doc
 * @param {Object} res 3rd parameter to callback
 * @param {Object} fields
 * @param {Query} self
 * @param {Array} [pop] array of paths used in population
 * @param {Function} callback
 * @api private
 */ function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
    if (options.rawResult && doc == null) {
        _init(null);
        return null;
    }
    helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);
    function _init(err, casted) {
        if (err) {
            return immediate(()=>callback(err));
        }
        if (options.rawResult) {
            if (doc && casted) {
                if (options.session != null) {
                    casted.$session(options.session);
                }
                res.value = casted;
            } else {
                res.value = null;
            }
            return immediate(()=>callback(null, res));
        }
        if (options.session != null) {
            casted.$session(options.session);
        }
        immediate(()=>callback(null, casted));
    }
}
/**
 * If the model is a discriminator type and not root, then add the key & value to the criteria.
 * @param {Query} query
 * @api private
 */ function prepareDiscriminatorCriteria(query) {
    if (!query || !query.model || !query.model.schema) {
        return;
    }
    const schema = query.model.schema;
    if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
}
/**
 * Issues a mongodb [findAndModify](https://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
 *
 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found
 * document (if any) to the callback. The query executes if
 * `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndUpdate()`
 *
 * #### Available options
 *
 * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
 * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
 * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
 * - `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.
 * - `rawResult`: if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 *
 * #### Callback Signature
 *
 *     function(error, doc) {
 *       // error: any errors that occurred
 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
 *     }
 *
 * #### Example:
 *
 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
 *     query.findOneAndUpdate(conditions, update, callback) // executes
 *     query.findOneAndUpdate(conditions, update)           // returns Query
 *     query.findOneAndUpdate(update, callback)             // returns Query
 *     query.findOneAndUpdate(update)                       // returns Query
 *     query.findOneAndUpdate(callback)                     // executes
 *     query.findOneAndUpdate()                             // returns Query
 *
 * @method findOneAndUpdate
 * @memberOf Query
 * @instance
 * @param {Object|Query} [filter]
 * @param {Object} [doc]
 * @param {Object} [options]
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and [the Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.
 * @param {Function} [callback] optional params are (error, doc), _unless_ `rawResult` is used, in which case params are (error, writeOpResult)
 * @see Tutorial /docs/tutorials/findoneandupdate.html
 * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/
 * @see ModifyResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html
 * @see findOneAndUpdate https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate
 * @return {Query} this
 * @api public
 */ Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
    this.op = "findOneAndUpdate";
    this._validateOp();
    this._validate();
    switch(arguments.length){
        case 3:
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            break;
        case 2:
            if (typeof doc === "function") {
                callback = doc;
                doc = criteria;
                criteria = undefined;
            }
            options = undefined;
            break;
        case 1:
            if (typeof criteria === "function") {
                callback = criteria;
                criteria = options = doc = undefined;
            } else {
                doc = criteria;
                criteria = options = undefined;
            }
    }
    if (mquery.canMerge(criteria)) {
        this.merge(criteria);
    }
    // apply doc
    if (doc) {
        this._mergeUpdate(doc);
    }
    options = options ? utils.clone(options) : {};
    if (options.projection) {
        this.select(options.projection);
        delete options.projection;
    }
    if (options.fields) {
        this.select(options.fields);
        delete options.fields;
    }
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Thunk around findOneAndUpdate()
 *
 * @param {Function} [callback]
 * @method _findOneAndUpdate
 * @memberOf Query
 * @api private
 */ Query.prototype._findOneAndUpdate = wrapThunk(function(callback) {
    if (this.error() != null) {
        return callback(this.error());
    }
    this._findAndModify("update", callback);
});
/**
 * Issues a mongodb [findAndModify](https://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
 *
 * Finds a matching document, removes it, passing the found document (if any) to
 * the callback. Executes if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndRemove()`
 *
 * #### Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
 * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 *
 * #### Callback Signature
 *
 *     function(error, doc) {
 *       // error: any errors that occurred
 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
 *     }
 *
 * #### Example:
 *
 *     A.where().findOneAndRemove(conditions, options, callback) // executes
 *     A.where().findOneAndRemove(conditions, options)  // return Query
 *     A.where().findOneAndRemove(conditions, callback) // executes
 *     A.where().findOneAndRemove(conditions) // returns Query
 *     A.where().findOneAndRemove(callback)   // executes
 *     A.where().findOneAndRemove()           // returns Query
 *
 * @method findOneAndRemove
 * @memberOf Query
 * @instance
 * @param {Object} [conditions]
 * @param {Object} [options]
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Function} [callback] optional params are (error, document)
 * @return {Query} this
 * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/
 * @api public
 */ Query.prototype.findOneAndRemove = function(conditions, options, callback) {
    this.op = "findOneAndRemove";
    this._validateOp();
    this._validate();
    switch(arguments.length){
        case 2:
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            break;
        case 1:
            if (typeof conditions === "function") {
                callback = conditions;
                conditions = undefined;
                options = undefined;
            }
            break;
    }
    if (mquery.canMerge(conditions)) {
        this.merge(conditions);
    }
    options && this.setOptions(options);
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Issues a MongoDB [findOneAndDelete](https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndDelete/) command.
 *
 * Finds a matching document, removes it, and passes the found document (if any)
 * to the callback. Executes if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndDelete()`
 *
 * This function differs slightly from `Model.findOneAndRemove()` in that
 * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/),
 * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,
 * this distinction is purely pedantic. You should use `findOneAndDelete()`
 * unless you have a good reason not to.
 *
 * #### Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
 * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 *
 * #### Callback Signature
 *
 *     function(error, doc) {
 *       // error: any errors that occurred
 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
 *     }
 *
 * #### Example:
 *
 *     A.where().findOneAndDelete(conditions, options, callback) // executes
 *     A.where().findOneAndDelete(conditions, options)  // return Query
 *     A.where().findOneAndDelete(conditions, callback) // executes
 *     A.where().findOneAndDelete(conditions) // returns Query
 *     A.where().findOneAndDelete(callback)   // executes
 *     A.where().findOneAndDelete()           // returns Query
 *
 * @method findOneAndDelete
 * @memberOf Query
 * @param {Object} [conditions]
 * @param {Object} [options]
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Function} [callback] optional params are (error, document)
 * @return {Query} this
 * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/
 * @api public
 */ Query.prototype.findOneAndDelete = function(conditions, options, callback) {
    this.op = "findOneAndDelete";
    this._validateOp();
    this._validate();
    switch(arguments.length){
        case 2:
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            break;
        case 1:
            if (typeof conditions === "function") {
                callback = conditions;
                conditions = undefined;
                options = undefined;
            }
            break;
    }
    if (mquery.canMerge(conditions)) {
        this.merge(conditions);
    }
    options && this.setOptions(options);
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Thunk around findOneAndDelete()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @method _findOneAndDelete
 * @memberOf Query
 * @api private
 */ Query.prototype._findOneAndDelete = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error() != null) {
        callback(this.error());
        return null;
    }
    const filter = this._conditions;
    const options = this._optionsForExec();
    let fields = null;
    if (this._fields != null) {
        options.projection = this._castFields(utils.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
            callback(fields);
            return null;
        }
    }
    this._collection.collection.findOneAndDelete(filter, options, _wrapThunkCallback(this, (err, res)=>{
        if (err) {
            return callback(err);
        }
        const doc = res.value;
        return this._completeOne(doc, res, callback);
    }));
});
/**
 * Issues a MongoDB [findOneAndReplace](https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndReplace/) command.
 *
 * Finds a matching document, removes it, and passes the found document (if any)
 * to the callback. Executes if `callback` is passed.
 *
 * This function triggers the following middleware.
 *
 * - `findOneAndReplace()`
 *
 * #### Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
 * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 *
 * #### Callback Signature
 *
 *     function(error, doc) {
 *       // error: any errors that occurred
 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
 *     }
 *
 * #### Example:
 *
 *     A.where().findOneAndReplace(filter, replacement, options, callback); // executes
 *     A.where().findOneAndReplace(filter, replacement, options); // return Query
 *     A.where().findOneAndReplace(filter, replacement, callback); // executes
 *     A.where().findOneAndReplace(filter); // returns Query
 *     A.where().findOneAndReplace(callback); // executes
 *     A.where().findOneAndReplace(); // returns Query
 *
 * @method findOneAndReplace
 * @memberOf Query
 * @param {Object} [filter]
 * @param {Object} [replacement]
 * @param {Object} [options]
 * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api/query.html#query_Query-lean) and [the Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](/docs/transactions.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.
 * @param {Function} [callback] optional params are (error, document)
 * @return {Query} this
 * @api public
 */ Query.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
    this.op = "findOneAndReplace";
    this._validateOp();
    this._validate();
    switch(arguments.length){
        case 3:
            if (typeof options === "function") {
                callback = options;
                options = void 0;
            }
            break;
        case 2:
            if (typeof replacement === "function") {
                callback = replacement;
                replacement = void 0;
            }
            break;
        case 1:
            if (typeof filter === "function") {
                callback = filter;
                filter = void 0;
                replacement = void 0;
                options = void 0;
            }
            break;
    }
    if (mquery.canMerge(filter)) {
        this.merge(filter);
    }
    if (replacement != null) {
        if (hasDollarKeys(replacement)) {
            throw new Error("The replacement document must not contain atomic operators.");
        }
        this._mergeUpdate(replacement);
    }
    options = options || {};
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    this.setOptions({
        overwrite: true
    });
    if (!callback) {
        return this;
    }
    this.exec(callback);
    return this;
};
/**
 * Thunk around findOneAndReplace()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @method _findOneAndReplace
 * @instance
 * @memberOf Query
 * @api private
 */ Query.prototype._findOneAndReplace = wrapThunk(function(callback) {
    this._castConditions();
    if (this.error() != null) {
        callback(this.error());
        return null;
    }
    const filter = this._conditions;
    const options = this._optionsForExec();
    convertNewToReturnDocument(options);
    let fields = null;
    this._applyPaths();
    if (this._fields != null) {
        options.projection = this._castFields(utils.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
            callback(fields);
            return null;
        }
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators === false) {
        try {
            this._update = this._castUpdate(this._update, true);
        } catch (err) {
            const validationError = new ValidationError();
            validationError.errors[err.path] = err;
            callback(validationError);
            return null;
        }
        this._collection.collection.findOneAndReplace(filter, this._update || {}, options, _wrapThunkCallback(this, (err, res)=>{
            if (err) {
                return callback(err);
            }
            const doc = res.value;
            return this._completeOne(doc, res, callback);
        }));
        return;
    }
    let castedDoc = new this.model(this._update, null, true);
    this._update = castedDoc;
    castedDoc.validate((err)=>{
        if (err != null) {
            return callback(err);
        }
        if (castedDoc.toBSON) {
            castedDoc = castedDoc.toBSON();
        }
        this._collection.collection.findOneAndReplace(filter, castedDoc, options, _wrapThunkCallback(this, (err, res)=>{
            if (err) {
                return callback(err);
            }
            const doc = res.value;
            return this._completeOne(doc, res, callback);
        }));
    });
});
/**
 * Support the `new` option as an alternative to `returnOriginal` for backwards
 * compat.
 * @api private
 */ function convertNewToReturnDocument(options) {
    if ("new" in options) {
        options.returnDocument = options["new"] ? "after" : "before";
        delete options["new"];
    }
    if ("returnOriginal" in options) {
        options.returnDocument = options["returnOriginal"] ? "before" : "after";
        delete options["returnOriginal"];
    }
    // Temporary since driver 4.0.0-beta does not support `returnDocument`
    if (typeof options.returnDocument === "string") {
        options.returnOriginal = options.returnDocument === "before";
    }
}
/**
 * Thunk around findOneAndRemove()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @method _findOneAndRemove
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._findOneAndRemove = wrapThunk(function(callback) {
    if (this.error() != null) {
        callback(this.error());
        return;
    }
    this._findAndModify("remove", callback);
});
/**
 * Get options from query opts, falling back to the base mongoose object.
 * @param {Query} query
 * @param {Object} option
 * @param {Any} def
 * @api private
 */ function _getOption(query, option, def) {
    const opts = query._optionsForExec(query.model);
    if (option in opts) {
        return opts[option];
    }
    if (option in query.model.base.options) {
        return query.model.base.options[option];
    }
    return def;
}
/**
 * Override mquery.prototype._findAndModify to provide casting etc.
 *
 * @param {String} type either "remove" or "update"
 * @param {Function} callback
 * @method _findAndModify
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._findAndModify = function(type, callback) {
    if (typeof callback !== "function") {
        throw new Error("Expected callback in _findAndModify");
    }
    const model = this.model;
    const schema = model.schema;
    const _this = this;
    let fields;
    const castedQuery = castQuery(this);
    if (castedQuery instanceof Error) {
        return callback(castedQuery);
    }
    _castArrayFilters(this);
    const opts = this._optionsForExec(model);
    if ("strict" in opts) {
        this._mongooseOptions.strict = opts.strict;
    }
    const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
    if (isOverwriting) {
        this._update = new this.model(this._update, null, true);
    }
    if (type === "remove") {
        opts.remove = true;
    } else {
        if (!("new" in opts) && !("returnOriginal" in opts) && !("returnDocument" in opts)) {
            opts.new = false;
        }
        if (!("upsert" in opts)) {
            opts.upsert = false;
        }
        if (opts.upsert || opts["new"]) {
            opts.remove = false;
        }
        if (!isOverwriting) {
            try {
                this._update = this._castUpdate(this._update, opts.overwrite);
            } catch (err) {
                return callback(err);
            }
            const _opts = Object.assign({}, opts, {
                setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
            });
            this._update = setDefaultsOnInsert(this._conditions, schema, this._update, _opts);
            if (!this._update || Object.keys(this._update).length === 0) {
                if (opts.upsert) {
                    // still need to do the upsert to empty doc
                    const doc = utils.clone(castedQuery);
                    delete doc._id;
                    this._update = {
                        $set: doc
                    };
                } else {
                    this._executionStack = null;
                    this.findOne(callback);
                    return this;
                }
            } else if (this._update instanceof Error) {
                return callback(this._update);
            } else {
                // In order to make MongoDB 2.6 happy (see
                // https://jira.mongodb.org/browse/SERVER-12266 and related issues)
                // if we have an actual update document but $set is empty, junk the $set.
                if (this._update.$set && Object.keys(this._update.$set).length === 0) {
                    delete this._update.$set;
                }
            }
        }
        if (Array.isArray(opts.arrayFilters)) {
            opts.arrayFilters = removeUnusedArrayFilters(this._update, opts.arrayFilters);
        }
    }
    this._applyPaths();
    if (this._fields) {
        fields = utils.clone(this._fields);
        opts.projection = this._castFields(fields);
        if (opts.projection instanceof Error) {
            return callback(opts.projection);
        }
    }
    if (opts.sort) convertSortToArray(opts);
    const cb = function(err, doc, res) {
        if (err) {
            return callback(err);
        }
        _this._completeOne(doc, res, callback);
    };
    const runValidators = _getOption(this, "runValidators", false);
    // Bypass mquery
    const collection = _this._collection.collection;
    convertNewToReturnDocument(opts);
    if (type === "remove") {
        collection.findOneAndDelete(castedQuery, opts, _wrapThunkCallback(_this, function(error, res) {
            return cb(error, res ? res.value : res, res);
        }));
        return this;
    }
    // honors legacy overwrite option for backward compatibility
    const updateMethod = isOverwriting ? "findOneAndReplace" : "findOneAndUpdate";
    if (runValidators) {
        this.validate(this._update, opts, isOverwriting, (error)=>{
            if (error) {
                return callback(error);
            }
            if (this._update && this._update.toBSON) {
                this._update = this._update.toBSON();
            }
            collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error, res) {
                return cb(error, res ? res.value : res, res);
            }));
        });
    } else {
        if (this._update && this._update.toBSON) {
            this._update = this._update.toBSON();
        }
        collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error, res) {
            return cb(error, res ? res.value : res, res);
        }));
    }
    return this;
};
/*!
 * ignore
 */ function _completeOneLean(schema, doc, path, res, opts, callback) {
    if (opts.lean && typeof opts.lean.transform === "function") {
        opts.lean.transform(doc);
        for(let i = 0; i < schema.childSchemas.length; i++){
            const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
            const _schema = schema.childSchemas[i].schema;
            const obj = mpath.get(childPath, doc);
            if (obj == null) {
                continue;
            }
            if (Array.isArray(obj)) {
                for(let i = 0; i < obj.length; i++){
                    opts.lean.transform(obj[i]);
                }
            } else {
                opts.lean.transform(obj);
            }
            _completeOneLean(_schema, obj, childPath, res, opts);
        }
        if (callback) {
            return callback(null, doc);
        } else {
            return;
        }
    }
    if (opts.rawResult) {
        return callback(null, res);
    }
    return callback(null, doc);
}
/*!
 * ignore
 */ function _completeManyLean(schema, docs, path, opts, callback) {
    if (opts.lean && typeof opts.lean.transform === "function") {
        for (const doc of docs){
            opts.lean.transform(doc);
        }
        for(let i = 0; i < schema.childSchemas.length; i++){
            const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
            const _schema = schema.childSchemas[i].schema;
            let doc = mpath.get(childPath, docs);
            if (doc == null) {
                continue;
            }
            doc = doc.flat();
            for(let i = 0; i < doc.length; i++){
                opts.lean.transform(doc[i]);
            }
            _completeManyLean(_schema, doc, childPath, opts);
        }
    }
    if (!callback) {
        return;
    }
    return callback(null, docs);
}
/**
 * Override mquery.prototype._mergeUpdate to handle mongoose objects in
 * updates.
 *
 * @param {Object} doc
 * @method _mergeUpdate
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._mergeUpdate = function(doc) {
    if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
        return;
    }
    if (!this._update) {
        this._update = Array.isArray(doc) ? [] : {};
    }
    if (doc instanceof Query) {
        if (Array.isArray(this._update)) {
            throw new Error("Cannot mix array and object updates");
        }
        if (doc._update) {
            utils.mergeClone(this._update, doc._update);
        }
    } else if (Array.isArray(doc)) {
        if (!Array.isArray(this._update)) {
            throw new Error("Cannot mix array and object updates");
        }
        this._update = this._update.concat(doc);
    } else {
        if (Array.isArray(this._update)) {
            throw new Error("Cannot mix array and object updates");
        }
        utils.mergeClone(this._update, doc);
    }
};
/**
 * The mongodb driver 1.3.23 only supports the nested array sort
 * syntax. We must convert it or sorting findAndModify will not work.
 * @param {Object} opts
 * @param {Array|Object} opts.sort
 * @api private
 */ function convertSortToArray(opts) {
    if (Array.isArray(opts.sort)) {
        return;
    }
    if (!utils.isObject(opts.sort)) {
        return;
    }
    const sort = [];
    for(const key in opts.sort){
        if (utils.object.hasOwnProperty(opts.sort, key)) {
            sort.push([
                key,
                opts.sort[key]
            ]);
        }
    }
    opts.sort = sort;
}
/*!
 * ignore
 */ function _updateThunk(op, callback) {
    this._castConditions();
    _castArrayFilters(this);
    if (this.error() != null) {
        callback(this.error());
        return null;
    }
    callback = _wrapThunkCallback(this, callback);
    const castedQuery = this._conditions;
    const options = this._optionsForExec(this.model);
    this._update = utils.clone(this._update, options);
    const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
    if (isOverwriting) {
        if (op === "updateOne" || op === "updateMany") {
            return callback(new MongooseError("The MongoDB server disallows " + "overwriting documents using `" + op + "`. See: " + "https://mongoosejs.com/docs/deprecations.html#update"));
        }
        this._update = new this.model(this._update, null, true);
    } else {
        try {
            this._update = this._castUpdate(this._update, options.overwrite);
        } catch (err) {
            callback(err);
            return null;
        }
        if (this._update == null || Object.keys(this._update).length === 0) {
            callback(null, {
                acknowledged: false
            });
            return null;
        }
        const _opts = Object.assign({}, options, {
            setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
        });
        this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    }
    if (Array.isArray(options.arrayFilters)) {
        options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
        this.validate(this._update, options, isOverwriting, (err)=>{
            if (err) {
                return callback(err);
            }
            if (this._update.toBSON) {
                this._update = this._update.toBSON();
            }
            this._collection[op](castedQuery, this._update, options, callback);
        });
        return null;
    }
    if (this._update.toBSON) {
        this._update = this._update.toBSON();
    }
    this._collection[op](castedQuery, this._update, options, callback);
    return null;
}
/**
 * Mongoose calls this function internally to validate the query if
 * `runValidators` is set
 *
 * @param {Object} castedDoc the update, after casting
 * @param {Object} options the options from `_optionsForExec()`
 * @param {Boolean} isOverwriting
 * @param {Function} callback
 * @method validate
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype.validate = function validate(castedDoc, options, isOverwriting, callback) {
    return promiseOrCallback(callback, (cb)=>{
        try {
            if (isOverwriting) {
                castedDoc.$validate(cb);
            } else {
                updateValidators(this, this.model.schema, castedDoc, options, cb);
            }
        } catch (err) {
            immediate(function() {
                cb(err);
            });
        }
    });
};
/**
 * Internal thunk for .update()
 *
 * @param {Function} callback
 * @see Model.update #model_Model-update
 * @method _execUpdate
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._execUpdate = wrapThunk(function(callback) {
    return _updateThunk.call(this, "update", callback);
});
/**
 * Internal thunk for .updateMany()
 *
 * @param {Function} callback
 * @see Model.update #model_Model-update
 * @method _updateMany
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._updateMany = wrapThunk(function(callback) {
    return _updateThunk.call(this, "updateMany", callback);
});
/**
 * Internal thunk for .updateOne()
 *
 * @param {Function} callback
 * @see Model.update #model_Model-update
 * @method _updateOne
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._updateOne = wrapThunk(function(callback) {
    return _updateThunk.call(this, "updateOne", callback);
});
/**
 * Internal thunk for .replaceOne()
 *
 * @param {Function} callback
 * @see Model.replaceOne #model_Model-replaceOne
 * @method _replaceOne
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._replaceOne = wrapThunk(function(callback) {
    return _updateThunk.call(this, "replaceOne", callback);
});
/**
 * Declare and/or execute this query as an update() operation.
 *
 * _All paths passed that are not [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operations will become `$set` ops._
 *
 * This function triggers the following middleware.
 *
 * - `update()`
 *
 * #### Example:
 *
 *     Model.where({ _id: id }).update({ title: 'words' });
 *
 *     // becomes
 *
 *     Model.where({ _id: id }).update({ $set: { title: 'words' }});
 *
 * #### Valid options:
 *
 *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)
 *  - `multi` (boolean) whether multiple documents should be updated (false)
 *  - `runValidators` (boolean) if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
 *  - `setDefaultsOnInsert` (boolean) `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.
 *  - `strict` (boolean) overrides the `strict` option for this update
 *  - `read`
 *  - `writeConcern`
 *
 * #### Note:
 *
 * Passing an empty object `{}` as the doc will result in a no-op. The update operation will be ignored and the callback executed without sending the command to MongoDB.
 *
 * #### Note:
 *
 * The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the `exec()` method.
 *
 * ```javascript
 * const q = Model.where({ _id: id });
 * q.update({ $set: { name: 'bob' }}).update(); // not executed
 *
 * q.update({ $set: { name: 'bob' }}).exec(); // executed
 *
 * // keys that are not [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) ops become `$set`.
 * // this executes the same command as the previous example.
 * q.update({ name: 'bob' }).exec();
 *
 * // multi updates
 * Model.where()
 *      .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
 *
 * // more multi updates
 * Model.where()
 *      .setOptions({ multi: true })
 *      .update({ $set: { arr: [] }}, callback)
 *
 * // single update by default
 * Model.where({ email: 'address@example.com' })
 *      .update({ $inc: { counter: 1 }}, callback)
 * ```
 *
 * API summary
 *
 * ```javascript
 * update(filter, doc, options, cb); // executes
 * update(filter, doc, options);
 * update(filter, doc, cb); // executes
 * update(filter, doc);
 * update(doc, cb); // executes
 * update(doc);
 * update(cb); // executes
 * update(true); // executes
 * update();
 * ```
 *
 * @param {Object} [filter]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model-update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update https://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */ Query.prototype.update = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
        // .update(conditions, doc, callback)
        callback = options;
        options = null;
    } else if (typeof doc === "function") {
        // .update(doc, callback);
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
    } else if (typeof conditions === "function") {
        // .update(callback)
        callback = conditions;
        conditions = undefined;
        doc = undefined;
        options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
        // .update(doc)
        doc = conditions;
        conditions = undefined;
        options = undefined;
        callback = undefined;
    }
    return _update(this, "update", conditions, doc, options, callback);
};
/**
 * Declare and/or execute this query as an updateMany() operation. Same as
 * `update()`, except MongoDB will update _all_ documents that match
 * `filter` (as opposed to just the first one) regardless of the value of
 * the `multi` option.
 *
 * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`
 * and `post('updateMany')` instead.
 *
 * #### Example:
 *
 *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });
 *     res.n; // Number of documents matched
 *     res.nModified; // Number of documents modified
 *
 * This function triggers the following middleware.
 *
 * - `updateMany()`
 *
 * @param {Object} [filter]
 * @param {Object|Array} [update] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model-update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update https://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */ Query.prototype.updateMany = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
        // .update(conditions, doc, callback)
        callback = options;
        options = null;
    } else if (typeof doc === "function") {
        // .update(doc, callback);
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
    } else if (typeof conditions === "function") {
        // .update(callback)
        callback = conditions;
        conditions = undefined;
        doc = undefined;
        options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
        // .update(doc)
        doc = conditions;
        conditions = undefined;
        options = undefined;
        callback = undefined;
    }
    return _update(this, "updateMany", conditions, doc, options, callback);
};
/**
 * Declare and/or execute this query as an updateOne() operation. Same as
 * `update()`, except it does not support the `multi` option.
 *
 * - MongoDB will update _only_ the first document that matches `filter` regardless of the value of the `multi` option.
 * - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operators like `$set`.
 *
 * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`
 * and `post('updateOne')` instead.
 *
 * #### Example:
 *
 *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });
 *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.
 *     res.matchedCount; // Number of documents that matched the filter
 *     res.modifiedCount; // Number of documents that were modified
 *     res.upsertedCount; // Number of documents that were upserted
 *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)
 *
 * This function triggers the following middleware.
 *
 * - `updateOne()`
 *
 * @param {Object} [filter]
 * @param {Object|Array} [update] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model-update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update https://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */ Query.prototype.updateOne = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
        // .update(conditions, doc, callback)
        callback = options;
        options = null;
    } else if (typeof doc === "function") {
        // .update(doc, callback);
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
    } else if (typeof conditions === "function") {
        // .update(callback)
        callback = conditions;
        conditions = undefined;
        doc = undefined;
        options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
        // .update(doc)
        doc = conditions;
        conditions = undefined;
        options = undefined;
        callback = undefined;
    }
    return _update(this, "updateOne", conditions, doc, options, callback);
};
/**
 * Declare and/or execute this query as a replaceOne() operation. Same as
 * `update()`, except MongoDB will replace the existing document and will
 * not accept any [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operators (`$set`, etc.)
 *
 * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`
 * and `post('replaceOne')` instead.
 *
 * #### Example:
 *
 *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });
 *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.
 *     res.matchedCount; // Number of documents that matched the filter
 *     res.modifiedCount; // Number of documents that were modified
 *     res.upsertedCount; // Number of documents that were upserted
 *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)
 *
 * This function triggers the following middleware.
 *
 * - `replaceOne()`
 *
 * @param {Object} [filter]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document
 * @param {Object} [options.writeConcern=null] sets the [write concern](https://docs.mongodb.com/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.
 * @param {Function} [callback] params are (error, writeOpResult)
 * @return {Query} this
 * @see Model.update #model_Model-update
 * @see Query docs https://mongoosejs.com/docs/queries.html
 * @see update https://docs.mongodb.org/manual/reference/method/db.collection.update/
 * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/command/update/#update-command-output
 * @api public
 */ Query.prototype.replaceOne = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
        // .update(conditions, doc, callback)
        callback = options;
        options = null;
    } else if (typeof doc === "function") {
        // .update(doc, callback);
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
    } else if (typeof conditions === "function") {
        // .update(callback)
        callback = conditions;
        conditions = undefined;
        doc = undefined;
        options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
        // .update(doc)
        doc = conditions;
        conditions = undefined;
        options = undefined;
        callback = undefined;
    }
    this.setOptions({
        overwrite: true
    });
    return _update(this, "replaceOne", conditions, doc, options, callback);
};
/**
 * Internal helper for update, updateMany, updateOne, replaceOne
 * @param {Query} query
 * @param {String} op
 * @param {Object} filter
 * @param {Document} [doc]
 * @param {Object} [options]
 * @param {Function} callback
 * @api private
 */ function _update(query, op, filter, doc, options, callback) {
    // make sure we don't send in the whole Document to merge()
    query.op = op;
    query._validateOp();
    filter = utils.toObject(filter);
    doc = doc || {};
    // strict is an option used in the update checking, make sure it gets set
    if (options != null) {
        if ("strict" in options) {
            query._mongooseOptions.strict = options.strict;
        }
    }
    if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
        query.error(new ObjectParameterError(filter, "filter", op));
    } else {
        query.merge(filter);
    }
    if (utils.isObject(options)) {
        query.setOptions(options);
    }
    query._mergeUpdate(doc);
    // Hooks
    if (callback) {
        query.exec(callback);
        return query;
    }
    return Query.base[op].call(query, filter, void 0, options, callback);
}
/**
 * Runs a function `fn` and treats the return value of `fn` as the new value
 * for the query to resolve to.
 *
 * Any functions you pass to `transform()` will run **after** any post hooks.
 *
 * #### Example:
 *
 *     const res = await MyModel.findOne().transform(res => {
 *       // Sets a `loadedAt` property on the doc that tells you the time the
 *       // document was loaded.
 *       return res == null ?
 *         res :
 *         Object.assign(res, { loadedAt: new Date() });
 *     });
 *
 * @method transform
 * @memberOf Query
 * @instance
 * @param {Function} fn function to run to transform the query result
 * @return {Query} this
 */ Query.prototype.transform = function(fn) {
    this._transforms.push(fn);
    return this;
};
/**
 * Make this query throw an error if no documents match the given `filter`.
 * This is handy for integrating with async/await, because `orFail()` saves you
 * an extra `if` statement to check if no document was found.
 *
 * #### Example:
 *
 *     // Throws if no doc returned
 *     await Model.findOne({ foo: 'bar' }).orFail();
 *
 *     // Throws if no document was updated. Note that `orFail()` will still
 *     // throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,
 *     // because `orFail()` will throw if no document was _updated_, not
 *     // if no document was _found_.
 *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();
 *
 *     // Throws "No docs found!" error if no docs match `{ foo: 'bar' }`
 *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));
 *
 *     // Throws "Not found" error if no document was found
 *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).
 *       orFail(() => Error('Not found'));
 *
 * @method orFail
 * @memberOf Query
 * @instance
 * @param {Function|Error} [err] optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`
 * @return {Query} this
 */ Query.prototype.orFail = function(err) {
    this.transform((res)=>{
        switch(this.op){
            case "find":
                if (res.length === 0) {
                    throw _orFailError(err, this);
                }
                break;
            case "findOne":
                if (res == null) {
                    throw _orFailError(err, this);
                }
                break;
            case "replaceOne":
            case "update":
            case "updateMany":
            case "updateOne":
                if (res && res.modifiedCount === 0) {
                    throw _orFailError(err, this);
                }
                break;
            case "findOneAndDelete":
            case "findOneAndRemove":
                if ((res && res.lastErrorObject && res.lastErrorObject.n) === 0) {
                    throw _orFailError(err, this);
                }
                break;
            case "findOneAndUpdate":
            case "findOneAndReplace":
                if ((res && res.lastErrorObject && res.lastErrorObject.updatedExisting) === false) {
                    throw _orFailError(err, this);
                }
                break;
            case "deleteMany":
            case "deleteOne":
            case "remove":
                if (res.deletedCount === 0) {
                    throw _orFailError(err, this);
                }
                break;
            default:
                break;
        }
        return res;
    });
    return this;
};
/**
 * Get the error to throw for `orFail()`
 * @param {Error|undefined} err
 * @param {Query} query
 * @api private
 */ function _orFailError(err, query) {
    if (typeof err === "function") {
        err = err.call(query);
    }
    if (err == null) {
        err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
    }
    return err;
}
/**
 * Executes the query
 *
 * #### Example:
 *
 *     const promise = query.exec();
 *     const promise = query.exec('update');
 *
 *     query.exec(callback);
 *     query.exec('find', callback);
 *
 * @param {String|Function} [operation]
 * @param {Function} [callback] optional params depend on the function being called
 * @return {Promise}
 * @api public
 */ Query.prototype.exec = function exec(op, callback) {
    const _this = this;
    // Ensure that `exec()` is the first thing that shows up in
    // the stack when cast errors happen.
    const castError = new CastError();
    if (typeof op === "function") {
        callback = op;
        op = null;
    } else if (typeof op === "string") {
        this.op = op;
    }
    if (this.op == null) {
        throw new Error("Query must have `op` before executing");
    }
    this._validateOp();
    callback = this.model.$handleCallbackError(callback);
    return promiseOrCallback(callback, (cb)=>{
        cb = this.model.$wrapCallback(cb);
        if (!_this.op) {
            cb();
            return;
        }
        this._hooks.execPre("exec", this, [], (error)=>{
            if (error != null) {
                return cb(_cleanCastErrorStack(castError, error));
            }
            let thunk = "_" + this.op;
            if (this.op === "update") {
                thunk = "_execUpdate";
            } else if (this.op === "distinct") {
                thunk = "__distinct";
            }
            this[thunk].call(this, (error, res)=>{
                if (error) {
                    return cb(_cleanCastErrorStack(castError, error));
                }
                this._hooks.execPost("exec", this, [], {}, (error)=>{
                    if (error) {
                        return cb(_cleanCastErrorStack(castError, error));
                    }
                    cb(null, res);
                });
            });
        });
    }, this.model.events);
};
/*!
 * ignore
 */ function _cleanCastErrorStack(castError, error) {
    if (error instanceof CastError) {
        castError.copy(error);
        return castError;
    }
    return error;
}
/*!
 * ignore
 */ function _wrapThunkCallback(query, cb) {
    return function(error, res) {
        if (error != null) {
            return cb(error);
        }
        for (const fn of query._transforms){
            try {
                res = fn(res);
            } catch (error) {
                return cb(error);
            }
        }
        return cb(null, res);
    };
}
/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 *
 * More about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).
 *
 * @param {Function} [resolve]
 * @param {Function} [reject]
 * @return {Promise}
 * @api public
 */ Query.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
};
/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 * Like `.then()`, but only takes a rejection handler.
 *
 * More about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).
 *
 * @param {Function} [reject]
 * @return {Promise}
 * @api public
 */ Query.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
};
/**
 * Add pre [middleware](/docs/middleware.html) to this query instance. Doesn't affect
 * other queries.
 *
 * #### Example:
 *
 *     const q1 = Question.find({ answer: 42 });
 *     q1.pre(function middleware() {
 *       console.log(this.getFilter());
 *     });
 *     await q1.exec(); // Prints "{ answer: 42 }"
 *
 *     // Doesn't print anything, because `middleware()` is only
 *     // registered on `q1`.
 *     await Question.find({ answer: 42 });
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */ Query.prototype.pre = function(fn) {
    this._hooks.pre("exec", fn);
    return this;
};
/**
 * Add post [middleware](/docs/middleware.html) to this query instance. Doesn't affect
 * other queries.
 *
 * #### Example:
 *
 *     const q1 = Question.find({ answer: 42 });
 *     q1.post(function middleware() {
 *       console.log(this.getFilter());
 *     });
 *     await q1.exec(); // Prints "{ answer: 42 }"
 *
 *     // Doesn't print anything, because `middleware()` is only
 *     // registered on `q1`.
 *     await Question.find({ answer: 42 });
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */ Query.prototype.post = function(fn) {
    this._hooks.post("exec", fn);
    return this;
};
/**
 * Casts obj for an update command.
 *
 * @param {Object} obj
 * @param {Boolean} overwrite
 * @return {Object} obj after casting its values
 * @method _castUpdate
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
    if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
        const _schema = Object.values(baseSchema.discriminators).find((discriminator)=>discriminator.discriminatorMapping.value === obj[discriminatorKey]);
        if (_schema != null) {
            schema = _schema;
        }
    }
    let upsert;
    if ("upsert" in this.options) {
        upsert = this.options.upsert;
    }
    const filter = this._conditions;
    if (schema != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
        const discriminatorValue = filter[schema.options.discriminatorKey];
        const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);
        schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    }
    return castUpdate(schema, obj, {
        overwrite: overwrite,
        strict: this._mongooseOptions.strict,
        upsert: upsert,
        arrayFilters: this.options.arrayFilters,
        overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey
    }, this, this._conditions);
};
/**
 * castQuery
 * @api private
 */ function castQuery(query) {
    try {
        return query.cast(query.model);
    } catch (err) {
        return err;
    }
}
/**
 * Specifies paths which should be populated with other documents.
 *
 * #### Example:
 *
 *     let book = await Book.findOne().populate('authors');
 *     book.title; // 'Node.js in Action'
 *     book.authors[0].name; // 'TJ Holowaychuk'
 *     book.authors[1].name; // 'Nathan Rajlich'
 *
 *     let books = await Book.find().populate({
 *       path: 'authors',
 *       // `match` and `sort` apply to the Author model,
 *       // not the Book model. These options do not affect
 *       // which documents are in `books`, just the order and
 *       // contents of each book document's `authors`.
 *       match: { name: new RegExp('.*h.*', 'i') },
 *       sort: { name: -1 }
 *     });
 *     books[0].title; // 'Node.js in Action'
 *     // Each book's `authors` are sorted by name, descending.
 *     books[0].authors[0].name; // 'TJ Holowaychuk'
 *     books[0].authors[1].name; // 'Marc Harter'
 *
 *     books[1].title; // 'Professional AngularJS'
 *     // Empty array, no authors' name has the letter 'h'
 *     books[1].authors; // []
 *
 * Paths are populated after the query executes and a response is received. A
 * separate query is then executed for each path specified for population. After
 * a response for each query has also been returned, the results are passed to
 * the callback.
 *
 * @param {Object|String|String[]} path either the path(s) to populate or an object specifying all parameters
 * @param {Object|String} [select] Field selection for the population query
 * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
 * @param {Object} [match] Conditions for the population query
 * @param {Object} [options] Options for the population query (sort, etc)
 * @param {String} [options.path=null] The path to populate.
 * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.
 * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).
 * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.
 * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://docs.mongodb.com/manual/tutorial/query-documents/), or a function that returns a filter object.
 * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.
 * @param {Object} [options.options=null] Additional options like `limit` and `lean`.
 * @see population /docs/populate
 * @see Query#select #query_Query-select
 * @see Model.populate #model_Model-populate
 * @return {Query} this
 * @api public
 */ Query.prototype.populate = function() {
    // Bail when given no truthy arguments
    if (!Array.from(arguments).some(Boolean)) {
        return this;
    }
    const res = utils.populate.apply(null, arguments);
    // Propagate readConcern and readPreference and lean from parent query,
    // unless one already specified
    if (this.options != null) {
        const readConcern = this.options.readConcern;
        const readPref = this.options.readPreference;
        for (const populateOptions of res){
            if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {
                populateOptions.options = populateOptions.options || {};
                populateOptions.options.readConcern = readConcern;
            }
            if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {
                populateOptions.options = populateOptions.options || {};
                populateOptions.options.readPreference = readPref;
            }
        }
    }
    const opts = this._mongooseOptions;
    if (opts.lean != null) {
        const lean = opts.lean;
        for (const populateOptions of res){
            if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {
                populateOptions.options = populateOptions.options || {};
                populateOptions.options.lean = lean;
            }
        }
    }
    if (!utils.isObject(opts.populate)) {
        opts.populate = {};
    }
    const pop = opts.populate;
    for (const populateOptions of res){
        const path = populateOptions.path;
        if (pop[path] && pop[path].populate && populateOptions.populate) {
            populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
        }
        pop[populateOptions.path] = populateOptions;
    }
    return this;
};
/**
 * Gets a list of paths to be populated by this query
 *
 * #### Example:
 *
 *      bookSchema.pre('findOne', function() {
 *        let keys = this.getPopulatedPaths(); // ['author']
 *      });
 *      ...
 *      Book.findOne({}).populate('author');
 *
 * #### Example:
 *
 *      // Deep populate
 *      const q = L1.find().populate({
 *        path: 'level2',
 *        populate: { path: 'level3' }
 *      });
 *      q.getPopulatedPaths(); // ['level2', 'level2.level3']
 *
 * @return {Array} an array of strings representing populated paths
 * @api public
 */ Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
    const obj = this._mongooseOptions.populate || {};
    const ret = Object.keys(obj);
    for (const path of Object.keys(obj)){
        const pop = obj[path];
        if (!Array.isArray(pop.populate)) {
            continue;
        }
        _getPopulatedPaths(ret, pop.populate, path + ".");
    }
    return ret;
};
/*!
 * ignore
 */ function _getPopulatedPaths(list, arr, prefix) {
    for (const pop of arr){
        list.push(prefix + pop.path);
        if (!Array.isArray(pop.populate)) {
            continue;
        }
        _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
    }
}
/**
 * Casts this query to the schema of `model`
 *
 * #### Note:
 *
 * If `obj` is present, it is cast instead of this query.
 *
 * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`
 * @param {Object} [obj]
 * @return {Object}
 * @api public
 */ Query.prototype.cast = function(model, obj) {
    obj || (obj = this._conditions);
    model = model || this.model;
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
    }
    const opts = {
        upsert: this.options && this.options.upsert
    };
    if (this.options) {
        if ("strict" in this.options) {
            opts.strict = this.options.strict;
            opts.strictQuery = opts.strict;
        }
        if ("strictQuery" in this.options) {
            opts.strictQuery = this.options.strictQuery;
        }
    }
    try {
        return cast(model.schema, obj, opts, this);
    } catch (err) {
        // CastError, assign model
        if (typeof err.setModel === "function") {
            err.setModel(model);
        }
        throw err;
    }
};
/**
 * Casts selected field arguments for field selection with mongo 2.2
 *
 *     query.select({ ids: { $elemMatch: { $in: [hexString] }})
 *
 * @param {Object} fields
 * @see https://github.com/Automattic/mongoose/issues/1091
 * @see https://docs.mongodb.org/manual/reference/projection/elemMatch/
 * @api private
 */ Query.prototype._castFields = function _castFields(fields) {
    let selected, elemMatchKeys, keys, key, out, i;
    if (fields) {
        keys = Object.keys(fields);
        elemMatchKeys = [];
        i = keys.length;
        // collect $elemMatch args
        while(i--){
            key = keys[i];
            if (fields[key].$elemMatch) {
                selected || (selected = {});
                selected[key] = fields[key];
                elemMatchKeys.push(key);
            }
        }
    }
    if (selected) {
        // they passed $elemMatch, cast em
        try {
            out = this.cast(this.model, selected);
        } catch (err) {
            return err;
        }
        // apply the casted field args
        i = elemMatchKeys.length;
        while(i--){
            key = elemMatchKeys[i];
            fields[key] = out[key];
        }
    }
    return fields;
};
/**
 * Applies schematype selected options to this query.
 * @api private
 */ Query.prototype._applyPaths = function applyPaths() {
    this._fields = this._fields || {};
    helpers.applyPaths(this._fields, this.model.schema);
    let _selectPopulatedPaths = true;
    if ("selectPopulatedPaths" in this.model.base.options) {
        _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
    }
    if ("selectPopulatedPaths" in this.model.schema.options) {
        _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
    }
    if (_selectPopulatedPaths) {
        selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
    }
};
/**
 * Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html).
 * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.
 *
 * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.
 *
 * #### Example:
 *
 *     // There are 2 ways to use a cursor. First, as a stream:
 *     Thing.
 *       find({ name: /^hello/ }).
 *       cursor().
 *       on('data', function(doc) { console.log(doc); }).
 *       on('end', function() { console.log('Done!'); });
 *
 *     // Or you can use `.next()` to manually get the next doc in the stream.
 *     // `.next()` returns a promise, so you can use promises or callbacks.
 *     const cursor = Thing.find({ name: /^hello/ }).cursor();
 *     cursor.next(function(error, doc) {
 *       console.log(doc);
 *     });
 *
 *     // Because `.next()` returns a promise, you can use co
 *     // to easily iterate through all documents without loading them
 *     // all into memory.
 *     const cursor = Thing.find({ name: /^hello/ }).cursor();
 *     for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {
 *       console.log(doc);
 *     }
 *
 * #### Valid options
 *
 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.
 *
 * @return {QueryCursor}
 * @param {Object} [options]
 * @see QueryCursor /docs/api/querycursor
 * @api public
 */ Query.prototype.cursor = function cursor(opts) {
    this._applyPaths();
    this._fields = this._castFields(this._fields);
    this.setOptions({
        projection: this._fieldsForExec()
    });
    if (opts) {
        this.setOptions(opts);
    }
    const options = Object.assign({}, this._optionsForExec(), {
        projection: this.projection()
    });
    try {
        this.cast(this.model);
    } catch (err) {
        return new QueryCursor(this, options)._markError(err);
    }
    return new QueryCursor(this, options);
};
// the rest of these are basically to support older Mongoose syntax with mquery
/**
 * _DEPRECATED_ Alias of `maxScan`
 *
 * @deprecated
 * @see maxScan #query_Query-maxScan
 * @method maxscan
 * @memberOf Query
 * @instance
 */ Query.prototype.maxscan = Query.base.maxScan;
/**
 * Sets the tailable option (for use with capped collections).
 *
 * #### Example:
 *
 *     query.tailable(); // true
 *     query.tailable(true);
 *     query.tailable(false);
 *
 *     // Set both `tailable` and `awaitData` options
 *     query.tailable({ awaitData: true });
 *
 * #### Note:
 *
 * Cannot be used with `distinct()`
 *
 * @param {Boolean} bool defaults to true
 * @param {Object} [opts] options to set
 * @param {Boolean} [opts.awaitData] false by default. Set to true to keep the cursor open even if there's no data.
 * @param {Number} [opts.maxAwaitTimeMS] the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true
 * @see tailable https://docs.mongodb.org/manual/tutorial/create-tailable-cursor/
 * @api public
 */ Query.prototype.tailable = function(val, opts) {
    // we need to support the tailable({ awaitData : true }) as well as the
    // tailable(true, {awaitData :true}) syntax that mquery does not support
    if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
        opts = val;
        val = true;
    }
    if (val === undefined) {
        val = true;
    }
    if (opts && typeof opts === "object") {
        for (const key of Object.keys(opts)){
            if (key === "awaitData" || key === "awaitdata") {
                // For backwards compatibility
                this.options["awaitData"] = !!opts[key];
            } else {
                this.options[key] = opts[key];
            }
        }
    }
    return Query.base.tailable.call(this, val);
};
/**
 * Declares an intersects query for `geometry()`.
 *
 * #### Example:
 *
 *     query.where('path').intersects().geometry({
 *       type: 'LineString',
 *       coordinates: [[180.0, 11.0], [180, 9.0]]
 *     });
 *
 *     query.where('path').intersects({
 *       type: 'LineString',
 *       coordinates: [[180.0, 11.0], [180, 9.0]]
 *     });
 *
 * #### Note:
 *
 * **MUST** be used after `where()`.
 *
 * #### Note:
 *
 * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
 *
 * @method intersects
 * @memberOf Query
 * @instance
 * @param {Object} [arg]
 * @return {Query} this
 * @see $geometry https://docs.mongodb.org/manual/reference/operator/geometry/
 * @see geoIntersects https://docs.mongodb.org/manual/reference/operator/geoIntersects/
 * @api public
 */ /**
 * Specifies a `$geometry` condition
 *
 * #### Example:
 *
 *     const polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
 *
 *     // or
 *     const polyB = [[ 0, 0 ], [ 1, 1 ]]
 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
 *
 *     // or
 *     const polyC = [ 0, 0 ]
 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
 *
 *     // or
 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
 *
 * The argument is assigned to the most recent path passed to `where()`.
 *
 * #### Note:
 *
 * `geometry()` **must** come after either `intersects()` or `within()`.
 *
 * The `object` argument must contain `type` and `coordinates` properties.
 * - type {String}
 * - coordinates {Array}
 *
 * @method geometry
 * @memberOf Query
 * @instance
 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
 * @return {Query} this
 * @see $geometry https://docs.mongodb.org/manual/reference/operator/geometry/
 * @see Geospatial Support Enhancements https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements
 * @see MongoDB Geospatial Indexing https://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ /**
 * Specifies a `$near` or `$nearSphere` condition
 *
 * These operators return documents sorted by distance.
 *
 * #### Example:
 *
 *     query.where('loc').near({ center: [10, 10] });
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
 *
 * @method near
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Object} val
 * @return {Query} this
 * @see $near https://docs.mongodb.org/manual/reference/operator/near/
 * @see $nearSphere https://docs.mongodb.org/manual/reference/operator/nearSphere/
 * @see $maxDistance https://docs.mongodb.org/manual/reference/operator/maxDistance/
 * @see MongoDB Geospatial Indexing https://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ /**
 * Overwriting mquery is needed to support a couple different near() forms found in older
 * versions of mongoose
 * near([1,1])
 * near(1,1)
 * near(field, [1,2])
 * near(field, 1, 2)
 * In addition to all of the normal forms supported by mquery
 *
 * @method near
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype.near = function() {
    const params = [];
    const sphere = this._mongooseOptions.nearSphere;
    // TODO refactor
    if (arguments.length === 1) {
        if (Array.isArray(arguments[0])) {
            params.push({
                center: arguments[0],
                spherical: sphere
            });
        } else if (typeof arguments[0] === "string") {
            // just passing a path
            params.push(arguments[0]);
        } else if (utils.isObject(arguments[0])) {
            if (typeof arguments[0].spherical !== "boolean") {
                arguments[0].spherical = sphere;
            }
            params.push(arguments[0]);
        } else {
            throw new TypeError("invalid argument");
        }
    } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
            params.push({
                center: [
                    arguments[0],
                    arguments[1]
                ],
                spherical: sphere
            });
        } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
            params.push(arguments[0]);
            params.push({
                center: arguments[1],
                spherical: sphere
            });
        } else if (typeof arguments[0] === "string" && utils.isObject(arguments[1])) {
            params.push(arguments[0]);
            if (typeof arguments[1].spherical !== "boolean") {
                arguments[1].spherical = sphere;
            }
            params.push(arguments[1]);
        } else {
            throw new TypeError("invalid argument");
        }
    } else if (arguments.length === 3) {
        if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
            params.push(arguments[0]);
            params.push({
                center: [
                    arguments[1],
                    arguments[2]
                ],
                spherical: sphere
            });
        } else {
            throw new TypeError("invalid argument");
        }
    } else {
        throw new TypeError("invalid argument");
    }
    return Query.base.near.apply(this, params);
};
/**
 * _DEPRECATED_ Specifies a `$nearSphere` condition
 *
 * #### Example:
 *
 *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });
 *
 * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.
 *
 * #### Example:
 *
 *     query.where('loc').near({ center: [10, 10], spherical: true });
 *
 * @deprecated
 * @see near() #query_Query-near
 * @see $near https://docs.mongodb.org/manual/reference/operator/near/
 * @see $nearSphere https://docs.mongodb.org/manual/reference/operator/nearSphere/
 * @see $maxDistance https://docs.mongodb.org/manual/reference/operator/maxDistance/
 */ Query.prototype.nearSphere = function() {
    this._mongooseOptions.nearSphere = true;
    this.near.apply(this, arguments);
    return this;
};
/**
 * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)
 * This function *only* works for `find()` queries.
 * You do not need to call this function explicitly, the JavaScript runtime
 * will call it for you.
 *
 * #### Example:
 *
 *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {
 *       console.log(doc.name);
 *     }
 *
 * Node.js 10.x supports async iterators natively without any flags. You can
 * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).
 *
 * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If
 * `Symbol.asyncIterator` is undefined, that means your Node.js version does not
 * support async iterators.
 *
 * @method Symbol.asyncIterator
 * @memberOf Query
 * @instance
 * @api public
 */ if (Symbol.asyncIterator != null) {
    Query.prototype[Symbol.asyncIterator] = function() {
        return this.cursor().transformNull()._transformForAsyncIterator();
    };
}
/**
 * Specifies a `$polygon` condition
 *
 * #### Example:
 *
 *     query.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);
 *     query.polygon('loc', [10, 20], [13, 25], [7, 15]);
 *
 * @method polygon
 * @memberOf Query
 * @instance
 * @param {String|Array} [path]
 * @param {Array|Object} [coordinatePairs...]
 * @return {Query} this
 * @see $polygon https://docs.mongodb.org/manual/reference/operator/polygon/
 * @see MongoDB Geospatial Indexing https://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ /**
 * Specifies a `$box` condition
 *
 * #### Example:
 *
 *     const lowerLeft = [40.73083, -73.99756]
 *     const upperRight= [40.741404,  -73.988135]
 *
 *     query.where('loc').within().box(lowerLeft, upperRight)
 *     query.box({ ll : lowerLeft, ur : upperRight })
 *
 * @method box
 * @memberOf Query
 * @instance
 * @see $box https://docs.mongodb.org/manual/reference/operator/box/
 * @see within() Query#within #query_Query-within
 * @see MongoDB Geospatial Indexing https://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @param {Object|Array<Number>} val1 Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates
 * @param {Array<Number>} [val2] Upper Right Coordinates
 * @return {Query} this
 * @api public
 */ /**
 * this is needed to support the mongoose syntax of:
 * box(field, { ll : [x,y], ur : [x2,y2] })
 * box({ ll : [x,y], ur : [x2,y2] })
 *
 * @method box
 * @memberOf Query
 * @instance
 * @api private
 */ Query.prototype.box = function(ll, ur) {
    if (!Array.isArray(ll) && utils.isObject(ll)) {
        ur = ll.ur;
        ll = ll.ll;
    }
    return Query.base.box.call(this, ll, ur);
};
/**
 * Specifies a `$center` or `$centerSphere` condition.
 *
 * #### Example:
 *
 *     const area = { center: [50, 50], radius: 10, unique: true }
 *     query.where('loc').within().circle(area)
 *     // alternatively
 *     query.circle('loc', area);
 *
 *     // spherical calculations
 *     const area = { center: [50, 50], radius: 10, unique: true, spherical: true }
 *     query.where('loc').within().circle(area)
 *     // alternatively
 *     query.circle('loc', area);
 *
 * @method circle
 * @memberOf Query
 * @instance
 * @param {String} [path]
 * @param {Object} area
 * @return {Query} this
 * @see $center https://docs.mongodb.org/manual/reference/operator/center/
 * @see $centerSphere https://docs.mongodb.org/manual/reference/operator/centerSphere/
 * @see $geoWithin https://docs.mongodb.org/manual/reference/operator/geoWithin/
 * @see MongoDB Geospatial Indexing https://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ /**
 * _DEPRECATED_ Alias for [circle](#query_Query-circle)
 *
 * **Deprecated.** Use [circle](#query_Query-circle) instead.
 *
 * @deprecated
 * @method center
 * @memberOf Query
 * @instance
 * @api public
 */ Query.prototype.center = Query.base.circle;
/**
 * _DEPRECATED_ Specifies a `$centerSphere` condition
 *
 * **Deprecated.** Use [circle](#query_Query-circle) instead.
 *
 * #### Example:
 *
 *     const area = { center: [50, 50], radius: 10 };
 *     query.where('loc').within().centerSphere(area);
 *
 * @deprecated
 * @param {String} [path]
 * @param {Object} val
 * @return {Query} this
 * @see MongoDB Geospatial Indexing https://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see $centerSphere https://docs.mongodb.org/manual/reference/operator/centerSphere/
 * @api public
 */ Query.prototype.centerSphere = function() {
    if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
        arguments[0].spherical = true;
    }
    if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
        arguments[1].spherical = true;
    }
    Query.base.circle.apply(this, arguments);
};
/**
 * Determines if field selection has been made.
 *
 * @method selected
 * @memberOf Query
 * @instance
 * @return {Boolean}
 * @api public
 */ /**
 * Determines if inclusive field selection has been made.
 *
 *     query.selectedInclusively(); // false
 *     query.select('name');
 *     query.selectedInclusively(); // true
 *
 * @method selectedInclusively
 * @memberOf Query
 * @instance
 * @return {Boolean}
 * @api public
 */ Query.prototype.selectedInclusively = function selectedInclusively() {
    return isInclusive(this._fields);
};
/**
 * Determines if exclusive field selection has been made.
 *
 *     query.selectedExclusively(); // false
 *     query.select('-name');
 *     query.selectedExclusively(); // true
 *     query.selectedInclusively(); // false
 *
 * @method selectedExclusively
 * @memberOf Query
 * @instance
 * @return {Boolean}
 * @api public
 */ Query.prototype.selectedExclusively = function selectedExclusively() {
    return isExclusive(this._fields);
};
/**
 * The model this query is associated with.
 *
 * #### Example:
 *
 *     const q = MyModel.find();
 *     q.model === MyModel; // true
 *
 * @api public
 * @property model
 * @memberOf Query
 * @instance
 */ Query.prototype.model;
/*!
 * Export
 */ module.exports = Query;


/***/ }),

/***/ 83524:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies
 */ const checkEmbeddedDiscriminatorKeyProjection = __webpack_require__(72176);
const get = __webpack_require__(39223);
const getDiscriminatorByValue = __webpack_require__(17492);
const isDefiningProjection = __webpack_require__(5281);
const clone = __webpack_require__(99889);
/**
 * Prepare a set of path options for query population.
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */ exports.preparePopulationOptions = function preparePopulationOptions(query, options) {
    const _populate = query.options.populate;
    const pop = Object.keys(_populate).reduce((vals, key)=>vals.concat([
            _populate[key]
        ]), []);
    // lean options should trickle through all queries
    if (options.lean != null) {
        pop.filter((p)=>(p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
    }
    pop.forEach((opts)=>{
        opts._localModel = query.model;
    });
    return pop;
};
/**
 * Prepare a set of path options for query population. This is the MongooseQuery
 * version
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */ exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
    const _populate = query._mongooseOptions.populate;
    const pop = Object.keys(_populate).reduce((vals, key)=>vals.concat([
            _populate[key]
        ]), []);
    // lean options should trickle through all queries
    if (options.lean != null) {
        pop.filter((p)=>(p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
    }
    const session = query && query.options && query.options.session || null;
    if (session != null) {
        pop.forEach((path)=>{
            if (path.options == null) {
                path.options = {
                    session: session
                };
                return;
            }
            if (!("session" in path.options)) {
                path.options.session = session;
            }
        });
    }
    const projection = query._fieldsForExec();
    pop.forEach((p)=>{
        p._queryProjection = projection;
    });
    pop.forEach((opts)=>{
        opts._localModel = query.model;
    });
    return pop;
};
/**
 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
 * it returns an instance of the given model.
 *
 * @param {Model}  model
 * @param {Object} doc
 * @param {Object} fields
 *
 * @return {Document}
 */ exports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
    model.hooks.execPreSync("createModel", doc);
    const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
    const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
    const value = doc[key];
    if (key && value && model.discriminators) {
        const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
        if (discriminator) {
            const _fields = clone(userProvidedFields);
            exports.applyPaths(_fields, discriminator.schema);
            return new discriminator(undefined, _fields, true);
        }
    }
    const _opts = {
        skipId: true,
        isNew: false,
        willInit: true
    };
    if (options != null && "defaults" in options) {
        _opts.defaults = options.defaults;
    }
    return new model(undefined, fields, _opts);
};
/*!
 * ignore
 */ exports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {
    const initOpts = populatedIds ? {
        populated: populatedIds
    } : undefined;
    const casted = exports.createModel(model, doc, fields, userProvidedFields, options);
    try {
        casted.$init(doc, initOpts, callback);
    } catch (error) {
        callback(error, casted);
    }
};
/*!
 * ignore
 */ exports.applyPaths = function applyPaths(fields, schema) {
    // determine if query is selecting or excluding fields
    let exclude;
    let keys;
    let keyIndex;
    if (fields) {
        keys = Object.keys(fields);
        keyIndex = keys.length;
        while(keyIndex--){
            if (keys[keyIndex][0] === "+") {
                continue;
            }
            const field = fields[keys[keyIndex]];
            // Skip `$meta` and `$slice`
            if (!isDefiningProjection(field)) {
                continue;
            }
            // `_id: 1, name: 0` is a mixed inclusive/exclusive projection in
            // MongoDB 4.0 and earlier, but not in later versions.
            if (keys[keyIndex] === "_id" && keys.length > 1) {
                continue;
            }
            exclude = !field;
            break;
        }
    }
    // if selecting, apply default schematype select:true fields
    // if excluding, apply schematype select:false fields
    const selected = [];
    const excluded = [];
    const stack = [];
    analyzeSchema(schema);
    switch(exclude){
        case true:
            for (const fieldName of excluded){
                fields[fieldName] = 0;
            }
            break;
        case false:
            if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
                fields._id = 0;
            }
            for (const fieldName of selected){
                fields[fieldName] = fields[fieldName] || 1;
            }
            break;
        case undefined:
            if (fields == null) {
                break;
            }
            // Any leftover plus paths must in the schema, so delete them (gh-7017)
            for (const key of Object.keys(fields || {})){
                if (key.startsWith("+")) {
                    delete fields[key];
                }
            }
            // user didn't specify fields, implies returning all fields.
            // only need to apply excluded fields and delete any plus paths
            for (const fieldName of excluded){
                if (fields[fieldName] != null) {
                    continue;
                }
                fields[fieldName] = 0;
            }
            break;
    }
    function analyzeSchema(schema, prefix) {
        prefix || (prefix = "");
        // avoid recursion
        if (stack.indexOf(schema) !== -1) {
            return [];
        }
        stack.push(schema);
        const addedPaths = [];
        schema.eachPath(function(path, type) {
            if (prefix) path = prefix + "." + path;
            if (type.$isSchemaMap || path.endsWith(".$*")) {
                const plusPath = "+" + path;
                const hasPlusPath = fields && plusPath in fields;
                if (type.options && type.options.select === false && !hasPlusPath) {
                    excluded.push(path);
                }
                return;
            }
            let addedPath = analyzePath(path, type);
            // arrays
            if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
                addedPath = analyzePath(path, type.caster);
            }
            if (addedPath != null) {
                addedPaths.push(addedPath);
            }
            // nested schemas
            if (type.schema) {
                const _addedPaths = analyzeSchema(type.schema, path);
                // Special case: if discriminator key is the only field that would
                // be projected in, remove it.
                if (exclude === false) {
                    checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
                }
            }
        });
        stack.pop();
        return addedPaths;
    }
    function analyzePath(path, type) {
        const plusPath = "+" + path;
        const hasPlusPath = fields && plusPath in fields;
        if (hasPlusPath) {
            // forced inclusion
            delete fields[plusPath];
        }
        if (typeof type.selected !== "boolean") {
            return;
        }
        // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,
        // because we have tests that assert that using `-path` to exclude schema-level `select: true`
        // fields counts as an exclusive projection. See gh-11546
        if (exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {
            delete fields[path];
            return;
        }
        if (hasPlusPath) {
            // forced inclusion
            delete fields[plusPath];
            // if there are other fields being included, add this one
            // if no other included fields, leave this out (implied inclusion)
            if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
                fields[path] = 1;
            }
            return;
        }
        // check for parent exclusions
        const pieces = path.split(".");
        let cur = "";
        for(let i = 0; i < pieces.length; ++i){
            cur += cur.length ? "." + pieces[i] : pieces[i];
            if (excluded.indexOf(cur) !== -1) {
                return;
            }
        }
        // Special case: if user has included a parent path of a discriminator key,
        // don't explicitly project in the discriminator key because that will
        // project out everything else under the parent path
        if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {
            let cur = "";
            for(let i = 0; i < pieces.length; ++i){
                cur += (cur.length === 0 ? "" : ".") + pieces[i];
                const projection = get(fields, cur, false) || get(fields, cur + ".$", false);
                if (projection && typeof projection !== "object") {
                    return;
                }
            }
        }
        (type.selected ? selected : excluded).push(path);
        return path;
    }
};
/**
 * Set each path query option to lean
 *
 * @param {Object} option
 */ function makeLean(val) {
    return function(option) {
        option.options || (option.options = {});
        if (val != null && Array.isArray(val.virtuals)) {
            val = Object.assign({}, val);
            val.virtuals = val.virtuals.filter((path)=>typeof path === "string" && path.startsWith(option.path + ".")).map((path)=>path.slice(option.path.length + 1));
        }
        option.options.lean = val;
    };
}


/***/ }),

/***/ 74951:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const EventEmitter = (__webpack_require__(82361).EventEmitter);
const Kareem = __webpack_require__(9840);
const MongooseError = __webpack_require__(51520);
const SchemaType = __webpack_require__(98878);
const SchemaTypeOptions = __webpack_require__(84252);
const VirtualOptions = __webpack_require__(87526);
const VirtualType = __webpack_require__(3596);
const addAutoId = __webpack_require__(40238);
const get = __webpack_require__(39223);
const getConstructorName = __webpack_require__(4065);
const getIndexes = __webpack_require__(43459);
const idGetter = __webpack_require__(28899);
const merge = __webpack_require__(38359);
const mpath = __webpack_require__(52988);
const readPref = (__webpack_require__(67085).get)().ReadPreference;
const setupTimestamps = __webpack_require__(78099);
const utils = __webpack_require__(52100);
const validateRef = __webpack_require__(38988);
const util = __webpack_require__(73837);
let MongooseTypes;
const queryHooks = (__webpack_require__(94135).middlewareFunctions);
const documentHooks = (__webpack_require__(13202).middlewareFunctions);
const hookNames = queryHooks.concat(documentHooks).reduce((s, hook)=>s.add(hook), new Set());
const isPOJO = utils.isPOJO;
let id = 0;
/**
 * Schema constructor.
 *
 * #### Example:
 *
 *     const child = new Schema({ name: String });
 *     const schema = new Schema({ name: String, age: Number, children: [child] });
 *     const Tree = mongoose.model('Tree', schema);
 *
 *     // setting schema options
 *     new Schema({ name: String }, { _id: false, autoIndex: false })
 *
 * #### Options:
 *
 * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)
 * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)
 * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true
 * - [bufferTimeoutMS](/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.
 * - [capped](/docs/guide.html#capped): bool | number | object - defaults to false
 * - [collection](/docs/guide.html#collection): string - no default
 * - [discriminatorKey](/docs/guide.html#discriminatorKey): string - defaults to `__t`
 * - [id](/docs/guide.html#id): bool - defaults to true
 * - [_id](/docs/guide.html#_id): bool - defaults to true
 * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true
 * - [read](/docs/guide.html#read): string
 * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)
 * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`
 * - [strict](/docs/guide.html#strict): bool - defaults to true
 * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false
 * - [toJSON](/docs/guide.html#toJSON) - object - no default
 * - [toObject](/docs/guide.html#toObject) - object - no default
 * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'
 * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`
 * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to "__v"
 * - [optimisticConcurrency](/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).
 * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)
 * - [timeseries](/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)
 * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`
 * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning
 * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.
 * - [pluginTags](/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.
 *
 * #### Options for Nested Schemas:
 *
 * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.
 *
 * #### Note:
 *
 * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._
 *
 * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas
 * @param {Object} [options]
 * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter
 * @event `init`: Emitted after the schema is compiled into a `Model`.
 * @api public
 */ function Schema(obj, options) {
    if (!(this instanceof Schema)) {
        return new Schema(obj, options);
    }
    this.obj = obj;
    this.paths = {};
    this.aliases = {};
    this.subpaths = {};
    this.virtuals = {};
    this.singleNestedPaths = {};
    this.nested = {};
    this.inherits = {};
    this.callQueue = [];
    this._indexes = [];
    this.methods = options && options.methods || {};
    this.methodOptions = {};
    this.statics = options && options.statics || {};
    this.tree = {};
    this.query = options && options.query || {};
    this.childSchemas = [];
    this.plugins = [];
    // For internal debugging. Do not use this to try to save a schema in MDB.
    this.$id = ++id;
    this.mapPaths = [];
    this.s = {
        hooks: new Kareem()
    };
    this.options = this.defaultOptions(options);
    // build paths
    if (Array.isArray(obj)) {
        for (const definition of obj){
            this.add(definition);
        }
    } else if (obj) {
        this.add(obj);
    }
    // build virtual paths
    if (options && options.virtuals) {
        const virtuals = options.virtuals;
        const pathNames = Object.keys(virtuals);
        for (const pathName of pathNames){
            const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;
            const virtual = this.virtual(pathName, pathOptions);
            if (virtuals[pathName].get) {
                virtual.get(virtuals[pathName].get);
            }
            if (virtuals[pathName].set) {
                virtual.set(virtuals[pathName].set);
            }
        }
    }
    // check if _id's value is a subdocument (gh-2276)
    const _idSubDoc = obj && obj._id && utils.isObject(obj._id);
    // ensure the documents get an auto _id unless disabled
    const auto_id = !this.paths["_id"] && this.options._id && !_idSubDoc;
    if (auto_id) {
        addAutoId(this);
    }
    this.setupTimestamp(this.options.timestamps);
}
/**
 * Create virtual properties with alias field
 * @api private
 */ function aliasFields(schema, paths) {
    for (const path of Object.keys(paths)){
        let alias = null;
        if (paths[path] != null) {
            alias = paths[path];
        } else {
            const options = get(schema.paths[path], "options");
            if (options == null) {
                continue;
            }
            alias = options.alias;
        }
        if (!alias) {
            continue;
        }
        const prop = schema.paths[path].path;
        if (Array.isArray(alias)) {
            for (const a of alias){
                if (typeof a !== "string") {
                    throw new Error("Invalid value for alias option on " + prop + ", got " + a);
                }
                schema.aliases[a] = prop;
                schema.virtual(a).get(function(p) {
                    return function() {
                        if (typeof this.get === "function") {
                            return this.get(p);
                        }
                        return this[p];
                    };
                }(prop)).set(function(p) {
                    return function(v) {
                        return this.$set(p, v);
                    };
                }(prop));
            }
            continue;
        }
        if (typeof alias !== "string") {
            throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
        }
        schema.aliases[alias] = prop;
        schema.virtual(alias).get(function(p) {
            return function() {
                if (typeof this.get === "function") {
                    return this.get(p);
                }
                return this[p];
            };
        }(prop)).set(function(p) {
            return function(v) {
                return this.$set(p, v);
            };
        }(prop));
    }
}
/*!
 * Inherit from EventEmitter.
 */ Schema.prototype = Object.create(EventEmitter.prototype);
Schema.prototype.constructor = Schema;
Schema.prototype.instanceOfSchema = true;
/*!
 * ignore
 */ Object.defineProperty(Schema.prototype, "$schemaType", {
    configurable: false,
    enumerable: false,
    writable: true
});
/**
 * Array of child schemas (from document arrays and single nested subdocs)
 * and their corresponding compiled models. Each element of the array is
 * an object with 2 properties: `schema` and `model`.
 *
 * This property is typically only useful for plugin authors and advanced users.
 * You do not need to interact with this property at all to use mongoose.
 *
 * @api public
 * @property childSchemas
 * @memberOf Schema
 * @instance
 */ Object.defineProperty(Schema.prototype, "childSchemas", {
    configurable: false,
    enumerable: true,
    writable: true
});
/**
 * Object containing all virtuals defined on this schema.
 * The objects' keys are the virtual paths and values are instances of `VirtualType`.
 *
 * This property is typically only useful for plugin authors and advanced users.
 * You do not need to interact with this property at all to use mongoose.
 *
 * #### Example:
 *
 *     const schema = new Schema({});
 *     schema.virtual('answer').get(() => 42);
 *
 *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }
 *     console.log(schema.virtuals['answer'].getters[0].call()); // 42
 *
 * @api public
 * @property virtuals
 * @memberOf Schema
 * @instance
 */ Object.defineProperty(Schema.prototype, "virtuals", {
    configurable: false,
    enumerable: true,
    writable: true
});
/**
 * The original object passed to the schema constructor
 *
 * #### Example:
 *
 *     const schema = new Schema({ a: String }).add({ b: String });
 *     schema.obj; // { a: String }
 *
 * @api public
 * @property obj
 * @memberOf Schema
 * @instance
 */ Schema.prototype.obj;
/**
 * The paths defined on this schema. The keys are the top-level paths
 * in this schema, and the values are instances of the SchemaType class.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String }, { _id: false });
 *     schema.paths; // { name: SchemaString { ... } }
 *
 *     schema.add({ age: Number });
 *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }
 *
 * @api public
 * @property paths
 * @memberOf Schema
 * @instance
 */ Schema.prototype.paths;
/**
 * Schema as a tree
 *
 * #### Example:
 *
 *     {
 *         '_id'     : ObjectId
 *       , 'nested'  : {
 *             'key' : String
 *         }
 *     }
 *
 * @api private
 * @property tree
 * @memberOf Schema
 * @instance
 */ Schema.prototype.tree;
/**
 * Returns a deep copy of the schema
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String });
 *     const clone = schema.clone();
 *     clone === schema; // false
 *     clone.path('name'); // SchemaString { ... }
 *
 * @return {Schema} the cloned schema
 * @api public
 * @memberOf Schema
 * @instance
 */ Schema.prototype.clone = function() {
    const s = this._clone();
    // Bubble up `init` for backwards compat
    s.on("init", (v)=>this.emit("init", v));
    return s;
};
/*!
 * ignore
 */ Schema.prototype._clone = function _clone(Constructor) {
    Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);
    const s = new Constructor({}, this._userProvidedOptions);
    s.base = this.base;
    s.obj = this.obj;
    s.options = utils.clone(this.options);
    s.callQueue = this.callQueue.map(function(f) {
        return f;
    });
    s.methods = utils.clone(this.methods);
    s.methodOptions = utils.clone(this.methodOptions);
    s.statics = utils.clone(this.statics);
    s.query = utils.clone(this.query);
    s.plugins = Array.prototype.slice.call(this.plugins);
    s._indexes = utils.clone(this._indexes);
    s.s.hooks = this.s.hooks.clone();
    s.tree = utils.clone(this.tree);
    s.paths = utils.clone(this.paths);
    s.nested = utils.clone(this.nested);
    s.subpaths = utils.clone(this.subpaths);
    s.singleNestedPaths = utils.clone(this.singleNestedPaths);
    s.childSchemas = gatherChildSchemas(s);
    s.virtuals = utils.clone(this.virtuals);
    s.$globalPluginsApplied = this.$globalPluginsApplied;
    s.$isRootDiscriminator = this.$isRootDiscriminator;
    s.$implicitlyCreated = this.$implicitlyCreated;
    s.$id = ++id;
    s.$originalSchemaId = this.$id;
    s.mapPaths = [].concat(this.mapPaths);
    if (this.discriminatorMapping != null) {
        s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
    }
    if (this.discriminators != null) {
        s.discriminators = Object.assign({}, this.discriminators);
    }
    if (this._applyDiscriminators != null) {
        s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);
    }
    s.aliases = Object.assign({}, this.aliases);
    return s;
};
/**
 * Returns a new schema that has the picked `paths` from this schema.
 *
 * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.
 *
 * #### Example:
 *
 *     const schema = Schema({ name: String, age: Number });
 *     // Creates a new schema with the same `name` path as `schema`,
 *     // but no `age` path.
 *     const newSchema = schema.pick(['name']);
 *
 *     newSchema.path('name'); // SchemaString { ... }
 *     newSchema.path('age'); // undefined
 *
 * @param {String[]} paths List of Paths to pick for the new Schema
 * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.
 * @return {Schema}
 * @api public
 */ Schema.prototype.pick = function(paths, options) {
    const newSchema = new Schema({}, options || this.options);
    if (!Array.isArray(paths)) {
        throw new MongooseError("Schema#pick() only accepts an array argument, " + 'got "' + typeof paths + '"');
    }
    for (const path of paths){
        if (this.nested[path]) {
            newSchema.add({
                [path]: get(this.tree, path)
            });
        } else {
            const schematype = this.path(path);
            if (schematype == null) {
                throw new MongooseError("Path `" + path + "` is not in the schema");
            }
            newSchema.add({
                [path]: schematype
            });
        }
    }
    return newSchema;
};
/**
 * Returns default options for this schema, merged with `options`.
 *
 * @param {Object} [options] Options to overwrite the default options
 * @return {Object} The merged options of `options` and the default options
 * @api private
 */ Schema.prototype.defaultOptions = function(options) {
    this._userProvidedOptions = options == null ? {} : utils.clone(options);
    const baseOptions = this.base && this.base.options || {};
    const strict = "strict" in baseOptions ? baseOptions.strict : true;
    const id = "id" in baseOptions ? baseOptions.id : true;
    options = utils.options({
        strict: strict,
        strictQuery: "strict" in this._userProvidedOptions ? this._userProvidedOptions.strict : "strictQuery" in baseOptions ? baseOptions.strictQuery : strict,
        bufferCommands: true,
        capped: false,
        versionKey: "__v",
        optimisticConcurrency: false,
        minimize: true,
        autoIndex: null,
        discriminatorKey: "__t",
        shardKey: null,
        read: null,
        validateBeforeSave: true,
        // the following are only applied at construction time
        _id: true,
        id: id,
        typeKey: "type"
    }, utils.clone(options));
    if (options.read) {
        options.read = readPref(options.read);
    }
    if (options.versionKey && typeof options.versionKey !== "string") {
        throw new MongooseError("`versionKey` must be falsy or string, got `" + typeof options.versionKey + "`");
    }
    if (options.optimisticConcurrency && !options.versionKey) {
        throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
    }
    return options;
};
/**
 * Inherit a Schema by applying a discriminator on an existing Schema.
 *
 *
 * #### Example:
 *
 *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });
 *
 *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });
 *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);
 *
 *     const Event = mongoose.model('Event', eventSchema);
 *
 *     Event.discriminators['clicked']; // Model { clicked }
 *
 *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });
 *     doc.element; // '#hero'
 *     doc instanceof ClickedModel; // true
 *
 * @param {String} name the name of the discriminator
 * @param {Schema} schema the discriminated Schema
 * @return {Schema} the Schema instance
 * @api public
 */ Schema.prototype.discriminator = function(name, schema) {
    this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, {
        [name]: schema
    });
    return this;
};
/**
 * Adds key path / schema type pairs to this schema.
 *
 * #### Example:
 *
 *     const ToySchema = new Schema();
 *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });
 *
 *     const TurboManSchema = new Schema();
 *     // You can also `add()` another schema and copy over all paths, virtuals,
 *     // getters, setters, indexes, methods, and statics.
 *     TurboManSchema.add(ToySchema).add({ year: Number });
 *
 * @param {Object|Schema} obj plain object with paths to add, or another schema
 * @param {String} [prefix] path to prefix the newly added paths with
 * @return {Schema} the Schema instance
 * @api public
 */ Schema.prototype.add = function add(obj, prefix) {
    if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {
        merge(this, obj);
        return this;
    }
    // Special case: setting top-level `_id` to false should convert to disabling
    // the `_id` option. This behavior never worked before 5.4.11 but numerous
    // codebases use it (see gh-7516, gh-7512).
    if (obj._id === false && prefix == null) {
        this.options._id = false;
    }
    prefix = prefix || "";
    // avoid prototype pollution
    if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
        return this;
    }
    const keys = Object.keys(obj);
    const typeKey = this.options.typeKey;
    for (const key of keys){
        if (utils.specialProperties.has(key)) {
            continue;
        }
        const fullPath = prefix + key;
        const val = obj[key];
        if (val == null) {
            throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + val + '"');
        }
        // Retain `_id: false` but don't set it as a path, re: gh-8274.
        if (key === "_id" && val === false) {
            continue;
        }
        if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === "VirtualType") {
            this.virtual(val);
            continue;
        }
        if (Array.isArray(val) && val.length === 1 && val[0] == null) {
            throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + val[0] + '"');
        }
        if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {
            // Special-case: Non-options definitely a path so leaf at this node
            // Examples: Schema instances, SchemaType instances
            if (prefix) {
                this.nested[prefix.substring(0, prefix.length - 1)] = true;
            }
            this.path(prefix + key, val);
            if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {
                const schemaType = this.path(prefix + key);
                for(const key in val[0].discriminators){
                    schemaType.discriminator(key, val[0].discriminators[key]);
                }
            } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {
                const applyDiscriminators = val[0]._applyDiscriminators || [];
                const schemaType = this.path(prefix + key);
                for(const disc in applyDiscriminators){
                    schemaType.discriminator(disc, applyDiscriminators[disc]);
                }
            } else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {
                const applyDiscriminators = val._applyDiscriminators || [];
                const schemaType = this.path(prefix + key);
                for(const disc in applyDiscriminators){
                    schemaType.discriminator(disc, applyDiscriminators[disc]);
                }
            }
        } else if (Object.keys(val).length < 1) {
            // Special-case: {} always interpreted as Mixed path so leaf at this node
            if (prefix) {
                this.nested[prefix.substring(0, prefix.length - 1)] = true;
            }
            this.path(fullPath, val); // mixed type
        } else if (!val[typeKey] || typeKey === "type" && isPOJO(val.type) && val.type.type) {
            // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse
            // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because
            // NestJS sometimes adds `Date.type`.
            this.nested[fullPath] = true;
            this.add(val, fullPath + ".");
        } else {
            // There IS a bona-fide type key that may also be a POJO
            const _typeDef = val[typeKey];
            if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {
                // If a POJO is the value of a type key, make it a subdocument
                if (prefix) {
                    this.nested[prefix.substring(0, prefix.length - 1)] = true;
                }
                const _schema = new Schema(_typeDef);
                const schemaWrappedPath = Object.assign({}, val, {
                    type: _schema
                });
                this.path(prefix + key, schemaWrappedPath);
            } else {
                // Either the type is non-POJO or we interpret it as Mixed anyway
                if (prefix) {
                    this.nested[prefix.substring(0, prefix.length - 1)] = true;
                }
                this.path(prefix + key, val);
                if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {
                    const schemaType = this.path(prefix + key);
                    for(const key in val.discriminators){
                        schemaType.discriminator(key, val.discriminators[key]);
                    }
                }
            }
        }
    }
    const aliasObj = Object.fromEntries(Object.entries(obj).map(([key])=>[
            prefix + key,
            null
        ]));
    aliasFields(this, aliasObj);
    return this;
};
/**
 * Add an alias for `path`. This means getting or setting the `alias`
 * is equivalent to getting or setting the `path`.
 *
 * #### Example:
 *
 *     const toySchema = new Schema({ n: String });
 *
 *     // Make 'name' an alias for 'n'
 *     toySchema.alias('n', 'name');
 *
 *     const Toy = mongoose.model('Toy', toySchema);
 *     const turboMan = new Toy({ n: 'Turbo Man' });
 *
 *     turboMan.name; // 'Turbo Man'
 *     turboMan.n; // 'Turbo Man'
 *
 *     turboMan.name = 'Turbo Man Action Figure';
 *     turboMan.n; // 'Turbo Man Action Figure'
 *
 *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }
 *
 *
 * @param {String} path real path to alias
 * @param {String|String[]} alias the path(s) to use as an alias for `path`
 * @return {Schema} the Schema instance
 * @api public
 */ Schema.prototype.alias = function alias(path, alias) {
    aliasFields(this, {
        [path]: alias
    });
    return this;
};
/**
 * Remove an index by name or index specification.
 *
 * removeIndex only removes indexes from your schema object. Does **not** affect the indexes
 * in MongoDB.
 *
 * #### Example:
 *
 *     const ToySchema = new Schema({ name: String, color: String, price: Number });
 *
 *     // Add a new index on { name, color }
 *     ToySchema.index({ name: 1, color: 1 });
 *
 *     // Remove index on { name, color }
 *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index
 *     ToySchema.removeIndex({ name: 1, color: 1 });
 *
 *     // Add an index with a custom name
 *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });
 *     // Remove index by name
 *     ToySchema.removeIndex('my custom index name');
 *
 * @param {Object|string} index name or index specification
 * @return {Schema} the Schema instance
 * @api public
 */ Schema.prototype.removeIndex = function removeIndex(index) {
    if (arguments.length > 1) {
        throw new Error("removeIndex() takes only 1 argument");
    }
    if (typeof index !== "object" && typeof index !== "string") {
        throw new Error("removeIndex() may only take either an object or a string as an argument");
    }
    if (typeof index === "object") {
        for(let i = this._indexes.length - 1; i >= 0; --i){
            if (util.isDeepStrictEqual(this._indexes[i][0], index)) {
                this._indexes.splice(i, 1);
            }
        }
    } else {
        for(let i = this._indexes.length - 1; i >= 0; --i){
            if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {
                this._indexes.splice(i, 1);
            }
        }
    }
    return this;
};
/**
 * Remove all indexes from this schema.
 *
 * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes
 * in MongoDB.
 *
 * #### Example:
 *
 *     const ToySchema = new Schema({ name: String, color: String, price: Number });
 *     ToySchema.index({ name: 1 });
 *     ToySchema.index({ color: 1 });
 *
 *     // Remove all indexes on this schema
 *     ToySchema.clearIndexes();
 *
 *     ToySchema.indexes(); // []
 *
 * @return {Schema} the Schema instance
 * @api public
 */ Schema.prototype.clearIndexes = function clearIndexes() {
    this._indexes.length = 0;
    return this;
};
/**
 * Reserved document keys.
 *
 * Keys in this object are names that are warned in schema declarations
 * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema
 * using `new Schema()` with one of these property names, Mongoose will log a warning.
 *
 * - _posts
 * - _pres
 * - collection
  * - emit
 * - errors
 * - get
 * - init
 * - isModified
 * - isNew
 * - listeners
 * - modelName
 * - on
 * - once
 * - populated
 * - prototype
 * - remove
 * - removeListener
 * - save
 * - schema
 * - toObject
 * - validate
 *
 * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.
 *
 *      const schema = new Schema(..);
 *      schema.methods.init = function () {} // potentially breaking
 *
 * @property reserved
 * @memberOf Schema
 * @static
 */ Schema.reserved = Object.create(null);
Schema.prototype.reserved = Schema.reserved;
const reserved = Schema.reserved;
// Core object
reserved["prototype"] = // EventEmitter
reserved.emit = reserved.listeners = reserved.removeListener = // document properties and functions
reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
reserved.collection = 1;
/**
 * Gets/sets schema paths.
 *
 * Sets a path (if arity 2)
 * Gets a path (if arity 1)
 *
 * #### Example:
 *
 *     schema.path('name') // returns a SchemaType
 *     schema.path('name', Number) // changes the schemaType of `name` to Number
 *
 * @param {String} path The name of the Path to get / set
 * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET
 * @api public
 */ Schema.prototype.path = function(path, obj) {
    // Convert to '.$' to check subpaths re: gh-6405
    const cleanPath = _pathToPositionalSyntax(path);
    if (obj === undefined) {
        let schematype = _getPath(this, path, cleanPath);
        if (schematype != null) {
            return schematype;
        }
        // Look for maps
        const mapPath = getMapPath(this, path);
        if (mapPath != null) {
            return mapPath;
        }
        // Look if a parent of this path is mixed
        schematype = this.hasMixedParent(cleanPath);
        if (schematype != null) {
            return schematype;
        }
        // subpaths?
        return /\.\d+\.?.*$/.test(path) ? getPositionalPath(this, path) : undefined;
    }
    // some path names conflict with document methods
    const firstPieceOfPath = path.split(".")[0];
    if (reserved[firstPieceOfPath] && !this.options.supressReservedKeysWarning) {
        const errorMessage = `\`${firstPieceOfPath}\` is a reserved schema pathname and may break some functionality. ` + "You are allowed to use it, but use at your own risk. " + "To disable this warning pass `supressReservedKeysWarning` as a schema option.";
        utils.warn(errorMessage);
    }
    if (typeof obj === "object" && utils.hasUserDefinedProperty(obj, "ref")) {
        validateRef(obj.ref, path);
    }
    // update the tree
    const subpaths = path.split(/\./);
    const last = subpaths.pop();
    let branch = this.tree;
    let fullPath = "";
    for (const sub of subpaths){
        if (utils.specialProperties.has(sub)) {
            throw new Error("Cannot set special property `" + sub + "` on a schema");
        }
        fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
        if (!branch[sub]) {
            this.nested[fullPath] = true;
            branch[sub] = {};
        }
        if (typeof branch[sub] !== "object") {
            const msg = "Cannot set nested path `" + path + "`. " + "Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
            throw new Error(msg);
        }
        branch = branch[sub];
    }
    branch[last] = utils.clone(obj);
    this.paths[path] = this.interpretAsType(path, obj, this.options);
    const schemaType = this.paths[path];
    if (schemaType.$isSchemaMap) {
        // Maps can have arbitrary keys, so `$*` is internal shorthand for "any key"
        // The '$' is to imply this path should never be stored in MongoDB so we
        // can easily build a regexp out of this path, and '*' to imply "any key."
        const mapPath = path + ".$*";
        this.paths[mapPath] = schemaType.$__schemaType;
        this.mapPaths.push(this.paths[mapPath]);
    }
    if (schemaType.$isSingleNested) {
        for (const key of Object.keys(schemaType.schema.paths)){
            this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)){
            this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)){
            this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)){
            this.singleNestedPaths[path + "." + key] = "nested";
        }
        Object.defineProperty(schemaType.schema, "base", {
            configurable: true,
            enumerable: false,
            writable: false,
            value: this.base
        });
        schemaType.caster.base = this.base;
        this.childSchemas.push({
            schema: schemaType.schema,
            model: schemaType.caster
        });
    } else if (schemaType.$isMongooseDocumentArray) {
        Object.defineProperty(schemaType.schema, "base", {
            configurable: true,
            enumerable: false,
            writable: false,
            value: this.base
        });
        schemaType.casterConstructor.base = this.base;
        this.childSchemas.push({
            schema: schemaType.schema,
            model: schemaType.casterConstructor
        });
    }
    if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
        let arrayPath = path;
        let _schemaType = schemaType;
        const toAdd = [];
        while(_schemaType.$isMongooseArray){
            arrayPath = arrayPath + ".$";
            // Skip arrays of document arrays
            if (_schemaType.$isMongooseDocumentArray) {
                _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
                _schemaType.$embeddedSchemaType._arrayParentPath = path;
                _schemaType = _schemaType.$embeddedSchemaType.clone();
            } else {
                _schemaType.caster._arrayPath = arrayPath;
                _schemaType.caster._arrayParentPath = path;
                _schemaType = _schemaType.caster.clone();
            }
            _schemaType.path = arrayPath;
            toAdd.push(_schemaType);
        }
        for (const _schemaType of toAdd){
            this.subpaths[_schemaType.path] = _schemaType;
        }
    }
    if (schemaType.$isMongooseDocumentArray) {
        for (const key of Object.keys(schemaType.schema.paths)){
            const _schemaType = schemaType.schema.paths[key];
            this.subpaths[path + "." + key] = _schemaType;
            if (typeof _schemaType === "object" && _schemaType != null) {
                _schemaType.$isUnderneathDocArray = true;
            }
        }
        for (const key of Object.keys(schemaType.schema.subpaths)){
            const _schemaType = schemaType.schema.subpaths[key];
            this.subpaths[path + "." + key] = _schemaType;
            if (typeof _schemaType === "object" && _schemaType != null) {
                _schemaType.$isUnderneathDocArray = true;
            }
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)){
            const _schemaType = schemaType.schema.singleNestedPaths[key];
            this.subpaths[path + "." + key] = _schemaType;
            if (typeof _schemaType === "object" && _schemaType != null) {
                _schemaType.$isUnderneathDocArray = true;
            }
        }
    }
    return this;
};
/*!
 * ignore
 */ function gatherChildSchemas(schema) {
    const childSchemas = [];
    for (const path of Object.keys(schema.paths)){
        const schematype = schema.paths[path];
        if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
            childSchemas.push({
                schema: schematype.schema,
                model: schematype.caster
            });
        }
    }
    return childSchemas;
}
/*!
 * ignore
 */ function _getPath(schema, path, cleanPath) {
    if (schema.paths.hasOwnProperty(path)) {
        return schema.paths[path];
    }
    if (schema.subpaths.hasOwnProperty(cleanPath)) {
        return schema.subpaths[cleanPath];
    }
    if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
        return schema.singleNestedPaths[cleanPath];
    }
    return null;
}
/*!
 * ignore
 */ function _pathToPositionalSyntax(path) {
    if (!/\.\d+/.test(path)) {
        return path;
    }
    return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
}
/*!
 * ignore
 */ function getMapPath(schema, path) {
    if (schema.mapPaths.length === 0) {
        return null;
    }
    for (const val of schema.mapPaths){
        const _path = val.path;
        const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
        if (re.test(path)) {
            return schema.paths[_path];
        }
    }
    return null;
}
/**
 * The Mongoose instance this schema is associated with
 *
 * @property base
 * @api private
 */ Object.defineProperty(Schema.prototype, "base", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: null
});
/**
 * Converts type arguments into Mongoose Types.
 *
 * @param {String} path
 * @param {Object} obj constructor
 * @param {Object} options
 * @api private
 */ Schema.prototype.interpretAsType = function(path, obj, options) {
    if (obj instanceof SchemaType) {
        if (obj.path === path) {
            return obj;
        }
        const clone = obj.clone();
        clone.path = path;
        return clone;
    }
    // If this schema has an associated Mongoose object, use the Mongoose object's
    // copy of SchemaTypes re: gh-7158 gh-6933
    const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;
    const Types = this.base != null ? this.base.Types : __webpack_require__(35836);
    if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
        const constructorName = utils.getFunctionName(obj.constructor);
        if (constructorName !== "Object") {
            const oldObj = obj;
            obj = {};
            obj[options.typeKey] = oldObj;
        }
    }
    // Get the type making sure to allow keys named "type"
    // and default to mixed if not specified.
    // { type: { type: String, default: 'freshcut' } }
    let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== "type" || !obj.type.type) ? obj[options.typeKey] : {};
    let name;
    if (utils.isPOJO(type) || type === "mixed") {
        return new MongooseTypes.Mixed(path, obj);
    }
    if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes.Array) {
        // if it was specified through { type } look for `cast`
        let cast = type === Array || type === "array" ? obj.cast || obj.of : type[0];
        // new Schema({ path: [new Schema({ ... })] })
        if (cast && cast.instanceOfSchema) {
            if (!(cast instanceof Schema)) {
                throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. " + "Please make sure you're using the same version " + "of Mongoose everywhere with `npm list mongoose`. If you are still " + "getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
            }
            return new MongooseTypes.DocumentArray(path, cast, obj);
        }
        if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {
            if (!(cast[options.typeKey] instanceof Schema)) {
                throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. " + "Please make sure you're using the same version " + "of Mongoose everywhere with `npm list mongoose`. If you are still " + "getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
            }
            return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);
        }
        if (Array.isArray(cast)) {
            return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);
        }
        // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`
        const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
        if (typeof cast === "string") {
            cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];
        } else if (utils.isPOJO(castFromTypeKey)) {
            if (Object.keys(castFromTypeKey).length) {
                // The `minimize` and `typeKey` options propagate to child schemas
                // declared inline, like `{ arr: [{ val: { $type: String } }] }`.
                // See gh-3560
                const childSchemaOptions = {
                    minimize: options.minimize
                };
                if (options.typeKey) {
                    childSchemaOptions.typeKey = options.typeKey;
                }
                // propagate 'strict' option to child schema
                if (options.hasOwnProperty("strict")) {
                    childSchemaOptions.strict = options.strict;
                }
                if (options.hasOwnProperty("strictQuery")) {
                    childSchemaOptions.strictQuery = options.strictQuery;
                }
                if (this._userProvidedOptions.hasOwnProperty("_id")) {
                    childSchemaOptions._id = this._userProvidedOptions._id;
                } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {
                    childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;
                }
                const childSchema = new Schema(castFromTypeKey, childSchemaOptions);
                childSchema.$implicitlyCreated = true;
                return new MongooseTypes.DocumentArray(path, childSchema, obj);
            } else {
                // Special case: empty object becomes mixed
                return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);
            }
        }
        if (cast) {
            type = cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
            if (Array.isArray(type)) {
                return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);
            }
            name = typeof type === "string" ? type : type.schemaName || utils.getFunctionName(type);
            // For Jest 26+, see #10296
            if (name === "ClockDate") {
                name = "Date";
            }
            if (name === void 0) {
                throw new TypeError("Invalid schema configuration: " + `Could not determine the embedded type for array \`${path}\`. ` + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
            }
            if (!MongooseTypes.hasOwnProperty(name)) {
                throw new TypeError("Invalid schema configuration: " + `\`${name}\` is not a valid type within the array \`${path}\`.` + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
            }
        }
        return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);
    }
    if (type && type.instanceOfSchema) {
        return new MongooseTypes.Subdocument(type, path, obj);
    }
    if (Buffer.isBuffer(type)) {
        name = "Buffer";
    } else if (typeof type === "function" || typeof type === "object") {
        name = type.schemaName || utils.getFunctionName(type);
    } else if (type === Types.ObjectId) {
        name = "ObjectId";
    } else if (type === Types.Decimal128) {
        name = "Decimal128";
    } else {
        name = type == null ? "" + type : type.toString();
    }
    if (name) {
        name = name.charAt(0).toUpperCase() + name.substring(1);
    }
    // Special case re: gh-7049 because the bson `ObjectID` class' capitalization
    // doesn't line up with Mongoose's.
    if (name === "ObjectID") {
        name = "ObjectId";
    }
    // For Jest 26+, see #10296
    if (name === "ClockDate") {
        name = "Date";
    }
    if (name === void 0) {
        throw new TypeError(`Invalid schema configuration: \`${path}\` schematype definition is ` + "invalid. See " + "https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
    }
    if (MongooseTypes[name] == null) {
        throw new TypeError(`Invalid schema configuration: \`${name}\` is not ` + `a valid type at path \`${path}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
    }
    const schemaType = new MongooseTypes[name](path, obj);
    if (schemaType.$isSchemaMap) {
        createMapNestedSchemaType(this, schemaType, path, obj, options);
    }
    return schemaType;
};
/*!
 * ignore
 */ function createMapNestedSchemaType(schema, schemaType, path, obj, options) {
    const mapPath = path + ".$*";
    let _mapType = {
        type: {}
    };
    if (utils.hasUserDefinedProperty(obj, "of")) {
        const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);
        if (isInlineSchema) {
            _mapType = {
                [schema.options.typeKey]: new Schema(obj.of)
            };
        } else if (utils.isPOJO(obj.of)) {
            _mapType = Object.assign({}, obj.of);
        } else {
            _mapType = {
                [schema.options.typeKey]: obj.of
            };
        }
        if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {
            const subdocumentSchema = _mapType[schema.options.typeKey];
            subdocumentSchema.eachPath((subpath, type)=>{
                if (type.options.select === true || type.options.select === false) {
                    throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + path + "." + subpath + '"');
                }
            });
        }
        if (utils.hasUserDefinedProperty(obj, "ref")) {
            _mapType.ref = obj.ref;
        }
    }
    schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);
}
/**
 * Iterates the schemas paths similar to Array#forEach.
 *
 * The callback is passed the pathname and the schemaType instance.
 *
 * #### Example:
 *
 *     const userSchema = new Schema({ name: String, registeredAt: Date });
 *     userSchema.eachPath((pathname, schematype) => {
 *       // Prints twice:
 *       // name SchemaString { ... }
 *       // registeredAt SchemaDate { ... }
 *       console.log(pathname, schematype);
 *     });
 *
 * @param {Function} fn callback function
 * @return {Schema} this
 * @api public
 */ Schema.prototype.eachPath = function(fn) {
    const keys = Object.keys(this.paths);
    const len = keys.length;
    for(let i = 0; i < len; ++i){
        fn(keys[i], this.paths[keys[i]]);
    }
    return this;
};
/**
 * Returns an Array of path strings that are required by this schema.
 *
 * #### Example:
 *
 *     const s = new Schema({
 *       name: { type: String, required: true },
 *       age: { type: String, required: true },
 *       notes: String
 *     });
 *     s.requiredPaths(); // [ 'age', 'name' ]
 *
 * @api public
 * @param {Boolean} invalidate Refresh the cache
 * @return {Array}
 */ Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
    if (this._requiredpaths && !invalidate) {
        return this._requiredpaths;
    }
    const paths = Object.keys(this.paths);
    let i = paths.length;
    const ret = [];
    while(i--){
        const path = paths[i];
        if (this.paths[path].isRequired) {
            ret.push(path);
        }
    }
    this._requiredpaths = ret;
    return this._requiredpaths;
};
/**
 * Returns indexes from fields and schema-level indexes (cached).
 *
 * @api private
 * @return {Array}
 */ Schema.prototype.indexedPaths = function indexedPaths() {
    if (this._indexedpaths) {
        return this._indexedpaths;
    }
    this._indexedpaths = this.indexes();
    return this._indexedpaths;
};
/**
 * Returns the pathType of `path` for this schema.
 *
 * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: String, nested: { foo: String } });
 *     s.virtual('foo').get(() => 42);
 *     s.pathType('name'); // "real"
 *     s.pathType('nested'); // "nested"
 *     s.pathType('foo'); // "virtual"
 *     s.pathType('fail'); // "adhocOrUndefined"
 *
 * @param {String} path
 * @return {String}
 * @api public
 */ Schema.prototype.pathType = function(path) {
    // Convert to '.$' to check subpaths re: gh-6405
    const cleanPath = _pathToPositionalSyntax(path);
    if (this.paths.hasOwnProperty(path)) {
        return "real";
    }
    if (this.virtuals.hasOwnProperty(path)) {
        return "virtual";
    }
    if (this.nested.hasOwnProperty(path)) {
        return "nested";
    }
    if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
        return "real";
    }
    const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
    if (singleNestedPath) {
        return singleNestedPath === "nested" ? "nested" : "real";
    }
    // Look for maps
    const mapPath = getMapPath(this, path);
    if (mapPath != null) {
        return "real";
    }
    if (/\.\d+\.|\.\d+$/.test(path)) {
        return getPositionalPathType(this, path);
    }
    return "adhocOrUndefined";
};
/**
 * Returns true iff this path is a child of a mixed schema.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */ Schema.prototype.hasMixedParent = function(path) {
    const subpaths = path.split(/\./g);
    path = "";
    for(let i = 0; i < subpaths.length; ++i){
        path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
        if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
            return this.paths[path];
        }
    }
    return null;
};
/**
 * Setup updatedAt and createdAt timestamps to documents if enabled
 *
 * @param {Boolean|Object} timestamps timestamps options
 * @api private
 */ Schema.prototype.setupTimestamp = function(timestamps) {
    return setupTimestamps(this, timestamps);
};
/**
 * ignore. Deprecated re: #6405
 * @param {Any} self
 * @param {String} path
 * @api private
 */ function getPositionalPathType(self, path) {
    const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
    if (subpaths.length < 2) {
        return self.paths.hasOwnProperty(subpaths[0]) ? self.paths[subpaths[0]] : "adhocOrUndefined";
    }
    let val = self.path(subpaths[0]);
    let isNested = false;
    if (!val) {
        return "adhocOrUndefined";
    }
    const last = subpaths.length - 1;
    for(let i = 1; i < subpaths.length; ++i){
        isNested = false;
        const subpath = subpaths[i];
        if (i === last && val && !/\D/.test(subpath)) {
            if (val.$isMongooseDocumentArray) {
                val = val.$embeddedSchemaType;
            } else if (val instanceof MongooseTypes.Array) {
                // StringSchema, NumberSchema, etc
                val = val.caster;
            } else {
                val = undefined;
            }
            break;
        }
        // ignore if its just a position segment: path.0.subpath
        if (!/\D/.test(subpath)) {
            // Nested array
            if (val instanceof MongooseTypes.Array && i !== last) {
                val = val.caster;
            }
            continue;
        }
        if (!(val && val.schema)) {
            val = undefined;
            break;
        }
        const type = val.schema.pathType(subpath);
        isNested = type === "nested";
        val = val.schema.path(subpath);
    }
    self.subpaths[path] = val;
    if (val) {
        return "real";
    }
    if (isNested) {
        return "nested";
    }
    return "adhocOrUndefined";
}
/*!
 * ignore
 */ function getPositionalPath(self, path) {
    getPositionalPathType(self, path);
    return self.subpaths[path];
}
/**
 * Adds a method call to the queue.
 *
 * #### Example:
 *
 *     schema.methods.print = function() { console.log(this); };
 *     schema.queue('print', []); // Print the doc every one is instantiated
 *
 *     const Model = mongoose.model('Test', schema);
 *     new Model({ name: 'test' }); // Prints '{"_id": ..., "name": "test" }'
 *
 * @param {String} name name of the document method to call later
 * @param {Array} args arguments to pass to the method
 * @api public
 */ Schema.prototype.queue = function(name, args) {
    this.callQueue.push([
        name,
        args
    ]);
    return this;
};
/**
 * Defines a pre hook for the model.
 *
 * #### Example:
 *
 *     const toySchema = new Schema({ name: String, created: Date });
 *
 *     toySchema.pre('save', function(next) {
 *       if (!this.created) this.created = new Date;
 *       next();
 *     });
 *
 *     toySchema.pre('validate', function(next) {
 *       if (this.name !== 'Woody') this.name = 'Woody';
 *       next();
 *     });
 *
 *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.
 *     toySchema.pre(/^find/, function(next) {
 *       console.log(this.getFilter());
 *     });
 *
 *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.
 *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {
 *       console.log(this.getFilter());
 *     });
 *
 *     toySchema.pre('deleteOne', function() {
 *       // Runs when you call `Toy.deleteOne()`
 *     });
 *
 *     toySchema.pre('deleteOne', { document: true }, function() {
 *       // Runs when you call `doc.deleteOne()`
 *     });
 *
 * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name
 * @param {Object} [options]
 * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.
 * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.
 * @param {Function} callback
 * @api public
 */ Schema.prototype.pre = function(name) {
    if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames){
            if (name.test(fn)) {
                this.pre.apply(this, [
                    fn
                ].concat(remainingArgs));
            }
        }
        return this;
    }
    if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name){
            this.pre.apply(this, [
                el
            ].concat(remainingArgs));
        }
        return this;
    }
    this.s.hooks.pre.apply(this.s.hooks, arguments);
    return this;
};
/**
 * Defines a post hook for the document
 *
 *     const schema = new Schema(..);
 *     schema.post('save', function (doc) {
 *       console.log('this fired after a document was saved');
 *     });
 *
 *     schema.post('find', function(docs) {
 *       console.log('this fired after you ran a find query');
 *     });
 *
 *     schema.post(/Many$/, function(res) {
 *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');
 *     });
 *
 *     const Model = mongoose.model('Model', schema);
 *
 *     const m = new Model(..);
 *     m.save(function(err) {
 *       console.log('this fires after the `post` hook');
 *     });
 *
 *     m.find(function(err, docs) {
 *       console.log('this fires after the post find hook');
 *     });
 *
 * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name
 * @param {Object} [options]
 * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.
 * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.
 * @param {Function} fn callback
 * @see middleware https://mongoosejs.com/docs/middleware.html
 * @see kareem https://npmjs.org/package/kareem
 * @api public
 */ Schema.prototype.post = function(name) {
    if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames){
            if (name.test(fn)) {
                this.post.apply(this, [
                    fn
                ].concat(remainingArgs));
            }
        }
        return this;
    }
    if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name){
            this.post.apply(this, [
                el
            ].concat(remainingArgs));
        }
        return this;
    }
    this.s.hooks.post.apply(this.s.hooks, arguments);
    return this;
};
/**
 * Registers a plugin for this schema.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: String });
 *     s.plugin(schema => console.log(schema.path('name').path));
 *     mongoose.model('Test', s); // Prints 'name'
 *
 * Or with Options:
 *
 *     const s = new Schema({ name: String });
 *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: "Schema Path Name:" });
 *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'
 *
 * @param {Function} plugin The Plugin's callback
 * @param {Object} [opts] Options to pass to the plugin
 * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)
 * @see plugins /docs/plugins.html
 * @api public
 */ Schema.prototype.plugin = function(fn, opts) {
    if (typeof fn !== "function") {
        throw new Error("First param to `schema.plugin()` must be a function, " + 'got "' + typeof fn + '"');
    }
    if (opts && opts.deduplicate) {
        for (const plugin of this.plugins){
            if (plugin.fn === fn) {
                return this;
            }
        }
    }
    this.plugins.push({
        fn: fn,
        opts: opts
    });
    fn(this, opts);
    return this;
};
/**
 * Adds an instance method to documents constructed from Models compiled from this schema.
 *
 * #### Example:
 *
 *     const schema = kittySchema = new Schema(..);
 *
 *     schema.method('meow', function () {
 *       console.log('meeeeeoooooooooooow');
 *     })
 *
 *     const Kitty = mongoose.model('Kitty', schema);
 *
 *     const fizz = new Kitty;
 *     fizz.meow(); // meeeeeooooooooooooow
 *
 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
 *
 *     schema.method({
 *         purr: function () {}
 *       , scratch: function () {}
 *     });
 *
 *     // later
 *     const fizz = new Kitty;
 *     fizz.purr();
 *     fizz.scratch();
 *
 * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](/docs/guide.html#methods)
 *
 * @param {String|Object} name The Method Name for a single function, or a Object of "string-function" pairs.
 * @param {Function} [fn] The Function in a single-function definition.
 * @api public
 */ Schema.prototype.method = function(name, fn, options) {
    if (typeof name !== "string") {
        for(const i in name){
            this.methods[i] = name[i];
            this.methodOptions[i] = utils.clone(options);
        }
    } else {
        this.methods[name] = fn;
        this.methodOptions[name] = utils.clone(options);
    }
    return this;
};
/**
 * Adds static "class" methods to Models compiled from this schema.
 *
 * #### Example:
 *
 *     const schema = new Schema(..);
 *     // Equivalent to `schema.statics.findByName = function(name) {}`;
 *     schema.static('findByName', function(name) {
 *       return this.find({ name: name });
 *     });
 *
 *     const Drink = mongoose.model('Drink', schema);
 *     await Drink.findByName('LaCroix');
 *
 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
 *
 *     schema.static({
 *         findByName: function () {..}
 *       , findByCost: function () {..}
 *     });
 *
 *     const Drink = mongoose.model('Drink', schema);
 *     await Drink.findByName('LaCroix');
 *     await Drink.findByCost(3);
 *
 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.
 *
 * @param {String|Object} name The Method Name for a single function, or a Object of "string-function" pairs.
 * @param {Function} [fn] The Function in a single-function definition.
 * @api public
 * @see Statics /docs/guide.html#statics
 */ Schema.prototype.static = function(name, fn) {
    if (typeof name !== "string") {
        for(const i in name){
            this.statics[i] = name[i];
        }
    } else {
        this.statics[name] = fn;
    }
    return this;
};
/**
 * Defines an index (most likely compound) for this schema.
 *
 * #### Example:
 *
 *     schema.index({ first: 1, last: -1 })
 *
 * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`
 * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)
 * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.
 * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.
 * @api public
 */ Schema.prototype.index = function(fields, options) {
    fields || (fields = {});
    options || (options = {});
    if (options.expires) {
        utils.expires(options);
    }
    this._indexes.push([
        fields,
        options
    ]);
    return this;
};
/**
 * Sets a schema option.
 *
 * #### Example:
 *
 *     schema.set('strict'); // 'true' by default
 *     schema.set('strict', false); // Sets 'strict' to false
 *     schema.set('strict'); // 'false'
 *
 * @param {String} key The name of the option to set the value to
 * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default
 * @see Schema #schema_Schema
 * @api public
 */ Schema.prototype.set = function(key, value, _tags) {
    if (arguments.length === 1) {
        return this.options[key];
    }
    switch(key){
        case "read":
            this.options[key] = readPref(value, _tags);
            this._userProvidedOptions[key] = this.options[key];
            break;
        case "timestamps":
            this.setupTimestamp(value);
            this.options[key] = value;
            this._userProvidedOptions[key] = this.options[key];
            break;
        case "_id":
            this.options[key] = value;
            this._userProvidedOptions[key] = this.options[key];
            if (value && !this.paths["_id"]) {
                addAutoId(this);
            } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
                this.remove("_id");
            }
            break;
        default:
            this.options[key] = value;
            this._userProvidedOptions[key] = this.options[key];
            break;
    }
    return this;
};
/**
 * Gets a schema option.
 *
 * #### Example:
 *
 *     schema.get('strict'); // true
 *     schema.set('strict', false);
 *     schema.get('strict'); // false
 *
 * @param {String} key The name of the Option to get the current value for
 * @api public
 * @return {Any} the option's value
 */ Schema.prototype.get = function(key) {
    return this.options[key];
};
const indexTypes = "2d 2dsphere hashed text".split(" ");
/**
 * The allowed index types
 *
 * @property {String[]} indexTypes
 * @memberOf Schema
 * @static
 * @api public
 */ Object.defineProperty(Schema, "indexTypes", {
    get: function() {
        return indexTypes;
    },
    set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
    }
});
/**
 * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.
 * Indexes are expressed as an array `[spec, options]`.
 *
 * #### Example:
 *
 *     const userSchema = new Schema({
 *       email: { type: String, required: true, unique: true },
 *       registeredAt: { type: Date, index: true }
 *     });
 *
 *     // [ [ { email: 1 }, { unique: true, background: true } ],
 *     //   [ { registeredAt: 1 }, { background: true } ] ]
 *     userSchema.indexes();
 *
 * [Plugins](/docs/plugins.html) can use the return value of this function to modify a schema's indexes.
 * For example, the below plugin makes every index unique by default.
 *
 *     function myPlugin(schema) {
 *       for (const index of schema.indexes()) {
 *         if (index[1].unique === undefined) {
 *           index[1].unique = true;
 *         }
 *       }
 *     }
 *
 * @api public
 * @return {Array} list of indexes defined in the schema
 */ Schema.prototype.indexes = function() {
    return getIndexes(this);
};
/**
 * Creates a virtual type with the given name.
 *
 * @param {String} name The name of the Virtual
 * @param {Object} [options]
 * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](/docs/populate.html#populate-virtuals).
 * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.
 * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](/docs/populate.html#populate-virtuals) for more information.
 * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.
 * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.
 * @param {Function|null} [options.get=null] Adds a [getter](/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.
 * @return {VirtualType}
 */ Schema.prototype.virtual = function(name, options) {
    if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
        return this.virtual(name.path, name.options);
    }
    options = new VirtualOptions(options);
    if (utils.hasUserDefinedProperty(options, [
        "ref",
        "refPath"
    ])) {
        if (options.localField == null) {
            throw new Error("Reference virtuals require `localField` option");
        }
        if (options.foreignField == null) {
            throw new Error("Reference virtuals require `foreignField` option");
        }
        this.pre("init", function virtualPreInit(obj) {
            if (mpath.has(name, obj)) {
                const _v = mpath.get(name, obj);
                if (!this.$$populatedVirtuals) {
                    this.$$populatedVirtuals = {};
                }
                if (options.justOne || options.count) {
                    this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
                } else {
                    this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [
                        _v
                    ];
                }
                mpath.unset(name, obj);
            }
        });
        const virtual = this.virtual(name);
        virtual.options = options;
        virtual.set(function(_v) {
            if (!this.$$populatedVirtuals) {
                this.$$populatedVirtuals = {};
            }
            if (options.justOne || options.count) {
                this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
                if (typeof this.$$populatedVirtuals[name] !== "object") {
                    this.$$populatedVirtuals[name] = options.count ? _v : null;
                }
            } else {
                this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [
                    _v
                ];
                this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
                    return doc && typeof doc === "object";
                });
            }
        });
        if (typeof options.get === "function") {
            virtual.get(options.get);
        }
        // Workaround for gh-8198: if virtual is under document array, make a fake
        // virtual. See gh-8210
        const parts = name.split(".");
        let cur = parts[0];
        for(let i = 0; i < parts.length - 1; ++i){
            if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {
                const remnant = parts.slice(i + 1).join(".");
                this.paths[cur].schema.virtual(remnant, options);
                break;
            }
            cur += "." + parts[i + 1];
        }
        return virtual;
    }
    const virtuals = this.virtuals;
    const parts = name.split(".");
    if (this.pathType(name) === "real") {
        throw new Error('Virtual path "' + name + '"' + " conflicts with a real path in the schema");
    }
    virtuals[name] = parts.reduce(function(mem, part, i) {
        mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
        return mem[part];
    }, this.tree);
    return virtuals[name];
};
/**
 * Returns the virtual type with the given `name`.
 *
 * @param {String} name The name of the Virtual to get
 * @return {VirtualType|null}
 */ Schema.prototype.virtualpath = function(name) {
    return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
};
/**
 * Removes the given `path` (or [`paths`]).
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String, age: Number });
 *     schema.remove('name');
 *     schema.path('name'); // Undefined
 *     schema.path('age'); // SchemaNumber { ... }
 *
 * Or as a Array:
 *
 *     schema.remove(['name', 'age']);
 *     schema.path('name'); // Undefined
 *     schema.path('age'); // Undefined
 *
 * @param {String|Array} path The Path(s) to remove
 * @return {Schema} the Schema instance
 * @api public
 */ Schema.prototype.remove = function(path) {
    if (typeof path === "string") {
        path = [
            path
        ];
    }
    if (Array.isArray(path)) {
        path.forEach(function(name) {
            if (this.path(name) == null && !this.nested[name]) {
                return;
            }
            if (this.nested[name]) {
                const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
                for (const path of allKeys){
                    if (path.startsWith(name + ".")) {
                        delete this.paths[path];
                        delete this.nested[path];
                        _deletePath(this, path);
                    }
                }
                delete this.nested[name];
                _deletePath(this, name);
                return;
            }
            delete this.paths[name];
            _deletePath(this, name);
        }, this);
    }
    return this;
};
/*!
 * ignore
 */ function _deletePath(schema, name) {
    const pieces = name.split(".");
    const last = pieces.pop();
    let branch = schema.tree;
    for (const piece of pieces){
        branch = branch[piece];
    }
    delete branch[last];
}
/**
 * Removes the given virtual or virtuals from the schema.
 *
 * @param {String|Array} path The virutal path(s) to remove.
 * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.
 * @api public
 */ Schema.prototype.removeVirtual = function(path) {
    if (typeof path === "string") {
        path = [
            path
        ];
    }
    if (Array.isArray(path)) {
        for (const virtual of path){
            if (this.virtuals[virtual] == null) {
                throw new MongooseError(`Attempting to remove virtual "${virtual}" that does not exist.`);
            }
        }
        for (const virtual of path){
            delete this.paths[virtual];
            delete this.virtuals[virtual];
        }
    }
    return this;
};
/**
 * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),
 * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)
 * to schema [virtuals](/docs/guide.html#virtuals),
 * [statics](/docs/guide.html#statics), and
 * [methods](/docs/guide.html#methods).
 *
 * #### Example:
 *
 * ```javascript
 * const md5 = require('md5');
 * const userSchema = new Schema({ email: String });
 * class UserClass {
 *   // `gravatarImage` becomes a virtual
 *   get gravatarImage() {
 *     const hash = md5(this.email.toLowerCase());
 *     return `https://www.gravatar.com/avatar/${hash}`;
 *   }
 *
 *   // `getProfileUrl()` becomes a document method
 *   getProfileUrl() {
 *     return `https://mysite.com/${this.email}`;
 *   }
 *
 *   // `findByEmail()` becomes a static
 *   static findByEmail(email) {
 *     return this.findOne({ email });
 *   }
 * }
 *
 * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,
 * // and a `findByEmail()` static
 * userSchema.loadClass(UserClass);
 * ```
 *
 * @param {Function} model The Class to load
 * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics
 */ Schema.prototype.loadClass = function(model, virtualsOnly) {
    // Stop copying when hit certain base classes
    if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype") || model.prototype.hasOwnProperty("$isMongooseDocumentPrototype")) {
        return this;
    }
    this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
    // Add static methods
    if (!virtualsOnly) {
        Object.getOwnPropertyNames(model).forEach(function(name) {
            if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
                return;
            }
            const prop = Object.getOwnPropertyDescriptor(model, name);
            if (prop.hasOwnProperty("value")) {
                this.static(name, prop.value);
            }
        }, this);
    }
    // Add methods and virtuals
    Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
        if (name.match(/^(constructor)$/)) {
            return;
        }
        const method = Object.getOwnPropertyDescriptor(model.prototype, name);
        if (!virtualsOnly) {
            if (typeof method.value === "function") {
                this.method(name, method.value);
            }
        }
        if (typeof method.get === "function") {
            if (this.virtuals[name]) {
                this.virtuals[name].getters = [];
            }
            this.virtual(name).get(method.get);
        }
        if (typeof method.set === "function") {
            if (this.virtuals[name]) {
                this.virtuals[name].setters = [];
            }
            this.virtual(name).set(method.set);
        }
    }, this);
    return this;
};
/*!
 * ignore
 */ Schema.prototype._getSchema = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    const resultPath = [];
    if (pathschema) {
        pathschema.$fullPath = path;
        return pathschema;
    }
    function search(parts, schema) {
        let p = parts.length + 1;
        let foundschema;
        let trypath;
        while(p--){
            trypath = parts.slice(0, p).join(".");
            foundschema = schema.path(trypath);
            if (foundschema) {
                resultPath.push(trypath);
                if (foundschema.caster) {
                    // array of Mixed?
                    if (foundschema.caster instanceof MongooseTypes.Mixed) {
                        foundschema.caster.$fullPath = resultPath.join(".");
                        return foundschema.caster;
                    }
                    // Now that we found the array, we need to check if there
                    // are remaining document paths to look up for casting.
                    // Also we need to handle array.$.path since schema.path
                    // doesn't work for that.
                    // If there is no foundschema.schema we are dealing with
                    // a path like array.$
                    if (p !== parts.length) {
                        if (foundschema.schema) {
                            let ret;
                            if (parts[p] === "$" || isArrayFilter(parts[p])) {
                                if (p + 1 === parts.length) {
                                    // comments.$
                                    return foundschema;
                                }
                                // comments.$.comments.$.title
                                ret = search(parts.slice(p + 1), foundschema.schema);
                                if (ret) {
                                    ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                                }
                                return ret;
                            }
                            // this is the last path of the selector
                            ret = search(parts.slice(p), foundschema.schema);
                            if (ret) {
                                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                            }
                            return ret;
                        }
                    }
                } else if (foundschema.$isSchemaMap) {
                    if (p >= parts.length) {
                        return foundschema;
                    }
                    // Any path in the map will be an instance of the map's embedded schematype
                    if (p + 1 >= parts.length) {
                        return foundschema.$__schemaType;
                    }
                    if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {
                        return foundschema.$__schemaType;
                    }
                    if (foundschema.$__schemaType.schema != null) {
                        // Map of docs
                        const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);
                        return ret;
                    }
                }
                foundschema.$fullPath = resultPath.join(".");
                return foundschema;
            }
        }
    }
    // look for arrays
    const parts = path.split(".");
    for(let i = 0; i < parts.length; ++i){
        if (parts[i] === "$" || isArrayFilter(parts[i])) {
            // Re: gh-5628, because `schema.path()` doesn't take $ into account.
            parts[i] = "0";
        }
    }
    return search(parts, _this);
};
/*!
 * ignore
 */ Schema.prototype._getPathType = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    if (pathschema) {
        return "real";
    }
    function search(parts, schema) {
        let p = parts.length + 1, foundschema, trypath;
        while(p--){
            trypath = parts.slice(0, p).join(".");
            foundschema = schema.path(trypath);
            if (foundschema) {
                if (foundschema.caster) {
                    // array of Mixed?
                    if (foundschema.caster instanceof MongooseTypes.Mixed) {
                        return {
                            schema: foundschema,
                            pathType: "mixed"
                        };
                    }
                    // Now that we found the array, we need to check if there
                    // are remaining document paths to look up for casting.
                    // Also we need to handle array.$.path since schema.path
                    // doesn't work for that.
                    // If there is no foundschema.schema we are dealing with
                    // a path like array.$
                    if (p !== parts.length && foundschema.schema) {
                        if (parts[p] === "$" || isArrayFilter(parts[p])) {
                            if (p === parts.length - 1) {
                                return {
                                    schema: foundschema,
                                    pathType: "nested"
                                };
                            }
                            // comments.$.comments.$.title
                            return search(parts.slice(p + 1), foundschema.schema);
                        }
                        // this is the last path of the selector
                        return search(parts.slice(p), foundschema.schema);
                    }
                    return {
                        schema: foundschema,
                        pathType: foundschema.$isSingleNested ? "nested" : "array"
                    };
                }
                return {
                    schema: foundschema,
                    pathType: "real"
                };
            } else if (p === parts.length && schema.nested[trypath]) {
                return {
                    schema: schema,
                    pathType: "nested"
                };
            }
        }
        return {
            schema: foundschema || schema,
            pathType: "undefined"
        };
    }
    // look for arrays
    return search(path.split("."), _this);
};
/*!
 * ignore
 */ function isArrayFilter(piece) {
    return piece.startsWith("$[") && piece.endsWith("]");
}
/**
 * Called by `compile()` _right before_ compiling. Good for making any changes to
 * the schema that should respect options set by plugins, like `id`
 * @method _preCompile
 * @memberOf Schema
 * @instance
 * @api private
 */ Schema.prototype._preCompile = function _preCompile() {
    idGetter(this);
};
/*!
 * Module exports.
 */ module.exports = exports = Schema;
// require down here because of reference issues
/**
 * The various built-in Mongoose Schema Types.
 *
 * #### Example:
 *
 *     const mongoose = require('mongoose');
 *     const ObjectId = mongoose.Schema.Types.ObjectId;
 *
 * #### Types:
 *
 * - [String](/docs/schematypes.html#strings)
 * - [Number](/docs/schematypes.html#numbers)
 * - [Boolean](/docs/schematypes.html#booleans) | Bool
 * - [Array](/docs/schematypes.html#arrays)
 * - [Buffer](/docs/schematypes.html#buffers)
 * - [Date](/docs/schematypes.html#dates)
 * - [ObjectId](/docs/schematypes.html#objectids) | Oid
 * - [Mixed](/docs/schematypes.html#mixed)
 *
 * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.
 *
 *     const Mixed = mongoose.Schema.Types.Mixed;
 *     new mongoose.Schema({ _user: Mixed })
 *
 * @api public
 */ Schema.Types = MongooseTypes = __webpack_require__(20042);
/*!
 * ignore
 */ exports.ObjectId = MongooseTypes.ObjectId;


/***/ }),

/***/ 24046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const CastError = __webpack_require__(96996);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const ObjectExpectedError = __webpack_require__(7860);
const SchemaSubdocumentOptions = __webpack_require__(27254);
const SchemaType = __webpack_require__(98878);
const applyDefaults = __webpack_require__(1796);
const $exists = __webpack_require__(13637);
const castToNumber = (__webpack_require__(22272)/* .castToNumber */ .W);
const discriminator = __webpack_require__(47683);
const geospatial = __webpack_require__(95280);
const getConstructor = __webpack_require__(81442);
const handleIdOption = __webpack_require__(61688);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const utils = __webpack_require__(52100);
let Subdocument;
module.exports = SubdocumentPath;
/**
 * Single nested subdocument SchemaType constructor.
 *
 * @param {Schema} schema
 * @param {String} path
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SubdocumentPath(schema, path, options) {
    const schemaTypeIdOption = SubdocumentPath.defaultOptions && SubdocumentPath.defaultOptions._id;
    if (schemaTypeIdOption != null) {
        options = options || {};
        options._id = schemaTypeIdOption;
    }
    schema = handleIdOption(schema, options);
    this.caster = _createConstructor(schema);
    this.caster.path = path;
    this.caster.prototype.$basePath = path;
    this.schema = schema;
    this.$isSingleNested = true;
    this.base = schema.base;
    SchemaType.call(this, path, options, "Embedded");
}
/*!
 * ignore
 */ SubdocumentPath.prototype = Object.create(SchemaType.prototype);
SubdocumentPath.prototype.constructor = SubdocumentPath;
SubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;
/*!
 * ignore
 */ function _createConstructor(schema, baseClass) {
    // lazy load
    Subdocument || (Subdocument = __webpack_require__(97490));
    const _embedded = function SingleNested(value, path, parent) {
        this.$__parent = parent;
        Subdocument.apply(this, arguments);
        if (parent == null) {
            return;
        }
        this.$session(parent.$session());
    };
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
    _embedded.prototype = Object.create(proto);
    _embedded.prototype.$__setSchema(schema);
    _embedded.prototype.constructor = _embedded;
    _embedded.schema = schema;
    _embedded.$isSingleNested = true;
    _embedded.events = new EventEmitter();
    _embedded.prototype.toBSON = function() {
        return this.toObject(internalToObjectOptions);
    };
    // apply methods
    for(const i in schema.methods){
        _embedded.prototype[i] = schema.methods[i];
    }
    // apply statics
    for(const i in schema.statics){
        _embedded[i] = schema.statics[i];
    }
    for(const i in EventEmitter.prototype){
        _embedded[i] = EventEmitter.prototype[i];
    }
    return _embedded;
}
/**
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param {Object} val
 * @api private
 */ SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
    return {
        $geometry: this.castForQuery(val.$geometry)
    };
};
/*!
 * ignore
 */ SubdocumentPath.prototype.$conditionalHandlers.$near = SubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
SubdocumentPath.prototype.$conditionalHandlers.$within = SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
SubdocumentPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
SubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
SubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
SubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;
/**
 * Casts contents
 *
 * @param {Object} value
 * @api private
 */ SubdocumentPath.prototype.cast = function(val, doc, init, priorVal, options) {
    if (val && val.$isSingleNested && val.parent === doc) {
        return val;
    }
    if (val != null && (typeof val !== "object" || Array.isArray(val))) {
        throw new ObjectExpectedError(this.path, val);
    }
    const Constructor = getConstructor(this.caster, val);
    let subdoc;
    // Only pull relevant selected paths and pull out the base path
    const parentSelected = doc && doc.$__ && doc.$__.selected || {};
    const path = this.path;
    const selected = Object.keys(parentSelected).reduce((obj, key)=>{
        if (key.startsWith(path + ".")) {
            obj = obj || {};
            obj[key.substring(path.length + 1)] = parentSelected[key];
        }
        return obj;
    }, null);
    options = Object.assign({}, options, {
        priorDoc: priorVal
    });
    if (init) {
        subdoc = new Constructor(void 0, selected, doc, false, {
            defaults: false
        });
        delete subdoc.$__.defaults;
        subdoc.$init(val);
        applyDefaults(subdoc, selected);
    } else {
        if (Object.keys(val).length === 0) {
            return new Constructor({}, selected, doc, undefined, options);
        }
        return new Constructor(val, selected, doc, undefined, options);
    }
    return subdoc;
};
/**
 * Casts contents for query
 *
 * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)
 * @param {any} value
 * @api private
 */ SubdocumentPath.prototype.castForQuery = function($conditional, val, options) {
    let handler;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
            throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
    }
    val = $conditional;
    if (val == null) {
        return val;
    }
    if (this.options.runSetters) {
        val = this._applySetters(val);
    }
    const Constructor = getConstructor(this.caster, val);
    const overrideStrict = options != null && options.strict != null ? options.strict : void 0;
    try {
        val = new Constructor(val, overrideStrict);
    } catch (error) {
        // Make sure we always wrap in a CastError (gh-6803)
        if (!(error instanceof CastError)) {
            throw new CastError("Embedded", val, this.path, error, this);
        }
        throw error;
    }
    return val;
};
/**
 * Async validation on this single nested doc.
 *
 * @api private
 */ SubdocumentPath.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor)) {
        value = new Constructor(value, null, scope != null && scope.$__ != null ? scope : null);
    }
    if (options && options.skipSchemaValidators) {
        if (!value) {
            return fn(null);
        }
        return value.validate(fn);
    }
    SchemaType.prototype.doValidate.call(this, value, function(error) {
        if (error) {
            return fn(error);
        }
        if (!value) {
            return fn(null);
        }
        value.validate(fn);
    }, scope, options);
};
/**
 * Synchronously validate this single nested doc
 *
 * @api private
 */ SubdocumentPath.prototype.doValidateSync = function(value, scope, options) {
    if (!options || !options.skipSchemaValidators) {
        const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
        if (schemaTypeError) {
            return schemaTypeError;
        }
    }
    if (!value) {
        return;
    }
    return value.validateSync();
};
/**
 * Adds a discriminator to this single nested subdocument.
 *
 * #### Example:
 *
 *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });
 *     const schema = Schema({ shape: shapeSchema });
 *
 *     const singleNestedPath = parentSchema.path('shape');
 *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));
 *
 * @param {String} name
 * @param {Schema} schema fields to add to the schema for instances of this sub-class
 * @param {Object|string} [options] If string, same as `options.value`.
 * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.
 * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.
 * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model
 * @see discriminators /docs/discriminators.html
 * @api public
 */ SubdocumentPath.prototype.discriminator = function(name, schema, options) {
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone) {
        schema = schema.clone();
    }
    schema = discriminator(this.caster, name, schema, value);
    this.caster.discriminators[name] = _createConstructor(schema, this.caster);
    return this.caster.discriminators[name];
};
/*!
 * ignore
 */ SubdocumentPath.defaultOptions = {};
/**
 * Sets a default option for all SubdocumentPath instances.
 *
 * #### Example:
 *
 *     // Make all numbers have option `min` equal to 0.
 *     mongoose.Schema.SubdocumentPath.set('required', true);
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {void}
 * @function set
 * @static
 * @api public
 */ SubdocumentPath.set = SchemaType.set;
/*!
 * ignore
 */ SubdocumentPath.prototype.toJSON = function toJSON() {
    return {
        path: this.path,
        options: this.options
    };
};
/*!
 * ignore
 */ SubdocumentPath.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.schema, this.path, options);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
        schematype.requiredValidator = this.requiredValidator;
    }
    schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
    return schematype;
};


/***/ }),

/***/ 81491:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const $exists = __webpack_require__(13637);
const $type = __webpack_require__(92340);
const MongooseError = __webpack_require__(51520);
const SchemaArrayOptions = __webpack_require__(64787);
const SchemaType = __webpack_require__(98878);
const CastError = SchemaType.CastError;
const Mixed = __webpack_require__(76541);
const arrayDepth = __webpack_require__(79163);
const cast = __webpack_require__(54749);
const isOperator = __webpack_require__(75831);
const util = __webpack_require__(73837);
const utils = __webpack_require__(52100);
const castToNumber = (__webpack_require__(22272)/* .castToNumber */ .W);
const geospatial = __webpack_require__(95280);
const getDiscriminatorByValue = __webpack_require__(17492);
let MongooseArray;
let EmbeddedDoc;
const isNestedArraySymbol = Symbol("mongoose#isNestedArray");
const emptyOpts = Object.freeze({});
/**
 * Array SchemaType constructor
 *
 * @param {String} key
 * @param {SchemaType} cast
 * @param {Object} options
 * @param {Object} schemaOptions
 * @inherits SchemaType
 * @api public
 */ function SchemaArray(key, cast, options, schemaOptions) {
    // lazy load
    EmbeddedDoc || (EmbeddedDoc = (__webpack_require__(35836).Embedded));
    let typeKey = "type";
    if (schemaOptions && schemaOptions.typeKey) {
        typeKey = schemaOptions.typeKey;
    }
    this.schemaOptions = schemaOptions;
    if (cast) {
        let castOptions = {};
        if (utils.isPOJO(cast)) {
            if (cast[typeKey]) {
                // support { type: Woot }
                castOptions = utils.clone(cast); // do not alter user arguments
                delete castOptions[typeKey];
                cast = cast[typeKey];
            } else {
                cast = Mixed;
            }
        }
        if (options != null && options.ref != null && castOptions.ref == null) {
            castOptions.ref = options.ref;
        }
        if (cast === Object) {
            cast = Mixed;
        }
        // support { type: 'String' }
        const name = typeof cast === "string" ? cast : utils.getFunctionName(cast);
        const Types = __webpack_require__(20042);
        const caster = Types.hasOwnProperty(name) ? Types[name] : cast;
        this.casterConstructor = caster;
        if (this.casterConstructor instanceof SchemaArray) {
            this.casterConstructor[isNestedArraySymbol] = true;
        }
        if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
            const path = this.caster instanceof EmbeddedDoc ? null : key;
            this.caster = new caster(path, castOptions);
        } else {
            this.caster = caster;
            if (!(this.caster instanceof EmbeddedDoc)) {
                this.caster.path = key;
            }
        }
        this.$embeddedSchemaType = this.caster;
    }
    this.$isMongooseArray = true;
    SchemaType.call(this, key, options, "Array");
    let defaultArr;
    let fn;
    if (this.defaultValue != null) {
        defaultArr = this.defaultValue;
        fn = typeof defaultArr === "function";
    }
    if (!("defaultValue" in this) || this.defaultValue !== void 0) {
        const defaultFn = function() {
            // Leave it up to `cast()` to convert the array
            return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];
        };
        defaultFn.$runBeforeSetters = !fn;
        this.default(defaultFn);
    }
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaArray.schemaName = "Array";
/**
 * Options for all arrays.
 *
 * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.
 *
 * @static
 * @api public
 */ SchemaArray.options = {
    castNonArrays: true
};
/*!
 * ignore
 */ SchemaArray.defaultOptions = {};
/**
 * Sets a default option for all Array instances.
 *
 * #### Example:
 *
 *     // Make all Array instances have `required` of true by default.
 *     mongoose.Schema.Array.set('required', true);
 *
 *     const User = mongoose.model('User', new Schema({ test: Array }));
 *     new User({ }).validateSync().errors.test.message; // Path `test` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @api public
 */ SchemaArray.set = SchemaType.set;
/*!
 * Inherits from SchemaType.
 */ SchemaArray.prototype = Object.create(SchemaType.prototype);
SchemaArray.prototype.constructor = SchemaArray;
SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
/*!
 * ignore
 */ SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
/**
 * Override the function the required validator uses to check whether an array
 * passes the `required` check.
 *
 * #### Example:
 *
 *     // Require non-empty array to pass `required` check
 *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);
 *
 *     const M = mongoose.model({ arr: { type: Array, required: true } });
 *     new M({ arr: [] }).validateSync(); // `null`, validation fails!
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @api public
 */ SchemaArray.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies the `required` validator.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return !!value;
    }
    // `require('util').inherits()` does **not** copy static properties, and
    // plugins like mongoose-float use `inherits()` for pre-ES6.
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
    return _checkRequired(value);
};
/**
 * Adds an enum validator if this is an array of strings or numbers. Equivalent to
 * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`
 *
 * @param {...String|Object} [args] enumeration values
 * @return {SchemaArray} this
 */ SchemaArray.prototype.enum = function() {
    let arr = this;
    while(true){
        const instance = arr && arr.caster && arr.caster.instance;
        if (instance === "Array") {
            arr = arr.caster;
            continue;
        }
        if (instance !== "String" && instance !== "Number") {
            throw new Error("`enum` can only be set on an array of strings or numbers " + ", not " + instance);
        }
        break;
    }
    let enumArray = arguments;
    if (!Array.isArray(arguments) && utils.isObject(arguments)) {
        enumArray = utils.object.vals(enumArray);
    }
    arr.caster.enum.apply(arr.caster, enumArray);
    return this;
};
/**
 * Overrides the getters application for the population special-case
 *
 * @param {Object} value
 * @param {Object} scope
 * @api private
 */ SchemaArray.prototype.applyGetters = function(value, scope) {
    if (scope != null && scope.$__ != null && scope.$populated(this.path)) {
        // means the object id was populated
        return value;
    }
    const ret = SchemaType.prototype.applyGetters.call(this, value, scope);
    if (Array.isArray(ret)) {
        const rawValue = utils.isMongooseArray(ret) ? ret.__array : ret;
        const len = rawValue.length;
        for(let i = 0; i < len; ++i){
            rawValue[i] = this.caster.applyGetters(rawValue[i], scope);
        }
    }
    return ret;
};
SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
    if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
        // Check nesting levels and wrap in array if necessary
        let depth = 0;
        let arr = this;
        while(arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray){
            ++depth;
            arr = arr.casterConstructor;
        }
        // No need to wrap empty arrays
        if (value != null && value.length !== 0) {
            const valueDepth = arrayDepth(value);
            if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
                for(let i = valueDepth.max; i < depth; ++i){
                    value = [
                        value
                    ];
                }
            }
        }
    }
    return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
};
/**
 * Casts values for set().
 *
 * @param {Object} value
 * @param {Document} doc document that triggers the casting
 * @param {Boolean} init whether this is an initialization cast
 * @api private
 */ SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
    // lazy load
    MongooseArray || (MongooseArray = (__webpack_require__(35836).Array));
    let i;
    let l;
    if (Array.isArray(value)) {
        const len = value.length;
        if (!len && doc) {
            const indexes = doc.schema.indexedPaths();
            const arrayPath = this.path;
            for(i = 0, l = indexes.length; i < l; ++i){
                const pathIndex = indexes[i][0][arrayPath];
                if (pathIndex === "2dsphere" || pathIndex === "2d") {
                    return;
                }
            }
            // Special case: if this index is on the parent of what looks like
            // GeoJSON, skip setting the default to empty array re: #1668, #3233
            const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
            if (arrayGeojsonPath != null) {
                for(i = 0, l = indexes.length; i < l; ++i){
                    const pathIndex = indexes[i][0][arrayGeojsonPath];
                    if (pathIndex === "2dsphere") {
                        return;
                    }
                }
            }
        }
        options = options || emptyOpts;
        let rawValue = utils.isMongooseArray(value) ? value.__array : value;
        value = MongooseArray(rawValue, options.path || this._arrayPath || this.path, doc, this);
        rawValue = value.__array;
        if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {
            return value;
        }
        const caster = this.caster;
        const isMongooseArray = caster.$isMongooseArray;
        if (caster && this.casterConstructor !== Mixed) {
            try {
                const len = rawValue.length;
                for(i = 0; i < len; i++){
                    const opts = {};
                    // Perf: creating `arrayPath` is expensive for large arrays.
                    // We only need `arrayPath` if this is a nested array, so
                    // skip if possible.
                    if (isMongooseArray) {
                        if (options.arrayPath != null) {
                            opts.arrayPathIndex = i;
                        } else if (caster._arrayParentPath != null) {
                            opts.arrayPathIndex = i;
                        }
                    }
                    rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);
                }
            } catch (e) {
                // rethrow
                throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
            }
        }
        return value;
    }
    const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;
    if (init || castNonArraysOption) {
        // gh-2442: if we're loading this from the db and its not an array, mark
        // the whole array as modified.
        if (!!doc && !!init) {
            doc.markModified(this.path);
        }
        return this.cast([
            value
        ], doc, init);
    }
    throw new CastError("Array", util.inspect(value), this.path, null, this);
};
/*!
 * ignore
 */ SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
    // lazy load
    MongooseArray || (MongooseArray = (__webpack_require__(35836).Array));
    if (Array.isArray(value)) {
        let i;
        const rawValue = value.__array ? value.__array : value;
        const len = rawValue.length;
        const caster = this.caster;
        if (caster && this.casterConstructor !== Mixed) {
            try {
                for(i = 0; i < len; i++){
                    const opts = {};
                    // Perf: creating `arrayPath` is expensive for large arrays.
                    // We only need `arrayPath` if this is a nested array, so
                    // skip if possible.
                    if (caster.$isMongooseArray && caster._arrayParentPath != null) {
                        opts.arrayPathIndex = i;
                    }
                    rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);
                }
            } catch (e) {
                // rethrow
                throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
            }
        }
        return value;
    }
    throw new CastError("Array", util.inspect(value), this.path, null, this);
};
SchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;
/*!
 * ignore
 */ SchemaArray.prototype.discriminator = function(name, schema) {
    let arr = this;
    while(arr.$isMongooseArray && !arr.$isMongooseDocumentArray){
        arr = arr.casterConstructor;
        if (arr == null || typeof arr === "function") {
            throw new MongooseError("You can only add an embedded discriminator on " + "a document array, " + this.path + " is a plain array");
        }
    }
    return arr.discriminator(name, schema);
};
/*!
 * ignore
 */ SchemaArray.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
        schematype.requiredValidator = this.requiredValidator;
    }
    return schematype;
};
/**
 * Casts values for queries.
 *
 * @param {String} $conditional
 * @param {any} [value]
 * @api private
 */ SchemaArray.prototype.castForQuery = function($conditional, value) {
    let handler;
    let val;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
            throw new Error("Can't use " + $conditional + " with Array.");
        }
        val = handler.call(this, value);
    } else {
        val = $conditional;
        let Constructor = this.casterConstructor;
        if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
            if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
                Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
            } else {
                const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
                if (constructorByValue) {
                    Constructor = constructorByValue;
                }
            }
        }
        const proto = this.casterConstructor.prototype;
        let method = proto && (proto.castForQuery || proto.cast);
        if (!method && Constructor.castForQuery) {
            method = Constructor.castForQuery;
        }
        const caster = this.caster;
        if (Array.isArray(val)) {
            this.setters.reverse().forEach((setter)=>{
                val = setter.call(this, val, this);
            });
            val = val.map(function(v) {
                if (utils.isObject(v) && v.$elemMatch) {
                    return v;
                }
                if (method) {
                    v = method.call(caster, v);
                    return v;
                }
                if (v != null) {
                    v = new Constructor(v);
                    return v;
                }
                return v;
            });
        } else if (method) {
            val = method.call(caster, val);
        } else if (val != null) {
            val = new Constructor(val);
        }
    }
    return val;
};
function cast$all(val) {
    if (!Array.isArray(val)) {
        val = [
            val
        ];
    }
    val = val.map((v)=>{
        if (!utils.isObject(v)) {
            return v;
        }
        if (v.$elemMatch != null) {
            return {
                $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context)
            };
        }
        const o = {};
        o[this.path] = v;
        return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];
    }, this);
    return this.castForQuery(val);
}
function cast$elemMatch(val) {
    const keys = Object.keys(val);
    const numKeys = keys.length;
    for(let i = 0; i < numKeys; ++i){
        const key = keys[i];
        const value = val[key];
        if (isOperator(key) && value != null) {
            val[key] = this.castForQuery(key, value);
        }
    }
    // Is this an embedded discriminator and is the discriminator key set?
    // If so, use the discriminator schema. See gh-7449
    const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;
    const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
    if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
        return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);
    }
    return cast(this.casterConstructor.schema, val, null, this && this.$$context);
}
const handle = SchemaArray.prototype.$conditionalHandlers = {};
handle.$all = cast$all;
handle.$options = String;
handle.$elemMatch = cast$elemMatch;
handle.$geoIntersects = geospatial.cast$geoIntersects;
handle.$or = createLogicalQueryOperatorHandler("$or");
handle.$and = createLogicalQueryOperatorHandler("$and");
handle.$nor = createLogicalQueryOperatorHandler("$nor");
function createLogicalQueryOperatorHandler(op) {
    return function logicalQueryOperatorHandler(val) {
        if (!Array.isArray(val)) {
            throw new TypeError("conditional " + op + " requires an array");
        }
        const ret = [];
        for (const obj of val){
            ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));
        }
        return ret;
    };
}
handle.$near = handle.$nearSphere = geospatial.cast$near;
handle.$within = handle.$geoWithin = geospatial.cast$within;
handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
handle.$exists = $exists;
handle.$type = $type;
handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$not = handle.$regex = SchemaArray.prototype.castForQuery;
// `$in` is special because you can also include an empty array in the query
// like `$in: [1, []]`, see gh-5913
handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
/*!
 * Module exports.
 */ module.exports = SchemaArray;


/***/ }),

/***/ 64248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const CastError = __webpack_require__(96996);
const SchemaType = __webpack_require__(98878);
const castBoolean = __webpack_require__(46709);
const utils = __webpack_require__(52100);
/**
 * Boolean SchemaType constructor.
 *
 * @param {String} path
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SchemaBoolean(path, options) {
    SchemaType.call(this, path, options, "Boolean");
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaBoolean.schemaName = "Boolean";
SchemaBoolean.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ SchemaBoolean.prototype = Object.create(SchemaType.prototype);
SchemaBoolean.prototype.constructor = SchemaBoolean;
/*!
 * ignore
 */ SchemaBoolean._cast = castBoolean;
/**
 * Sets a default option for all Boolean instances.
 *
 * #### Example:
 *
 *     // Make all booleans have `default` of false.
 *     mongoose.Schema.Boolean.set('default', false);
 *
 *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));
 *     new Order({ }).isPaid; // false
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ SchemaBoolean.set = SchemaType.set;
/**
 * Get/set the function used to cast arbitrary values to booleans.
 *
 * #### Example:
 *
 *     // Make Mongoose cast empty string '' to false.
 *     const original = mongoose.Schema.Boolean.cast();
 *     mongoose.Schema.Boolean.cast(v => {
 *       if (v === '') {
 *         return false;
 *       }
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.Schema.Boolean.cast(false);
 *
 * @param {Function} caster
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ SchemaBoolean.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ SchemaBoolean._defaultCaster = (v)=>{
    if (v != null && typeof v !== "boolean") {
        throw new Error();
    }
    return v;
};
/*!
 * ignore
 */ SchemaBoolean._checkRequired = (v)=>v === true || v === false;
/**
 * Override the function the required validator uses to check whether a boolean
 * passes the `required` check.
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ SchemaBoolean.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator. For a boolean
 * to satisfy a required validator, it must be strictly equal to true or to
 * false.
 *
 * @param {Any} value
 * @return {Boolean}
 * @api public
 */ SchemaBoolean.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
};
/**
 * Configure which values get casted to `true`.
 *
 * #### Example:
 *
 *     const M = mongoose.model('Test', new Schema({ b: Boolean }));
 *     new M({ b: 'affirmative' }).b; // undefined
 *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');
 *     new M({ b: 'affirmative' }).b; // true
 *
 * @property convertToTrue
 * @type {Set}
 * @api public
 */ Object.defineProperty(SchemaBoolean, "convertToTrue", {
    get: ()=>castBoolean.convertToTrue,
    set: (v)=>{
        castBoolean.convertToTrue = v;
    }
});
/**
 * Configure which values get casted to `false`.
 *
 * #### Example:
 *
 *     const M = mongoose.model('Test', new Schema({ b: Boolean }));
 *     new M({ b: 'nay' }).b; // undefined
 *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');
 *     new M({ b: 'nay' }).b; // false
 *
 * @property convertToFalse
 * @type {Set}
 * @api public
 */ Object.defineProperty(SchemaBoolean, "convertToFalse", {
    get: ()=>castBoolean.convertToFalse,
    set: (v)=>{
        castBoolean.convertToFalse = v;
    }
});
/**
 * Casts to boolean
 *
 * @param {Object} value
 * @param {Object} model this value is optional
 * @api private
 */ SchemaBoolean.prototype.cast = function(value) {
    let castBoolean;
    if (typeof this._castFunction === "function") {
        castBoolean = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castBoolean = this.constructor.cast();
    } else {
        castBoolean = SchemaBoolean.cast();
    }
    try {
        return castBoolean(value);
    } catch (error) {
        throw new CastError("Boolean", value, this.path, error, this);
    }
};
SchemaBoolean.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {});
/**
 * Casts contents for queries.
 *
 * @param {String} $conditional
 * @param {any} val
 * @api private
 */ SchemaBoolean.prototype.castForQuery = function($conditional, val) {
    let handler;
    if (arguments.length === 2) {
        handler = SchemaBoolean.$conditionalHandlers[$conditional];
        if (handler) {
            return handler.call(this, val);
        }
        return this._castForQuery(val);
    }
    return this._castForQuery($conditional);
};
/**
 *
 * @api private
 */ SchemaBoolean.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
        return v;
    }
    const castBoolean = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
    if (castBoolean == null) {
        return v;
    }
    if (castBoolean.convertToFalse instanceof Set && castBoolean.convertToFalse.has(v)) {
        return false;
    }
    if (castBoolean.convertToTrue instanceof Set && castBoolean.convertToTrue.has(v)) {
        return true;
    }
    return v;
};
/*!
 * Module exports.
 */ module.exports = SchemaBoolean;


/***/ }),

/***/ 48964:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseBuffer = __webpack_require__(77784);
const SchemaBufferOptions = __webpack_require__(69667);
const SchemaType = __webpack_require__(98878);
const handleBitwiseOperator = __webpack_require__(48826);
const utils = __webpack_require__(52100);
const Binary = MongooseBuffer.Binary;
const CastError = SchemaType.CastError;
/**
 * Buffer SchemaType constructor
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SchemaBuffer(key, options) {
    SchemaType.call(this, key, options, "Buffer");
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaBuffer.schemaName = "Buffer";
SchemaBuffer.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ SchemaBuffer.prototype = Object.create(SchemaType.prototype);
SchemaBuffer.prototype.constructor = SchemaBuffer;
SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
/*!
 * ignore
 */ SchemaBuffer._checkRequired = (v)=>!!(v && v.length);
/**
 * Sets a default option for all Buffer instances.
 *
 * #### Example:
 *
 *     // Make all buffers have `required` of true by default.
 *     mongoose.Schema.Buffer.set('required', true);
 *
 *     const User = mongoose.model('User', new Schema({ test: Buffer }));
 *     new User({ }).validateSync().errors.test.message; // Path `test` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ SchemaBuffer.set = SchemaType.set;
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * #### Example:
 *
 *     // Allow empty strings to pass `required` check
 *     mongoose.Schema.Types.String.checkRequired(v => v != null);
 *
 *     const M = mongoose.model({ buf: { type: Buffer, required: true } });
 *     new M({ buf: Buffer.from('') }).validateSync(); // validation passes!
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ SchemaBuffer.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator. To satisfy a
 * required validator, a buffer must not be null or undefined and have
 * non-zero length.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ SchemaBuffer.prototype.checkRequired = function(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
    }
    return this.constructor._checkRequired(value);
};
/**
 * Casts contents
 *
 * @param {Object} value
 * @param {Document} doc document that triggers the casting
 * @param {Boolean} init
 * @api private
 */ SchemaBuffer.prototype.cast = function(value, doc, init) {
    let ret;
    if (SchemaType._isRef(this, value, doc, init)) {
        if (value && value.isMongooseBuffer) {
            return value;
        }
        if (Buffer.isBuffer(value)) {
            if (!value || !value.isMongooseBuffer) {
                value = new MongooseBuffer(value, [
                    this.path,
                    doc
                ]);
                if (this.options.subtype != null) {
                    value._subtype = this.options.subtype;
                }
            }
            return value;
        }
        if (value instanceof Binary) {
            ret = new MongooseBuffer(value.value(true), [
                this.path,
                doc
            ]);
            if (typeof value.sub_type !== "number") {
                throw new CastError("Buffer", value, this.path, null, this);
            }
            ret._subtype = value.sub_type;
            return ret;
        }
        if (value == null || utils.isNonBuiltinObject(value)) {
            return this._castRef(value, doc, init);
        }
    }
    // documents
    if (value && value._id) {
        value = value._id;
    }
    if (value && value.isMongooseBuffer) {
        return value;
    }
    if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
            value = new MongooseBuffer(value, [
                this.path,
                doc
            ]);
            if (this.options.subtype != null) {
                value._subtype = this.options.subtype;
            }
        }
        return value;
    }
    if (value instanceof Binary) {
        ret = new MongooseBuffer(value.value(true), [
            this.path,
            doc
        ]);
        if (typeof value.sub_type !== "number") {
            throw new CastError("Buffer", value, this.path, null, this);
        }
        ret._subtype = value.sub_type;
        return ret;
    }
    if (value === null) {
        return value;
    }
    const type = typeof value;
    if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data) // gh-6863
    ) {
        if (type === "number") {
            value = [
                value
            ];
        }
        ret = new MongooseBuffer(value, [
            this.path,
            doc
        ]);
        if (this.options.subtype != null) {
            ret._subtype = this.options.subtype;
        }
        return ret;
    }
    throw new CastError("Buffer", value, this.path, null, this);
};
/**
 * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)
 * for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).
 *
 * #### Example:
 *
 *     const s = new Schema({ uuid: { type: Buffer, subtype: 4 });
 *     const M = db.model('M', s);
 *     const m = new M({ uuid: 'test string' });
 *     m.uuid._subtype; // 4
 *
 * @param {Number} subtype the default subtype
 * @return {SchemaType} this
 * @api public
 */ SchemaBuffer.prototype.subtype = function(subtype) {
    this.options.subtype = subtype;
    return this;
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.castForQuery(val);
}
SchemaBuffer.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
});
/**
 * Casts contents for queries.
 *
 * @param {String} $conditional
 * @param {any} [value]
 * @api private
 */ SchemaBuffer.prototype.castForQuery = function($conditional, val) {
    let handler;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
            throw new Error("Can't use " + $conditional + " with Buffer.");
        }
        return handler.call(this, val);
    }
    val = $conditional;
    const casted = this._castForQuery(val);
    return casted ? casted.toObject({
        transform: false,
        virtuals: false
    }) : casted;
};
/*!
 * Module exports.
 */ module.exports = SchemaBuffer;


/***/ }),

/***/ 16701:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module requirements.
 */ 
const MongooseError = __webpack_require__(40413);
const SchemaDateOptions = __webpack_require__(8628);
const SchemaType = __webpack_require__(98878);
const castDate = __webpack_require__(27320);
const getConstructorName = __webpack_require__(4065);
const utils = __webpack_require__(52100);
const CastError = SchemaType.CastError;
/**
 * Date SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SchemaDate(key, options) {
    SchemaType.call(this, key, options, "Date");
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaDate.schemaName = "Date";
SchemaDate.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ SchemaDate.prototype = Object.create(SchemaType.prototype);
SchemaDate.prototype.constructor = SchemaDate;
SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
/*!
 * ignore
 */ SchemaDate._cast = castDate;
/**
 * Sets a default option for all Date instances.
 *
 * #### Example:
 *
 *     // Make all dates have `required` of true by default.
 *     mongoose.Schema.Date.set('required', true);
 *
 *     const User = mongoose.model('User', new Schema({ test: Date }));
 *     new User({ }).validateSync().errors.test.message; // Path `test` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ SchemaDate.set = SchemaType.set;
/**
 * Get/set the function used to cast arbitrary values to dates.
 *
 * #### Example:
 *
 *     // Mongoose converts empty string '' into `null` for date types. You
 *     // can create a custom caster to disable it.
 *     const original = mongoose.Schema.Types.Date.cast();
 *     mongoose.Schema.Types.Date.cast(v => {
 *       assert.ok(v !== '');
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.Schema.Types.Date.cast(false);
 *
 * @param {Function} caster
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ SchemaDate.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ SchemaDate._defaultCaster = (v)=>{
    if (v != null && !(v instanceof Date)) {
        throw new Error();
    }
    return v;
};
/**
 * Declares a TTL index (rounded to the nearest second) for _Date_ types only.
 *
 * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.
 * This index type is only compatible with Date types.
 *
 * #### Example:
 *
 *     // expire in 24 hours
 *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});
 *
 * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:
 *
 * #### Example:
 *
 *     // expire in 24 hours
 *     new Schema({ createdAt: { type: Date, expires: '24h' }});
 *
 *     // expire in 1.5 hours
 *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});
 *
 *     // expire in 7 days
 *     const schema = new Schema({ createdAt: Date });
 *     schema.path('createdAt').expires('7d');
 *
 * @param {Number|String} when
 * @added 3.0.0
 * @return {SchemaType} this
 * @api public
 */ SchemaDate.prototype.expires = function(when) {
    if (getConstructorName(this._index) !== "Object") {
        this._index = {};
    }
    this._index.expires = when;
    utils.expires(this._index);
    return this;
};
/*!
 * ignore
 */ SchemaDate._checkRequired = (v)=>v instanceof Date;
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * #### Example:
 *
 *     // Allow empty strings to pass `required` check
 *     mongoose.Schema.Types.String.checkRequired(v => v != null);
 *
 *     const M = mongoose.model({ str: { type: String, required: true } });
 *     new M({ str: '' }).validateSync(); // `null`, validation passes!
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ SchemaDate.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator. To satisfy
 * a required validator, the given value must be an instance of `Date`.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ SchemaDate.prototype.checkRequired = function(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return value != null;
    }
    // `require('util').inherits()` does **not** copy static properties, and
    // plugins like mongoose-float use `inherits()` for pre-ES6.
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
    return _checkRequired(value);
};
/**
 * Sets a minimum date validator.
 *
 * #### Example:
 *
 *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })
 *     const M = db.model('M', s)
 *     const m = new M({ d: Date('1969-12-31') })
 *     m.save(function (err) {
 *       console.error(err) // validator error
 *       m.d = Date('2014-12-08');
 *       m.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MIN} token which will be replaced with the invalid value
 *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
 *     const schema = new Schema({ d: { type: Date, min: min })
 *     const M = mongoose.model('M', schema);
 *     const s= new M({ d: Date('1969-12-31') });
 *     s.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).
 *     })
 *
 * @param {Date} value minimum date
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaDate.prototype.min = function(value, message) {
    if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.minValidator;
        }, this);
    }
    if (value) {
        let msg = message || MongooseError.messages.Date.min;
        if (typeof msg === "string") {
            msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
            validator: this.minValidator = function(val) {
                let _value = value;
                if (typeof value === "function" && value !== Date.now) {
                    _value = _value.call(this);
                }
                const min = _value === Date.now ? _value() : _this.cast(_value);
                return val === null || val.valueOf() >= min.valueOf();
            },
            message: msg,
            type: "min",
            min: value
        });
    }
    return this;
};
/**
 * Sets a maximum date validator.
 *
 * #### Example:
 *
 *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })
 *     const M = db.model('M', s)
 *     const m = new M({ d: Date('2014-12-08') })
 *     m.save(function (err) {
 *       console.error(err) // validator error
 *       m.d = Date('2013-12-31');
 *       m.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MAX} token which will be replaced with the invalid value
 *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
 *     const schema = new Schema({ d: { type: Date, max: max })
 *     const M = mongoose.model('M', schema);
 *     const s= new M({ d: Date('2014-12-08') });
 *     s.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).
 *     })
 *
 * @param {Date} maximum date
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaDate.prototype.max = function(value, message) {
    if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.maxValidator;
        }, this);
    }
    if (value) {
        let msg = message || MongooseError.messages.Date.max;
        if (typeof msg === "string") {
            msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
            validator: this.maxValidator = function(val) {
                let _value = value;
                if (typeof _value === "function" && _value !== Date.now) {
                    _value = _value.call(this);
                }
                const max = _value === Date.now ? _value() : _this.cast(_value);
                return val === null || val.valueOf() <= max.valueOf();
            },
            message: msg,
            type: "max",
            max: value
        });
    }
    return this;
};
/**
 * Casts to date
 *
 * @param {Object} value to cast
 * @api private
 */ SchemaDate.prototype.cast = function(value) {
    let castDate;
    if (typeof this._castFunction === "function") {
        castDate = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castDate = this.constructor.cast();
    } else {
        castDate = SchemaDate.cast();
    }
    try {
        return castDate(value);
    } catch (error) {
        throw new CastError("date", value, this.path, error, this);
    }
};
/**
 * Date Query casting.
 *
 * @param {Any} val
 * @api private
 */ function handleSingle(val) {
    return this.cast(val);
}
SchemaDate.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
});
/**
 * Casts contents for queries.
 *
 * @param {String} $conditional
 * @param {any} [value]
 * @api private
 */ SchemaDate.prototype.castForQuery = function($conditional, val) {
    if (arguments.length !== 2) {
        return this._castForQuery($conditional);
    }
    const handler = this.$conditionalHandlers[$conditional];
    if (!handler) {
        throw new Error("Can't use " + $conditional + " with Date.");
    }
    return handler.call(this, val);
};
/*!
 * Module exports.
 */ module.exports = SchemaDate;


/***/ }),

/***/ 98567:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const SchemaType = __webpack_require__(98878);
const CastError = SchemaType.CastError;
const castDecimal128 = __webpack_require__(46930);
const utils = __webpack_require__(52100);
const isBsonType = __webpack_require__(85847);
/**
 * Decimal128 SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function Decimal128(key, options) {
    SchemaType.call(this, key, options, "Decimal128");
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ Decimal128.schemaName = "Decimal128";
Decimal128.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ Decimal128.prototype = Object.create(SchemaType.prototype);
Decimal128.prototype.constructor = Decimal128;
/*!
 * ignore
 */ Decimal128._cast = castDecimal128;
/**
 * Sets a default option for all Decimal128 instances.
 *
 * #### Example:
 *
 *     // Make all decimal 128s have `required` of true by default.
 *     mongoose.Schema.Decimal128.set('required', true);
 *
 *     const User = mongoose.model('User', new Schema({ test: mongoose.Decimal128 }));
 *     new User({ }).validateSync().errors.test.message; // Path `test` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ Decimal128.set = SchemaType.set;
/**
 * Get/set the function used to cast arbitrary values to decimals.
 *
 * #### Example:
 *
 *     // Make Mongoose only refuse to cast numbers as decimal128
 *     const original = mongoose.Schema.Types.Decimal128.cast();
 *     mongoose.Decimal128.cast(v => {
 *       assert.ok(typeof v !== 'number');
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.Decimal128.cast(false);
 *
 * @param {Function} [caster]
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ Decimal128.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ Decimal128._defaultCaster = (v)=>{
    if (v != null && !isBsonType(v, "Decimal128")) {
        throw new Error();
    }
    return v;
};
/*!
 * ignore
 */ Decimal128._checkRequired = (v)=>isBsonType(v, "Decimal128");
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ Decimal128.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ Decimal128.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
    }
    // `require('util').inherits()` does **not** copy static properties, and
    // plugins like mongoose-float use `inherits()` for pre-ES6.
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : Decimal128.checkRequired();
    return _checkRequired(value);
};
/**
 * Casts to Decimal128
 *
 * @param {Object} value
 * @param {Object} doc
 * @param {Boolean} init whether this is an initialization cast
 * @api private
 */ Decimal128.prototype.cast = function(value, doc, init) {
    if (SchemaType._isRef(this, value, doc, init)) {
        if (isBsonType(value, "Decimal128")) {
            return value;
        }
        return this._castRef(value, doc, init);
    }
    let castDecimal128;
    if (typeof this._castFunction === "function") {
        castDecimal128 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castDecimal128 = this.constructor.cast();
    } else {
        castDecimal128 = Decimal128.cast();
    }
    try {
        return castDecimal128(value);
    } catch (error) {
        throw new CastError("Decimal128", value, this.path, error, this);
    }
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.cast(val);
}
Decimal128.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
});
/*!
 * Module exports.
 */ module.exports = Decimal128;


/***/ }),

/***/ 87568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const ArrayType = __webpack_require__(81491);
const CastError = __webpack_require__(96996);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const SchemaDocumentArrayOptions = __webpack_require__(50857);
const SchemaType = __webpack_require__(98878);
const SubdocumentPath = __webpack_require__(24046);
const discriminator = __webpack_require__(47683);
const handleIdOption = __webpack_require__(61688);
const handleSpreadDoc = __webpack_require__(4715);
const utils = __webpack_require__(52100);
const getConstructor = __webpack_require__(81442);
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const arrayPathSymbol = (__webpack_require__(5089).arrayPathSymbol);
const documentArrayParent = (__webpack_require__(5089).documentArrayParent);
let MongooseDocumentArray;
let Subdocument;
/**
 * SubdocsArray SchemaType constructor
 *
 * @param {String} key
 * @param {Schema} schema
 * @param {Object} options
 * @param {Object} schemaOptions
 * @inherits SchemaArray
 * @api public
 */ function DocumentArrayPath(key, schema, options, schemaOptions) {
    const schemaTypeIdOption = DocumentArrayPath.defaultOptions && DocumentArrayPath.defaultOptions._id;
    if (schemaTypeIdOption != null) {
        schemaOptions = schemaOptions || {};
        schemaOptions._id = schemaTypeIdOption;
    }
    if (schemaOptions != null && schemaOptions._id != null) {
        schema = handleIdOption(schema, schemaOptions);
    } else if (options != null && options._id != null) {
        schema = handleIdOption(schema, options);
    }
    const EmbeddedDocument = _createConstructor(schema, options);
    EmbeddedDocument.prototype.$basePath = key;
    ArrayType.call(this, key, EmbeddedDocument, options);
    this.schema = schema;
    this.schemaOptions = schemaOptions || {};
    this.$isMongooseDocumentArray = true;
    this.Constructor = EmbeddedDocument;
    EmbeddedDocument.base = schema.base;
    const fn = this.defaultValue;
    if (!("defaultValue" in this) || fn !== void 0) {
        this.default(function() {
            let arr = fn.call(this);
            if (arr != null && !Array.isArray(arr)) {
                arr = [
                    arr
                ];
            }
            // Leave it up to `cast()` to convert this to a documentarray
            return arr;
        });
    }
    const parentSchemaType = this;
    this.$embeddedSchemaType = new SchemaType(key + ".$", {
        required: this && this.schemaOptions && this.schemaOptions.required || false
    });
    this.$embeddedSchemaType.cast = function(value, doc, init) {
        return parentSchemaType.cast(value, doc, init)[0];
    };
    this.$embeddedSchemaType.doValidate = function(value, fn, scope, options) {
        const Constructor = getConstructor(this.caster, value);
        if (value && !(value instanceof Constructor)) {
            value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);
        }
        return SubdocumentPath.prototype.doValidate.call(this, value, fn, scope, options);
    };
    this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;
    this.$embeddedSchemaType.caster = this.Constructor;
    this.$embeddedSchemaType.schema = this.schema;
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ DocumentArrayPath.schemaName = "DocumentArray";
/**
 * Options for all document arrays.
 *
 * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.
 *
 * @api public
 */ DocumentArrayPath.options = {
    castNonArrays: true
};
/*!
 * Inherits from ArrayType.
 */ DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
DocumentArrayPath.prototype.constructor = DocumentArrayPath;
DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
/*!
 * ignore
 */ function _createConstructor(schema, options, baseClass) {
    Subdocument || (Subdocument = __webpack_require__(46829));
    // compile an embedded document for this schema
    function EmbeddedDocument() {
        Subdocument.apply(this, arguments);
        if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {
            return;
        }
        this.$session(this.__parentArray.getArrayParent().$session());
    }
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
    EmbeddedDocument.prototype = Object.create(proto);
    EmbeddedDocument.prototype.$__setSchema(schema);
    EmbeddedDocument.schema = schema;
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    EmbeddedDocument.$isArraySubdocument = true;
    EmbeddedDocument.events = new EventEmitter();
    EmbeddedDocument.base = schema.base;
    // apply methods
    for(const i in schema.methods){
        EmbeddedDocument.prototype[i] = schema.methods[i];
    }
    // apply statics
    for(const i in schema.statics){
        EmbeddedDocument[i] = schema.statics[i];
    }
    for(const i in EventEmitter.prototype){
        EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.options = options;
    return EmbeddedDocument;
}
/**
 * Adds a discriminator to this document array.
 *
 * #### Example:
 *
 *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });
 *     const schema = Schema({ shapes: [shapeSchema] });
 *
 *     const docArrayPath = parentSchema.path('shapes');
 *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));
 *
 * @param {String} name
 * @param {Schema} schema fields to add to the schema for instances of this sub-class
 * @param {Object|string} [options] If string, same as `options.value`.
 * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.
 * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.
 * @see discriminators /docs/discriminators.html
 * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model
 * @api public
 */ DocumentArrayPath.prototype.discriminator = function(name, schema, options) {
    if (typeof name === "function") {
        name = utils.getFunctionName(name);
    }
    options = options || {};
    const tiedValue = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone) {
        schema = schema.clone();
    }
    schema = discriminator(this.casterConstructor, name, schema, tiedValue);
    const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
    EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
    try {
        Object.defineProperty(EmbeddedDocument, "name", {
            value: name
        });
    } catch (error) {
    // Ignore error, only happens on old versions of node
    }
    this.casterConstructor.discriminators[name] = EmbeddedDocument;
    return this.casterConstructor.discriminators[name];
};
/**
 * Performs local validations first, then validations on each embedded doc
 *
 * @api private
 */ DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {
    // lazy load
    MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(90102));
    const _this = this;
    try {
        SchemaType.prototype.doValidate.call(this, array, cb, scope);
    } catch (err) {
        return fn(err);
    }
    function cb(err) {
        if (err) {
            return fn(err);
        }
        let count = array && array.length;
        let error;
        if (!count) {
            return fn();
        }
        if (options && options.updateValidator) {
            return fn();
        }
        if (!utils.isMongooseDocumentArray(array)) {
            array = new MongooseDocumentArray(array, _this.path, scope);
        }
        // handle sparse arrays, do not use array.forEach which does not
        // iterate over sparse elements yet reports array.length including
        // them :(
        function callback(err) {
            if (err != null) {
                error = err;
            }
            --count || fn(error);
        }
        for(let i = 0, len = count; i < len; ++i){
            // sidestep sparse entries
            let doc = array[i];
            if (doc == null) {
                --count || fn(error);
                continue;
            }
            // If you set the array index directly, the doc might not yet be
            // a full fledged mongoose subdoc, so make it into one.
            if (!(doc instanceof Subdocument)) {
                const Constructor = getConstructor(_this.casterConstructor, array[i]);
                doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
            }
            if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
                --count || fn(error);
                continue;
            }
            doc.$__validate(callback);
        }
    }
};
/**
 * Performs local validations first, then validations on each embedded doc.
 *
 * #### Note:
 *
 * This method ignores the asynchronous validators.
 *
 * @return {MongooseError|undefined}
 * @api private
 */ DocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {
    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
    if (schemaTypeError != null) {
        return schemaTypeError;
    }
    const count = array && array.length;
    let resultError = null;
    if (!count) {
        return;
    }
    // handle sparse arrays, do not use array.forEach which does not
    // iterate over sparse elements yet reports array.length including
    // them :(
    for(let i = 0, len = count; i < len; ++i){
        // sidestep sparse entries
        let doc = array[i];
        if (!doc) {
            continue;
        }
        // If you set the array index directly, the doc might not yet be
        // a full fledged mongoose subdoc, so make it into one.
        if (!(doc instanceof Subdocument)) {
            const Constructor = getConstructor(this.casterConstructor, array[i]);
            doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
            continue;
        }
        const subdocValidateError = doc.validateSync();
        if (subdocValidateError && resultError == null) {
            resultError = subdocValidateError;
        }
    }
    return resultError;
};
/*!
 * ignore
 */ DocumentArrayPath.prototype.getDefault = function(scope, init, options) {
    let ret = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
    if (ret == null) {
        return ret;
    }
    if (options && options.skipCast) {
        return ret;
    }
    // lazy load
    MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(90102));
    if (!Array.isArray(ret)) {
        ret = [
            ret
        ];
    }
    ret = new MongooseDocumentArray(ret, this.path, scope);
    for(let i = 0; i < ret.length; ++i){
        const Constructor = getConstructor(this.casterConstructor, ret[i]);
        const _subdoc = new Constructor({}, ret, undefined, undefined, i);
        _subdoc.$init(ret[i]);
        _subdoc.isNew = true;
        // Make sure all paths in the subdoc are set to `default` instead
        // of `init` since we used `init`.
        Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
        _subdoc.$__.activePaths.init = {};
        ret[i] = _subdoc;
    }
    return ret;
};
const _toObjectOptions = Object.freeze({
    transform: false,
    virtuals: false
});
const initDocumentOptions = Object.freeze({
    skipId: false,
    willInit: true
});
/**
 * Casts contents
 *
 * @param {Object} value
 * @param {Document} document that triggers the casting
 * @api private
 */ DocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {
    // lazy load
    MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(90102));
    // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266
    if (value != null && value[arrayPathSymbol] != null && value === prev) {
        return value;
    }
    let selected;
    let subdoc;
    options = options || {};
    if (!Array.isArray(value)) {
        if (!init && !DocumentArrayPath.options.castNonArrays) {
            throw new CastError("DocumentArray", value, this.path, null, this);
        }
        // gh-2442 mark whole array as modified if we're initializing a doc from
        // the db and the path isn't an array in the document
        if (!!doc && init) {
            doc.markModified(this.path);
        }
        return this.cast([
            value
        ], doc, init, prev, options);
    }
    // We need to create a new array, otherwise change tracking will
    // update the old doc (gh-4449)
    if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {
        value = new MongooseDocumentArray(value, this.path, doc);
    }
    if (prev != null) {
        value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
    }
    if (options.arrayPathIndex != null) {
        value[arrayPathSymbol] = this.path + "." + options.arrayPathIndex;
    }
    const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;
    const len = rawArray.length;
    for(let i = 0; i < len; ++i){
        if (!rawArray[i]) {
            continue;
        }
        const Constructor = getConstructor(this.casterConstructor, rawArray[i]);
        // Check if the document has a different schema (re gh-3701)
        if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {
            const spreadDoc = handleSpreadDoc(rawArray[i], true);
            if (rawArray[i] !== spreadDoc) {
                rawArray[i] = spreadDoc;
            } else {
                rawArray[i] = rawArray[i].toObject({
                    transform: false,
                    // Special case: if different model, but same schema, apply virtuals
                    // re: gh-7898
                    virtuals: rawArray[i].schema === Constructor.schema
                });
            }
        }
        if (rawArray[i] instanceof Subdocument) {
            if (rawArray[i][documentArrayParent] !== doc) {
                if (init) {
                    const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
                    rawArray[i] = subdoc.$init(rawArray[i]);
                } else {
                    const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);
                    rawArray[i] = subdoc;
                }
            }
            // Might not have the correct index yet, so ensure it does.
            if (rawArray[i].__index == null) {
                rawArray[i].$setIndex(i);
            }
        } else if (rawArray[i] != null) {
            if (init) {
                if (doc) {
                    selected || (selected = scopePaths(this, doc.$__.selected, init));
                } else {
                    selected = true;
                }
                subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
                rawArray[i] = subdoc.$init(rawArray[i]);
            } else {
                if (prev && typeof prev.id === "function") {
                    subdoc = prev.id(rawArray[i]._id);
                }
                if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {
                    // handle resetting doc with existing id and same data
                    subdoc.set(rawArray[i]);
                    // if set() is hooked it will have no return value
                    // see gh-746
                    rawArray[i] = subdoc;
                } else {
                    try {
                        subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);
                        // if set() is hooked it will have no return value
                        // see gh-746
                        rawArray[i] = subdoc;
                    } catch (error) {
                        throw new CastError("embedded", rawArray[i], value[arrayPathSymbol], error, this);
                    }
                }
            }
        }
    }
    return value;
};
/*!
 * ignore
 */ DocumentArrayPath.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
        schematype.requiredValidator = this.requiredValidator;
    }
    schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);
    return schematype;
};
/*!
 * ignore
 */ DocumentArrayPath.prototype.applyGetters = function(value, scope) {
    return SchemaType.prototype.applyGetters.call(this, value, scope);
};
/**
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param {DocumentArrayPath} array the array to scope `fields` paths
 * @param {Object|undefined} fields the root fields selected in the query
 * @param {Boolean|undefined} init if we are being created part of a query result
 * @api private
 */ function scopePaths(array, fields, init) {
    if (!(init && fields)) {
        return undefined;
    }
    const path = array.path + ".";
    const keys = Object.keys(fields);
    let i = keys.length;
    const selected = {};
    let hasKeys;
    let key;
    let sub;
    while(i--){
        key = keys[i];
        if (key.startsWith(path)) {
            sub = key.substring(path.length);
            if (sub === "$") {
                continue;
            }
            if (sub.startsWith("$.")) {
                sub = sub.substring(2);
            }
            hasKeys || (hasKeys = true);
            selected[sub] = fields[key];
        }
    }
    return hasKeys && selected || undefined;
}
/*!
 * ignore
 */ DocumentArrayPath.defaultOptions = {};
/**
 * Sets a default option for all DocumentArray instances.
 *
 * #### Example:
 *
 *     // Make all numbers have option `min` equal to 0.
 *     mongoose.Schema.DocumentArray.set('_id', false);
 *
 * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)
 * @param {Any} value The value of the option you'd like to set.
 * @return {void}
 * @function set
 * @static
 * @api public
 */ DocumentArrayPath.set = SchemaType.set;
/*!
 * Module exports.
 */ module.exports = DocumentArrayPath;


/***/ }),

/***/ 20042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module exports.
 */ 
exports.String = __webpack_require__(434);
exports.Number = __webpack_require__(31410);
exports.Boolean = __webpack_require__(64248);
exports.DocumentArray = __webpack_require__(87568);
exports.Subdocument = __webpack_require__(24046);
exports.Array = __webpack_require__(81491);
exports.Buffer = __webpack_require__(48964);
exports.Date = __webpack_require__(16701);
exports.ObjectId = __webpack_require__(88108);
exports.Mixed = __webpack_require__(76541);
exports.Decimal128 = exports.Decimal = __webpack_require__(98567);
exports.Map = __webpack_require__(45717);
exports.UUID = __webpack_require__(785);
// alias
exports.Oid = exports.ObjectId;
exports.Object = exports.Mixed;
exports.Bool = exports.Boolean;
exports.ObjectID = exports.ObjectId;


/***/ }),

/***/ 45717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * ignore
 */ const MongooseMap = __webpack_require__(58269);
const SchemaMapOptions = __webpack_require__(53945);
const SchemaType = __webpack_require__(98878);
/*!
 * ignore
 */ class Map extends SchemaType {
    constructor(key, options){
        super(key, options, "Map");
        this.$isSchemaMap = true;
    }
    set(option, value) {
        return SchemaType.set(option, value);
    }
    cast(val, doc, init) {
        if (val instanceof MongooseMap) {
            return val;
        }
        const path = this.path;
        if (init) {
            const map = new MongooseMap({}, path, doc, this.$__schemaType);
            if (val instanceof global.Map) {
                for (const key of val.keys()){
                    let _val = val.get(key);
                    if (_val == null) {
                        _val = map.$__schemaType._castNullish(_val);
                    } else {
                        _val = map.$__schemaType.cast(_val, doc, true, null, {
                            path: path + "." + key
                        });
                    }
                    map.$init(key, _val);
                }
            } else {
                for (const key of Object.keys(val)){
                    let _val = val[key];
                    if (_val == null) {
                        _val = map.$__schemaType._castNullish(_val);
                    } else {
                        _val = map.$__schemaType.cast(_val, doc, true, null, {
                            path: path + "." + key
                        });
                    }
                    map.$init(key, _val);
                }
            }
            return map;
        }
        return new MongooseMap(val, path, doc, this.$__schemaType);
    }
    clone() {
        const schematype = super.clone();
        if (this.$__schemaType != null) {
            schematype.$__schemaType = this.$__schemaType.clone();
        }
        return schematype;
    }
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ Map.schemaName = "Map";
Map.prototype.OptionsConstructor = SchemaMapOptions;
Map.defaultOptions = {};
module.exports = Map;


/***/ }),

/***/ 76541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const SchemaType = __webpack_require__(98878);
const symbols = __webpack_require__(36825);
const isObject = __webpack_require__(89026);
const utils = __webpack_require__(52100);
/**
 * Mixed SchemaType constructor.
 *
 * @param {String} path
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function Mixed(path, options) {
    if (options && options.default) {
        const def = options.default;
        if (Array.isArray(def) && def.length === 0) {
            // make sure empty array defaults are handled
            options.default = Array;
        } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {
            // prevent odd "shared" objects between documents
            options.default = function() {
                return {};
            };
        }
    }
    SchemaType.call(this, path, options, "Mixed");
    this[symbols.schemaMixedSymbol] = true;
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ Mixed.schemaName = "Mixed";
Mixed.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ Mixed.prototype = Object.create(SchemaType.prototype);
Mixed.prototype.constructor = Mixed;
/**
 * Attaches a getter for all Mixed paths.
 *
 * #### Example:
 *
 *     // Hide the 'hidden' path
 *     mongoose.Schema.Mixed.get(v => Object.assign({}, v, { hidden: null }));
 *
 *     const Model = mongoose.model('Test', new Schema({ test: {} }));
 *     new Model({ test: { hidden: 'Secret!' } }).test.hidden; // null
 *
 * @param {Function} getter
 * @return {this}
 * @function get
 * @static
 * @api public
 */ Mixed.get = SchemaType.get;
/**
 * Sets a default option for all Mixed instances.
 *
 * #### Example:
 *
 *     // Make all mixed instances have `required` of true by default.
 *     mongoose.Schema.Mixed.set('required', true);
 *
 *     const User = mongoose.model('User', new Schema({ test: mongoose.Mixed }));
 *     new User({ }).validateSync().errors.test.message; // Path `test` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ Mixed.set = SchemaType.set;
/**
 * Casts `val` for Mixed.
 *
 * _this is a no-op_
 *
 * @param {Object} value to cast
 * @api private
 */ Mixed.prototype.cast = function(val) {
    if (val instanceof Error) {
        return utils.errorToPOJO(val);
    }
    return val;
};
/**
 * Casts contents for queries.
 *
 * @param {String} $cond
 * @param {any} [val]
 * @api private
 */ Mixed.prototype.castForQuery = function($cond, val) {
    if (arguments.length === 2) {
        return val;
    }
    return $cond;
};
/*!
 * Module exports.
 */ module.exports = Mixed;


/***/ }),

/***/ 31410:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module requirements.
 */ const MongooseError = __webpack_require__(40413);
const SchemaNumberOptions = __webpack_require__(93610);
const SchemaType = __webpack_require__(98878);
const castNumber = __webpack_require__(71155);
const handleBitwiseOperator = __webpack_require__(48826);
const utils = __webpack_require__(52100);
const CastError = SchemaType.CastError;
/**
 * Number SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SchemaNumber(key, options) {
    SchemaType.call(this, key, options, "Number");
}
/**
 * Attaches a getter for all Number instances.
 *
 * #### Example:
 *
 *     // Make all numbers round down
 *     mongoose.Number.get(function(v) { return Math.floor(v); });
 *
 *     const Model = mongoose.model('Test', new Schema({ test: Number }));
 *     new Model({ test: 3.14 }).test; // 3
 *
 * @param {Function} getter
 * @return {this}
 * @function get
 * @static
 * @api public
 */ SchemaNumber.get = SchemaType.get;
/**
 * Sets a default option for all Number instances.
 *
 * #### Example:
 *
 *     // Make all numbers have option `min` equal to 0.
 *     mongoose.Schema.Number.set('min', 0);
 *
 *     const Order = mongoose.model('Order', new Schema({ amount: Number }));
 *     new Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ SchemaNumber.set = SchemaType.set;
/*!
 * ignore
 */ SchemaNumber._cast = castNumber;
/**
 * Get/set the function used to cast arbitrary values to numbers.
 *
 * #### Example:
 *
 *     // Make Mongoose cast empty strings '' to 0 for paths declared as numbers
 *     const original = mongoose.Number.cast();
 *     mongoose.Number.cast(v => {
 *       if (v === '') { return 0; }
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.Number.cast(false);
 *
 * @param {Function} caster
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ SchemaNumber.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ SchemaNumber._defaultCaster = (v)=>{
    if (typeof v !== "number") {
        throw new Error();
    }
    return v;
};
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaNumber.schemaName = "Number";
SchemaNumber.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ SchemaNumber.prototype = Object.create(SchemaType.prototype);
SchemaNumber.prototype.constructor = SchemaNumber;
SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
/*!
 * ignore
 */ SchemaNumber._checkRequired = (v)=>typeof v === "number" || v instanceof Number;
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ SchemaNumber.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return value != null;
    }
    // `require('util').inherits()` does **not** copy static properties, and
    // plugins like mongoose-float use `inherits()` for pre-ES6.
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
    return _checkRequired(value);
};
/**
 * Sets a minimum number validator.
 *
 * #### Example:
 *
 *     const s = new Schema({ n: { type: Number, min: 10 })
 *     const M = db.model('M', s)
 *     const m = new M({ n: 9 })
 *     m.save(function (err) {
 *       console.error(err) // validator error
 *       m.n = 10;
 *       m.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MIN} token which will be replaced with the invalid value
 *     const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
 *     const schema = new Schema({ n: { type: Number, min: min })
 *     const M = mongoose.model('Measurement', schema);
 *     const s= new M({ n: 4 });
 *     s.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).
 *     })
 *
 * @param {Number} value minimum number
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaNumber.prototype.min = function(value, message) {
    if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.minValidator;
        }, this);
    }
    if (value !== null && value !== undefined) {
        let msg = message || MongooseError.messages.Number.min;
        msg = msg.replace(/{MIN}/, value);
        this.validators.push({
            validator: this.minValidator = function(v) {
                return v == null || v >= value;
            },
            message: msg,
            type: "min",
            min: value
        });
    }
    return this;
};
/**
 * Sets a maximum number validator.
 *
 * #### Example:
 *
 *     const s = new Schema({ n: { type: Number, max: 10 })
 *     const M = db.model('M', s)
 *     const m = new M({ n: 11 })
 *     m.save(function (err) {
 *       console.error(err) // validator error
 *       m.n = 10;
 *       m.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MAX} token which will be replaced with the invalid value
 *     const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
 *     const schema = new Schema({ n: { type: Number, max: max })
 *     const M = mongoose.model('Measurement', schema);
 *     const s= new M({ n: 4 });
 *     s.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).
 *     })
 *
 * @param {Number} maximum number
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaNumber.prototype.max = function(value, message) {
    if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.maxValidator;
        }, this);
    }
    if (value !== null && value !== undefined) {
        let msg = message || MongooseError.messages.Number.max;
        msg = msg.replace(/{MAX}/, value);
        this.validators.push({
            validator: this.maxValidator = function(v) {
                return v == null || v <= value;
            },
            message: msg,
            type: "max",
            max: value
        });
    }
    return this;
};
/**
 * Sets a enum validator
 *
 * #### Example:
 *
 *     const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });
 *     const M = db.model('M', s);
 *
 *     const m = new M({ n: 4 });
 *     await m.save(); // throws validation error
 *
 *     m.n = 3;
 *     await m.save(); // succeeds
 *
 * @param {Array} values allowed values
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaNumber.prototype.enum = function(values, message) {
    if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.enumValidator;
        }, this);
    }
    if (!Array.isArray(values)) {
        const isObjectSyntax = utils.isPOJO(values) && values.values != null;
        if (isObjectSyntax) {
            message = values.message;
            values = values.values;
        } else if (typeof values === "number") {
            values = Array.prototype.slice.call(arguments);
            message = null;
        }
        if (utils.isPOJO(values)) {
            values = Object.values(values);
        }
        message = message || MongooseError.messages.Number.enum;
    }
    message = message == null ? MongooseError.messages.Number.enum : message;
    this.enumValidator = (v)=>v == null || values.indexOf(v) !== -1;
    this.validators.push({
        validator: this.enumValidator,
        message: message,
        type: "enum",
        enumValues: values
    });
    return this;
};
/**
 * Casts to number
 *
 * @param {Object} value value to cast
 * @param {Document} doc document that triggers the casting
 * @param {Boolean} init
 * @api private
 */ SchemaNumber.prototype.cast = function(value, doc, init) {
    if (typeof value !== "number" && SchemaType._isRef(this, value, doc, init)) {
        if (value == null || utils.isNonBuiltinObject(value)) {
            return this._castRef(value, doc, init);
        }
    }
    const val = value && typeof value._id !== "undefined" ? value._id : value;
    let castNumber;
    if (typeof this._castFunction === "function") {
        castNumber = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castNumber = this.constructor.cast();
    } else {
        castNumber = SchemaNumber.cast();
    }
    try {
        return castNumber(val);
    } catch (err) {
        throw new CastError("Number", val, this.path, err, this);
    }
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.cast(val);
}
function handleArray(val) {
    const _this = this;
    if (!Array.isArray(val)) {
        return [
            this.cast(val)
        ];
    }
    return val.map(function(m) {
        return _this.cast(m);
    });
}
SchemaNumber.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $mod: handleArray
});
/**
 * Casts contents for queries.
 *
 * @param {String} $conditional
 * @param {any} [value]
 * @api private
 */ SchemaNumber.prototype.castForQuery = function($conditional, val) {
    let handler;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
            throw new CastError("number", val, this.path, null, this);
        }
        return handler.call(this, val);
    }
    val = this._castForQuery($conditional);
    return val;
};
/*!
 * Module exports.
 */ module.exports = SchemaNumber;


/***/ }),

/***/ 88108:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const SchemaObjectIdOptions = __webpack_require__(96782);
const SchemaType = __webpack_require__(98878);
const castObjectId = __webpack_require__(82637);
const getConstructorName = __webpack_require__(4065);
const oid = __webpack_require__(41370);
const isBsonType = __webpack_require__(85847);
const utils = __webpack_require__(52100);
const CastError = SchemaType.CastError;
let Document;
/**
 * ObjectId SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function ObjectId(key, options) {
    const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
    const suppressWarning = options && options.suppressWarning;
    if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
        utils.warn("mongoose: To create a new ObjectId please try " + "`Mongoose.Types.ObjectId` instead of using " + "`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if " + "you're trying to create a hex char path in your schema.");
    }
    SchemaType.call(this, key, options, "ObjectID");
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ ObjectId.schemaName = "ObjectId";
ObjectId.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ ObjectId.prototype = Object.create(SchemaType.prototype);
ObjectId.prototype.constructor = ObjectId;
ObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;
/**
 * Attaches a getter for all ObjectId instances
 *
 * #### Example:
 *
 *     // Always convert to string when getting an ObjectId
 *     mongoose.ObjectId.get(v => v.toString());
 *
 *     const Model = mongoose.model('Test', new Schema({}));
 *     typeof (new Model({})._id); // 'string'
 *
 * @param {Function} getter
 * @return {this}
 * @function get
 * @static
 * @api public
 */ ObjectId.get = SchemaType.get;
/**
 * Sets a default option for all ObjectId instances.
 *
 * #### Example:
 *
 *     // Make all object ids have option `required` equal to true.
 *     mongoose.Schema.ObjectId.set('required', true);
 *
 *     const Order = mongoose.model('Order', new Schema({ userId: ObjectId }));
 *     new Order({ }).validateSync().errors.userId.message; // Path `userId` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ ObjectId.set = SchemaType.set;
/**
 * Adds an auto-generated ObjectId default if turnOn is true.
 * @param {Boolean} turnOn auto generated ObjectId defaults
 * @api public
 * @return {SchemaType} this
 */ ObjectId.prototype.auto = function(turnOn) {
    if (turnOn) {
        this.default(defaultId);
        this.set(resetId);
    }
    return this;
};
/*!
 * ignore
 */ ObjectId._checkRequired = (v)=>isBsonType(v, "ObjectID");
/*!
 * ignore
 */ ObjectId._cast = castObjectId;
/**
 * Get/set the function used to cast arbitrary values to objectids.
 *
 * #### Example:
 *
 *     // Make Mongoose only try to cast length 24 strings. By default, any 12
 *     // char string is a valid ObjectId.
 *     const original = mongoose.ObjectId.cast();
 *     mongoose.ObjectId.cast(v => {
 *       assert.ok(typeof v !== 'string' || v.length === 24);
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.ObjectId.cast(false);
 *
 * @param {Function} caster
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ ObjectId.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ ObjectId._defaultCaster = (v)=>{
    if (!isBsonType(v, "ObjectID")) {
        throw new Error(v + " is not an instance of ObjectId");
    }
    return v;
};
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * #### Example:
 *
 *     // Allow empty strings to pass `required` check
 *     mongoose.Schema.Types.String.checkRequired(v => v != null);
 *
 *     const M = mongoose.model({ str: { type: String, required: true } });
 *     new M({ str: '' }).validateSync(); // `null`, validation passes!
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ ObjectId.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ ObjectId.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
    }
    // `require('util').inherits()` does **not** copy static properties, and
    // plugins like mongoose-float use `inherits()` for pre-ES6.
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : ObjectId.checkRequired();
    return _checkRequired(value);
};
/**
 * Casts to ObjectId
 *
 * @param {Object} value
 * @param {Object} doc
 * @param {Boolean} init whether this is an initialization cast
 * @api private
 */ ObjectId.prototype.cast = function(value, doc, init) {
    if (!isBsonType(value, "ObjectID") && SchemaType._isRef(this, value, doc, init)) {
        // wait! we may need to cast this to a document
        if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
            return new oid(value.toHexString());
        }
        if (value == null || utils.isNonBuiltinObject(value)) {
            return this._castRef(value, doc, init);
        }
    }
    let castObjectId;
    if (typeof this._castFunction === "function") {
        castObjectId = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castObjectId = this.constructor.cast();
    } else {
        castObjectId = ObjectId.cast();
    }
    try {
        return castObjectId(value);
    } catch (error) {
        throw new CastError("ObjectId", value, this.path, error, this);
    }
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.cast(val);
}
ObjectId.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
});
/*!
 * ignore
 */ function defaultId() {
    return new oid();
}
defaultId.$runBeforeSetters = true;
function resetId(v) {
    Document || (Document = __webpack_require__(14001));
    if (this instanceof Document) {
        if (v === void 0) {
            const _v = new oid();
            return _v;
        }
    }
    return v;
}
/*!
 * Module exports.
 */ module.exports = ObjectId;


/***/ }),

/***/ 48826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module requirements.
 */ 
const CastError = __webpack_require__(96996);
/*!
 * ignore
 */ function handleBitwiseOperator(val) {
    const _this = this;
    if (Array.isArray(val)) {
        return val.map(function(v) {
            return _castNumber(_this.path, v);
        });
    } else if (Buffer.isBuffer(val)) {
        return val;
    }
    // Assume trying to cast to number
    return _castNumber(_this.path, val);
}
/*!
 * ignore
 */ function _castNumber(path, num) {
    const v = Number(num);
    if (isNaN(v)) {
        throw new CastError("number", num, path);
    }
    return v;
}
module.exports = handleBitwiseOperator;


/***/ }),

/***/ 13637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const castBoolean = __webpack_require__(46709);
/*!
 * ignore
 */ module.exports = function(val) {
    const path = this != null ? this.path : null;
    return castBoolean(val, path);
};


/***/ }),

/***/ 95280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module requirements.
 */ 
const castArraysOfNumbers = (__webpack_require__(22272)/* .castArraysOfNumbers */ .i);
const castToNumber = (__webpack_require__(22272)/* .castToNumber */ .W);
/*!
 * ignore
 */ exports.cast$geoIntersects = cast$geoIntersects;
exports.cast$near = cast$near;
exports.cast$within = cast$within;
function cast$near(val) {
    const SchemaArray = __webpack_require__(81491);
    if (Array.isArray(val)) {
        castArraysOfNumbers(val, this);
        return val;
    }
    _castMinMaxDistance(this, val);
    if (val && val.$geometry) {
        return cast$geometry(val, this);
    }
    if (!Array.isArray(val)) {
        throw new TypeError("$near must be either an array or an object " + "with a $geometry property");
    }
    return SchemaArray.prototype.castForQuery.call(this, val);
}
function cast$geometry(val, self) {
    switch(val.$geometry.type){
        case "Polygon":
        case "LineString":
        case "Point":
            castArraysOfNumbers(val.$geometry.coordinates, self);
            break;
        default:
            break;
    }
    _castMinMaxDistance(self, val);
    return val;
}
function cast$within(val) {
    _castMinMaxDistance(this, val);
    if (val.$box || val.$polygon) {
        const type = val.$box ? "$box" : "$polygon";
        val[type].forEach((arr)=>{
            if (!Array.isArray(arr)) {
                const msg = "Invalid $within $box argument. " + "Expected an array, received " + arr;
                throw new TypeError(msg);
            }
            arr.forEach((v, i)=>{
                arr[i] = castToNumber.call(this, v);
            });
        });
    } else if (val.$center || val.$centerSphere) {
        const type = val.$center ? "$center" : "$centerSphere";
        val[type].forEach((item, i)=>{
            if (Array.isArray(item)) {
                item.forEach((v, j)=>{
                    item[j] = castToNumber.call(this, v);
                });
            } else {
                val[type][i] = castToNumber.call(this, item);
            }
        });
    } else if (val.$geometry) {
        cast$geometry(val, this);
    }
    return val;
}
function cast$geoIntersects(val) {
    const geo = val.$geometry;
    if (!geo) {
        return;
    }
    cast$geometry(val, this);
    return val;
}
function _castMinMaxDistance(self, val) {
    if (val.$maxDistance) {
        val.$maxDistance = castToNumber.call(self, val.$maxDistance);
    }
    if (val.$minDistance) {
        val.$minDistance = castToNumber.call(self, val.$minDistance);
    }
}


/***/ }),

/***/ 22272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module requirements.
 */ const SchemaNumber = __webpack_require__(31410);
/*!
 * ignore
 */ exports.W = castToNumber;
exports.i = castArraysOfNumbers;
/*!
 * ignore
 */ function castToNumber(val) {
    return SchemaNumber.cast()(val);
}
function castArraysOfNumbers(arr, self) {
    arr.forEach(function(v, i) {
        if (Array.isArray(v)) {
            castArraysOfNumbers(v, self);
        } else {
            arr[i] = castToNumber.call(self, v);
        }
    });
}


/***/ }),

/***/ 83398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CastError = __webpack_require__(96996);
const castBoolean = __webpack_require__(46709);
const castString = __webpack_require__(16199);
/**
 * Casts val to an object suitable for `$text`. Throws an error if the object
 * can't be casted.
 *
 * @param {Any} val value to cast
 * @param {String} [path] path to associate with any errors that occured
 * @return {Object} casted object
 * @see https://docs.mongodb.com/manual/reference/operator/query/text/
 * @api private
 */ module.exports = function(val, path) {
    if (val == null || typeof val !== "object") {
        throw new CastError("$text", val, path);
    }
    if (val.$search != null) {
        val.$search = castString(val.$search, path + ".$search");
    }
    if (val.$language != null) {
        val.$language = castString(val.$language, path + ".$language");
    }
    if (val.$caseSensitive != null) {
        val.$caseSensitive = castBoolean(val.$caseSensitive, path + ".$castSensitive");
    }
    if (val.$diacriticSensitive != null) {
        val.$diacriticSensitive = castBoolean(val.$diacriticSensitive, path + ".$diacriticSensitive");
    }
    return val;
};


/***/ }),

/***/ 92340:
/***/ ((module) => {

"use strict";

/*!
 * ignore
 */ module.exports = function(val) {
    if (Array.isArray(val)) {
        if (!val.every((v)=>typeof v === "number" || typeof v === "string")) {
            throw new Error("$type array values must be strings or numbers");
        }
        return val;
    }
    if (typeof val !== "number" && typeof val !== "string") {
        throw new Error("$type parameter must be number, string, or array of numbers and strings");
    }
    return val;
};


/***/ }),

/***/ 434:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const SchemaType = __webpack_require__(98878);
const MongooseError = __webpack_require__(40413);
const SchemaStringOptions = __webpack_require__(50942);
const castString = __webpack_require__(16199);
const utils = __webpack_require__(52100);
const isBsonType = __webpack_require__(85847);
const CastError = SchemaType.CastError;
/**
 * String SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SchemaString(key, options) {
    this.enumValues = [];
    this.regExp = null;
    SchemaType.call(this, key, options, "String");
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaString.schemaName = "String";
SchemaString.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ SchemaString.prototype = Object.create(SchemaType.prototype);
SchemaString.prototype.constructor = SchemaString;
Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: SchemaStringOptions
});
/*!
 * ignore
 */ SchemaString._cast = castString;
/**
 * Get/set the function used to cast arbitrary values to strings.
 *
 * #### Example:
 *
 *     // Throw an error if you pass in an object. Normally, Mongoose allows
 *     // objects with custom `toString()` functions.
 *     const original = mongoose.Schema.Types.String.cast();
 *     mongoose.Schema.Types.String.cast(v => {
 *       assert.ok(v == null || typeof v !== 'object');
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.Schema.Types.String.cast(false);
 *
 * @param {Function} caster
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ SchemaString.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ SchemaString._defaultCaster = (v)=>{
    if (v != null && typeof v !== "string") {
        throw new Error();
    }
    return v;
};
/**
 * Attaches a getter for all String instances.
 *
 * #### Example:
 *
 *     // Make all numbers round down
 *     mongoose.Schema.String.get(v => v.toLowerCase());
 *
 *     const Model = mongoose.model('Test', new Schema({ test: String }));
 *     new Model({ test: 'FOO' }).test; // 'foo'
 *
 * @param {Function} getter
 * @return {this}
 * @function get
 * @static
 * @api public
 */ SchemaString.get = SchemaType.get;
/**
 * Sets a default option for all String instances.
 *
 * #### Example:
 *
 *     // Make all strings have option `trim` equal to true.
 *     mongoose.Schema.String.set('trim', true);
 *
 *     const User = mongoose.model('User', new Schema({ name: String }));
 *     new User({ name: '   John Doe   ' }).name; // 'John Doe'
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ SchemaString.set = SchemaType.set;
/*!
 * ignore
 */ SchemaString._checkRequired = (v)=>(v instanceof String || typeof v === "string") && v.length;
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * #### Example:
 *
 *     // Allow empty strings to pass `required` check
 *     mongoose.Schema.Types.String.checkRequired(v => v != null);
 *
 *     const M = mongoose.model({ str: { type: String, required: true } });
 *     new M({ str: '' }).validateSync(); // `null`, validation passes!
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ SchemaString.checkRequired = SchemaType.checkRequired;
/**
 * Adds an enum validator
 *
 * #### Example:
 *
 *     const states = ['opening', 'open', 'closing', 'closed']
 *     const s = new Schema({ state: { type: String, enum: states }})
 *     const M = db.model('M', s)
 *     const m = new M({ state: 'invalid' })
 *     m.save(function (err) {
 *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.
 *       m.state = 'open'
 *       m.save(callback) // success
 *     })
 *
 *     // or with custom error messages
 *     const enum = {
 *       values: ['opening', 'open', 'closing', 'closed'],
 *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'
 *     }
 *     const s = new Schema({ state: { type: String, enum: enum })
 *     const M = db.model('M', s)
 *     const m = new M({ state: 'invalid' })
 *     m.save(function (err) {
 *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`
 *       m.state = 'open'
 *       m.save(callback) // success
 *     })
 *
 * @param {...String|Object} [args] enumeration values
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaString.prototype.enum = function() {
    if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.enumValidator;
        }, this);
        this.enumValidator = false;
    }
    if (arguments[0] === void 0 || arguments[0] === false) {
        return this;
    }
    let values;
    let errorMessage;
    if (utils.isObject(arguments[0])) {
        if (Array.isArray(arguments[0].values)) {
            values = arguments[0].values;
            errorMessage = arguments[0].message;
        } else {
            values = utils.object.vals(arguments[0]);
            errorMessage = MongooseError.messages.String.enum;
        }
    } else {
        values = arguments;
        errorMessage = MongooseError.messages.String.enum;
    }
    for (const value of values){
        if (value !== undefined) {
            this.enumValues.push(this.cast(value));
        }
    }
    const vals = this.enumValues;
    this.enumValidator = function(v) {
        return undefined === v || ~vals.indexOf(v);
    };
    this.validators.push({
        validator: this.enumValidator,
        message: errorMessage,
        type: "enum",
        enumValues: vals
    });
    return this;
};
/**
 * Adds a lowercase [setter](https://mongoosejs.com/docs/api/schematype.html#schematype_SchemaType-set).
 *
 * #### Example:
 *
 *     const s = new Schema({ email: { type: String, lowercase: true }})
 *     const M = db.model('M', s);
 *     const m = new M({ email: 'SomeEmail@example.COM' });
 *     console.log(m.email) // someemail@example.com
 *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'
 *
 * Note that `lowercase` does **not** affect regular expression queries:
 *
 * #### Example:
 *
 *     // Still queries for documents whose `email` matches the regular
 *     // expression /SomeEmail/. Mongoose does **not** convert the RegExp
 *     // to lowercase.
 *     M.find({ email: /SomeEmail/ });
 *
 * @api public
 * @return {SchemaType} this
 */ SchemaString.prototype.lowercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
        return this;
    }
    return this.set((v)=>{
        if (typeof v !== "string") {
            v = this.cast(v);
        }
        if (v) {
            return v.toLowerCase();
        }
        return v;
    });
};
/**
 * Adds an uppercase [setter](https://mongoosejs.com/docs/api/schematype.html#schematype_SchemaType-set).
 *
 * #### Example:
 *
 *     const s = new Schema({ caps: { type: String, uppercase: true }})
 *     const M = db.model('M', s);
 *     const m = new M({ caps: 'an example' });
 *     console.log(m.caps) // AN EXAMPLE
 *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'
 *
 * Note that `uppercase` does **not** affect regular expression queries:
 *
 * #### Example:
 *
 *     // Mongoose does **not** convert the RegExp to uppercase.
 *     M.find({ email: /an example/ });
 *
 * @api public
 * @return {SchemaType} this
 */ SchemaString.prototype.uppercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
        return this;
    }
    return this.set((v)=>{
        if (typeof v !== "string") {
            v = this.cast(v);
        }
        if (v) {
            return v.toUpperCase();
        }
        return v;
    });
};
/**
 * Adds a trim [setter](https://mongoosejs.com/docs/api/schematype.html#schematype_SchemaType-set).
 *
 * The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: { type: String, trim: true }});
 *     const M = db.model('M', s);
 *     const string = ' some name ';
 *     console.log(string.length); // 11
 *     const m = new M({ name: string });
 *     console.log(m.name.length); // 9
 *
 *     // Equivalent to `findOne({ name: string.trim() })`
 *     M.findOne({ name: string });
 *
 * Note that `trim` does **not** affect regular expression queries:
 *
 * #### Example:
 *
 *     // Mongoose does **not** trim whitespace from the RegExp.
 *     M.find({ name: / some name / });
 *
 * @api public
 * @return {SchemaType} this
 */ SchemaString.prototype.trim = function(shouldTrim) {
    if (arguments.length > 0 && !shouldTrim) {
        return this;
    }
    return this.set((v)=>{
        if (typeof v !== "string") {
            v = this.cast(v);
        }
        if (v) {
            return v.trim();
        }
        return v;
    });
};
/**
 * Sets a minimum length validator.
 *
 * #### Example:
 *
 *     const schema = new Schema({ postalCode: { type: String, minlength: 5 })
 *     const Address = db.model('Address', schema)
 *     const address = new Address({ postalCode: '9512' })
 *     address.save(function (err) {
 *       console.error(err) // validator error
 *       address.postalCode = '95125';
 *       address.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length
 *     const minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];
 *     const schema = new Schema({ postalCode: { type: String, minlength: minlength })
 *     const Address = mongoose.model('Address', schema);
 *     const address = new Address({ postalCode: '9512' });
 *     address.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).
 *     })
 *
 * @param {Number} value minimum string length
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaString.prototype.minlength = function(value, message) {
    if (this.minlengthValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.minlengthValidator;
        }, this);
    }
    if (value !== null && value !== undefined) {
        let msg = message || MongooseError.messages.String.minlength;
        msg = msg.replace(/{MINLENGTH}/, value);
        this.validators.push({
            validator: this.minlengthValidator = function(v) {
                return v === null || v.length >= value;
            },
            message: msg,
            type: "minlength",
            minlength: value
        });
    }
    return this;
};
SchemaString.prototype.minLength = SchemaString.prototype.minlength;
/**
 * Sets a maximum length validator.
 *
 * #### Example:
 *
 *     const schema = new Schema({ postalCode: { type: String, maxlength: 9 })
 *     const Address = db.model('Address', schema)
 *     const address = new Address({ postalCode: '9512512345' })
 *     address.save(function (err) {
 *       console.error(err) // validator error
 *       address.postalCode = '95125';
 *       address.save() // success
 *     })
 *
 *     // custom error messages
 *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length
 *     const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];
 *     const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })
 *     const Address = mongoose.model('Address', schema);
 *     const address = new Address({ postalCode: '9512512345' });
 *     address.validate(function (err) {
 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).
 *     })
 *
 * @param {Number} value maximum string length
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaString.prototype.maxlength = function(value, message) {
    if (this.maxlengthValidator) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.maxlengthValidator;
        }, this);
    }
    if (value !== null && value !== undefined) {
        let msg = message || MongooseError.messages.String.maxlength;
        msg = msg.replace(/{MAXLENGTH}/, value);
        this.validators.push({
            validator: this.maxlengthValidator = function(v) {
                return v === null || v.length <= value;
            },
            message: msg,
            type: "maxlength",
            maxlength: value
        });
    }
    return this;
};
SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
/**
 * Sets a regexp validator.
 *
 * Any value that does not pass `regExp`.test(val) will fail validation.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: { type: String, match: /^a/ }})
 *     const M = db.model('M', s)
 *     const m = new M({ name: 'I am invalid' })
 *     m.validate(function (err) {
 *       console.error(String(err)) // "ValidationError: Path `name` is invalid (I am invalid)."
 *       m.name = 'apples'
 *       m.validate(function (err) {
 *         assert.ok(err) // success
 *       })
 *     })
 *
 *     // using a custom error message
 *     const match = [ /\.html$/, "That file doesn't end in .html ({VALUE})" ];
 *     const s = new Schema({ file: { type: String, match: match }})
 *     const M = db.model('M', s);
 *     const m = new M({ file: 'invalid' });
 *     m.validate(function (err) {
 *       console.log(String(err)) // "ValidationError: That file doesn't end in .html (invalid)"
 *     })
 *
 * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.
 *
 *     const s = new Schema({ name: { type: String, match: /^a/, required: true }})
 *
 * @param {RegExp} regExp regular expression to test against
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @api public
 */ SchemaString.prototype.match = function match(regExp, message) {
    // yes, we allow multiple match validators
    const msg = message || MongooseError.messages.String.match;
    const matchValidator = function(v) {
        if (!regExp) {
            return false;
        }
        // In case RegExp happens to have `/g` flag set, we need to reset the
        // `lastIndex`, otherwise `match` will intermittently fail.
        regExp.lastIndex = 0;
        const ret = v != null && v !== "" ? regExp.test(v) : true;
        return ret;
    };
    this.validators.push({
        validator: matchValidator,
        message: msg,
        type: "regexp",
        regexp: regExp
    });
    return this;
};
/**
 * Check if the given value satisfies the `required` validator. The value is
 * considered valid if it is a string (that is, not `null` or `undefined`) and
 * has positive length. The `required` validator **will** fail for empty
 * strings.
 *
 * @param {Any} value
 * @param {Document} doc
 * @return {Boolean}
 * @api public
 */ SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
        return value != null;
    }
    // `require('util').inherits()` does **not** copy static properties, and
    // plugins like mongoose-float use `inherits()` for pre-ES6.
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
    return _checkRequired(value);
};
/**
 * Casts to String
 *
 * @api private
 */ SchemaString.prototype.cast = function(value, doc, init) {
    if (typeof value !== "string" && SchemaType._isRef(this, value, doc, init)) {
        return this._castRef(value, doc, init);
    }
    let castString;
    if (typeof this._castFunction === "function") {
        castString = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castString = this.constructor.cast();
    } else {
        castString = SchemaString.cast();
    }
    try {
        return castString(value);
    } catch (error) {
        throw new CastError("string", value, this.path, null, this);
    }
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.castForQuery(val);
}
/*!
 * ignore
 */ function handleArray(val) {
    const _this = this;
    if (!Array.isArray(val)) {
        return [
            this.castForQuery(val)
        ];
    }
    return val.map(function(m) {
        return _this.castForQuery(m);
    });
}
/*!
 * ignore
 */ function handleSingleNoSetters(val) {
    if (val == null) {
        return this._castNullish(val);
    }
    return this.cast(val, this);
}
const $conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $options: handleSingleNoSetters,
    $regex: function handle$regex(val) {
        if (Object.prototype.toString.call(val) === "[object RegExp]") {
            return val;
        }
        return handleSingleNoSetters.call(this, val);
    },
    $not: handleSingle
});
Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Object.freeze($conditionalHandlers)
});
/**
 * Casts contents for queries.
 *
 * @param {String} $conditional
 * @param {any} [val]
 * @api private
 */ SchemaString.prototype.castForQuery = function($conditional, val) {
    let handler;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
            throw new Error("Can't use " + $conditional + " with String.");
        }
        return handler.call(this, val);
    }
    val = $conditional;
    if (Object.prototype.toString.call(val) === "[object RegExp]" || isBsonType(val, "BSONRegExp")) {
        return val;
    }
    return this._castForQuery(val);
};
/*!
 * Module exports.
 */ module.exports = SchemaString;


/***/ }),

/***/ 36825:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
exports.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");


/***/ }),

/***/ 785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const MongooseBuffer = __webpack_require__(77784);
const SchemaType = __webpack_require__(98878);
const CastError = SchemaType.CastError;
const utils = __webpack_require__(52100);
const isBsonType = __webpack_require__(85847);
const handleBitwiseOperator = __webpack_require__(48826);
const UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;
const Binary = MongooseBuffer.Binary;
/**
 * Helper function to convert the input hex-string to a buffer
 * @param {String} hex The hex string to convert
 * @returns {Buffer} The hex as buffer
 * @api private
 */ function hex2buffer(hex) {
    // use buffer built-in function to convert from hex-string to buffer
    const buff = Buffer.from(hex, "hex");
    return buff;
}
/**
 * Helper function to convert the buffer input to a string
 * @param {Buffer} buf The buffer to convert to a hex-string
 * @returns {String} The buffer as a hex-string
 * @api private
 */ function binary2hex(buf) {
    // use buffer built-in function to convert from buffer to hex-string
    const hex = buf.toString("hex");
    return hex;
}
/**
 * Convert a String to Binary
 * @param {String} uuidStr The value to process
 * @returns {MongooseBuffer} The binary to store
 * @api private
 */ function stringToBinary(uuidStr) {
    // Protect against undefined & throwing err
    if (typeof uuidStr !== "string") uuidStr = "";
    const hex = uuidStr.replace(/[{}-]/g, ""); // remove extra characters
    const bytes = hex2buffer(hex);
    const buff = new MongooseBuffer(bytes);
    buff._subtype = 4;
    return buff;
}
/**
 * Convert binary to a uuid string
 * @param {Buffer|Binary|String} uuidBin The value to process
 * @returns {String} The completed uuid-string
 * @api private
 */ function binaryToString(uuidBin) {
    // i(hasezoey) dont quite know why, but "uuidBin" may sometimes also be the already processed string
    let hex;
    if (typeof uuidBin !== "string") {
        hex = binary2hex(uuidBin);
        const uuidStr = hex.substring(0, 8) + "-" + hex.substring(8, 8 + 4) + "-" + hex.substring(12, 12 + 4) + "-" + hex.substring(16, 16 + 4) + "-" + hex.substring(20, 20 + 12);
        return uuidStr;
    }
    return uuidBin;
}
/**
 * UUIDv1 SchemaType constructor.
 *
 * @param {String} key
 * @param {Object} options
 * @inherits SchemaType
 * @api public
 */ function SchemaUUID(key, options) {
    SchemaType.call(this, key, options, "UUID");
    this.getters.push(binaryToString);
}
/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */ SchemaUUID.schemaName = "UUID";
SchemaUUID.defaultOptions = {};
/*!
 * Inherits from SchemaType.
 */ SchemaUUID.prototype = Object.create(SchemaType.prototype);
SchemaUUID.prototype.constructor = SchemaUUID;
/*!
 * ignore
 */ SchemaUUID._cast = function(value) {
    if (value === null) {
        return value;
    }
    function newBuffer(initbuff) {
        const buff = new MongooseBuffer(initbuff);
        buff._subtype = 4;
        return buff;
    }
    if (typeof value === "string") {
        if (UUID_FORMAT.test(value)) {
            return stringToBinary(value);
        } else {
            throw new CastError(SchemaUUID.schemaName, value, this.path);
        }
    }
    if (Buffer.isBuffer(value)) {
        return newBuffer(value);
    }
    if (value instanceof Binary) {
        return newBuffer(value.value(true));
    }
    // Re: gh-647 and gh-3030, we're ok with casting using `toString()`
    // **unless** its the default Object.toString, because "[object Object]"
    // doesn't really qualify as useful data
    if (value.toString && value.toString !== Object.prototype.toString) {
        if (UUID_FORMAT.test(value.toString())) {
            return stringToBinary(value.toString());
        }
    }
    throw new CastError(SchemaUUID.schemaName, value, this.path);
};
/**
 * Sets a default option for all UUID instances.
 *
 * #### Example:
 *
 *     // Make all UUIDs have `required` of true by default.
 *     mongoose.Schema.UUID.set('required', true);
 *
 *     const User = mongoose.model('User', new Schema({ test: mongoose.UUID }));
 *     new User({ }).validateSync().errors.test.message; // Path `test` is required.
 *
 * @param {String} option The option you'd like to set the value for
 * @param {Any} value value for option
 * @return {undefined}
 * @function set
 * @static
 * @api public
 */ SchemaUUID.set = SchemaType.set;
/**
 * Get/set the function used to cast arbitrary values to UUIDs.
 *
 * #### Example:
 *
 *     // Make Mongoose refuse to cast UUIDs with 0 length
 *     const original = mongoose.Schema.Types.UUID.cast();
 *     mongoose.UUID.cast(v => {
 *       assert.ok(typeof v === "string" && v.length > 0);
 *       return original(v);
 *     });
 *
 *     // Or disable casting entirely
 *     mongoose.UUID.cast(false);
 *
 * @param {Function} [caster]
 * @return {Function}
 * @function get
 * @static
 * @api public
 */ SchemaUUID.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
};
/*!
 * ignore
 */ SchemaUUID._checkRequired = (v)=>v != null;
/**
 * Override the function the required validator uses to check whether a string
 * passes the `required` check.
 *
 * @param {Function} fn
 * @return {Function}
 * @function checkRequired
 * @static
 * @api public
 */ SchemaUUID.checkRequired = SchemaType.checkRequired;
/**
 * Check if the given value satisfies a required validator.
 *
 * @param {Any} value
 * @return {Boolean}
 * @api public
 */ SchemaUUID.prototype.checkRequired = function checkRequired(value) {
    return UUID_FORMAT.test(value);
};
/**
 * Casts to UUID
 *
 * @param {Object} value
 * @param {Object} doc
 * @param {Boolean} init whether this is an initialization cast
 * @api private
 */ SchemaUUID.prototype.cast = function(value, doc, init) {
    if (SchemaType._isRef(this, value, doc, init)) {
        if (isBsonType(value, "UUID")) {
            return value;
        }
        return this._castRef(value, doc, init);
    }
    let castFn;
    if (typeof this._castFunction === "function") {
        castFn = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
        castFn = this.constructor.cast();
    } else {
        castFn = SchemaUUID.cast();
    }
    try {
        return castFn(value);
    } catch (error) {
        throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);
    }
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.cast(val);
}
/*!
 * ignore
 */ function handleArray(val) {
    return val.map((m)=>{
        return this.cast(m);
    });
}
SchemaUUID.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $in: handleArray,
    $lt: handleSingle,
    $lte: handleSingle,
    $ne: handleSingle,
    $nin: handleArray
});
/**
 * Casts contents for queries.
 *
 * @param {String} $conditional
 * @param {any} val
 * @api private
 */ SchemaUUID.prototype.castForQuery = function($conditional, val) {
    let handler;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) throw new Error("Can't use " + $conditional + " with UUID.");
        return handler.call(this, val);
    } else {
        return this.cast($conditional);
    }
};
/*!
 * Module exports.
 */ module.exports = SchemaUUID;


/***/ }),

/***/ 98878:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const MongooseError = __webpack_require__(40413);
const SchemaTypeOptions = __webpack_require__(84252);
const $exists = __webpack_require__(13637);
const $type = __webpack_require__(92340);
const handleImmutable = __webpack_require__(82819);
const isAsyncFunction = __webpack_require__(27297);
const isSimpleValidator = __webpack_require__(51418);
const immediate = __webpack_require__(96621);
const schemaTypeSymbol = (__webpack_require__(5089).schemaTypeSymbol);
const utils = __webpack_require__(52100);
const validatorErrorSymbol = (__webpack_require__(5089).validatorErrorSymbol);
const documentIsModified = (__webpack_require__(5089).documentIsModified);
const populateModelSymbol = (__webpack_require__(5089).populateModelSymbol);
const CastError = MongooseError.CastError;
const ValidatorError = MongooseError.ValidatorError;
const setOptionsForDefaults = {
    _skipMarkModified: true
};
/**
 * SchemaType constructor. Do **not** instantiate `SchemaType` directly.
 * Mongoose converts your schema paths into SchemaTypes automatically.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String });
 *     schema.path('name') instanceof SchemaType; // true
 *
 * @param {String} path
 * @param {SchemaTypeOptions} [options] See [SchemaTypeOptions docs](/docs/api/schematypeoptions.html)
 * @param {String} [instance]
 * @api public
 */ function SchemaType(path, options, instance) {
    this[schemaTypeSymbol] = true;
    this.path = path;
    this.instance = instance;
    this.validators = [];
    this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
    this.setters = [];
    this.splitPath();
    options = options || {};
    const defaultOptions = this.constructor.defaultOptions || {};
    const defaultOptionsKeys = Object.keys(defaultOptions);
    for (const option of defaultOptionsKeys){
        if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {
            options[option] = defaultOptions[option];
        }
    }
    if (options.select == null) {
        delete options.select;
    }
    const Options = this.OptionsConstructor || SchemaTypeOptions;
    this.options = new Options(options);
    this._index = null;
    if (utils.hasUserDefinedProperty(this.options, "immutable")) {
        this.$immutable = this.options.immutable;
        handleImmutable(this);
    }
    const keys = Object.keys(this.options);
    for (const prop of keys){
        if (prop === "cast") {
            this.castFunction(this.options[prop]);
            continue;
        }
        if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
            // { unique: true, index: true }
            if (prop === "index" && this._index) {
                if (options.index === false) {
                    const index = this._index;
                    if (typeof index === "object" && index != null) {
                        if (index.unique) {
                            throw new Error('Path "' + this.path + '" may not have `index` ' + "set to false and `unique` set to true");
                        }
                        if (index.sparse) {
                            throw new Error('Path "' + this.path + '" may not have `index` ' + "set to false and `sparse` set to true");
                        }
                    }
                    this._index = false;
                }
                continue;
            }
            const val = options[prop];
            // Special case so we don't screw up array defaults, see gh-5780
            if (prop === "default") {
                this.default(val);
                continue;
            }
            const opts = Array.isArray(val) ? val : [
                val
            ];
            this[prop].apply(this, opts);
        }
    }
    Object.defineProperty(this, "$$context", {
        enumerable: false,
        configurable: false,
        writable: true,
        value: null
    });
}
/**
 * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.
 * @memberOf SchemaType
 * @instance
 * @api private
 */ SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
/**
 * The path to this SchemaType in a Schema.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: String });
 *     schema.path('name').path; // 'name'
 *
 * @property path
 * @api public
 * @memberOf SchemaType
 */ SchemaType.prototype.path;
/**
 * The validators that Mongoose should run to validate properties at this SchemaType's path.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: { type: String, required: true } });
 *     schema.path('name').validators.length; // 1, the `required` validator
 *
 * @property validators
 * @api public
 * @memberOf SchemaType
 */ SchemaType.prototype.validators;
/**
 * True if this SchemaType has a required validator. False otherwise.
 *
 * #### Example:
 *
 *     const schema = new Schema({ name: { type: String, required: true } });
 *     schema.path('name').isRequired; // true
 *
 *     schema.path('name').required(false);
 *     schema.path('name').isRequired; // false
 *
 * @property isRequired
 * @api public
 * @memberOf SchemaType
 */ SchemaType.prototype.validators;
/**
 * Split the current dottet path into segments
 *
 * @return {String[]|undefined}
 * @api private
 */ SchemaType.prototype.splitPath = function() {
    if (this._presplitPath != null) {
        return this._presplitPath;
    }
    if (this.path == null) {
        return undefined;
    }
    this._presplitPath = this.path.indexOf(".") === -1 ? [
        this.path
    ] : this.path.split(".");
    return this._presplitPath;
};
/**
 * Get/set the function used to cast arbitrary values to this type.
 *
 * #### Example:
 *
 *     // Disallow `null` for numbers, and don't try to cast any values to
 *     // numbers, so even strings like '123' will cause a CastError.
 *     mongoose.Number.cast(function(v) {
 *       assert.ok(v === undefined || typeof v === 'number');
 *       return v;
 *     });
 *
 * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed
 * @return {Function}
 * @static
 * @memberOf SchemaType
 * @function cast
 * @api public
 */ SchemaType.cast = function cast(caster) {
    if (arguments.length === 0) {
        return this._cast;
    }
    if (caster === false) {
        caster = (v)=>v;
    }
    this._cast = caster;
    return this._cast;
};
/**
 * Get/set the function used to cast arbitrary values to this particular schematype instance.
 * Overrides `SchemaType.cast()`.
 *
 * #### Example:
 *
 *     // Disallow `null` for numbers, and don't try to cast any values to
 *     // numbers, so even strings like '123' will cause a CastError.
 *     const number = new mongoose.Number('mypath', {});
 *     number.cast(function(v) {
 *       assert.ok(v === undefined || typeof v === 'number');
 *       return v;
 *     });
 *
 * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed
 * @return {Function}
 * @memberOf SchemaType
 * @api public
 */ SchemaType.prototype.castFunction = function castFunction(caster) {
    if (arguments.length === 0) {
        return this._castFunction;
    }
    if (caster === false) {
        caster = this.constructor._defaultCaster || ((v)=>v);
    }
    this._castFunction = caster;
    return this._castFunction;
};
/**
 * The function that Mongoose calls to cast arbitrary values to this SchemaType.
 *
 * @param {Object} value value to cast
 * @param {Document} doc document that triggers the casting
 * @param {Boolean} init
 * @api public
 */ SchemaType.prototype.cast = function cast() {
    throw new Error("Base SchemaType class does not implement a `cast()` function");
};
/**
 * Sets a default option for this schema type.
 *
 * #### Example:
 *
 *     // Make all strings be trimmed by default
 *     mongoose.SchemaTypes.String.set('trim', true);
 *
 * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)
 * @param {Any} value The value of the option you'd like to set.
 * @return {void}
 * @static
 * @memberOf SchemaType
 * @function set
 * @api public
 */ SchemaType.set = function set(option, value) {
    if (!this.hasOwnProperty("defaultOptions")) {
        this.defaultOptions = Object.assign({}, this.defaultOptions);
    }
    this.defaultOptions[option] = value;
};
/**
 * Attaches a getter for all instances of this schema type.
 *
 * #### Example:
 *
 *     // Make all numbers round down
 *     mongoose.Number.get(function(v) { return Math.floor(v); });
 *
 * @param {Function} getter
 * @return {this}
 * @static
 * @memberOf SchemaType
 * @function get
 * @api public
 */ SchemaType.get = function(getter) {
    this.getters = this.hasOwnProperty("getters") ? this.getters : [];
    this.getters.push(getter);
};
/**
 * Sets a default value for this SchemaType.
 *
 * #### Example:
 *
 *     const schema = new Schema({ n: { type: Number, default: 10 })
 *     const M = db.model('M', schema)
 *     const m = new M;
 *     console.log(m.n) // 10
 *
 * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.
 *
 * #### Example:
 *
 *     // values are cast:
 *     const schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})
 *     const M = db.model('M', schema)
 *     const m = new M;
 *     console.log(m.aNumber) // 4.815162342
 *
 *     // default unique objects for Mixed types:
 *     const schema = new Schema({ mixed: Schema.Types.Mixed });
 *     schema.path('mixed').default(function () {
 *       return {};
 *     });
 *
 *     // if we don't use a function to return object literals for Mixed defaults,
 *     // each document will receive a reference to the same object literal creating
 *     // a "shared" object instance:
 *     const schema = new Schema({ mixed: Schema.Types.Mixed });
 *     schema.path('mixed').default({});
 *     const M = db.model('M', schema);
 *     const m1 = new M;
 *     m1.mixed.added = 1;
 *     console.log(m1.mixed); // { added: 1 }
 *     const m2 = new M;
 *     console.log(m2.mixed); // { added: 1 }
 *
 * @param {Function|any} val The default value to set
 * @return {Any|undefined} Returns the set default value.
 * @api public
 */ SchemaType.prototype.default = function(val) {
    if (arguments.length === 1) {
        if (val === void 0) {
            this.defaultValue = void 0;
            return void 0;
        }
        if (val != null && val.instanceOfSchema) {
            throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
        }
        this.defaultValue = val;
        return this.defaultValue;
    } else if (arguments.length > 1) {
        this.defaultValue = [
            ...arguments
        ];
    }
    return this.defaultValue;
};
/**
 * Declares the index options for this schematype.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: { type: String, index: true })
 *     const s = new Schema({ name: { type: String, index: -1 })
 *     const s = new Schema({ loc: { type: [Number], index: 'hashed' })
 *     const s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })
 *     const s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})
 *     const s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})
 *     s.path('my.path').index(true);
 *     s.path('my.date').index({ expires: 60 });
 *     s.path('my.path').index({ unique: true, sparse: true });
 *
 * #### Note:
 *
 * _Indexes are created [in the background](https://docs.mongodb.com/manual/core/index-creation/#index-creation-background)
 * by default. If `background` is set to `false`, MongoDB will not execute any
 * read/write operations you send until the index build.
 * Specify `background: false` to override Mongoose's default._
 *
 * @param {Object|Boolean|String|Number} options
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.index = function(options) {
    this._index = options;
    utils.expires(this._index);
    return this;
};
/**
 * Declares an unique index.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: { type: String, unique: true } });
 *     s.path('name').index({ unique: true });
 *
 * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._
 *
 * @param {Boolean} bool
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.unique = function(bool) {
    if (this._index === false) {
        if (!bool) {
            return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `unique` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
        return this;
    }
    if (this._index == null || this._index === true) {
        this._index = {};
    } else if (typeof this._index === "string") {
        this._index = {
            type: this._index
        };
    }
    this._index.unique = bool;
    return this;
};
/**
 * Declares a full text index.
 *
 * ### Example:
 *
 *      const s = new Schema({ name : { type: String, text : true } })
 *      s.path('name').index({ text : true });
 *
 * @param {Boolean} bool
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.text = function(bool) {
    if (this._index === false) {
        if (!bool) {
            return this;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `text` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
        return this;
    }
    if (this._index === null || this._index === undefined || typeof this._index === "boolean") {
        this._index = {};
    } else if (typeof this._index === "string") {
        this._index = {
            type: this._index
        };
    }
    this._index.text = bool;
    return this;
};
/**
 * Declares a sparse index.
 *
 * #### Example:
 *
 *     const s = new Schema({ name: { type: String, sparse: true } });
 *     s.path('name').index({ sparse: true });
 *
 * @param {Boolean} bool
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.sparse = function(bool) {
    if (this._index === false) {
        if (!bool) {
            return this;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `sparse` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
        return this;
    }
    if (this._index == null || typeof this._index === "boolean") {
        this._index = {};
    } else if (typeof this._index === "string") {
        this._index = {
            type: this._index
        };
    }
    this._index.sparse = bool;
    return this;
};
/**
 * Defines this path as immutable. Mongoose prevents you from changing
 * immutable paths unless the parent document has [`isNew: true`](/docs/api/document.html#document_Document-isNew).
 *
 * #### Example:
 *
 *     const schema = new Schema({
 *       name: { type: String, immutable: true },
 *       age: Number
 *     });
 *     const Model = mongoose.model('Test', schema);
 *
 *     await Model.create({ name: 'test' });
 *     const doc = await Model.findOne();
 *
 *     doc.isNew; // false
 *     doc.name = 'new name';
 *     doc.name; // 'test', because `name` is immutable
 *
 * Mongoose also prevents changing immutable properties using `updateOne()`
 * and `updateMany()` based on [strict mode](/docs/guide.html#strict).
 *
 * #### Example:
 *
 *     // Mongoose will strip out the `name` update, because `name` is immutable
 *     Model.updateOne({}, { $set: { name: 'test2' }, $inc: { age: 1 } });
 *
 *     // If `strict` is set to 'throw', Mongoose will throw an error if you
 *     // update `name`
 *     const err = await Model.updateOne({}, { name: 'test2' }, { strict: 'throw' }).
 *       then(() => null, err => err);
 *     err.name; // StrictModeError
 *
 *     // If `strict` is `false`, Mongoose allows updating `name` even though
 *     // the property is immutable.
 *     Model.updateOne({}, { name: 'test2' }, { strict: false });
 *
 * @param {Boolean} bool
 * @return {SchemaType} this
 * @see isNew /docs/api/document.html#document_Document-isNew
 * @api public
 */ SchemaType.prototype.immutable = function(bool) {
    this.$immutable = bool;
    handleImmutable(this);
    return this;
};
/**
 * Defines a custom function for transforming this path when converting a document to JSON.
 *
 * Mongoose calls this function with one parameter: the current `value` of the path. Mongoose
 * then uses the return value in the JSON output.
 *
 * #### Example:
 *
 *     const schema = new Schema({
 *       date: { type: Date, transform: v => v.getFullYear() }
 *     });
 *     const Model = mongoose.model('Test', schema);
 *
 *     await Model.create({ date: new Date('2016-06-01') });
 *     const doc = await Model.findOne();
 *
 *     doc.date instanceof Date; // true
 *
 *     doc.toJSON().date; // 2016 as a number
 *     JSON.stringify(doc); // '{"_id":...,"date":2016}'
 *
 * @param {Function} fn
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.transform = function(fn) {
    this.options.transform = fn;
    return this;
};
/**
 * Adds a setter to this schematype.
 *
 * #### Example:
 *
 *     function capitalize (val) {
 *       if (typeof val !== 'string') val = '';
 *       return val.charAt(0).toUpperCase() + val.substring(1);
 *     }
 *
 *     // defining within the schema
 *     const s = new Schema({ name: { type: String, set: capitalize }});
 *
 *     // or with the SchemaType
 *     const s = new Schema({ name: String })
 *     s.path('name').set(capitalize);
 *
 * Setters allow you to transform the data before it gets to the raw mongodb
 * document or query.
 *
 * Suppose you are implementing user registration for a website. Users provide
 * an email and password, which gets saved to mongodb. The email is a string
 * that you will want to normalize to lower case, in order to avoid one email
 * having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.
 *
 * You can set up email lower case normalization easily via a Mongoose setter.
 *
 *     function toLower(v) {
 *       return v.toLowerCase();
 *     }
 *
 *     const UserSchema = new Schema({
 *       email: { type: String, set: toLower }
 *     });
 *
 *     const User = db.model('User', UserSchema);
 *
 *     const user = new User({email: 'AVENUE@Q.COM'});
 *     console.log(user.email); // 'avenue@q.com'
 *
 *     // or
 *     const user = new User();
 *     user.email = 'Avenue@Q.com';
 *     console.log(user.email); // 'avenue@q.com'
 *     User.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'
 *
 * As you can see above, setters allow you to transform the data before it
 * stored in MongoDB, or before executing a query.
 *
 * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._
 *
 *     new Schema({ email: { type: String, lowercase: true }})
 *
 * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.
 *
 *     function inspector (val, priorValue, schematype) {
 *       if (schematype.options.required) {
 *         return schematype.path + ' is required';
 *       } else {
 *         return val;
 *       }
 *     }
 *
 *     const VirusSchema = new Schema({
 *       name: { type: String, required: true, set: inspector },
 *       taxonomy: { type: String, set: inspector }
 *     })
 *
 *     const Virus = db.model('Virus', VirusSchema);
 *     const v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });
 *
 *     console.log(v.name);     // name is required
 *     console.log(v.taxonomy); // Parvovirinae
 *
 * You can also use setters to modify other properties on the document. If
 * you're setting a property `name` on a document, the setter will run with
 * `this` as the document. Be careful, in mongoose 5 setters will also run
 * when querying by `name` with `this` as the query.
 *
 *     const nameSchema = new Schema({ name: String, keywords: [String] });
 *     nameSchema.path('name').set(function(v) {
 *       // Need to check if `this` is a document, because in mongoose 5
 *       // setters will also run on queries, in which case `this` will be a
 *       // mongoose query object.
 *       if (this instanceof Document && v != null) {
 *         this.keywords = v.split(' ');
 *       }
 *       return v;
 *     });
 *
 * @param {Function} fn
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.set = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("A setter must be a function.");
    }
    this.setters.push(fn);
    return this;
};
/**
 * Adds a getter to this schematype.
 *
 * #### Example:
 *
 *     function dob (val) {
 *       if (!val) return val;
 *       return (val.getMonth() + 1) + "/" + val.getDate() + "/" + val.getFullYear();
 *     }
 *
 *     // defining within the schema
 *     const s = new Schema({ born: { type: Date, get: dob })
 *
 *     // or by retreiving its SchemaType
 *     const s = new Schema({ born: Date })
 *     s.path('born').get(dob)
 *
 * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.
 *
 * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:
 *
 *     function obfuscate (cc) {
 *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);
 *     }
 *
 *     const AccountSchema = new Schema({
 *       creditCardNumber: { type: String, get: obfuscate }
 *     });
 *
 *     const Account = db.model('Account', AccountSchema);
 *
 *     Account.findById(id, function (err, found) {
 *       console.log(found.creditCardNumber); // '****-****-****-1234'
 *     });
 *
 * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.
 *
 *     function inspector (val, priorValue, schematype) {
 *       if (schematype.options.required) {
 *         return schematype.path + ' is required';
 *       } else {
 *         return schematype.path + ' is not';
 *       }
 *     }
 *
 *     const VirusSchema = new Schema({
 *       name: { type: String, required: true, get: inspector },
 *       taxonomy: { type: String, get: inspector }
 *     })
 *
 *     const Virus = db.model('Virus', VirusSchema);
 *
 *     Virus.findById(id, function (err, virus) {
 *       console.log(virus.name);     // name is required
 *       console.log(virus.taxonomy); // taxonomy is not
 *     })
 *
 * @param {Function} fn
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.get = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("A getter must be a function.");
    }
    this.getters.push(fn);
    return this;
};
/**
 * Adds validator(s) for this document path.
 *
 * Validators always receive the value to validate as their first argument and
 * must return `Boolean`. Returning `false` or throwing an error means
 * validation failed.
 *
 * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_MongooseError-messages) will be used.
 *
 * #### Example:
 *
 *     // make sure every value is equal to "something"
 *     function validator (val) {
 *       return val === 'something';
 *     }
 *     new Schema({ name: { type: String, validate: validator }});
 *
 *     // with a custom error message
 *
 *     const custom = [validator, 'Uh oh, {PATH} does not equal "something".']
 *     new Schema({ name: { type: String, validate: custom }});
 *
 *     // adding many validators at a time
 *
 *     const many = [
 *         { validator: validator, msg: 'uh oh' }
 *       , { validator: anotherValidator, msg: 'failed' }
 *     ]
 *     new Schema({ name: { type: String, validate: many }});
 *
 *     // or utilizing SchemaType methods directly:
 *
 *     const schema = new Schema({ name: 'string' });
 *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');
 *
 * #### Error message templates:
 *
 * From the examples above, you may have noticed that error messages support
 * basic templating. There are a few other template keywords besides `{PATH}`
 * and `{VALUE}` too. To find out more, details are available
 * [here](#error_messages_MongooseError-messages).
 *
 * If Mongoose's built-in error message templating isn't enough, Mongoose
 * supports setting the `message` property to a function.
 *
 *     schema.path('name').validate({
 *       validator: function(v) { return v.length > 5; },
 *       // `errors['name']` will be "name must have length 5, got 'foo'"
 *       message: function(props) {
 *         return `${props.path} must have length 5, got '${props.value}'`;
 *       }
 *     });
 *
 * To bypass Mongoose's error messages and just copy the error message that
 * the validator throws, do this:
 *
 *     schema.path('name').validate({
 *       validator: function() { throw new Error('Oops!'); },
 *       // `errors['name']` will be "Oops!"
 *       message: function(props) { return props.reason.message; }
 *     });
 *
 * #### Asynchronous validation:
 *
 * Mongoose supports validators that return a promise. A validator that returns
 * a promise is called an _async validator_. Async validators run in
 * parallel, and `validate()` will wait until all async validators have settled.
 *
 *     schema.path('name').validate({
 *       validator: function (value) {
 *         return new Promise(function (resolve, reject) {
 *           resolve(false); // validation failed
 *         });
 *       }
 *     });
 *
 * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.
 *
 * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).
 *
 * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.
 *
 *     const conn = mongoose.createConnection(..);
 *     conn.on('error', handleError);
 *
 *     const Product = conn.model('Product', yourSchema);
 *     const dvd = new Product(..);
 *     dvd.save(); // emits error on the `conn` above
 *
 * If you want to handle these errors at the Model level, add an `error`
 * listener to your Model as shown below.
 *
 *     // registering an error listener on the Model lets us handle errors more locally
 *     Product.on('error', handleError);
 *
 * @param {RegExp|Function|Object} obj validator function, or hash describing options
 * @param {Function} [obj.validator] validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.
 * @param {String|Function} [obj.message] optional error message. If function, should return the error message as a string
 * @param {Boolean} [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.
 * @param {String|Function} [errorMsg] optional error message. If function, should return the error message as a string
 * @param {String} [type] optional validator type
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.validate = function(obj, message, type) {
    if (typeof obj === "function" || obj && utils.getFunctionName(obj.constructor) === "RegExp") {
        let properties;
        if (typeof message === "function") {
            properties = {
                validator: obj,
                message: message
            };
            properties.type = type || "user defined";
        } else if (message instanceof Object && !type) {
            properties = isSimpleValidator(message) ? Object.assign({}, message) : utils.clone(message);
            if (!properties.message) {
                properties.message = properties.msg;
            }
            properties.validator = obj;
            properties.type = properties.type || "user defined";
        } else {
            if (message == null) {
                message = MongooseError.messages.general.default;
            }
            if (!type) {
                type = "user defined";
            }
            properties = {
                message: message,
                type: type,
                validator: obj
            };
        }
        this.validators.push(properties);
        return this;
    }
    let i;
    let length;
    let arg;
    for(i = 0, length = arguments.length; i < length; i++){
        arg = arguments[i];
        if (!utils.isPOJO(arg)) {
            const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See https://mongoosejs.com/docs/api/schematype.html#schematype_SchemaType-validate";
            throw new Error(msg);
        }
        this.validate(arg.validator, arg);
    }
    return this;
};
/**
 * Adds a required validator to this SchemaType. The validator gets added
 * to the front of this SchemaType's validators array using `unshift()`.
 *
 * #### Example:
 *
 *     const s = new Schema({ born: { type: Date, required: true })
 *
 *     // or with custom error message
 *
 *     const s = new Schema({ born: { type: Date, required: '{PATH} is required!' })
 *
 *     // or with a function
 *
 *     const s = new Schema({
 *       userId: ObjectId,
 *       username: {
 *         type: String,
 *         required: function() { return this.userId != null; }
 *       }
 *     })
 *
 *     // or with a function and a custom message
 *     const s = new Schema({
 *       userId: ObjectId,
 *       username: {
 *         type: String,
 *         required: [
 *           function() { return this.userId != null; },
 *           'username is required if id is specified'
 *         ]
 *       }
 *     })
 *
 *     // or through the path API
 *
 *     s.path('name').required(true);
 *
 *     // with custom error messaging
 *
 *     s.path('name').required(true, 'grrr :( ');
 *
 *     // or make a path conditionally required based on a function
 *     const isOver18 = function() { return this.age >= 18; };
 *     s.path('voterRegistrationId').required(isOver18);
 *
 * The required validator uses the SchemaType's `checkRequired` function to
 * determine whether a given value satisfies the required validator. By default,
 * a value satisfies the required validator if `val != null` (that is, if
 * the value is not null nor undefined). However, most built-in mongoose schema
 * types override the default `checkRequired` function:
 *
 * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object
 * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean
 * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.
 * @param {String} [message] optional custom error message
 * @return {SchemaType} this
 * @see Customized Error Messages #error_messages_MongooseError-messages
 * @see SchemaArray#checkRequired #schema_array_SchemaArray-checkRequired
 * @see SchemaBoolean#checkRequired #schema_boolean_SchemaBoolean-checkRequired
 * @see SchemaBuffer#checkRequired #schema_buffer_SchemaBuffer-schemaName
 * @see SchemaNumber#checkRequired #schema_number_SchemaNumber-min
 * @see SchemaObjectId#checkRequired #schema_objectid_ObjectId-auto
 * @see SchemaString#checkRequired #schema_string_SchemaString-checkRequired
 * @api public
 */ SchemaType.prototype.required = function(required, message) {
    let customOptions = {};
    if (arguments.length > 0 && required == null) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
    }
    if (typeof required === "object") {
        customOptions = required;
        message = customOptions.message || message;
        required = required.isRequired;
    }
    if (required === false) {
        this.validators = this.validators.filter(function(v) {
            return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
    }
    const _this = this;
    this.isRequired = true;
    this.requiredValidator = function(v) {
        const cachedRequired = this && this.$__ && this.$__.cachedRequired;
        // no validation when this path wasn't selected in the query.
        if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
            return true;
        }
        // `$cachedRequired` gets set in `_evaluateRequiredFunctions()` so we
        // don't call required functions multiple times in one validate call
        // See gh-6801
        if (cachedRequired != null && _this.path in cachedRequired) {
            const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
            delete cachedRequired[_this.path];
            return res;
        } else if (typeof required === "function") {
            return required.apply(this) ? _this.checkRequired(v, this) : true;
        }
        return _this.checkRequired(v, this);
    };
    this.originalRequiredValue = required;
    if (typeof required === "string") {
        message = required;
        required = undefined;
    }
    const msg = message || MongooseError.messages.general.required;
    this.validators.unshift(Object.assign({}, customOptions, {
        validator: this.requiredValidator,
        message: msg,
        type: "required"
    }));
    return this;
};
/**
 * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)
 * looks at to determine the foreign collection it should query.
 *
 * #### Example:
 *
 *     const userSchema = new Schema({ name: String });
 *     const User = mongoose.model('User', userSchema);
 *
 *     const postSchema = new Schema({ user: mongoose.ObjectId });
 *     postSchema.path('user').ref('User'); // Can set ref to a model name
 *     postSchema.path('user').ref(User); // Or a model class
 *     postSchema.path('user').ref(() => 'User'); // Or a function that returns the model name
 *     postSchema.path('user').ref(() => User); // Or a function that returns the model class
 *
 *     // Or you can just declare the `ref` inline in your schema
 *     const postSchema2 = new Schema({
 *       user: { type: mongoose.ObjectId, ref: User }
 *     });
 *
 * @param {String|Model|Function} ref either a model name, a [Model](https://mongoosejs.com/docs/models.html), or a function that returns a model name or model.
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.ref = function(ref) {
    this.options.ref = ref;
    return this;
};
/**
 * Gets the default value
 *
 * @param {Object} scope the scope which callback are executed
 * @param {Boolean} init
 * @return {Any} The Stored default value.
 * @api private
 */ SchemaType.prototype.getDefault = function(scope, init, options) {
    let ret;
    if (typeof this.defaultValue === "function") {
        if (this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid") {
            ret = this.defaultValue.call(scope);
        } else {
            ret = this.defaultValue.call(scope, scope);
        }
    } else {
        ret = this.defaultValue;
    }
    if (ret !== null && ret !== undefined) {
        if (typeof ret === "object" && (!this.options || !this.options.shared)) {
            ret = utils.clone(ret);
        }
        if (options && options.skipCast) {
            return this._applySetters(ret, scope);
        }
        const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);
        if (casted && !Array.isArray(casted) && casted.$isSingleNested) {
            casted.$__parent = scope;
        }
        return casted;
    }
    return ret;
};
/**
 * Applies setters without casting
 *
 * @param {Any} value
 * @param {Any} scope
 * @param {Boolean} init
 * @param {Any} priorVal
 * @param {Object} [options]
 * @instance
 * @api private
 */ SchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {
    let v = value;
    if (init) {
        return v;
    }
    const setters = this.setters;
    for(let i = setters.length - 1; i >= 0; i--){
        v = setters[i].call(scope, v, priorVal, this, options);
    }
    return v;
};
/*!
 * ignore
 */ SchemaType.prototype._castNullish = function _castNullish(v) {
    return v;
};
/**
 * Applies setters
 *
 * @param {Object} value
 * @param {Object} scope
 * @param {Boolean} init
 * @return {Any}
 * @api private
 */ SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
    let v = this._applySetters(value, scope, init, priorVal, options);
    if (v == null) {
        return this._castNullish(v);
    }
    // do not cast until all setters are applied #665
    v = this.cast(v, scope, init, priorVal, options);
    return v;
};
/**
 * Applies getters to a value
 *
 * @param {Object} value
 * @param {Object} scope
 * @return {Any}
 * @api private
 */ SchemaType.prototype.applyGetters = function(value, scope) {
    let v = value;
    const getters = this.getters;
    const len = getters.length;
    if (len === 0) {
        return v;
    }
    for(let i = 0; i < len; ++i){
        v = getters[i].call(scope, v, this);
    }
    return v;
};
/**
 * Sets default `select()` behavior for this path.
 *
 * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.
 *
 * #### Example:
 *
 *     T = db.model('T', new Schema({ x: { type: String, select: true }}));
 *     T.find(..); // field x will always be selected ..
 *     // .. unless overridden;
 *     T.find().select('-x').exec(callback);
 *
 * @param {Boolean} val
 * @return {SchemaType} this
 * @api public
 */ SchemaType.prototype.select = function select(val) {
    this.selected = !!val;
    return this;
};
/**
 * Performs a validation of `value` using the validators declared for this SchemaType.
 *
 * @param {Any} value
 * @param {Function} callback
 * @param {Object} scope
 * @param {Object} [options]
 * @param {String} [options.path]
 * @return {Any} If no validators, returns the output from calling `fn`, otherwise no return
 * @api public
 */ SchemaType.prototype.doValidate = function(value, fn, scope, options) {
    let err = false;
    const path = this.path;
    // Avoid non-object `validators`
    const validators = this.validators.filter((v)=>typeof v === "object" && v !== null);
    let count = validators.length;
    if (!count) {
        return fn(null);
    }
    for(let i = 0, len = validators.length; i < len; ++i){
        if (err) {
            break;
        }
        const v = validators[i];
        const validator = v.validator;
        let ok;
        const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : utils.clone(v);
        validatorProperties.path = options && options.path ? options.path : path;
        validatorProperties.value = value;
        if (validator instanceof RegExp) {
            validate(validator.test(value), validatorProperties, scope);
            continue;
        }
        if (typeof validator !== "function") {
            continue;
        }
        if (value === undefined && validator !== this.requiredValidator) {
            validate(true, validatorProperties, scope);
            continue;
        }
        try {
            if (validatorProperties.propsParameter) {
                ok = validator.call(scope, value, validatorProperties);
            } else {
                ok = validator.call(scope, value);
            }
        } catch (error) {
            ok = false;
            validatorProperties.reason = error;
            if (error.message) {
                validatorProperties.message = error.message;
            }
        }
        if (ok != null && typeof ok.then === "function") {
            ok.then(function(ok) {
                validate(ok, validatorProperties, scope);
            }, function(error) {
                validatorProperties.reason = error;
                validatorProperties.message = error.message;
                ok = false;
                validate(ok, validatorProperties, scope);
            });
        } else {
            validate(ok, validatorProperties, scope);
        }
    }
    function validate(ok, validatorProperties, scope) {
        if (err) {
            return;
        }
        if (ok === undefined || ok) {
            if (--count <= 0) {
                immediate(function() {
                    fn(null);
                });
            }
        } else {
            const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
            err = new ErrorConstructor(validatorProperties, scope);
            err[validatorErrorSymbol] = true;
            immediate(function() {
                fn(err);
            });
        }
    }
};
function _validate(ok, validatorProperties) {
    if (ok !== undefined && !ok) {
        const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
        const err = new ErrorConstructor(validatorProperties);
        err[validatorErrorSymbol] = true;
        return err;
    }
}
/**
 * Performs a validation of `value` using the validators declared for this SchemaType.
 *
 * #### Note:
 *
 * This method ignores the asynchronous validators.
 *
 * @param {Any} value
 * @param {Object} scope
 * @param {Object} [options]
 * @param {Object} [options.path]
 * @return {MongooseError|null}
 * @api private
 */ SchemaType.prototype.doValidateSync = function(value, scope, options) {
    const path = this.path;
    const count = this.validators.length;
    if (!count) {
        return null;
    }
    let validators = this.validators;
    if (value === void 0) {
        if (this.validators.length !== 0 && this.validators[0].type === "required") {
            validators = [
                this.validators[0]
            ];
        } else {
            return null;
        }
    }
    let err = null;
    let i = 0;
    const len = validators.length;
    for(i = 0; i < len; ++i){
        const v = validators[i];
        if (v === null || typeof v !== "object") {
            continue;
        }
        const validator = v.validator;
        const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : utils.clone(v);
        validatorProperties.path = options && options.path ? options.path : path;
        validatorProperties.value = value;
        let ok = false;
        // Skip any explicit async validators. Validators that return a promise
        // will still run, but won't trigger any errors.
        if (isAsyncFunction(validator)) {
            continue;
        }
        if (validator instanceof RegExp) {
            err = _validate(validator.test(value), validatorProperties);
            continue;
        }
        if (typeof validator !== "function") {
            continue;
        }
        try {
            if (validatorProperties.propsParameter) {
                ok = validator.call(scope, value, validatorProperties);
            } else {
                ok = validator.call(scope, value);
            }
        } catch (error) {
            ok = false;
            validatorProperties.reason = error;
        }
        // Skip any validators that return a promise, we can't handle those
        // synchronously
        if (ok != null && typeof ok.then === "function") {
            continue;
        }
        err = _validate(ok, validatorProperties);
        if (err) {
            break;
        }
    }
    return err;
};
/**
 * Determines if value is a valid Reference.
 *
 * @param {SchemaType} self
 * @param {Object} value
 * @param {Document} doc
 * @param {Boolean} init
 * @return {Boolean}
 * @api private
 */ SchemaType._isRef = function(self, value, doc, init) {
    // fast path
    let ref = init && self.options && (self.options.ref || self.options.refPath);
    if (!ref && doc && doc.$__ != null) {
        // checks for
        // - this populated with adhoc model and no ref was set in schema OR
        // - setting / pushing values after population
        const path = doc.$__fullPath(self.path, true);
        const owner = doc.ownerDocument();
        ref = path != null && owner.$populated(path) || doc.$populated(self.path);
    }
    if (ref) {
        if (value == null) {
            return true;
        }
        if (!Buffer.isBuffer(value) && // buffers are objects too
        value._bsontype !== "Binary" // raw binary value from the db
         && utils.isObject(value) // might have deselected _id in population query
        ) {
            return true;
        }
        return init;
    }
    return false;
};
/*!
 * ignore
 */ SchemaType.prototype._castRef = function _castRef(value, doc, init) {
    if (value == null) {
        return value;
    }
    if (value.$__ != null) {
        value.$__.wasPopulated = value.$__.wasPopulated || true;
        return value;
    }
    // setting a populated path
    if (Buffer.isBuffer(value) || !utils.isObject(value)) {
        if (init) {
            return value;
        }
        throw new CastError(this.instance, value, this.path, null, this);
    }
    // Handle the case where user directly sets a populated
    // path to a plain object; cast to the Model used in
    // the population query.
    const path = doc.$__fullPath(this.path, true);
    const owner = doc.ownerDocument();
    const pop = owner.$populated(path, true);
    let ret = value;
    if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
        ret = new pop.options[populateModelSymbol](value);
        ret.$__.wasPopulated = true;
    }
    return ret;
};
/*!
 * ignore
 */ function handleSingle(val) {
    return this.castForQuery(val);
}
/*!
 * ignore
 */ function handleArray(val) {
    const _this = this;
    if (!Array.isArray(val)) {
        return [
            this.castForQuery(val)
        ];
    }
    return val.map(function(m) {
        return _this.castForQuery(m);
    });
}
/**
 * Just like handleArray, except also allows `[]` because surprisingly
 * `$in: [1, []]` works fine
 * @api private
 */ function handle$in(val) {
    const _this = this;
    if (!Array.isArray(val)) {
        return [
            this.castForQuery(val)
        ];
    }
    return val.map(function(m) {
        if (Array.isArray(m) && m.length === 0) {
            return m;
        }
        return _this.castForQuery(m);
    });
}
/*!
 * ignore
 */ SchemaType.prototype.$conditionalHandlers = {
    $all: handleArray,
    $eq: handleSingle,
    $in: handle$in,
    $ne: handleSingle,
    $nin: handle$in,
    $exists: $exists,
    $type: $type
};
/**
 * Wraps `castForQuery` to handle context
 * @param {Object} params
 * @instance
 * @api private
 */ SchemaType.prototype.castForQueryWrapper = function(params) {
    this.$$context = params.context;
    if ("$conditional" in params) {
        const ret = this.castForQuery(params.$conditional, params.val);
        this.$$context = null;
        return ret;
    }
    if (params.$skipQueryCastForUpdate || params.$applySetters) {
        const ret = this._castForQuery(params.val);
        this.$$context = null;
        return ret;
    }
    const ret = this.castForQuery(params.val);
    this.$$context = null;
    return ret;
};
/**
 * Cast the given value with the given optional query operator.
 *
 * @param {String} [$conditional] query operator, like `$eq` or `$in`
 * @param {Any} val
 * @return {Any}
 * @api private
 */ SchemaType.prototype.castForQuery = function($conditional, val) {
    let handler;
    if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
            throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
    }
    val = $conditional;
    return this._castForQuery(val);
};
/**
 * Internal switch for runSetters
 *
 * @param {Any} val
 * @return {Any}
 * @api private
 */ SchemaType.prototype._castForQuery = function(val) {
    return this.applySetters(val, this.$$context);
};
/**
 * Set & Get the `checkRequired` function
 * Override the function the required validator uses to check whether a value
 * passes the `required` check. Override this on the individual SchemaType.
 *
 * #### Example:
 *
 *     // Use this to allow empty strings to pass the `required` validator
 *     mongoose.Schema.Types.String.checkRequired(v => typeof v === 'string');
 *
 * @param {Function} [fn] If set, will overwrite the current set function
 * @return {Function} The input `fn` or the already set function
 * @static
 * @memberOf SchemaType
 * @function checkRequired
 * @api public
 */ SchemaType.checkRequired = function(fn) {
    if (arguments.length !== 0) {
        this._checkRequired = fn;
    }
    return this._checkRequired;
};
/**
 * Default check for if this path satisfies the `required` validator.
 *
 * @param {Any} val
 * @return {Boolean} `true` when the value is not `null`, `false` otherwise
 * @api private
 */ SchemaType.prototype.checkRequired = function(val) {
    return val != null;
};
/**
 * Clone the current SchemaType
 *
 * @return {SchemaType} The cloned SchemaType instance
 * @api private
 */ SchemaType.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, options, this.instance);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) schematype.requiredValidator = this.requiredValidator;
    if (this.defaultValue !== undefined) schematype.defaultValue = this.defaultValue;
    if (this.$immutable !== undefined && this.options.immutable === undefined) {
        schematype.$immutable = this.$immutable;
        handleImmutable(schematype);
    }
    if (this._index !== undefined) schematype._index = this._index;
    if (this.selected !== undefined) schematype.selected = this.selected;
    if (this.isRequired !== undefined) schematype.isRequired = this.isRequired;
    if (this.originalRequiredValue !== undefined) schematype.originalRequiredValue = this.originalRequiredValue;
    schematype.getters = this.getters.slice();
    schematype.setters = this.setters.slice();
    return schematype;
};
/*!
 * Module exports.
 */ module.exports = exports = SchemaType;
exports.CastError = CastError;
exports.ValidatorError = ValidatorError;


/***/ }),

/***/ 4455:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const utils = __webpack_require__(52100); // eslint-disable-line no-unused-vars
/**
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */ const StateMachine = module.exports = exports = function StateMachine() {};
/**
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @api private
 */ StateMachine.ctor = function() {
    const states = [
        ...arguments
    ];
    const ctor = function() {
        StateMachine.apply(this, arguments);
        this.paths = {};
        this.states = {};
    };
    ctor.prototype = new StateMachine();
    ctor.prototype.stateNames = states;
    states.forEach(function(state) {
        // Changes the `path`'s state to `state`.
        ctor.prototype[state] = function(path) {
            this._changeState(path, state);
        };
    });
    return ctor;
};
/**
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */ StateMachine.prototype._changeState = function _changeState(path, nextState) {
    const prevBucket = this.states[this.paths[path]];
    if (prevBucket) delete prevBucket[path];
    this.paths[path] = nextState;
    this.states[nextState] = this.states[nextState] || {};
    this.states[nextState][path] = true;
};
/*!
 * ignore
 */ StateMachine.prototype.clear = function clear(state) {
    if (this.states[state] == null) {
        return;
    }
    const keys = Object.keys(this.states[state]);
    let i = keys.length;
    let path;
    while(i--){
        path = keys[i];
        delete this.states[state][path];
        delete this.paths[path];
    }
};
/*!
 * ignore
 */ StateMachine.prototype.clearPath = function clearPath(path) {
    const state = this.paths[path];
    if (!state) {
        return;
    }
    delete this.paths[path];
    delete this.states[state][path];
};
/**
 * Gets the paths for the given state, or empty object `{}` if none.
 * @api private
 */ StateMachine.prototype.getStatePaths = function getStatePaths(state) {
    if (this.states[state] != null) {
        return this.states[state];
    }
    return {};
};
/**
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @api private
 */ StateMachine.prototype.some = function some() {
    const _this = this;
    const what = arguments.length ? arguments : this.stateNames;
    return Array.prototype.some.call(what, function(state) {
        if (_this.states[state] == null) {
            return false;
        }
        return Object.keys(_this.states[state]).length;
    });
};
/**
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */ StateMachine.prototype._iter = function _iter(iterMethod) {
    return function() {
        let states = [
            ...arguments
        ];
        const callback = states.pop();
        if (!states.length) states = this.stateNames;
        const _this = this;
        const paths = states.reduce(function(paths, state) {
            if (_this.states[state] == null) {
                return paths;
            }
            return paths.concat(Object.keys(_this.states[state]));
        }, []);
        return paths[iterMethod](function(path, i, paths) {
            return callback(path, i, paths);
        });
    };
};
/**
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @api private
 */ StateMachine.prototype.forEach = function forEach() {
    this.forEach = this._iter("forEach");
    return this.forEach.apply(this, arguments);
};
/**
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @api private
 */ StateMachine.prototype.map = function map() {
    this.map = this._iter("map");
    return this.map.apply(this, arguments);
};


/***/ }),

/***/ 46829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const Subdocument = __webpack_require__(97490);
const utils = __webpack_require__(52100);
const documentArrayParent = (__webpack_require__(5089).documentArrayParent);
/**
 * A constructor.
 *
 * @param {Object} obj js object returned from the db
 * @param {MongooseDocumentArray} parentArr the parent array of this document
 * @param {Boolean} skipId
 * @param {Object} fields
 * @param {Number} index
 * @inherits Document
 * @api private
 */ function ArraySubdocument(obj, parentArr, skipId, fields, index) {
    if (utils.isMongooseDocumentArray(parentArr)) {
        this.__parentArray = parentArr;
        this[documentArrayParent] = parentArr.$parent();
    } else {
        this.__parentArray = undefined;
        this[documentArrayParent] = undefined;
    }
    this.$setIndex(index);
    this.$__parent = this[documentArrayParent];
    Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, {
        isNew: true
    });
}
/*!
 * Inherit from Subdocument
 */ ArraySubdocument.prototype = Object.create(Subdocument.prototype);
ArraySubdocument.prototype.constructor = ArraySubdocument;
Object.defineProperty(ArraySubdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: false
});
Object.defineProperty(ArraySubdocument.prototype, "$isDocumentArrayElement", {
    configurable: false,
    writable: false,
    value: true
});
for(const i in EventEmitter.prototype){
    ArraySubdocument[i] = EventEmitter.prototype[i];
}
/*!
 * ignore
 */ ArraySubdocument.prototype.$setIndex = function(index) {
    this.__index = index;
    if (this.$__ != null && this.$__.validationError != null) {
        const keys = Object.keys(this.$__.validationError.errors);
        for (const key of keys){
            this.invalidate(key, this.$__.validationError.errors[key]);
        }
    }
};
/*!
 * ignore
 */ ArraySubdocument.prototype.populate = function() {
    throw new Error("Mongoose does not support calling populate() on nested " + 'docs. Instead of `doc.arr[0].populate("path")`, use ' + '`doc.populate("arr.0.path")`');
};
/*!
 * ignore
 */ ArraySubdocument.prototype.$__removeFromParent = function() {
    const _id = this._doc._id;
    if (!_id) {
        throw new Error("For your own good, Mongoose does not know " + "how to remove an ArraySubdocument that has no _id");
    }
    this.__parentArray.pull({
        _id: _id
    });
};
/**
 * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.
 *
 * @param {String} [path]
 * @param {Boolean} [skipIndex] Skip adding the array index. For example `arr.foo` instead of `arr.0.foo`.
 * @return {String}
 * @api private
 * @method $__fullPath
 * @memberOf ArraySubdocument
 * @instance
 */ ArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {
    if (this.__index == null) {
        return null;
    }
    if (!this.$__.fullPath) {
        this.ownerDocument();
    }
    if (skipIndex) {
        return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    }
    return path ? this.$__.fullPath + "." + this.__index + "." + path : this.$__.fullPath + "." + this.__index;
};
/**
 * Given a path relative to this document, return the path relative
 * to the top-level document.
 * @method $__pathRelativeToParent
 * @memberOf ArraySubdocument
 * @instance
 * @api private
 */ ArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {
    if (this.__index == null) {
        return null;
    }
    if (skipIndex) {
        return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + path;
    }
    if (path == null) {
        return this.__parentArray.$path() + "." + this.__index;
    }
    return this.__parentArray.$path() + "." + this.__index + "." + path;
};
/**
 * Returns this sub-documents parent document.
 * @method $parent
 * @memberOf ArraySubdocument
 * @instance
 * @api public
 */ ArraySubdocument.prototype.$parent = function() {
    return this[documentArrayParent];
};
/**
 * Returns this subdocument's parent array.
 *
 * #### Example:
 *
 *     const Test = mongoose.model('Test', new Schema({
 *       docArr: [{ name: String }]
 *     }));
 *     const doc = new Test({ docArr: [{ name: 'test subdoc' }] });
 *
 *     doc.docArr[0].parentArray() === doc.docArr; // true
 *
 * @api public
 * @method parentArray
 * @returns DocumentArray
 */ ArraySubdocument.prototype.parentArray = function() {
    return this.__parentArray;
};
/*!
 * Module exports.
 */ module.exports = ArraySubdocument;


/***/ }),

/***/ 90102:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const ArrayMethods = __webpack_require__(10338);
const DocumentArrayMethods = __webpack_require__(10196);
const Document = __webpack_require__(14001);
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const arrayAtomicsBackupSymbol = (__webpack_require__(5089).arrayAtomicsBackupSymbol);
const arrayParentSymbol = (__webpack_require__(5089).arrayParentSymbol);
const arrayPathSymbol = (__webpack_require__(5089).arrayPathSymbol);
const arraySchemaSymbol = (__webpack_require__(5089).arraySchemaSymbol);
const _basePush = Array.prototype.push;
const numberRE = /^\d+$/;
/**
 * DocumentArray constructor
 *
 * @param {Array} values
 * @param {String} path the path to this array
 * @param {Document} doc parent document
 * @api private
 * @return {MongooseDocumentArray}
 * @inherits MongooseArray
 * @see https://bit.ly/f6CnZU
 */ function MongooseDocumentArray(values, path, doc) {
    const __array = [];
    const internals = {
        [arrayAtomicsSymbol]: {},
        [arrayAtomicsBackupSymbol]: void 0,
        [arrayPathSymbol]: path,
        [arraySchemaSymbol]: void 0,
        [arrayParentSymbol]: void 0
    };
    if (Array.isArray(values)) {
        if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
            internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
        }
        values.forEach((v)=>{
            _basePush.call(__array, v);
        });
    }
    internals[arrayPathSymbol] = path;
    internals.__array = __array;
    // Because doc comes from the context of another function, doc === global
    // can happen if there was a null somewhere up the chain (see #3020 && #3034)
    // RB Jun 17, 2015 updated to check for presence of expected paths instead
    // to make more proof against unusual node environments
    if (doc && doc instanceof Document) {
        internals[arrayParentSymbol] = doc;
        internals[arraySchemaSymbol] = doc.$__schema.path(path);
        // `schema.path()` doesn't drill into nested arrays properly yet, see
        // gh-6398, gh-6602. This is a workaround because nested arrays are
        // always plain non-document arrays, so once you get to a document array
        // nesting is done. Matryoshka code.
        while(internals[arraySchemaSymbol] != null && internals[arraySchemaSymbol].$isMongooseArray && !internals[arraySchemaSymbol].$isMongooseDocumentArray){
            internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;
        }
    }
    const proxy = new Proxy(__array, {
        get: function(target, prop) {
            if (prop === "isMongooseArray" || prop === "isMongooseArrayProxy" || prop === "isMongooseDocumentArray" || prop === "isMongooseDocumentArrayProxy") {
                return true;
            }
            if (internals.hasOwnProperty(prop)) {
                return internals[prop];
            }
            if (DocumentArrayMethods.hasOwnProperty(prop)) {
                return DocumentArrayMethods[prop];
            }
            if (ArrayMethods.hasOwnProperty(prop)) {
                return ArrayMethods[prop];
            }
            return __array[prop];
        },
        set: function(target, prop, value) {
            if (typeof prop === "string" && numberRE.test(prop)) {
                DocumentArrayMethods.set.call(proxy, prop, value, false);
            } else if (internals.hasOwnProperty(prop)) {
                internals[prop] = value;
            } else {
                __array[prop] = value;
            }
            return true;
        }
    });
    return proxy;
}
/*!
 * Module exports.
 */ module.exports = MongooseDocumentArray;


/***/ }),

/***/ 3362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.isMongooseDocumentArray = function(mongooseDocumentArray) {
    return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;
};


/***/ }),

/***/ 10196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ArrayMethods = __webpack_require__(10338);
const Document = __webpack_require__(14001);
const castObjectId = __webpack_require__(82637);
const getDiscriminatorByValue = __webpack_require__(17492);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const utils = __webpack_require__(52100);
const isBsonType = __webpack_require__(85847);
const arrayParentSymbol = (__webpack_require__(5089).arrayParentSymbol);
const arrayPathSymbol = (__webpack_require__(5089).arrayPathSymbol);
const arraySchemaSymbol = (__webpack_require__(5089).arraySchemaSymbol);
const documentArrayParent = (__webpack_require__(5089).documentArrayParent);
const methods = {
    /*!
   * ignore
   */ toBSON () {
        return this.toObject(internalToObjectOptions);
    },
    /*!
   * ignore
   */ getArrayParent () {
        return this[arrayParentSymbol];
    },
    /**
   * Overrides MongooseArray#cast
   *
   * @method _cast
   * @api private
   * @memberOf MongooseDocumentArray
   */ _cast (value, index) {
        if (this[arraySchemaSymbol] == null) {
            return value;
        }
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        const isInstance = Constructor.$isMongooseDocumentArray ? utils.isMongooseDocumentArray(value) : value instanceof Constructor;
        if (isInstance || // Hack re: #5001, see #5005
        value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
            if (!(value[documentArrayParent] && value.__parentArray)) {
                // value may have been created using array.create()
                value[documentArrayParent] = this[arrayParentSymbol];
                value.__parentArray = this;
            }
            value.$setIndex(index);
            return value;
        }
        if (value === undefined || value === null) {
            return null;
        }
        // handle cast('string') or cast(ObjectId) etc.
        // only objects are permitted so we can safely assume that
        // non-objects are to be interpreted as _id
        if (Buffer.isBuffer(value) || isBsonType(value, "ObjectID") || !utils.isObject(value)) {
            value = {
                _id: value
            };
        }
        if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
            if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
                Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
            } else {
                const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
                if (constructorByValue) {
                    Constructor = constructorByValue;
                }
            }
        }
        if (Constructor.$isMongooseDocumentArray) {
            return Constructor.cast(value, this, undefined, undefined, index);
        }
        const ret = new Constructor(value, this, undefined, undefined, index);
        ret.isNew = true;
        return ret;
    },
    /**
   * Searches array items for the first document with a matching _id.
   *
   * #### Example:
   *
   *     const embeddedDoc = m.array.id(some_id);
   *
   * @return {EmbeddedDocument|null} the subdocument or null if not found.
   * @param {ObjectId|String|Number|Buffer} id
   * @TODO cast to the _id based on schema for proper comparison
   * @method id
   * @api public
   * @memberOf MongooseDocumentArray
   */ id (id) {
        let casted;
        let sid;
        let _id;
        try {
            casted = castObjectId(id).toString();
        } catch (e) {
            casted = null;
        }
        for (const val of this){
            if (!val) {
                continue;
            }
            _id = val.get("_id");
            if (_id === null || typeof _id === "undefined") {
                continue;
            } else if (_id instanceof Document) {
                sid || (sid = String(id));
                if (sid == _id._id) {
                    return val;
                }
            } else if (!isBsonType(id, "ObjectID") && !isBsonType(_id, "ObjectID")) {
                if (id == _id || utils.deepEqual(id, _id)) {
                    return val;
                }
            } else if (casted == _id) {
                return val;
            }
        }
        return null;
    },
    /**
   * Returns a native js Array of plain js objects
   *
   * #### Note:
   *
   * _Each sub-document is converted to a plain object by calling its `#toObject` method._
   *
   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
   * @return {Array}
   * @method toObject
   * @api public
   * @memberOf MongooseDocumentArray
   */ toObject (options) {
        // `[].concat` coerces the return value into a vanilla JS array, rather
        // than a Mongoose array.
        return [].concat(this.map(function(doc) {
            if (doc == null) {
                return null;
            }
            if (typeof doc.toObject !== "function") {
                return doc;
            }
            return doc.toObject(options);
        }));
    },
    $toObject () {
        return this.constructor.prototype.toObject.apply(this, arguments);
    },
    /**
   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
   *
   * @param {...Object} [args]
   * @api public
   * @method push
   * @memberOf MongooseDocumentArray
   */ push () {
        const ret = ArrayMethods.push.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
    },
    /**
   * Pulls items from the array atomically.
   *
   * @param {...Object} [args]
   * @api public
   * @method pull
   * @memberOf MongooseDocumentArray
   */ pull () {
        const ret = ArrayMethods.pull.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
    },
    /**
   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
   * @api private
   */ shift () {
        const ret = ArrayMethods.shift.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
    },
    /**
   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
   * @api private
   */ splice () {
        const ret = ArrayMethods.splice.apply(this, arguments);
        _updateParentPopulated(this);
        return ret;
    },
    /**
   * Helper for console.log
   *
   * @method inspect
   * @api public
   * @memberOf MongooseDocumentArray
   */ inspect () {
        return this.toObject();
    },
    /**
   * Creates a subdocument casted to this schema.
   *
   * This is the same subdocument constructor used for casting.
   *
   * @param {Object} obj the value to cast to this arrays SubDocument schema
   * @method create
   * @api public
   * @memberOf MongooseDocumentArray
   */ create (obj) {
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
            if (typeof obj[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
                Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
            } else {
                const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);
                if (constructorByValue) {
                    Constructor = constructorByValue;
                }
            }
        }
        return new Constructor(obj, this);
    },
    /*!
   * ignore
   */ notify (event) {
        const _this = this;
        return function notify(val, _arr) {
            _arr = _arr || _this;
            let i = _arr.length;
            while(i--){
                if (_arr[i] == null) {
                    continue;
                }
                switch(event){
                    // only swap for save event for now, we may change this to all event types later
                    case "save":
                        val = _this[i];
                        break;
                    default:
                        break;
                }
                if (utils.isMongooseArray(_arr[i])) {
                    notify(val, _arr[i]);
                } else if (_arr[i]) {
                    _arr[i].emit(event, val);
                }
            }
        };
    },
    set (i, val, skipModified) {
        const arr = this.__array;
        if (skipModified) {
            arr[i] = val;
            return this;
        }
        const value = methods._cast.call(this, val, i);
        methods._markModified.call(this, i);
        arr[i] = value;
        return this;
    },
    _markModified (elem, embeddedPath) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
            dirtyPath = this[arrayPathSymbol];
            if (arguments.length) {
                if (embeddedPath != null) {
                    // an embedded doc bubbled up the change
                    const index = elem.__index;
                    dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
                } else {
                    // directly set an index
                    dirtyPath = dirtyPath + "." + elem;
                }
            }
            if (dirtyPath != null && dirtyPath.endsWith(".$")) {
                return this;
            }
            parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
        }
        return this;
    }
};
module.exports = methods;
/**
 * If this is a document array, each element may contain single
 * populated paths, so we need to modify the top-level document's
 * populated cache. See gh-8247, gh-8265.
 * @param {Array} arr
 * @api private
 */ function _updateParentPopulated(arr) {
    const parent = arr[arrayParentSymbol];
    if (!parent || parent.$__.populated == null) return;
    const populatedPaths = Object.keys(parent.$__.populated).filter((p)=>p.startsWith(arr[arrayPathSymbol] + "."));
    for (const path of populatedPaths){
        const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
        if (!Array.isArray(parent.$__.populated[path].value)) {
            continue;
        }
        parent.$__.populated[path].value = arr.map((val)=>val.$populated(remnant));
    }
}


/***/ }),

/***/ 74484:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const Document = __webpack_require__(14001);
const mongooseArrayMethods = __webpack_require__(10338);
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const arrayAtomicsBackupSymbol = (__webpack_require__(5089).arrayAtomicsBackupSymbol);
const arrayParentSymbol = (__webpack_require__(5089).arrayParentSymbol);
const arrayPathSymbol = (__webpack_require__(5089).arrayPathSymbol);
const arraySchemaSymbol = (__webpack_require__(5089).arraySchemaSymbol);
/**
 * Mongoose Array constructor.
 *
 * #### Note:
 *
 * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._
 *
 * @param {Array} values
 * @param {String} path
 * @param {Document} doc parent document
 * @api private
 * @inherits Array
 * @see https://bit.ly/f6CnZU
 */ const _basePush = Array.prototype.push;
const numberRE = /^\d+$/;
function MongooseArray(values, path, doc, schematype) {
    let __array;
    if (Array.isArray(values)) {
        const len = values.length;
        // Perf optimizations for small arrays: much faster to use `...` than `for` + `push`,
        // but large arrays may cause stack overflows. And for arrays of length 0/1, just
        // modifying the array is faster. Seems small, but adds up when you have a document
        // with thousands of nested arrays.
        if (len === 0) {
            __array = new Array();
        } else if (len === 1) {
            __array = new Array(1);
            __array[0] = values[0];
        } else if (len < 10000) {
            __array = new Array();
            _basePush.apply(__array, values);
        } else {
            __array = new Array();
            for(let i = 0; i < len; ++i){
                _basePush.call(__array, values[i]);
            }
        }
    } else {
        __array = [];
    }
    const internals = {
        [arrayAtomicsSymbol]: {},
        [arrayAtomicsBackupSymbol]: void 0,
        [arrayPathSymbol]: path,
        [arraySchemaSymbol]: schematype,
        [arrayParentSymbol]: void 0,
        isMongooseArray: true,
        isMongooseArrayProxy: true,
        __array: __array
    };
    if (values && values[arrayAtomicsSymbol] != null) {
        internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
    }
    // Because doc comes from the context of another function, doc === global
    // can happen if there was a null somewhere up the chain (see #3020)
    // RB Jun 17, 2015 updated to check for presence of expected paths instead
    // to make more proof against unusual node environments
    if (doc != null && doc instanceof Document) {
        internals[arrayParentSymbol] = doc;
        internals[arraySchemaSymbol] = schematype || doc.schema.path(path);
    }
    const proxy = new Proxy(__array, {
        get: function(target, prop) {
            if (internals.hasOwnProperty(prop)) {
                return internals[prop];
            }
            if (mongooseArrayMethods.hasOwnProperty(prop)) {
                return mongooseArrayMethods[prop];
            }
            return __array[prop];
        },
        set: function(target, prop, value) {
            if (typeof prop === "string" && numberRE.test(prop)) {
                mongooseArrayMethods.set.call(proxy, prop, value, false);
            } else if (internals.hasOwnProperty(prop)) {
                internals[prop] = value;
            } else {
                __array[prop] = value;
            }
            return true;
        }
    });
    return proxy;
}
/*!
 * Module exports.
 */ module.exports = exports = MongooseArray;


/***/ }),

/***/ 50911:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.isMongooseArray = function(mongooseArray) {
    return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;
};


/***/ }),

/***/ 10338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Document = __webpack_require__(14001);
const ArraySubdocument = __webpack_require__(46829);
const MongooseError = __webpack_require__(51520);
const cleanModifiedSubpaths = __webpack_require__(74797);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const mpath = __webpack_require__(52988);
const utils = __webpack_require__(52100);
const isBsonType = __webpack_require__(85847);
const arrayAtomicsSymbol = (__webpack_require__(5089).arrayAtomicsSymbol);
const arrayParentSymbol = (__webpack_require__(5089).arrayParentSymbol);
const arrayPathSymbol = (__webpack_require__(5089).arrayPathSymbol);
const arraySchemaSymbol = (__webpack_require__(5089).arraySchemaSymbol);
const populateModelSymbol = (__webpack_require__(5089).populateModelSymbol);
const slicedSymbol = Symbol("mongoose#Array#sliced");
const _basePush = Array.prototype.push;
/*!
 * ignore
 */ const methods = {
    /**
   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
   *
   * If no atomics exist, we return all array values after conversion.
   *
   * @return {Array}
   * @method $__getAtomics
   * @memberOf MongooseArray
   * @instance
   * @api private
   */ $__getAtomics () {
        const ret = [];
        const keys = Object.keys(this[arrayAtomicsSymbol] || {});
        let i = keys.length;
        const opts = Object.assign({}, internalToObjectOptions, {
            _isNested: true
        });
        if (i === 0) {
            ret[0] = [
                "$set",
                this.toObject(opts)
            ];
            return ret;
        }
        while(i--){
            const op = keys[i];
            let val = this[arrayAtomicsSymbol][op];
            // the atomic values which are arrays are not MongooseArrays. we
            // need to convert their elements as if they were MongooseArrays
            // to handle populated arrays versus DocumentArrays properly.
            if (utils.isMongooseObject(val)) {
                val = val.toObject(opts);
            } else if (Array.isArray(val)) {
                val = this.toObject.call(val, opts);
            } else if (val != null && Array.isArray(val.$each)) {
                val.$each = this.toObject.call(val.$each, opts);
            } else if (val != null && typeof val.valueOf === "function") {
                val = val.valueOf();
            }
            if (op === "$addToSet") {
                val = {
                    $each: val
                };
            }
            ret.push([
                op,
                val
            ]);
        }
        return ret;
    },
    /*!
   * ignore
   */ $atomics () {
        return this[arrayAtomicsSymbol];
    },
    /*!
   * ignore
   */ $parent () {
        return this[arrayParentSymbol];
    },
    /*!
   * ignore
   */ $path () {
        return this[arrayPathSymbol];
    },
    /**
   * Atomically shifts the array at most one time per document `save()`.
   *
   * #### Note:
   *
   * _Calling this multiple times on an array before saving sends the same command as calling it once._
   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
   *
   *      doc.array = [1,2,3];
   *
   *      const shifted = doc.array.$shift();
   *      console.log(shifted); // 1
   *      console.log(doc.array); // [2,3]
   *
   *      // no affect
   *      shifted = doc.array.$shift();
   *      console.log(doc.array); // [2,3]
   *
   *      doc.save(function (err) {
   *        if (err) return handleError(err);
   *
   *        // we saved, now $shift works again
   *        shifted = doc.array.$shift();
   *        console.log(shifted ); // 2
   *        console.log(doc.array); // [3]
   *      })
   *
   * @api public
   * @memberOf MongooseArray
   * @instance
   * @method $shift
   * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
   */ $shift () {
        this._registerAtomic("$pop", -1);
        this._markModified();
        // only allow shifting once
        if (this._shifted) {
            return;
        }
        this._shifted = true;
        return [].shift.call(this);
    },
    /**
   * Pops the array atomically at most one time per document `save()`.
   *
   * #### NOTE:
   *
   * _Calling this multiple times on an array before saving sends the same command as calling it once._
   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
   *
   *      doc.array = [1,2,3];
   *
   *      const popped = doc.array.$pop();
   *      console.log(popped); // 3
   *      console.log(doc.array); // [1,2]
   *
   *      // no affect
   *      popped = doc.array.$pop();
   *      console.log(doc.array); // [1,2]
   *
   *      doc.save(function (err) {
   *        if (err) return handleError(err);
   *
   *        // we saved, now $pop works again
   *        popped = doc.array.$pop();
   *        console.log(popped); // 2
   *        console.log(doc.array); // [1]
   *      })
   *
   * @api public
   * @method $pop
   * @memberOf MongooseArray
   * @instance
   * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
   * @method $pop
   * @memberOf MongooseArray
   */ $pop () {
        this._registerAtomic("$pop", 1);
        this._markModified();
        // only allow popping once
        if (this._popped) {
            return;
        }
        this._popped = true;
        return [].pop.call(this);
    },
    /*!
   * ignore
   */ $schema () {
        return this[arraySchemaSymbol];
    },
    /**
   * Casts a member based on this arrays schema.
   *
   * @param {any} value
   * @return value the casted value
   * @method _cast
   * @api private
   * @memberOf MongooseArray
   */ _cast (value) {
        let populated = false;
        let Model;
        const parent = this[arrayParentSymbol];
        if (parent) {
            populated = parent.$populated(this[arrayPathSymbol], true);
        }
        if (populated && value !== null && value !== undefined) {
            // cast to the populated Models schema
            Model = populated.options[populateModelSymbol];
            // only objects are permitted so we can safely assume that
            // non-objects are to be interpreted as _id
            if (Buffer.isBuffer(value) || isBsonType(value, "ObjectID") || !utils.isObject(value)) {
                value = {
                    _id: value
                };
            }
            // gh-2399
            // we should cast model only when it's not a discriminator
            const isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;
            if (!isDisc) {
                value = new Model(value);
            }
            return this[arraySchemaSymbol].caster.applySetters(value, parent, true);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, parent, false);
    },
    /**
   * Internal helper for .map()
   *
   * @api private
   * @return {Number}
   * @method _mapCast
   * @memberOf MongooseArray
   */ _mapCast (val, index) {
        return this._cast(val, this.length + index);
    },
    /**
   * Marks this array as modified.
   *
   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
   *
   * @param {ArraySubdocument} subdoc the embedded doc that invoked this method on the Array
   * @param {String} embeddedPath the path which changed in the subdoc
   * @method _markModified
   * @api private
   * @memberOf MongooseArray
   */ _markModified (elem) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
            dirtyPath = this[arrayPathSymbol];
            if (arguments.length) {
                dirtyPath = dirtyPath + "." + elem;
            }
            if (dirtyPath != null && dirtyPath.endsWith(".$")) {
                return this;
            }
            parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
        }
        return this;
    },
    /**
   * Register an atomic operation with the parent.
   *
   * @param {Array} op operation
   * @param {any} val
   * @method _registerAtomic
   * @api private
   * @memberOf MongooseArray
   */ _registerAtomic (op, val) {
        if (this[slicedSymbol]) {
            return;
        }
        if (op === "$set") {
            // $set takes precedence over all other ops.
            // mark entire array modified.
            this[arrayAtomicsSymbol] = {
                $set: val
            };
            cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
            this._markModified();
            return this;
        }
        const atomics = this[arrayAtomicsSymbol];
        // reset pop/shift after save
        if (op === "$pop" && !("$pop" in atomics)) {
            const _this = this;
            this[arrayParentSymbol].once("save", function() {
                _this._popped = _this._shifted = null;
            });
        }
        // check for impossible $atomic combos (Mongo denies more than one
        // $atomic op on a single path
        if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {
            // a different op was previously registered.
            // save the entire thing.
            this[arrayAtomicsSymbol] = {
                $set: this
            };
            return this;
        }
        let selector;
        if (op === "$pullAll" || op === "$addToSet") {
            atomics[op] || (atomics[op] = []);
            atomics[op] = atomics[op].concat(val);
        } else if (op === "$pullDocs") {
            const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
            if (val[0] instanceof ArraySubdocument) {
                selector = pullOp["$or"] || (pullOp["$or"] = []);
                Array.prototype.push.apply(selector, val.map((v)=>{
                    return v.toObject({
                        transform: (doc, ret)=>{
                            if (v == null || v.$__ == null) {
                                return ret;
                            }
                            Object.keys(v.$__.activePaths.getStatePaths("default")).forEach((path)=>{
                                mpath.unset(path, ret);
                                _minimizePath(ret, path);
                            });
                            return ret;
                        },
                        virtuals: false
                    });
                }));
            } else {
                selector = pullOp["_id"] || (pullOp["_id"] = {
                    $in: []
                });
                selector["$in"] = selector["$in"].concat(val);
            }
        } else if (op === "$push") {
            atomics.$push = atomics.$push || {
                $each: []
            };
            if (val != null && utils.hasUserDefinedProperty(val, "$each")) {
                atomics.$push = val;
            } else {
                atomics.$push.$each = atomics.$push.$each.concat(val);
            }
        } else {
            atomics[op] = val;
        }
        return this;
    },
    /**
   * Adds values to the array if not already present.
   *
   * #### Example:
   *
   *     console.log(doc.array) // [2,3,4]
   *     const added = doc.array.addToSet(4,5);
   *     console.log(doc.array) // [2,3,4,5]
   *     console.log(added)     // [5]
   *
   * @param {...any} [args]
   * @return {Array} the values that were added
   * @memberOf MongooseArray
   * @api public
   * @method addToSet
   */ addToSet () {
        _checkManualPopulation(this, arguments);
        let values = [].map.call(arguments, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        const added = [];
        let type = "";
        if (values[0] instanceof ArraySubdocument) {
            type = "doc";
        } else if (values[0] instanceof Date) {
            type = "date";
        }
        const rawValues = utils.isMongooseArray(values) ? values.__array : this;
        const rawArray = utils.isMongooseArray(this) ? this.__array : this;
        rawValues.forEach(function(v) {
            let found;
            const val = +v;
            switch(type){
                case "doc":
                    found = this.some(function(doc) {
                        return doc.equals(v);
                    });
                    break;
                case "date":
                    found = this.some(function(d) {
                        return +d === val;
                    });
                    break;
                default:
                    found = ~this.indexOf(v);
            }
            if (!found) {
                this._markModified();
                rawArray.push(v);
                this._registerAtomic("$addToSet", v);
                [].push.call(added, v);
            }
        }, this);
        return added;
    },
    /**
   * Returns the number of pending atomic operations to send to the db for this array.
   *
   * @api private
   * @return {Number}
   * @method hasAtomics
   * @memberOf MongooseArray
   */ hasAtomics () {
        if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
            return 0;
        }
        return Object.keys(this[arrayAtomicsSymbol]).length;
    },
    /**
   * Return whether or not the `obj` is included in the array.
   *
   * @param {Object} obj the item to check
   * @param {Number} fromIndex
   * @return {Boolean}
   * @api public
   * @method includes
   * @memberOf MongooseArray
   */ includes (obj, fromIndex) {
        const ret = this.indexOf(obj, fromIndex);
        return ret !== -1;
    },
    /**
   * Return the index of `obj` or `-1` if not found.
   *
   * @param {Object} obj the item to look for
   * @param {Number} fromIndex
   * @return {Number}
   * @api public
   * @method indexOf
   * @memberOf MongooseArray
   */ indexOf (obj, fromIndex) {
        if (isBsonType(obj, "ObjectID")) {
            obj = obj.toString();
        }
        fromIndex = fromIndex == null ? 0 : fromIndex;
        const len = this.length;
        for(let i = fromIndex; i < len; ++i){
            if (obj == this[i]) {
                return i;
            }
        }
        return -1;
    },
    /**
   * Helper for console.log
   *
   * @api public
   * @method inspect
   * @memberOf MongooseArray
   */ inspect () {
        return JSON.stringify(this);
    },
    /**
   * Pushes items to the array non-atomically.
   *
   * #### Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @param {...any} [args]
   * @api public
   * @method nonAtomicPush
   * @memberOf MongooseArray
   */ nonAtomicPush () {
        const values = [].map.call(arguments, this._mapCast, this);
        this._markModified();
        const ret = [].push.apply(this, values);
        this._registerAtomic("$set", this);
        return ret;
    },
    /**
   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
   *
   * #### Note:
   *
   * _marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it._
   *
   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
   * @api public
   * @method pop
   * @memberOf MongooseArray
   */ pop () {
        this._markModified();
        const ret = [].pop.call(this);
        this._registerAtomic("$set", this);
        return ret;
    },
    /**
   * Pulls items from the array atomically. Equality is determined by casting
   * the provided value to an embedded document and comparing using
   * [the `Document.equals()` function.](/docs/api/document.html#document_Document-equals)
   *
   * #### Example:
   *
   *     doc.array.pull(ObjectId)
   *     doc.array.pull({ _id: 'someId' })
   *     doc.array.pull(36)
   *     doc.array.pull('tag 1', 'tag 2')
   *
   * To remove a document from a subdocument array we may pass an object with a matching `_id`.
   *
   *     doc.subdocs.push({ _id: 4815162342 })
   *     doc.subdocs.pull({ _id: 4815162342 }) // removed
   *
   * Or we may passing the _id directly and let mongoose take care of it.
   *
   *     doc.subdocs.push({ _id: 4815162342 })
   *     doc.subdocs.pull(4815162342); // works
   *
   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
   *
   * @param {...any} [args]
   * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
   * @api public
   * @method pull
   * @memberOf MongooseArray
   */ pull () {
        const values = [].map.call(arguments, this._cast, this);
        const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
        let i = cur.length;
        let mem;
        this._markModified();
        while(i--){
            mem = cur[i];
            if (mem instanceof Document) {
                const some = values.some(function(v) {
                    return mem.equals(v);
                });
                if (some) {
                    [].splice.call(cur, i, 1);
                }
            } else if (~cur.indexOf.call(values, mem)) {
                [].splice.call(cur, i, 1);
            }
        }
        if (values[0] instanceof ArraySubdocument) {
            this._registerAtomic("$pullDocs", values.map(function(v) {
                const _id = v.$__getValue("_id");
                if (_id === undefined || v.$isDefault("_id")) {
                    return v;
                }
                return _id;
            }));
        } else {
            this._registerAtomic("$pullAll", values);
        }
        // Might have modified child paths and then pulled, like
        // `doc.children[1].name = 'test';` followed by
        // `doc.children.remove(doc.children[0]);`. In this case we fall back
        // to a `$set` on the whole array. See #3511
        if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
            this._registerAtomic("$set", this);
        }
        return this;
    },
    /**
   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
   *
   * #### Example:
   *
   *     const schema = Schema({ nums: [Number] });
   *     const Model = mongoose.model('Test', schema);
   *
   *     const doc = await Model.create({ nums: [3, 4] });
   *     doc.nums.push(5); // Add 5 to the end of the array
   *     await doc.save();
   *
   *     // You can also pass an object with `$each` as the
   *     // first parameter to use MongoDB's `$position`
   *     doc.nums.push({
   *       $each: [1, 2],
   *       $position: 0
   *     });
   *     doc.nums; // [1, 2, 3, 4, 5]
   *
   * @param {...Object} [args]
   * @api public
   * @method push
   * @memberOf MongooseArray
   */ push () {
        let values = arguments;
        let atomic = values;
        const isOverwrite = values[0] != null && utils.hasUserDefinedProperty(values[0], "$each");
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        if (isOverwrite) {
            atomic = values[0];
            values = values[0].$each;
        }
        if (this[arraySchemaSymbol] == null) {
            return _basePush.apply(this, values);
        }
        _checkManualPopulation(this, values);
        const parent = this[arrayParentSymbol];
        values = [].map.call(values, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, parent, undefined, undefined, {
            skipDocumentArrayCast: true
        });
        let ret;
        const atomics = this[arrayAtomicsSymbol];
        this._markModified();
        if (isOverwrite) {
            atomic.$each = values;
            if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != atomic.$position) {
                throw new MongooseError("Cannot call `Array#push()` multiple times " + "with different `$position`");
            }
            if (atomic.$position != null) {
                [].splice.apply(arr, [
                    atomic.$position,
                    0
                ].concat(values));
                ret = this.length;
            } else {
                ret = [].push.apply(arr, values);
            }
        } else {
            if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != null) {
                throw new MongooseError("Cannot call `Array#push()` multiple times " + "with different `$position`");
            }
            atomic = values;
            ret = [].push.apply(arr, values);
        }
        this._registerAtomic("$push", atomic);
        return ret;
    },
    /**
   * Alias of [pull](#mongoosearray_MongooseArray-pull)
   *
   * @see MongooseArray#pull #types_array_MongooseArray-pull
   * @see mongodb https://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
   * @api public
   * @memberOf MongooseArray
   * @instance
   * @method remove
   */ remove () {
        return this.pull.apply(this, arguments);
    },
    /**
   * Sets the casted `val` at index `i` and marks the array modified.
   *
   * #### Example:
   *
   *     // given documents based on the following
   *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));
   *
   *     const doc = new Doc({ array: [2,3,4] })
   *
   *     console.log(doc.array) // [2,3,4]
   *
   *     doc.array.set(1,"5");
   *     console.log(doc.array); // [2,5,4] // properly cast to number
   *     doc.save() // the change is saved
   *
   *     // VS not using array#set
   *     doc.array[1] = "5";
   *     console.log(doc.array); // [2,"5",4] // no casting
   *     doc.save() // change is not saved
   *
   * @return {Array} this
   * @api public
   * @method set
   * @memberOf MongooseArray
   */ set (i, val, skipModified) {
        const arr = this.__array;
        if (skipModified) {
            arr[i] = val;
            return this;
        }
        const value = methods._cast.call(this, val, i);
        methods._markModified.call(this, i);
        arr[i] = value;
        return this;
    },
    /**
   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
   *
   * #### Example:
   *
   *     doc.array = [2,3];
   *     const res = doc.array.shift();
   *     console.log(res) // 2
   *     console.log(doc.array) // [3]
   *
   * #### Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method shift
   * @memberOf MongooseArray
   */ shift () {
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        const ret = [].shift.call(arr);
        this._registerAtomic("$set", this);
        return ret;
    },
    /**
   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
   *
   * #### Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method sort
   * @memberOf MongooseArray
   * @see https://masteringjs.io/tutorials/fundamentals/array-sort
   */ sort () {
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        const ret = [].sort.apply(arr, arguments);
        this._registerAtomic("$set", this);
        return ret;
    },
    /**
   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
   *
   * #### Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method splice
   * @memberOf MongooseArray
   * @see https://masteringjs.io/tutorials/fundamentals/array-splice
   */ splice () {
        let ret;
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
        if (arguments.length) {
            let vals;
            if (this[arraySchemaSymbol] == null) {
                vals = arguments;
            } else {
                vals = [];
                for(let i = 0; i < arguments.length; ++i){
                    vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
                }
            }
            ret = [].splice.apply(arr, vals);
            this._registerAtomic("$set", this);
        }
        return ret;
    },
    /*!
   * ignore
   */ toBSON () {
        return this.toObject(internalToObjectOptions);
    },
    /**
   * Returns a native js Array.
   *
   * @param {Object} options
   * @return {Array}
   * @api public
   * @method toObject
   * @memberOf MongooseArray
   */ toObject (options) {
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        if (options && options.depopulate) {
            options = utils.clone(options);
            options._isNested = true;
            // Ensure return value is a vanilla array, because in Node.js 6+ `map()`
            // is smart enough to use the inherited array's constructor.
            return [].concat(arr).map(function(doc) {
                return doc instanceof Document ? doc.toObject(options) : doc;
            });
        }
        return [].concat(arr);
    },
    $toObject () {
        return this.constructor.prototype.toObject.apply(this, arguments);
    },
    /**
   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
   *
   * #### Note:
   *
   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._
   *
   * @api public
   * @method unshift
   * @memberOf MongooseArray
   */ unshift () {
        _checkManualPopulation(this, arguments);
        let values;
        if (this[arraySchemaSymbol] == null) {
            values = arguments;
        } else {
            values = [].map.call(arguments, this._cast, this);
            values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        }
        const arr = utils.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        [].unshift.apply(arr, values);
        this._registerAtomic("$set", this);
        return this.length;
    }
};
/*!
 * ignore
 */ function _isAllSubdocs(docs, ref) {
    if (!ref) {
        return false;
    }
    for (const arg of docs){
        if (arg == null) {
            return false;
        }
        const model = arg.constructor;
        if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {
            return false;
        }
    }
    return true;
}
/*!
 * Minimize _just_ empty objects along the path chain specified
 * by `parts`, ignoring all other paths. Useful in cases where
 * you want to minimize after unsetting a path.
 *
 * #### Example:
 *
 *     const obj = { foo: { bar: { baz: {} } }, a: {} };
 *     _minimizePath(obj, 'foo.bar.baz');
 *     obj; // { a: {} }
 */ function _minimizePath(obj, parts, i) {
    if (typeof parts === "string") {
        if (parts.indexOf(".") === -1) {
            return;
        }
        parts = mpath.stringToParts(parts);
    }
    i = i || 0;
    if (i >= parts.length) {
        return;
    }
    if (obj == null || typeof obj !== "object") {
        return;
    }
    _minimizePath(obj[parts[0]], parts, i + 1);
    if (obj[parts[0]] != null && typeof obj[parts[0]] === "object" && Object.keys(obj[parts[0]]).length === 0) {
        delete obj[parts[0]];
    }
}
/*!
 * ignore
 */ function _checkManualPopulation(arr, docs) {
    const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
    if (arr.length === 0 && docs.length !== 0) {
        if (_isAllSubdocs(docs, ref)) {
            arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {
                [populateModelSymbol]: docs[0].constructor
            });
        }
    }
}
const returnVanillaArrayMethods = [
    "filter",
    "flat",
    "flatMap",
    "map",
    "slice"
];
for (const method of returnVanillaArrayMethods){
    if (Array.prototype[method] == null) {
        continue;
    }
    methods[method] = function() {
        const _arr = utils.isMongooseArray(this) ? this.__array : this;
        const arr = [].concat(_arr);
        return arr[method].apply(arr, arguments);
    };
}
module.exports = methods;


/***/ }),

/***/ 77784:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Module dependencies.
 */ 
const Binary = (__webpack_require__(67085).get)().Binary;
const utils = __webpack_require__(52100);
/**
 * Mongoose Buffer constructor.
 *
 * Values always have to be passed to the constructor to initialize.
 *
 * @param {Buffer} value
 * @param {String} encode
 * @param {Number} offset
 * @api private
 * @inherits Buffer
 * @see https://bit.ly/f6CnZU
 */ function MongooseBuffer(value, encode, offset) {
    let val = value;
    if (value == null) {
        val = 0;
    }
    let encoding;
    let path;
    let doc;
    if (Array.isArray(encode)) {
        // internal casting
        path = encode[0];
        doc = encode[1];
    } else {
        encoding = encode;
    }
    let buf;
    if (typeof val === "number" || val instanceof Number) {
        buf = Buffer.alloc(val);
    } else {
        buf = Buffer.from(val, encoding, offset);
    }
    utils.decorate(buf, MongooseBuffer.mixin);
    buf.isMongooseBuffer = true;
    // make sure these internal props don't show up in Object.keys()
    buf[MongooseBuffer.pathSymbol] = path;
    buf[parentSymbol] = doc;
    buf._subtype = 0;
    return buf;
}
const pathSymbol = Symbol.for("mongoose#Buffer#_path");
const parentSymbol = Symbol.for("mongoose#Buffer#_parent");
MongooseBuffer.pathSymbol = pathSymbol;
/*!
 * Inherit from Buffer.
 */ MongooseBuffer.mixin = {
    /**
   * Default subtype for the Binary representing this Buffer
   *
   * @api private
   * @property _subtype
   * @memberOf MongooseBuffer.mixin
   * @static
   */ _subtype: undefined,
    /**
   * Marks this buffer as modified.
   *
   * @api private
   * @method _markModified
   * @memberOf MongooseBuffer.mixin
   * @static
   */ _markModified: function() {
        const parent = this[parentSymbol];
        if (parent) {
            parent.markModified(this[MongooseBuffer.pathSymbol]);
        }
        return this;
    },
    /**
   * Writes the buffer.
   *
   * @api public
   * @method write
   * @memberOf MongooseBuffer.mixin
   * @static
   */ write: function() {
        const written = Buffer.prototype.write.apply(this, arguments);
        if (written > 0) {
            this._markModified();
        }
        return written;
    },
    /**
   * Copies the buffer.
   *
   * #### Note:
   *
   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
   *
   * @return {Number} The number of bytes copied.
   * @param {Buffer} target
   * @method copy
   * @memberOf MongooseBuffer.mixin
   * @static
   */ copy: function(target) {
        const ret = Buffer.prototype.copy.apply(this, arguments);
        if (target && target.isMongooseBuffer) {
            target._markModified();
        }
        return ret;
    }
};
/*!
 * Compile other Buffer methods marking this buffer as modified.
 */ utils.each([
    // node < 0.5
    "writeUInt8",
    "writeUInt16",
    "writeUInt32",
    "writeInt8",
    "writeInt16",
    "writeInt32",
    "writeFloat",
    "writeDouble",
    "fill",
    "utf8Write",
    "binaryWrite",
    "asciiWrite",
    "set",
    // node >= 0.5
    "writeUInt16LE",
    "writeUInt16BE",
    "writeUInt32LE",
    "writeUInt32BE",
    "writeInt16LE",
    "writeInt16BE",
    "writeInt32LE",
    "writeInt32BE",
    "writeFloatLE",
    "writeFloatBE",
    "writeDoubleLE",
    "writeDoubleBE"
], function(method) {
    if (!Buffer.prototype[method]) {
        return;
    }
    MongooseBuffer.mixin[method] = function() {
        const ret = Buffer.prototype[method].apply(this, arguments);
        this._markModified();
        return ret;
    };
});
/**
 * Converts this buffer to its Binary type representation.
 *
 * #### SubTypes:
 *
 *     const bson = require('bson')
 *     bson.BSON_BINARY_SUBTYPE_DEFAULT
 *     bson.BSON_BINARY_SUBTYPE_FUNCTION
 *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
 *     bson.BSON_BINARY_SUBTYPE_UUID
 *     bson.BSON_BINARY_SUBTYPE_MD5
 *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED
 *     doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);
 *
 * @see bsonspec https://bsonspec.org/#/specification
 * @param {Hex} [subtype]
 * @return {Binary}
 * @api public
 * @method toObject
 * @memberOf MongooseBuffer
 */ MongooseBuffer.mixin.toObject = function(options) {
    const subtype = typeof options === "number" ? options : this._subtype || 0;
    return new Binary(Buffer.from(this), subtype);
};
MongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;
/**
 * Converts this buffer for storage in MongoDB, including subtype
 *
 * @return {Binary}
 * @api public
 * @method toBSON
 * @memberOf MongooseBuffer
 */ MongooseBuffer.mixin.toBSON = function() {
    return new Binary(this, this._subtype || 0);
};
/**
 * Determines if this buffer is equals to `other` buffer
 *
 * @param {Buffer} other
 * @return {Boolean}
 * @method equals
 * @memberOf MongooseBuffer
 */ MongooseBuffer.mixin.equals = function(other) {
    if (!Buffer.isBuffer(other)) {
        return false;
    }
    if (this.length !== other.length) {
        return false;
    }
    for(let i = 0; i < this.length; ++i){
        if (this[i] !== other[i]) {
            return false;
        }
    }
    return true;
};
/**
 * Sets the subtype option and marks the buffer modified.
 *
 * #### SubTypes:
 *
 *     const bson = require('bson')
 *     bson.BSON_BINARY_SUBTYPE_DEFAULT
 *     bson.BSON_BINARY_SUBTYPE_FUNCTION
 *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
 *     bson.BSON_BINARY_SUBTYPE_UUID
 *     bson.BSON_BINARY_SUBTYPE_MD5
 *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED
 *
 *     doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);
 *
 * @see bsonspec https://bsonspec.org/#/specification
 * @param {Hex} subtype
 * @api public
 * @method subtype
 * @memberOf MongooseBuffer
 */ MongooseBuffer.mixin.subtype = function(subtype) {
    if (typeof subtype !== "number") {
        throw new TypeError("Invalid subtype. Expected a number");
    }
    if (this._subtype !== subtype) {
        this._markModified();
    }
    this._subtype = subtype;
};
/*!
 * Module exports.
 */ MongooseBuffer.Binary = Binary;
module.exports = MongooseBuffer;


/***/ }),

/***/ 37489:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Decimal128 type constructor
 *
 * #### Example:
 *
 *     const id = new mongoose.Types.Decimal128('3.1415');
 *
 * @constructor Decimal128
 */ 
module.exports = (__webpack_require__(67085).get)().Decimal128;


/***/ }),

/***/ 35836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Module exports.
 */ 
exports.Array = __webpack_require__(74484);
exports.Buffer = __webpack_require__(77784);
exports.Document = exports.Embedded = __webpack_require__(46829);
exports.DocumentArray = __webpack_require__(90102);
exports.Decimal128 = __webpack_require__(37489);
exports.ObjectId = __webpack_require__(41370);
exports.Map = __webpack_require__(58269);
exports.Subdocument = __webpack_require__(97490);


/***/ }),

/***/ 58269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Mixed = __webpack_require__(76541);
const MongooseError = __webpack_require__(51520);
const clone = __webpack_require__(99889);
const deepEqual = (__webpack_require__(52100).deepEqual);
const getConstructorName = __webpack_require__(4065);
const handleSpreadDoc = __webpack_require__(4715);
const util = __webpack_require__(73837);
const specialProperties = __webpack_require__(36848);
const isBsonType = __webpack_require__(85847);
const populateModelSymbol = (__webpack_require__(5089).populateModelSymbol);
/*!
 * ignore
 */ class MongooseMap extends Map {
    constructor(v, path, doc, schemaType){
        if (getConstructorName(v) === "Object") {
            v = Object.keys(v).reduce((arr, key)=>arr.concat([
                    [
                        key,
                        v[key]
                    ]
                ]), []);
        }
        super(v);
        this.$__parent = doc != null && doc.$__ != null ? doc : null;
        this.$__path = path;
        this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
        this.$__runDeferred();
    }
    $init(key, value) {
        checkValidKey(key);
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
            value.$basePath = this.$__path + "." + key;
        }
    }
    $__set(key, value) {
        super.set(key, value);
    }
    /**
   * Overwrites native Map's `get()` function to support Mongoose getters.
   *
   * @api public
   * @method get
   * @memberOf Map
   */ get(key, options) {
        if (isBsonType(key, "ObjectID")) {
            key = key.toString();
        }
        options = options || {};
        if (options.getters === false) {
            return super.get(key);
        }
        return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
    }
    /**
   * Overwrites native Map's `set()` function to support setters, `populate()`,
   * and change tracking. Note that Mongoose maps _only_ support strings and
   * ObjectIds as keys.
   *
   * #### Example:
   *
   *     doc.myMap.set('test', 42); // works
   *     doc.myMap.set({ obj: 42 }, 42); // Throws "Mongoose maps only support string keys"
   *
   * @api public
   * @method set
   * @memberOf Map
   */ set(key, value) {
        if (isBsonType(key, "ObjectID")) {
            key = key.toString();
        }
        checkValidKey(key);
        value = handleSpreadDoc(value);
        // Weird, but because you can't assign to `this` before calling `super()`
        // you can't get access to `$__schemaType` to cast in the initial call to
        // `set()` from the `super()` constructor.
        if (this.$__schemaType == null) {
            this.$__deferred = this.$__deferred || [];
            this.$__deferred.push({
                key: key,
                value: value
            });
            return;
        }
        const fullPath = this.$__path + "." + key;
        const populated = this.$__parent != null && this.$__parent.$__ ? this.$__parent.$populated(fullPath, true) || this.$__parent.$populated(this.$__path, true) : null;
        const priorVal = this.get(key);
        if (populated != null) {
            if (this.$__schemaType.$isSingleNested) {
                throw new MongooseError("Cannot manually populate single nested subdoc underneath Map " + `at path "${this.$__path}". Try using an array instead of a Map.`);
            }
            if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {
                value = value.map((v)=>{
                    if (v.$__ == null) {
                        v = new populated.options[populateModelSymbol](v);
                    }
                    // Doesn't support single nested "in-place" populate
                    v.$__.wasPopulated = {
                        value: v._id
                    };
                    return v;
                });
            } else {
                if (value.$__ == null) {
                    value = new populated.options[populateModelSymbol](value);
                }
                // Doesn't support single nested "in-place" populate
                value.$__.wasPopulated = {
                    value: value._id
                };
            }
        } else {
            try {
                value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), {
                    path: fullPath
                });
            } catch (error) {
                if (this.$__parent != null && this.$__parent.$__ != null) {
                    this.$__parent.invalidate(fullPath, error);
                    return;
                }
                throw error;
            }
        }
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
            value.$basePath = this.$__path + "." + key;
        }
        const parent = this.$__parent;
        if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
            parent.markModified(this.$__path + "." + key);
        }
    }
    /**
   * Overwrites native Map's `clear()` function to support change tracking.
   *
   * @api public
   * @method clear
   * @memberOf Map
   */ clear() {
        super.clear();
        const parent = this.$__parent;
        if (parent != null) {
            parent.markModified(this.$__path);
        }
    }
    /**
   * Overwrites native Map's `delete()` function to support change tracking.
   *
   * @api public
   * @method delete
   * @memberOf Map
   */ delete(key) {
        if (isBsonType(key, "ObjectID")) {
            key = key.toString();
        }
        this.set(key, undefined);
        return super.delete(key);
    }
    /**
   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.
   *
   * @api public
   * @method toBSON
   * @memberOf Map
   */ toBSON() {
        return new Map(this);
    }
    toObject(options) {
        if (options && options.flattenMaps) {
            const ret = {};
            const keys = this.keys();
            for (const key of keys){
                ret[key] = clone(this.get(key), options);
            }
            return ret;
        }
        return new Map(this);
    }
    $toObject() {
        return this.constructor.prototype.toObject.apply(this, arguments);
    }
    /**
   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set
   * the `flattenMaps` option to convert this map to a POJO instead.
   *
   * #### Example:
   *
   *     doc.myMap.toJSON() instanceof Map; // true
   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false
   *
   * @api public
   * @method toJSON
   * @param {Object} [options]
   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map
   * @memberOf Map
   */ toJSON(options) {
        if (typeof (options && options.flattenMaps) === "boolean" ? options.flattenMaps : true) {
            const ret = {};
            const keys = this.keys();
            for (const key of keys){
                ret[key] = clone(this.get(key), options);
            }
            return ret;
        }
        return new Map(this);
    }
    inspect() {
        return new Map(this);
    }
    $__runDeferred() {
        if (!this.$__deferred) {
            return;
        }
        for (const keyValueObject of this.$__deferred){
            this.set(keyValueObject.key, keyValueObject.value);
        }
        this.$__deferred = null;
    }
}
if (util.inspect.custom) {
    Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {
        enumerable: false,
        writable: false,
        configurable: false,
        value: MongooseMap.prototype.inspect
    });
}
Object.defineProperty(MongooseMap.prototype, "$__set", {
    enumerable: false,
    writable: true,
    configurable: false
});
Object.defineProperty(MongooseMap.prototype, "$__parent", {
    enumerable: false,
    writable: true,
    configurable: false
});
Object.defineProperty(MongooseMap.prototype, "$__path", {
    enumerable: false,
    writable: true,
    configurable: false
});
Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
    enumerable: false,
    writable: true,
    configurable: false
});
/**
 * Set to `true` for all Mongoose map instances
 *
 * @api public
 * @property $isMongooseMap
 * @memberOf MongooseMap
 * @instance
 */ Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
});
Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
});
/**
 * Since maps are stored as objects under the hood, keys must be strings
 * and can't contain any invalid characters
 * @param {String} key
 * @api private
 */ function checkValidKey(key) {
    const keyType = typeof key;
    if (keyType !== "string") {
        throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
    }
    if (key.startsWith("$")) {
        throw new Error(`Mongoose maps do not support keys that start with "$", got "${key}"`);
    }
    if (key.includes(".")) {
        throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
    }
    if (specialProperties.has(key)) {
        throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
    }
}
module.exports = MongooseMap;


/***/ }),

/***/ 41370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * ObjectId type constructor
 *
 * #### Example:
 *
 *     const id = new mongoose.Types.ObjectId;
 *
 * @constructor ObjectId
 */ 
const ObjectId = (__webpack_require__(67085).get)().ObjectId;
const objectIdSymbol = (__webpack_require__(5089).objectIdSymbol);
/**
 * Getter for convenience with populate, see gh-6115
 * @api private
 */ Object.defineProperty(ObjectId.prototype, "_id", {
    enumerable: false,
    configurable: true,
    get: function() {
        return this;
    }
});
/*!
 * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299
 */ if (!ObjectId.prototype.hasOwnProperty("valueOf")) {
    ObjectId.prototype.valueOf = function objectIdValueOf() {
        return this.toString();
    };
}
ObjectId.prototype[objectIdSymbol] = true;
module.exports = ObjectId;


/***/ }),

/***/ 97490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Document = __webpack_require__(14001);
const immediate = __webpack_require__(96621);
const internalToObjectOptions = (__webpack_require__(82128)/* .internalToObjectOptions */ .h);
const promiseOrCallback = __webpack_require__(83593);
const util = __webpack_require__(73837);
const utils = __webpack_require__(52100);
module.exports = Subdocument;
/**
 * Subdocument constructor.
 *
 * @inherits Document
 * @api private
 */ function Subdocument(value, fields, parent, skipId, options) {
    if (parent != null) {
        // If setting a nested path, should copy isNew from parent re: gh-7048
        const parentOptions = {
            isNew: parent.isNew
        };
        if ("defaults" in parent.$__) {
            parentOptions.defaults = parent.$__.defaults;
        }
        options = Object.assign(parentOptions, options);
    }
    if (options != null && options.path != null) {
        this.$basePath = options.path;
    }
    Document.call(this, value, fields, skipId, options);
    delete this.$__.priorDoc;
}
Subdocument.prototype = Object.create(Document.prototype);
Object.defineProperty(Subdocument.prototype, "$isSubdocument", {
    configurable: false,
    writable: false,
    value: true
});
Object.defineProperty(Subdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: true
});
/*!
 * ignore
 */ Subdocument.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
};
/**
 * Used as a stub for middleware
 *
 * #### Note:
 *
 * _This is a no-op. Does not actually save the doc to the db._
 *
 * @param {Function} [fn]
 * @return {Promise} resolved Promise
 * @api private
 */ Subdocument.prototype.save = function(options, fn) {
    if (typeof options === "function") {
        fn = options;
        options = {};
    }
    options = options || {};
    if (!options.suppressWarning) {
        utils.warn("mongoose: calling `save()` on a subdoc does **not** save " + "the document to MongoDB, it only runs save middleware. " + "Use `subdoc.save({ suppressWarning: true })` to hide this warning " + "if you're sure this behavior is right for your app.");
    }
    return promiseOrCallback(fn, (cb)=>{
        this.$__save(cb);
    });
};
/**
 * Given a path relative to this document, return the path relative
 * to the top-level document.
 * @param {String} path
 * @method $__fullPath
 * @memberOf Subdocument
 * @instance
 * @returns {String}
 * @api private
 */ Subdocument.prototype.$__fullPath = function(path) {
    if (!this.$__.fullPath) {
        this.ownerDocument();
    }
    return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
};
/**
 * Given a path relative to this document, return the path relative
 * to the top-level document.
 * @param {String} p
 * @returns {String}
 * @method $__pathRelativeToParent
 * @memberOf Subdocument
 * @instance
 * @api private
 */ Subdocument.prototype.$__pathRelativeToParent = function(p) {
    if (p == null) {
        return this.$basePath;
    }
    return [
        this.$basePath,
        p
    ].join(".");
};
/**
 * Used as a stub for middleware
 *
 * #### Note:
 *
 * _This is a no-op. Does not actually save the doc to the db._
 *
 * @param {Function} [fn]
 * @method $__save
 * @api private
 */ Subdocument.prototype.$__save = function(fn) {
    return immediate(()=>fn(null, this));
};
/*!
 * ignore
 */ Subdocument.prototype.$isValid = function(path) {
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
        return parent.$isValid(fullPath);
    }
    return Document.prototype.$isValid.call(this, path);
};
/*!
 * ignore
 */ Subdocument.prototype.markModified = function(path) {
    Document.prototype.markModified.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent == null || fullPath == null) {
        return;
    }
    const myPath = this.$__pathRelativeToParent().replace(/\.$/, "");
    if (parent.isDirectModified(myPath) || this.isNew) {
        return;
    }
    this.$__parent.markModified(fullPath, this);
};
/*!
 * ignore
 */ Subdocument.prototype.isModified = function(paths, modifiedPaths) {
    const parent = this.$parent();
    if (parent != null) {
        if (Array.isArray(paths) || typeof paths === "string") {
            paths = Array.isArray(paths) ? paths : paths.split(" ");
            paths = paths.map((p)=>this.$__pathRelativeToParent(p)).filter((p)=>p != null);
        } else if (!paths) {
            paths = this.$__pathRelativeToParent();
        }
        return parent.$isModified(paths, modifiedPaths);
    }
    return Document.prototype.isModified.call(this, paths, modifiedPaths);
};
/**
 * Marks a path as valid, removing existing validation errors.
 *
 * @param {String} path the field to mark as valid
 * @api private
 * @method $markValid
 * @memberOf Subdocument
 */ Subdocument.prototype.$markValid = function(path) {
    Document.prototype.$markValid.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
        parent.$markValid(fullPath);
    }
};
/*!
 * ignore
 */ Subdocument.prototype.invalidate = function(path, err, val) {
    Document.prototype.invalidate.call(this, path, err, val);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
        parent.invalidate(fullPath, err, val);
    } else if (err.kind === "cast" || err.name === "CastError" || fullPath == null) {
        throw err;
    }
    return this.ownerDocument().$__.validationError;
};
/*!
 * ignore
 */ Subdocument.prototype.$ignore = function(path) {
    Document.prototype.$ignore.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
        parent.$ignore(fullPath);
    }
};
/**
 * Returns the top level document of this sub-document.
 *
 * @return {Document}
 */ Subdocument.prototype.ownerDocument = function() {
    if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
    }
    let parent = this; // eslint-disable-line consistent-this
    const paths = [];
    const seenDocs = new Set([
        parent
    ]);
    while(true){
        if (typeof parent.$__pathRelativeToParent !== "function") {
            break;
        }
        paths.unshift(parent.$__pathRelativeToParent(void 0, true));
        const _parent = parent.$parent();
        if (_parent == null) {
            break;
        }
        parent = _parent;
        if (seenDocs.has(parent)) {
            throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
        }
        seenDocs.add(parent);
    }
    this.$__.fullPath = paths.join(".");
    this.$__.ownerDocument = parent;
    return this.$__.ownerDocument;
};
/*!
 * ignore
 */ Subdocument.prototype.$__fullPathWithIndexes = function() {
    let parent = this; // eslint-disable-line consistent-this
    const paths = [];
    const seenDocs = new Set([
        parent
    ]);
    while(true){
        if (typeof parent.$__pathRelativeToParent !== "function") {
            break;
        }
        paths.unshift(parent.$__pathRelativeToParent(void 0, false));
        const _parent = parent.$parent();
        if (_parent == null) {
            break;
        }
        parent = _parent;
        if (seenDocs.has(parent)) {
            throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
        }
        seenDocs.add(parent);
    }
    return paths.join(".");
};
/**
 * Returns this sub-documents parent document.
 *
 * @api public
 */ Subdocument.prototype.parent = function() {
    return this.$__parent;
};
/**
 * Returns this sub-documents parent document.
 *
 * @api public
 * @method $parent
 */ Subdocument.prototype.$parent = Subdocument.prototype.parent;
/**
 * no-op for hooks
 * @param {Function} cb
 * @method $__remove
 * @memberOf Subdocument
 * @instance
 * @api private
 */ Subdocument.prototype.$__remove = function(cb) {
    if (cb == null) {
        return;
    }
    return cb(null, this);
};
/**
 * ignore
 * @method $__removeFromParent
 * @memberOf Subdocument
 * @instance
 * @api private
 */ Subdocument.prototype.$__removeFromParent = function() {
    this.$__parent.set(this.$basePath, null);
};
/**
 * Null-out this subdoc
 *
 * @param {Object} [options]
 * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove
 */ Subdocument.prototype.remove = function(options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    registerRemoveListener(this);
    // If removing entire doc, no need to remove subdoc
    if (!options || !options.noop) {
        this.$__removeFromParent();
    }
    return this.$__remove(callback);
};
/*!
 * ignore
 */ Subdocument.prototype.populate = function() {
    throw new Error("Mongoose does not support calling populate() on nested " + 'docs. Instead of `doc.nested.populate("path")`, use ' + '`doc.populate("nested.path")`');
};
/**
 * Helper for console.log
 *
 * @api public
 */ Subdocument.prototype.inspect = function() {
    return this.toObject({
        transform: false,
        virtuals: false,
        flattenDecimals: false
    });
};
if (util.inspect.custom) {
    // Avoid Node deprecation warning DEP0079
    Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;
}
/**
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {Subdocument} sub
 * @api private
 */ function registerRemoveListener(sub) {
    let owner = sub.ownerDocument();
    function emitRemove() {
        owner.$removeListener("save", emitRemove);
        owner.$removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
    }
    owner.$on("save", emitRemove);
    owner.$on("remove", emitRemove);
}


/***/ }),

/***/ 52100:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*!
 * Module dependencies.
 */ const ms = __webpack_require__(57518);
const mpath = __webpack_require__(52988);
const ObjectId = __webpack_require__(41370);
const PopulateOptions = __webpack_require__(71392);
const clone = __webpack_require__(99889);
const immediate = __webpack_require__(96621);
const isObject = __webpack_require__(89026);
const isMongooseArray = __webpack_require__(50911);
const isMongooseDocumentArray = __webpack_require__(3362);
const isBsonType = __webpack_require__(85847);
const getFunctionName = __webpack_require__(50377);
const isMongooseObject = __webpack_require__(36569);
const promiseOrCallback = __webpack_require__(83593);
const schemaMerge = __webpack_require__(38359);
const specialProperties = __webpack_require__(36848);
const { trustedSymbol  } = __webpack_require__(79657);
let Document;
exports.specialProperties = specialProperties;
exports.isMongooseArray = isMongooseArray.isMongooseArray;
exports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;
exports.registerMongooseArray = isMongooseArray.registerMongooseArray;
exports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;
/**
 * Produces a collection name from model `name`. By default, just returns
 * the model name
 *
 * @param {String} name a model name
 * @param {Function} pluralize function that pluralizes the collection name
 * @return {String} a collection name
 * @api private
 */ exports.toCollectionName = function(name, pluralize) {
    if (name === "system.profile") {
        return name;
    }
    if (name === "system.indexes") {
        return name;
    }
    if (typeof pluralize === "function") {
        return pluralize(name);
    }
    return name;
};
/**
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param {any} a a value to compare to `b`
 * @param {any} b a value to compare to `a`
 * @return {Boolean}
 * @api private
 */ exports.deepEqual = function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (typeof a !== "object" || typeof b !== "object") {
        return a === b;
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
        return a.toString() === b.toString();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
        return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global && a.dotAll === b.dotAll && a.unicode === b.unicode && a.sticky === b.sticky && a.hasIndices === b.hasIndices;
    }
    if (a == null || b == null) {
        return false;
    }
    if (a.prototype !== b.prototype) {
        return false;
    }
    if (a instanceof Map || b instanceof Map) {
        if (!(a instanceof Map) || !(b instanceof Map)) {
            return false;
        }
        return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
    }
    // Handle MongooseNumbers
    if (a instanceof Number && b instanceof Number) {
        return a.valueOf() === b.valueOf();
    }
    if (Buffer.isBuffer(a)) {
        return exports.buffer.areEqual(a, b);
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        if (!Array.isArray(a) || !Array.isArray(b)) {
            return false;
        }
        const len = a.length;
        if (len !== b.length) {
            return false;
        }
        for(let i = 0; i < len; ++i){
            if (!deepEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if (a.$__ != null) {
        a = a._doc;
    } else if (isMongooseObject(a)) {
        a = a.toObject();
    }
    if (b.$__ != null) {
        b = b._doc;
    } else if (isMongooseObject(b)) {
        b = b.toObject();
    }
    const ka = Object.keys(a);
    const kb = Object.keys(b);
    const kaLength = ka.length;
    // having the same number of owned properties (keys incorporates
    // hasOwnProperty)
    if (kaLength !== kb.length) {
        return false;
    }
    // ~~~cheap key test
    for(let i = kaLength - 1; i >= 0; i--){
        if (ka[i] !== kb[i]) {
            return false;
        }
    }
    // equivalent values for every corresponding key, and
    // ~~~possibly expensive deep test
    for (const key of ka){
        if (!deepEqual(a[key], b[key])) {
            return false;
        }
    }
    return true;
};
/**
 * Get the last element of an array
 * @param {Array} arr
 */ exports.last = function(arr) {
    if (arr.length > 0) {
        return arr[arr.length - 1];
    }
    return void 0;
};
exports.clone = clone;
/*!
 * ignore
 */ exports.promiseOrCallback = promiseOrCallback;
/*!
 * ignore
 */ exports.cloneArrays = function cloneArrays(arr) {
    if (!Array.isArray(arr)) {
        return arr;
    }
    return arr.map((el)=>exports.cloneArrays(el));
};
/*!
 * ignore
 */ exports.omit = function omit(obj, keys) {
    if (keys == null) {
        return Object.assign({}, obj);
    }
    if (!Array.isArray(keys)) {
        keys = [
            keys
        ];
    }
    const ret = Object.assign({}, obj);
    for (const key of keys){
        delete ret[key];
    }
    return ret;
};
/**
 * Shallow copies defaults into options.
 *
 * @param {Object} defaults
 * @param {Object} [options]
 * @return {Object} the merged object
 * @api private
 */ exports.options = function(defaults, options) {
    const keys = Object.keys(defaults);
    let i = keys.length;
    let k;
    options = options || {};
    while(i--){
        k = keys[i];
        if (!(k in options)) {
            options[k] = defaults[k];
        }
    }
    return options;
};
/**
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @param {Object} [options]
 * @param {String} [path]
 * @api private
 */ exports.merge = function merge(to, from, options, path) {
    options = options || {};
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    if (from[trustedSymbol]) {
        to[trustedSymbol] = from[trustedSymbol];
    }
    path = path || "";
    const omitNested = options.omitNested || {};
    while(i < len){
        key = keys[i++];
        if (options.omit && options.omit[key]) {
            continue;
        }
        if (omitNested[path]) {
            continue;
        }
        if (specialProperties.has(key)) {
            continue;
        }
        if (to[key] == null) {
            to[key] = from[key];
        } else if (exports.isObject(from[key])) {
            if (!exports.isObject(to[key])) {
                to[key] = {};
            }
            if (from[key] != null) {
                // Skip merging schemas if we're creating a discriminator schema and
                // base schema has a given path as a single nested but discriminator schema
                // has the path as a document array, or vice versa (gh-9534)
                if (options.isDiscriminatorSchemaMerge && from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
                    continue;
                } else if (from[key].instanceOfSchema) {
                    if (to[key].instanceOfSchema) {
                        schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
                    } else {
                        to[key] = from[key].clone();
                    }
                    continue;
                } else if (isBsonType(from[key], "ObjectID")) {
                    to[key] = new ObjectId(from[key]);
                    continue;
                }
            }
            merge(to[key], from[key], options, path ? path + "." + key : key);
        } else if (options.overwrite) {
            to[key] = from[key];
        }
    }
};
/**
 * Applies toObject recursively.
 *
 * @param {Document|Array|Object} obj
 * @return {Object}
 * @api private
 */ exports.toObject = function toObject(obj) {
    Document || (Document = __webpack_require__(14001));
    let ret;
    if (obj == null) {
        return obj;
    }
    if (obj instanceof Document) {
        return obj.toObject();
    }
    if (Array.isArray(obj)) {
        ret = [];
        for (const doc of obj){
            ret.push(toObject(doc));
        }
        return ret;
    }
    if (exports.isPOJO(obj)) {
        ret = {};
        if (obj[trustedSymbol]) {
            ret[trustedSymbol] = obj[trustedSymbol];
        }
        for (const k of Object.keys(obj)){
            if (specialProperties.has(k)) {
                continue;
            }
            ret[k] = toObject(obj[k]);
        }
        return ret;
    }
    return obj;
};
exports.isObject = isObject;
/**
 * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
 * `arg` must be an object but not an instance of any special class, like String,
 * ObjectId, etc.
 *
 * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */ exports.isPOJO = function isPOJO(arg) {
    if (arg == null || typeof arg !== "object") {
        return false;
    }
    const proto = Object.getPrototypeOf(arg);
    // Prototype may be null if you used `Object.create(null)`
    // Checking `proto`'s constructor is safe because `getPrototypeOf()`
    // explicitly crosses the boundary from object data to object metadata
    return !proto || proto.constructor.name === "Object";
};
/**
 * Determines if `arg` is an object that isn't an instance of a built-in value
 * class, like Array, Buffer, ObjectId, etc.
 * @param {Any} val
 */ exports.isNonBuiltinObject = function isNonBuiltinObject(val) {
    return typeof val === "object" && !exports.isNativeObject(val) && !exports.isMongooseType(val) && val != null;
};
/**
 * Determines if `obj` is a built-in object like an array, date, boolean,
 * etc.
 * @param {Any} arg
 */ exports.isNativeObject = function(arg) {
    return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
};
/**
 * Determines if `val` is an object that has no own keys
 * @param {Any} val
 */ exports.isEmptyObject = function(val) {
    return val != null && typeof val === "object" && Object.keys(val).length === 0;
};
/**
 * Search if `obj` or any POJOs nested underneath `obj` has a property named
 * `key`
 * @param {Object} obj
 * @param {String} key
 */ exports.hasKey = function hasKey(obj, key) {
    const props = Object.keys(obj);
    for (const prop of props){
        if (prop === key) {
            return true;
        }
        if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {
            return true;
        }
    }
    return false;
};
/**
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param {Function} callback
 * @api private
 */ exports.tick = function tick(callback) {
    if (typeof callback !== "function") {
        return;
    }
    return function() {
        try {
            callback.apply(this, arguments);
        } catch (err) {
            // only nextTick on err to get out of
            // the event loop and avoid state corruption.
            immediate(function() {
                throw err;
            });
        }
    };
};
/**
 * Returns true if `v` is an object that can be serialized as a primitive in
 * MongoDB
 * @param {Any} v
 */ exports.isMongooseType = function(v) {
    return isBsonType(v, "ObjectID") || isBsonType(v, "Decimal128") || v instanceof Buffer;
};
exports.isMongooseObject = isMongooseObject;
/**
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param {Object} object
 * @api private
 */ exports.expires = function expires(object) {
    if (!(object && object.constructor.name === "Object")) {
        return;
    }
    if (!("expires" in object)) {
        return;
    }
    object.expireAfterSeconds = typeof object.expires !== "string" ? object.expires : Math.round(ms(object.expires) / 1000);
    delete object.expires;
};
/**
 * populate helper
 * @param {String} path
 * @param {String} select
 * @param {Model} model
 * @param {Object} match
 * @param {Object} options
 * @param {Any} subPopulate
 * @param {Boolean} justOne
 * @param {Boolean} count
 */ exports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {
    // might have passed an object specifying all arguments
    let obj = null;
    if (arguments.length === 1) {
        if (path instanceof PopulateOptions) {
            // If reusing old populate docs, avoid reusing `_docs` because that may
            // lead to bugs and memory leaks. See gh-11641
            path._docs = [];
            path._childDocs = [];
            return [
                path
            ];
        }
        if (Array.isArray(path)) {
            const singles = makeSingles(path);
            return singles.map((o)=>exports.populate(o)[0]);
        }
        if (exports.isObject(path)) {
            obj = Object.assign({}, path);
        } else {
            obj = {
                path: path
            };
        }
    } else if (typeof model === "object") {
        obj = {
            path: path,
            select: select,
            match: model,
            options: match
        };
    } else {
        obj = {
            path: path,
            select: select,
            model: model,
            match: match,
            options: options,
            populate: subPopulate,
            justOne: justOne,
            count: count
        };
    }
    if (typeof obj.path !== "string") {
        throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path + "`");
    }
    return _populateObj(obj);
    // The order of select/conditions args is opposite Model.find but
    // necessary to keep backward compatibility (select could be
    // an array, string, or object literal).
    function makeSingles(arr) {
        const ret = [];
        arr.forEach(function(obj) {
            if (/[\s]/.test(obj.path)) {
                const paths = obj.path.split(" ");
                paths.forEach(function(p) {
                    const copy = Object.assign({}, obj);
                    copy.path = p;
                    ret.push(copy);
                });
            } else {
                ret.push(obj);
            }
        });
        return ret;
    }
};
function _populateObj(obj) {
    if (Array.isArray(obj.populate)) {
        const ret = [];
        obj.populate.forEach(function(obj) {
            if (/[\s]/.test(obj.path)) {
                const copy = Object.assign({}, obj);
                const paths = copy.path.split(" ");
                paths.forEach(function(p) {
                    copy.path = p;
                    ret.push(exports.populate(copy)[0]);
                });
            } else {
                ret.push(exports.populate(obj)[0]);
            }
        });
        obj.populate = exports.populate(ret);
    } else if (obj.populate != null && typeof obj.populate === "object") {
        obj.populate = exports.populate(obj.populate);
    }
    const ret = [];
    const paths = obj.path.split(" ");
    if (obj.options != null) {
        obj.options = exports.clone(obj.options);
    }
    for (const path of paths){
        ret.push(new PopulateOptions(Object.assign({}, obj, {
            path: path
        })));
    }
    return ret;
}
/**
 * Return the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Object} obj
 * @param {Any} map
 */ exports.getValue = function(path, obj, map) {
    return mpath.get(path, obj, "_doc", map);
};
/**
 * Sets the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Anything} val
 * @param {Object} obj
 * @param {Any} map
 * @param {Any} _copying
 */ exports.setValue = function(path, val, obj, map, _copying) {
    mpath.set(path, val, obj, "_doc", map, _copying);
};
/**
 * Returns an array of values from object `o`.
 *
 * @param {Object} o
 * @return {Array}
 * @api private
 */ exports.object = {};
exports.object.vals = function vals(o) {
    const keys = Object.keys(o);
    let i = keys.length;
    const ret = [];
    while(i--){
        ret.push(o[keys[i]]);
    }
    return ret;
};
/**
 * @see exports.options
 */ exports.object.shallowCopy = exports.options;
const hop = Object.prototype.hasOwnProperty;
/**
 * Safer helper for hasOwnProperty checks
 *
 * @param {Object} obj
 * @param {String} prop
 */ exports.object.hasOwnProperty = function(obj, prop) {
    return hop.call(obj, prop);
};
/**
 * Determine if `val` is null or undefined
 *
 * @param {Any} val
 * @return {Boolean}
 */ exports.isNullOrUndefined = function(val) {
    return val === null || val === undefined;
};
/*!
 * ignore
 */ exports.array = {};
/**
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param {Array} arr
 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.
 * @param {Array} ret
 * @return {Array}
 * @api private
 */ exports.array.flatten = function flatten(arr, filter, ret) {
    ret || (ret = []);
    arr.forEach(function(item) {
        if (Array.isArray(item)) {
            flatten(item, filter, ret);
        } else {
            if (!filter || filter(item)) {
                ret.push(item);
            }
        }
    });
    return ret;
};
/*!
 * ignore
 */ const _hasOwnProperty = Object.prototype.hasOwnProperty;
exports.hasUserDefinedProperty = function(obj, key) {
    if (obj == null) {
        return false;
    }
    if (Array.isArray(key)) {
        for (const k of key){
            if (exports.hasUserDefinedProperty(obj, k)) {
                return true;
            }
        }
        return false;
    }
    if (_hasOwnProperty.call(obj, key)) {
        return true;
    }
    if (typeof obj === "object" && key in obj) {
        const v = obj[key];
        return v !== Object.prototype[key] && v !== Array.prototype[key];
    }
    return false;
};
/*!
 * ignore
 */ const MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
exports.isArrayIndex = function(val) {
    if (typeof val === "number") {
        return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    if (typeof val === "string") {
        if (!/^\d+$/.test(val)) {
            return false;
        }
        val = +val;
        return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    return false;
};
/**
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */ exports.array.unique = function(arr) {
    const primitives = new Set();
    const ids = new Set();
    const ret = [];
    for (const item of arr){
        if (typeof item === "number" || typeof item === "string" || item == null) {
            if (primitives.has(item)) {
                continue;
            }
            ret.push(item);
            primitives.add(item);
        } else if (isBsonType(item, "ObjectID")) {
            if (ids.has(item.toString())) {
                continue;
            }
            ret.push(item);
            ids.add(item.toString());
        } else {
            ret.push(item);
        }
    }
    return ret;
};
exports.buffer = {};
/**
 * Determines if two buffers are equal.
 *
 * @param {Buffer} a
 * @param {Object} b
 */ exports.buffer.areEqual = function(a, b) {
    if (!Buffer.isBuffer(a)) {
        return false;
    }
    if (!Buffer.isBuffer(b)) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    for(let i = 0, len = a.length; i < len; ++i){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
};
exports.getFunctionName = getFunctionName;
/**
 * Decorate buffers
 * @param {Object} destination
 * @param {Object} source
 */ exports.decorate = function(destination, source) {
    for(const key in source){
        if (specialProperties.has(key)) {
            continue;
        }
        destination[key] = source[key];
    }
};
/**
 * merges to with a copy of from
 *
 * @param {Object} to
 * @param {Object} fromObj
 * @api private
 */ exports.mergeClone = function(to, fromObj) {
    if (isMongooseObject(fromObj)) {
        fromObj = fromObj.toObject({
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
        });
    }
    const keys = Object.keys(fromObj);
    const len = keys.length;
    let i = 0;
    let key;
    while(i < len){
        key = keys[i++];
        if (specialProperties.has(key)) {
            continue;
        }
        if (typeof to[key] === "undefined") {
            to[key] = exports.clone(fromObj[key], {
                transform: false,
                virtuals: false,
                depopulate: true,
                getters: false,
                flattenDecimals: false
            });
        } else {
            let val = fromObj[key];
            if (val != null && val.valueOf && !(val instanceof Date)) {
                val = val.valueOf();
            }
            if (exports.isObject(val)) {
                let obj = val;
                if (isMongooseObject(val) && !val.isMongooseBuffer) {
                    obj = obj.toObject({
                        transform: false,
                        virtuals: false,
                        depopulate: true,
                        getters: false,
                        flattenDecimals: false
                    });
                }
                if (val.isMongooseBuffer) {
                    obj = Buffer.from(obj);
                }
                exports.mergeClone(to[key], obj);
            } else {
                to[key] = exports.clone(val, {
                    flattenDecimals: false
                });
            }
        }
    }
};
/**
 * Executes a function on each element of an array (like _.each)
 *
 * @param {Array} arr
 * @param {Function} fn
 * @api private
 */ exports.each = function(arr, fn) {
    for (const item of arr){
        fn(item);
    }
};
/*!
 * ignore
 */ exports.getOption = function(name) {
    const sources = Array.prototype.slice.call(arguments, 1);
    for (const source of sources){
        if (source == null) {
            continue;
        }
        if (source[name] != null) {
            return source[name];
        }
    }
    return null;
};
/*!
 * ignore
 */ exports.noop = function() {};
exports.errorToPOJO = function errorToPOJO(error) {
    const isError = error instanceof Error;
    if (!isError) {
        throw new Error("`error` must be `instanceof Error`.");
    }
    const ret = {};
    for (const properyName of Object.getOwnPropertyNames(error)){
        ret[properyName] = error[properyName];
    }
    return ret;
};
/*!
 * ignore
 */ exports.warn = function warn(message) {
    return process.emitWarning(message, {
        code: "MONGOOSE"
    });
};
exports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {
    if (timestampsOption == null) {
        return;
    }
    writeOperation.timestamps = timestampsOption;
};


/***/ }),

/***/ 4365:
/***/ ((module) => {

"use strict";
/*!
 * Valid mongoose options
 */ 
const VALID_OPTIONS = Object.freeze([
    "allowDiskUse",
    "applyPluginsToChildSchemas",
    "applyPluginsToDiscriminators",
    "autoCreate",
    "autoIndex",
    "bufferCommands",
    "bufferTimeoutMS",
    "cloneSchemas",
    "debug",
    "id",
    "timestamps.createdAt.immutable",
    "maxTimeMS",
    "objectIdGetter",
    "overwriteModels",
    "returnOriginal",
    "runValidators",
    "sanitizeFilter",
    "sanitizeProjection",
    "selectPopulatedPaths",
    "setDefaultsOnInsert",
    "strict",
    "strictPopulate",
    "strictQuery",
    "toJSON",
    "toObject"
]);
module.exports = VALID_OPTIONS;


/***/ }),

/***/ 3596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(52100);
/**
 * VirtualType constructor
 *
 * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.
 *
 * #### Example:
 *
 *     const fullname = schema.virtual('fullname');
 *     fullname instanceof mongoose.VirtualType // true
 *
 * @param {Object} options
 * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](/docs/populate.html#populate-virtuals)
 * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.
 * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.
 * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.
 * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual
 * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](./api/query.html#query_Query-countDocuments)
 * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`
 * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query
 * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query
 * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.
 * @param {Object} [options.options=null] Additional options like `limit` and `lean`.
 * @param {String} name
 * @api public
 */ function VirtualType(options, name) {
    this.path = name;
    this.getters = [];
    this.setters = [];
    this.options = Object.assign({}, options);
}
/**
 * If no getters/setters, add a default
 *
 * @api private
 */ VirtualType.prototype._applyDefaultGetters = function() {
    if (this.getters.length > 0 || this.setters.length > 0) {
        return;
    }
    const path = this.path;
    const internalProperty = "$" + path;
    this.getters.push(function() {
        return this.$locals[internalProperty];
    });
    this.setters.push(function(v) {
        this.$locals[internalProperty] = v;
    });
};
/*!
 * ignore
 */ VirtualType.prototype.clone = function() {
    const clone = new VirtualType(this.options, this.path);
    clone.getters = [].concat(this.getters);
    clone.setters = [].concat(this.setters);
    return clone;
};
/**
 * Adds a custom getter to this virtual.
 *
 * Mongoose calls the getter function with the below 3 parameters.
 *
 * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.
 * - `virtual`: the virtual object you called `.get()` on.
 * - `doc`: the document this virtual is attached to. Equivalent to `this`.
 *
 * #### Example:
 *
 *     const virtual = schema.virtual('fullname');
 *     virtual.get(function(value, virtual, doc) {
 *       return this.name.first + ' ' + this.name.last;
 *     });
 *
 * @param {Function} fn
 * @return {VirtualType} this
 * @api public
 */ VirtualType.prototype.get = function(fn) {
    this.getters.push(fn);
    return this;
};
/**
 * Adds a custom setter to this virtual.
 *
 * Mongoose calls the setter function with the below 3 parameters.
 *
 * - `value`: the value being set.
 * - `virtual`: the virtual object you're calling `.set()` on.
 * - `doc`: the document this virtual is attached to. Equivalent to `this`.
 *
 * #### Example:
 *
 *     const virtual = schema.virtual('fullname');
 *     virtual.set(function(value, virtual, doc) {
 *       const parts = value.split(' ');
 *       this.name.first = parts[0];
 *       this.name.last = parts[1];
 *     });
 *
 *     const Model = mongoose.model('Test', schema);
 *     const doc = new Model();
 *     // Calls the setter with `value = 'Jean-Luc Picard'`
 *     doc.fullname = 'Jean-Luc Picard';
 *     doc.name.first; // 'Jean-Luc'
 *     doc.name.last; // 'Picard'
 *
 * @param {Function} fn
 * @return {VirtualType} this
 * @api public
 */ VirtualType.prototype.set = function(fn) {
    this.setters.push(fn);
    return this;
};
/**
 * Applies getters to `value`.
 *
 * @param {Object} value
 * @param {Document} doc The document this virtual is attached to
 * @return {Any} the value after applying all getters
 * @api public
 */ VirtualType.prototype.applyGetters = function(value, doc) {
    if (utils.hasUserDefinedProperty(this.options, [
        "ref",
        "refPath"
    ]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
        value = doc.$$populatedVirtuals[this.path];
    }
    let v = value;
    for (const getter of this.getters){
        v = getter.call(doc, v, this, doc);
    }
    return v;
};
/**
 * Applies setters to `value`.
 *
 * @param {Object} value
 * @param {Document} doc
 * @return {Any} the value after applying all setters
 * @api public
 */ VirtualType.prototype.applySetters = function(value, doc) {
    let v = value;
    for (const setter of this.setters){
        v = setter.call(doc, v, this, doc);
    }
    return v;
};
/*!
 * exports
 */ module.exports = VirtualType;


/***/ }),

/***/ 52988:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

module.exports = exports = __webpack_require__(85508);


/***/ }),

/***/ 85508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* eslint strict:off */ /* eslint no-var: off */ /* eslint no-redeclare: off */ var stringToParts = __webpack_require__(93659);
// These properties are special and can open client libraries to security
// issues
var ignoreProperties = [
    "__proto__",
    "constructor",
    "prototype"
];
/**
 * Returns the value of object `o` at the given `path`.
 *
 * ####Example:
 *
 *     var obj = {
 *         comments: [
 *             { title: 'exciting!', _doc: { title: 'great!' }}
 *           , { title: 'number dos' }
 *         ]
 *     }
 *
 *     mpath.get('comments.0.title', o)         // 'exciting!'
 *     mpath.get('comments.0.title', o, '_doc') // 'great!'
 *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']
 *
 *     // summary
 *     mpath.get(path, o)
 *     mpath.get(path, o, special)
 *     mpath.get(path, o, map)
 *     mpath.get(path, o, special, map)
 *
 * @param {String} path
 * @param {Object} o
 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
 * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.
 */ exports.get = function(path, o, special, map) {
    var lookup;
    if ("function" == typeof special) {
        if (special.length < 2) {
            map = special;
            special = undefined;
        } else {
            lookup = special;
            special = undefined;
        }
    }
    map || (map = K);
    var parts = "string" == typeof path ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var obj = o, part;
    for(var i = 0; i < parts.length; ++i){
        part = parts[i];
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
            throw new TypeError("Each segment of path to `get()` must be a string or number, got " + typeof parts[i]);
        }
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
            // reading a property from the array items
            var paths = parts.slice(i);
            // Need to `concat()` to avoid `map()` calling a constructor of an array
            // subclass
            return [].concat(obj).map(function(item) {
                return item ? exports.get(paths, item, special || lookup, map) : map(undefined);
            });
        }
        if (lookup) {
            obj = lookup(obj, part);
        } else {
            var _from = special && obj[special] ? obj[special] : obj;
            obj = _from instanceof Map ? _from.get(part) : _from[part];
        }
        if (!obj) return map(obj);
    }
    return map(obj);
};
/**
 * Returns true if `in` returns true for every piece of the path
 *
 * @param {String} path
 * @param {Object} o
 */ exports.has = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for(var i = 0; i < len; ++i){
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
            throw new TypeError("Each segment of path to `has()` must be a string or number, got " + typeof parts[i]);
        }
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
            return false;
        }
        cur = cur[parts[i]];
    }
    return true;
};
/**
 * Deletes the last piece of `path`
 *
 * @param {String} path
 * @param {Object} o
 */ exports.unset = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for(var i = 0; i < len; ++i){
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
            return false;
        }
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
            throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + typeof parts[i]);
        }
        // Disallow any updates to __proto__ or special properties.
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
            return false;
        }
        if (i === len - 1) {
            delete cur[parts[i]];
            return true;
        }
        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
    }
    return true;
};
/**
 * Sets the `val` at the given `path` of object `o`.
 *
 * @param {String} path
 * @param {Anything} val
 * @param {Object} o
 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
 * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.
 */ exports.set = function(path, val, o, special, map, _copying) {
    var lookup;
    if ("function" == typeof special) {
        if (special.length < 2) {
            map = special;
            special = undefined;
        } else {
            lookup = special;
            special = undefined;
        }
    }
    map || (map = K);
    var parts = "string" == typeof path ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
    }
    if (null == o) return;
    for(var i = 0; i < parts.length; ++i){
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
            throw new TypeError("Each segment of path to `set()` must be a string or number, got " + typeof parts[i]);
        }
        // Silently ignore any updates to `__proto__`, these are potentially
        // dangerous if using mpath with unsanitized data.
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
            return;
        }
    }
    // the existance of $ in a path tells us if the user desires
    // the copying of an array instead of setting each value of
    // the array to the one by one to matching positions of the
    // current array. Unless the user explicitly opted out by passing
    // false, see Automattic/mongoose#6273
    var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
    for(var i = 0, len = parts.length - 1; i < len; ++i){
        part = parts[i];
        if ("$" == part) {
            if (i == len - 1) {
                break;
            } else {
                continue;
            }
        }
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
            var paths = parts.slice(i);
            if (!copy && Array.isArray(val)) {
                for(var j = 0; j < obj.length && j < val.length; ++j){
                    // assignment of single values of array
                    exports.set(paths, val[j], obj[j], special || lookup, map, copy);
                }
            } else {
                for(var j = 0; j < obj.length; ++j){
                    // assignment of entire value
                    exports.set(paths, val, obj[j], special || lookup, map, copy);
                }
            }
            return;
        }
        if (lookup) {
            obj = lookup(obj, part);
        } else {
            var _to = special && obj[special] ? obj[special] : obj;
            obj = _to instanceof Map ? _to.get(part) : _to[part];
        }
        if (!obj) return;
    }
    // process the last property of the path
    part = parts[len];
    // use the special property if exists
    if (special && obj[special]) {
        obj = obj[special];
    }
    // set the value on the last branch
    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        if (!copy && Array.isArray(val)) {
            _setArray(obj, val, part, lookup, special, map);
        } else {
            for(var j = 0; j < obj.length; ++j){
                var item = obj[j];
                if (item) {
                    if (lookup) {
                        lookup(item, part, map(val));
                    } else {
                        if (item[special]) item = item[special];
                        item[part] = map(val);
                    }
                }
            }
        }
    } else {
        if (lookup) {
            lookup(obj, part, map(val));
        } else if (obj instanceof Map) {
            obj.set(part, map(val));
        } else {
            obj[part] = map(val);
        }
    }
};
/*!
 * Split a string path into components delimited by '.' or
 * '[\d+]'
 *
 * #### Example:
 *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']
 */ exports.stringToParts = stringToParts;
/*!
 * Recursively set nested arrays
 */ function _setArray(obj, val, part, lookup, special, map) {
    for(var item, j = 0; j < obj.length && j < val.length; ++j){
        item = obj[j];
        if (Array.isArray(item) && Array.isArray(val[j])) {
            _setArray(item, val[j], part, lookup, special, map);
        } else if (item) {
            if (lookup) {
                lookup(item, part, map(val[j]));
            } else {
                if (item[special]) item = item[special];
                item[part] = map(val[j]);
            }
        }
    }
}
/*!
 * Returns the value passed to it.
 */ function K(v) {
    return v;
}


/***/ }),

/***/ 93659:
/***/ ((module) => {

"use strict";

module.exports = function stringToParts(str) {
    const result = [];
    let curPropertyName = "";
    let state = "DEFAULT";
    for(let i = 0; i < str.length; ++i){
        // Fall back to treating as property name rather than bracket notation if
        // square brackets contains something other than a number.
        if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
            state = "DEFAULT";
            curPropertyName = result[result.length - 1] + "[" + curPropertyName;
            result.splice(result.length - 1, 1);
        }
        if (str[i] === "[") {
            if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
                result.push(curPropertyName);
                curPropertyName = "";
            }
            state = "IN_SQUARE_BRACKETS";
        } else if (str[i] === "]") {
            if (state === "IN_SQUARE_BRACKETS") {
                state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
                result.push(curPropertyName);
                curPropertyName = "";
            } else {
                state = "DEFAULT";
                curPropertyName += str[i];
            }
        } else if (str[i] === ".") {
            if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
                result.push(curPropertyName);
                curPropertyName = "";
            }
            state = "DEFAULT";
        } else {
            curPropertyName += str[i];
        }
    }
    if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
        result.push(curPropertyName);
    }
    return result;
};


/***/ }),

/***/ 51037:
/***/ ((module, exports) => {

"use strict";

/**
 * methods a collection must implement
 */ const methods = [
    "find",
    "findOne",
    "update",
    "updateMany",
    "updateOne",
    "replaceOne",
    "remove",
    "count",
    "distinct",
    "findOneAndDelete",
    "findOneAndUpdate",
    "aggregate",
    "findCursor",
    "deleteOne",
    "deleteMany"
];
/**
 * Collection base class from which implementations inherit
 */ function Collection() {}
for(let i = 0, len = methods.length; i < len; ++i){
    const method = methods[i];
    Collection.prototype[method] = notImplemented(method);
}
module.exports = exports = Collection;
Collection.methods = methods;
/**
 * creates a function which throws an implementation error
 */ function notImplemented(method) {
    return function() {
        throw new Error("collection." + method + " not implemented");
    };
}


/***/ }),

/***/ 33716:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const env = __webpack_require__(91652);
if ("unknown" == env.type) {
    throw new Error("Unknown environment");
}
module.exports = env.isNode ? __webpack_require__(76868) : env.isMongo ? __webpack_require__(51037) : __webpack_require__(51037);


/***/ }),

/***/ 76868:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/**
 * Module dependencies
 */ const Collection = __webpack_require__(51037);
class NodeCollection extends Collection {
    constructor(col){
        super();
        this.collection = col;
        this.collectionName = col.collectionName;
    }
    /**
   * find(match, options, function(err, docs))
   */ find(match, options, cb) {
        const cursor = this.collection.find(match, options);
        try {
            cursor.toArray(cb);
        } catch (error) {
            cb(error);
        }
    }
    /**
   * findOne(match, options, function(err, doc))
   */ findOne(match, options, cb) {
        this.collection.findOne(match, options, cb);
    }
    /**
   * count(match, options, function(err, count))
   */ count(match, options, cb) {
        this.collection.count(match, options, cb);
    }
    /**
   * distinct(prop, match, options, function(err, count))
   */ distinct(prop, match, options, cb) {
        this.collection.distinct(prop, match, options, cb);
    }
    /**
   * update(match, update, options, function(err[, result]))
   */ update(match, update, options, cb) {
        this.collection.update(match, update, options, cb);
    }
    /**
   * update(match, update, options, function(err[, result]))
   */ updateMany(match, update, options, cb) {
        this.collection.updateMany(match, update, options, cb);
    }
    /**
   * update(match, update, options, function(err[, result]))
   */ updateOne(match, update, options, cb) {
        this.collection.updateOne(match, update, options, cb);
    }
    /**
   * replaceOne(match, update, options, function(err[, result]))
   */ replaceOne(match, update, options, cb) {
        this.collection.replaceOne(match, update, options, cb);
    }
    /**
   * deleteOne(match, options, function(err[, result])
   */ deleteOne(match, options, cb) {
        this.collection.deleteOne(match, options, cb);
    }
    /**
   * deleteMany(match, options, function(err[, result])
   */ deleteMany(match, options, cb) {
        this.collection.deleteMany(match, options, cb);
    }
    /**
   * remove(match, options, function(err[, result])
   */ remove(match, options, cb) {
        this.collection.remove(match, options, cb);
    }
    /**
   * findOneAndDelete(match, options, function(err[, result])
   */ findOneAndDelete(match, options, cb) {
        this.collection.findOneAndDelete(match, options, cb);
    }
    /**
   * findOneAndUpdate(match, update, options, function(err[, result])
   */ findOneAndUpdate(match, update, options, cb) {
        this.collection.findOneAndUpdate(match, update, options, cb);
    }
    /**
   * var cursor = findCursor(match, options)
   */ findCursor(match, options) {
        return this.collection.find(match, options);
    }
}
/**
 * Expose
 */ module.exports = exports = NodeCollection;


/***/ }),

/***/ 91652:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.isNode = "undefined" != typeof process && "object" == "object" && "object" == typeof global && "function" == typeof Buffer && process.argv;
exports.isMongo = !exports.isNode && "function" == typeof printjson && "function" == typeof ObjectId && "function" == typeof rs && "function" == typeof sh;
exports.isBrowser = !exports.isNode && !exports.isMongo && "undefined" != "undefined";
exports.type = exports.isNode ? "node" : exports.isMongo ? "mongo" : exports.isBrowser ? "browser" : "unknown";


/***/ }),

/***/ 66908:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/**
 * Dependencies
 */ const assert = __webpack_require__(39491);
const util = __webpack_require__(73837);
const utils = __webpack_require__(80154);
const debug = __webpack_require__(53550)("mquery");
/**
 * Query constructor used for building queries.
 *
 * ####Example:
 *
 *     var query = new Query({ name: 'mquery' });
 *     query.setOptions({ collection: moduleCollection })
 *     query.where('age').gte(21).exec(callback);
 *
 * @param {Object} [criteria]
 * @param {Object} [options]
 * @api public
 */ function Query(criteria, options) {
    if (!(this instanceof Query)) return new Query(criteria, options);
    const proto = this.constructor.prototype;
    this.op = proto.op || undefined;
    this.options = Object.assign({}, proto.options);
    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};
    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;
    this._update = proto._update ? utils.clone(proto._update) : undefined;
    this._path = proto._path || undefined;
    this._distinct = proto._distinct || undefined;
    this._collection = proto._collection || undefined;
    this._traceFunction = proto._traceFunction || undefined;
    if (options) {
        this.setOptions(options);
    }
    if (criteria) {
        if (criteria.find && criteria.remove && criteria.update) {
            // quack quack!
            this.collection(criteria);
        } else {
            this.find(criteria);
        }
    }
}
/**
 * This is a parameter that the user can set which determines if mquery
 * uses $within or $geoWithin for queries. It defaults to true which
 * means $geoWithin will be used. If using MongoDB < 2.4 you should
 * set this to false.
 *
 * @api public
 * @property use$geoWithin
 */ let $withinCmd = "$geoWithin";
Object.defineProperty(Query, "use$geoWithin", {
    get: function() {
        return $withinCmd == "$geoWithin";
    },
    set: function(v) {
        if (true === v) {
            // mongodb >= 2.4
            $withinCmd = "$geoWithin";
        } else {
            $withinCmd = "$within";
        }
    }
});
/**
 * Converts this query to a constructor function with all arguments and options retained.
 *
 * ####Example
 *
 *     // Create a query that will read documents with a "video" category from
 *     // `aCollection` on the primary node in the replica-set unless it is down,
 *     // in which case we'll read from a secondary node.
 *     var query = mquery({ category: 'video' })
 *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });
 *
 *     // create a constructor based off these settings
 *     var Video = query.toConstructor();
 *
 *     // Video is now a subclass of mquery() and works the same way but with the
 *     // default query parameters and options set.
 *
 *     // run a query with the previous settings but filter for movies with names
 *     // that start with "Life".
 *     Video().where({ name: /^Life/ }).exec(cb);
 *
 * @return {Query} new Query
 * @api public
 */ Query.prototype.toConstructor = function toConstructor() {
    function CustomQuery(criteria, options) {
        if (!(this instanceof CustomQuery)) return new CustomQuery(criteria, options);
        Query.call(this, criteria, options);
    }
    utils.inherits(CustomQuery, Query);
    // set inherited defaults
    const p = CustomQuery.prototype;
    p.options = {};
    p.setOptions(this.options);
    p.op = this.op;
    p._conditions = utils.clone(this._conditions);
    p._fields = utils.clone(this._fields);
    p._update = utils.clone(this._update);
    p._path = this._path;
    p._distinct = this._distinct;
    p._collection = this._collection;
    p._traceFunction = this._traceFunction;
    return CustomQuery;
};
/**
 * Sets query options.
 *
 * ####Options:
 *
 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
 * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
 * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *
 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
 * - collection the collection to query against
 *
 * _* denotes a query helper method is also available_
 *
 * @param {Object} options
 * @api public
 */ Query.prototype.setOptions = function(options) {
    if (!(options && utils.isObject(options))) return this;
    // set arbitrary options
    const methods = utils.keys(options);
    let method;
    for(let i = 0; i < methods.length; ++i){
        method = methods[i];
        // use methods if exist (safer option manipulation)
        if ("function" == typeof this[method]) {
            const args = Array.isArray(options[method]) ? options[method] : [
                options[method]
            ];
            this[method].apply(this, args);
        } else {
            this.options[method] = options[method];
        }
    }
    return this;
};
/**
 * Sets this Querys collection.
 *
 * @param {Collection} coll
 * @return {Query} this
 */ Query.prototype.collection = function collection(coll) {
    this._collection = new Query.Collection(coll);
    return this;
};
/**
 * Adds a collation to this op (MongoDB 3.4 and up)
 *
 * ####Example
 *
 *     query.find().collation({ locale: "en_US", strength: 1 })
 *
 * @param {Object} value
 * @return {Query} this
 * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation
 * @api public
 */ Query.prototype.collation = function(value) {
    this.options.collation = value;
    return this;
};
/**
 * Specifies a `$where` condition
 *
 * Use `$where` when you need to select documents using a JavaScript expression.
 *
 * ####Example
 *
 *     query.$where('this.comments.length > 10 || this.name.length > 5')
 *
 *     query.$where(function () {
 *       return this.comments.length > 10 || this.name.length > 5;
 *     })
 *
 * @param {String|Function} js javascript string or function
 * @return {Query} this
 * @memberOf Query
 * @method $where
 * @api public
 */ Query.prototype.$where = function(js) {
    this._conditions.$where = js;
    return this;
};
/**
 * Specifies a `path` for use with chaining.
 *
 * ####Example
 *
 *     // instead of writing:
 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
 *
 *     // we can instead write:
 *     User.where('age').gte(21).lte(65);
 *
 *     // passing query conditions is permitted
 *     User.find().where({ name: 'vonderful' })
 *
 *     // chaining
 *     User
 *     .where('age').gte(21).lte(65)
 *     .where('name', /^vonderful/i)
 *     .where('friends').slice(10)
 *     .exec(callback)
 *
 * @param {String} [path]
 * @param {Object} [val]
 * @return {Query} this
 * @api public
 */ Query.prototype.where = function() {
    if (!arguments.length) return this;
    if (!this.op) this.op = "find";
    const type = typeof arguments[0];
    if ("string" == type) {
        this._path = arguments[0];
        if (2 === arguments.length) {
            this._conditions[this._path] = arguments[1];
        }
        return this;
    }
    if ("object" == type && !Array.isArray(arguments[0])) {
        return this.merge(arguments[0]);
    }
    throw new TypeError("path must be a string or object");
};
/**
 * Specifies the complementary comparison value for paths specified with `where()`
 *
 * ####Example
 *
 *     User.where('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @param {Object} val
 * @return {Query} this
 * @api public
 */ Query.prototype.equals = function equals(val) {
    this._ensurePath("equals");
    const path = this._path;
    this._conditions[path] = val;
    return this;
};
/**
 * Specifies the complementary comparison value for paths specified with `where()`
 * This is alias of `equals`
 *
 * ####Example
 *
 *     User.where('age').eq(49);
 *
 *     // is the same as
 *
 *     User.shere('age').equals(49);
 *
 *     // is the same as
 *
 *     User.where('age', 49);
 *
 * @param {Object} val
 * @return {Query} this
 * @api public
 */ Query.prototype.eq = function eq(val) {
    this._ensurePath("eq");
    const path = this._path;
    this._conditions[path] = val;
    return this;
};
/**
 * Specifies arguments for an `$or` condition.
 *
 * ####Example
 *
 *     query.or([{ color: 'red' }, { status: 'emergency' }])
 *
 * @param {Array} array array of conditions
 * @return {Query} this
 * @api public
 */ Query.prototype.or = function or(array) {
    const or = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array)) array = [
        array
    ];
    or.push.apply(or, array);
    return this;
};
/**
 * Specifies arguments for a `$nor` condition.
 *
 * ####Example
 *
 *     query.nor([{ color: 'green' }, { status: 'ok' }])
 *
 * @param {Array} array array of conditions
 * @return {Query} this
 * @api public
 */ Query.prototype.nor = function nor(array) {
    const nor = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array)) array = [
        array
    ];
    nor.push.apply(nor, array);
    return this;
};
/**
 * Specifies arguments for a `$and` condition.
 *
 * ####Example
 *
 *     query.and([{ color: 'green' }, { status: 'ok' }])
 *
 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
 * @param {Array} array array of conditions
 * @return {Query} this
 * @api public
 */ Query.prototype.and = function and(array) {
    const and = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array)) array = [
        array
    ];
    and.push.apply(and, array);
    return this;
};
/**
 * Specifies a $gt query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * ####Example
 *
 *     Thing.find().where('age').gt(21)
 *
 *     // or
 *     Thing.find().gt('age', 21)
 *
 * @method gt
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a $gte query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method gte
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a $lt query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lt
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a $lte query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method lte
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a $ne query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method ne
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies an $in query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method in
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies an $nin query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method nin
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies an $all query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method all
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a $size query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method size
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /**
 * Specifies a $regex query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method regex
 * @memberOf Query
 * @param {String} [path]
 * @param {String|RegExp} val
 * @api public
 */ /**
 * Specifies a $maxDistance query condition.
 *
 * When called with one argument, the most recent path passed to `where()` is used.
 *
 * @method maxDistance
 * @memberOf Query
 * @param {String} [path]
 * @param {Number} val
 * @api public
 */ /*!
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */ "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
    Query.prototype[$conditional] = function() {
        let path, val;
        if (1 === arguments.length) {
            this._ensurePath($conditional);
            val = arguments[0];
            path = this._path;
        } else {
            val = arguments[1];
            path = arguments[0];
        }
        const conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
        conds["$" + $conditional] = val;
        return this;
    };
});
/**
 * Specifies a `$mod` condition
 *
 * @param {String} [path]
 * @param {Number} val
 * @return {Query} this
 * @api public
 */ Query.prototype.mod = function() {
    let val, path;
    if (1 === arguments.length) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = [
            arguments[0],
            arguments[1]
        ];
        path = this._path;
    } else if (3 === arguments.length) {
        val = [
            arguments[1],
            arguments[2]
        ];
        path = arguments[0];
    } else {
        val = arguments[1];
        path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
};
/**
 * Specifies an `$exists` condition
 *
 * ####Example
 *
 *     // { name: { $exists: true }}
 *     Thing.where('name').exists()
 *     Thing.where('name').exists(true)
 *     Thing.find().exists('name')
 *
 *     // { name: { $exists: false }}
 *     Thing.where('name').exists(false);
 *     Thing.find().exists('name', false);
 *
 * @param {String} [path]
 * @param {Number} val
 * @return {Query} this
 * @api public
 */ Query.prototype.exists = function() {
    let path, val;
    if (0 === arguments.length) {
        this._ensurePath("exists");
        path = this._path;
        val = true;
    } else if (1 === arguments.length) {
        if ("boolean" === typeof arguments[0]) {
            this._ensurePath("exists");
            path = this._path;
            val = arguments[0];
        } else {
            path = arguments[0];
            val = true;
        }
    } else if (2 === arguments.length) {
        path = arguments[0];
        val = arguments[1];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
};
/**
 * Specifies an `$elemMatch` condition
 *
 * ####Example
 *
 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
 *
 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
 *
 *     query.elemMatch('comment', function (elem) {
 *       elem.where('author').equals('autobot');
 *       elem.where('votes').gte(5);
 *     })
 *
 *     query.where('comment').elemMatch(function (elem) {
 *       elem.where({ author: 'autobot' });
 *       elem.where('votes').gte(5);
 *     })
 *
 * @param {String|Object|Function} path
 * @param {Object|Function} criteria
 * @return {Query} this
 * @api public
 */ Query.prototype.elemMatch = function() {
    if (null == arguments[0]) throw new TypeError("Invalid argument");
    let fn, path, criteria;
    if ("function" === typeof arguments[0]) {
        this._ensurePath("elemMatch");
        path = this._path;
        fn = arguments[0];
    } else if (utils.isObject(arguments[0])) {
        this._ensurePath("elemMatch");
        path = this._path;
        criteria = arguments[0];
    } else if ("function" === typeof arguments[1]) {
        path = arguments[0];
        fn = arguments[1];
    } else if (arguments[1] && utils.isObject(arguments[1])) {
        path = arguments[0];
        criteria = arguments[1];
    } else {
        throw new TypeError("Invalid argument");
    }
    if (fn) {
        criteria = new Query;
        fn(criteria);
        criteria = criteria._conditions;
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
};
// Spatial queries
/**
 * Sugar for geo-spatial queries.
 *
 * ####Example
 *
 *     query.within().box()
 *     query.within().circle()
 *     query.within().geometry()
 *
 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
 *     query.where('loc').within({ polygon: [[],[],[],[]] });
 *
 *     query.where('loc').within([], [], []) // polygon
 *     query.where('loc').within([], []) // box
 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
 *
 * ####NOTE:
 *
 * Must be used after `where()`.
 *
 * @memberOf Query
 * @return {Query} this
 * @api public
 */ Query.prototype.within = function within() {
    // opinionated, must be used after where
    this._ensurePath("within");
    this._geoComparison = $withinCmd;
    if (0 === arguments.length) {
        return this;
    }
    if (2 === arguments.length) {
        return this.box.apply(this, arguments);
    } else if (2 < arguments.length) {
        return this.polygon.apply(this, arguments);
    }
    const area = arguments[0];
    if (!area) throw new TypeError("Invalid argument");
    if (area.center) return this.circle(area);
    if (area.box) return this.box.apply(this, area.box);
    if (area.polygon) return this.polygon.apply(this, area.polygon);
    if (area.type && area.coordinates) return this.geometry(area);
    throw new TypeError("Invalid argument");
};
/**
 * Specifies a $box condition
 *
 * ####Example
 *
 *     var lowerLeft = [40.73083, -73.99756]
 *     var upperRight= [40.741404,  -73.988135]
 *
 *     query.where('loc').within().box(lowerLeft, upperRight)
 *     query.box('loc', lowerLeft, upperRight )
 *
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see Query#within #query_Query-within
 * @param {String} path
 * @param {Object} val
 * @return {Query} this
 * @api public
 */ Query.prototype.box = function() {
    let path, box;
    if (3 === arguments.length) {
        // box('loc', [], [])
        path = arguments[0];
        box = [
            arguments[1],
            arguments[2]
        ];
    } else if (2 === arguments.length) {
        // box([], [])
        this._ensurePath("box");
        path = this._path;
        box = [
            arguments[0],
            arguments[1]
        ];
    } else {
        throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = {
        $box: box
    };
    return this;
};
/**
 * Specifies a $polygon condition
 *
 * ####Example
 *
 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
 *     query.polygon('loc', [10,20], [13, 25], [7,15])
 *
 * @param {String|Array} [path]
 * @param {Array|Object} [val]
 * @return {Query} this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ Query.prototype.polygon = function() {
    let val, path;
    if ("string" == typeof arguments[0]) {
        // polygon('loc', [],[],[])
        val = Array.from(arguments);
        path = val.shift();
    } else {
        // polygon([],[],[])
        this._ensurePath("polygon");
        path = this._path;
        val = Array.from(arguments);
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = {
        $polygon: val
    };
    return this;
};
/**
 * Specifies a $center or $centerSphere condition.
 *
 * ####Example
 *
 *     var area = { center: [50, 50], radius: 10, unique: true }
 *     query.where('loc').within().circle(area)
 *     query.center('loc', area);
 *
 *     // for spherical calculations
 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
 *     query.where('loc').within().circle(area)
 *     query.center('loc', area);
 *
 * @param {String} [path]
 * @param {Object} area
 * @return {Query} this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ Query.prototype.circle = function() {
    let path, val;
    if (1 === arguments.length) {
        this._ensurePath("circle");
        path = this._path;
        val = arguments[0];
    } else if (2 === arguments.length) {
        path = arguments[0];
        val = arguments[1];
    } else {
        throw new TypeError("Invalid argument");
    }
    if (!("radius" in val && val.center)) throw new Error("center and radius are required");
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$centerSphere" : "$center";
    const wKey = this._geoComparison || $withinCmd;
    conds[wKey] = {};
    conds[wKey][type] = [
        val.center,
        val.radius
    ];
    if ("unique" in val) conds[wKey].$uniqueDocs = !!val.unique;
    return this;
};
/**
 * Specifies a `$near` or `$nearSphere` condition
 *
 * These operators return documents sorted by distance.
 *
 * ####Example
 *
 *     query.where('loc').near({ center: [10, 10] });
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
 *     query.near({ center: { type: 'Point', coordinates: [..] }})
 *     query.near().geometry({ type: 'Point', coordinates: [..] })
 *
 * @param {String} [path]
 * @param {Object} val
 * @return {Query} this
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @api public
 */ Query.prototype.near = function near() {
    let path, val;
    this._geoComparison = "$near";
    if (0 === arguments.length) {
        return this;
    } else if (1 === arguments.length) {
        this._ensurePath("near");
        path = this._path;
        val = arguments[0];
    } else if (2 === arguments.length) {
        path = arguments[0];
        val = arguments[1];
    } else {
        throw new TypeError("Invalid argument");
    }
    if (!val.center) {
        throw new Error("center is required");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$nearSphere" : "$near";
    // center could be a GeoJSON object or an Array
    if (Array.isArray(val.center)) {
        conds[type] = val.center;
        const radius = "maxDistance" in val ? val.maxDistance : null;
        if (null != radius) {
            conds.$maxDistance = radius;
        }
        if (null != val.minDistance) {
            conds.$minDistance = val.minDistance;
        }
    } else {
        // GeoJSON?
        if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
            throw new Error(util.format("Invalid GeoJSON specified for %s", type));
        }
        conds[type] = {
            $geometry: val.center
        };
        // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere
        if ("maxDistance" in val) {
            conds[type]["$maxDistance"] = val.maxDistance;
        }
        if ("minDistance" in val) {
            conds[type]["$minDistance"] = val.minDistance;
        }
    }
    return this;
};
/**
 * Declares an intersects query for `geometry()`.
 *
 * ####Example
 *
 *     query.where('path').intersects().geometry({
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     })
 *
 *     query.where('path').intersects({
 *         type: 'LineString'
 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
 *     })
 *
 * @param {Object} [arg]
 * @return {Query} this
 * @api public
 */ Query.prototype.intersects = function intersects() {
    // opinionated, must be used after where
    this._ensurePath("intersects");
    this._geoComparison = "$geoIntersects";
    if (0 === arguments.length) {
        return this;
    }
    const area = arguments[0];
    if (null != area && area.type && area.coordinates) return this.geometry(area);
    throw new TypeError("Invalid argument");
};
/**
 * Specifies a `$geometry` condition
 *
 * ####Example
 *
 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
 *
 *     // or
 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
 *
 *     // or
 *     var polyC = [ 0, 0 ]
 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
 *
 *     // or
 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
 *
 * ####NOTE:
 *
 * `geometry()` **must** come after either `intersects()` or `within()`.
 *
 * The `object` argument must contain `type` and `coordinates` properties.
 * - type {String}
 * - coordinates {Array}
 *
 * The most recent path passed to `where()` is used.
 *
 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
 * @return {Query} this
 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
 * @api public
 */ Query.prototype.geometry = function geometry() {
    if (!("$within" == this._geoComparison || "$geoWithin" == this._geoComparison || "$near" == this._geoComparison || "$geoIntersects" == this._geoComparison)) {
        throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
    }
    let val, path;
    if (1 === arguments.length) {
        this._ensurePath("geometry");
        path = this._path;
        val = arguments[0];
    } else {
        throw new TypeError("Invalid argument");
    }
    if (!(val.type && Array.isArray(val.coordinates))) {
        throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison] = {
        $geometry: val
    };
    return this;
};
// end spatial
/**
 * Specifies which document fields to include or exclude
 *
 * ####String syntax
 *
 * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.
 *
 * ####Example
 *
 *     // include a and b, exclude c
 *     query.select('a b -c');
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     query.select({a: 1, b: 1, c: 0});
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Object|String} arg
 * @return {Query} this
 * @see SchemaType
 * @api public
 */ Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg) return this;
    if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const type = typeof arg;
    let i, len;
    if (("string" == type || utils.isArgumentsObject(arg)) && "number" == typeof arg.length || Array.isArray(arg)) {
        if ("string" == type) arg = arg.split(/\s+/);
        for(i = 0, len = arg.length; i < len; ++i){
            let field = arg[i];
            if (!field) continue;
            const include = "-" == field[0] ? 0 : 1;
            if (include === 0) field = field.substring(1);
            fields[field] = include;
        }
        return this;
    }
    if (utils.isObject(arg)) {
        const keys = utils.keys(arg);
        for(i = 0; i < keys.length; ++i){
            fields[keys[i]] = arg[keys[i]];
        }
        return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
};
/**
 * Specifies a $slice condition for a `path`
 *
 * ####Example
 *
 *     query.slice('comments', 5)
 *     query.slice('comments', -5)
 *     query.slice('comments', [10, 5])
 *     query.where('comments').slice(5)
 *     query.where('comments').slice([-10, 5])
 *
 * @param {String} [path]
 * @param {Number} val number/range of elements to slice
 * @return {Query} this
 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
 * @api public
 */ Query.prototype.slice = function() {
    if (0 === arguments.length) return this;
    this._validate("slice");
    let path, val;
    if (1 === arguments.length) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
            const keys = Object.keys(arg);
            const numKeys = keys.length;
            for(let i = 0; i < numKeys; ++i){
                this.slice(keys[i], arg[keys[i]]);
            }
            return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
    } else if (2 === arguments.length) {
        if ("number" === typeof arguments[0]) {
            this._ensurePath("slice");
            path = this._path;
            val = [
                arguments[0],
                arguments[1]
            ];
        } else {
            path = arguments[0];
            val = arguments[1];
        }
    } else if (3 === arguments.length) {
        path = arguments[0];
        val = [
            arguments[1],
            arguments[2]
        ];
    }
    const myFields = this._fields || (this._fields = {});
    myFields[path] = {
        $slice: val
    };
    return this;
};
/**
 * Sets the sort order
 *
 * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
 *
 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
 *
 * ####Example
 *
 *     // these are equivalent
 *     query.sort({ field: 'asc', test: -1 });
 *     query.sort('field -test');
 *     query.sort([['field', 1], ['test', -1]]);
 *
 * ####Note
 *
 *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).
 *  - Cannot be used with `distinct()`
 *
 * @param {Object|String|Array} arg
 * @return {Query} this
 * @api public
 */ Query.prototype.sort = function(arg) {
    if (!arg) return this;
    let i, len, field;
    this._validate("sort");
    const type = typeof arg;
    // .sort([['field', 1], ['test', -1]])
    if (Array.isArray(arg)) {
        len = arg.length;
        for(i = 0; i < arg.length; ++i){
            if (!Array.isArray(arg[i])) {
                throw new Error("Invalid sort() argument, must be array of arrays");
            }
            _pushArr(this.options, arg[i][0], arg[i][1]);
        }
        return this;
    }
    // .sort('field -test')
    if (1 === arguments.length && "string" == type) {
        arg = arg.split(/\s+/);
        len = arg.length;
        for(i = 0; i < len; ++i){
            field = arg[i];
            if (!field) continue;
            const ascend = "-" == field[0] ? -1 : 1;
            if (ascend === -1) field = field.substring(1);
            push(this.options, field, ascend);
        }
        return this;
    }
    // .sort({ field: 1, test: -1 })
    if (utils.isObject(arg)) {
        const keys = utils.keys(arg);
        for(i = 0; i < keys.length; ++i){
            field = keys[i];
            push(this.options, field, arg[field]);
        }
        return this;
    }
    if (typeof Map !== "undefined" && arg instanceof Map) {
        _pushMap(this.options, arg);
        return this;
    }
    throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
};
/*!
 * @ignore
 */ const _validSortValue = {
    1: 1,
    "-1": -1,
    asc: 1,
    ascending: 1,
    desc: -1,
    descending: -1
};
function push(opts, field, value) {
    if (Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:" + "\n- `.sort([['field', 1], ['test', -1]])`" + "\n- `.sort({ field: 1, test: -1 })`");
    }
    let s;
    if (value && value.$meta) {
        s = opts.sort || (opts.sort = {});
        s[field] = {
            $meta: value.$meta
        };
        return;
    }
    s = opts.sort || (opts.sort = {});
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val) throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
    s[field] = val;
}
function _pushArr(opts, field, value) {
    opts.sort = opts.sort || [];
    if (!Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:" + "\n- `.sort([['field', 1], ['test', -1]])`" + "\n- `.sort({ field: 1, test: -1 })`");
    }
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val) throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
    opts.sort.push([
        field,
        val
    ]);
}
function _pushMap(opts, map) {
    opts.sort = opts.sort || new Map();
    if (!(opts.sort instanceof Map)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or " + "object or map consistently");
    }
    map.forEach(function(value, key) {
        let val = String(value || 1).toLowerCase();
        val = _validSortValue[val];
        if (!val) throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
        opts.sort.set(key, val);
    });
}
/**
 * Specifies the limit option.
 *
 * ####Example
 *
 *     query.limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method limit
 * @memberOf Query
 * @param {Number} val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D
 * @api public
 */ /**
 * Specifies the skip option.
 *
 * ####Example
 *
 *     query.skip(100).limit(20)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method skip
 * @memberOf Query
 * @param {Number} val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D
 * @api public
 */ /**
 * Specifies the maxScan option.
 *
 * ####Example
 *
 *     query.maxScan(100)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method maxScan
 * @memberOf Query
 * @param {Number} val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan
 * @api public
 */ /**
 * Specifies the batchSize option.
 *
 * ####Example
 *
 *     query.batchSize(100)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method batchSize
 * @memberOf Query
 * @param {Number} val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D
 * @api public
 */ /**
 * Specifies the `comment` option.
 *
 * ####Example
 *
 *     query.comment('login query')
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @method comment
 * @memberOf Query
 * @param {Number} val
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment
 * @api public
 */ /*!
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */ [
    "limit",
    "skip",
    "maxScan",
    "batchSize",
    "comment"
].forEach(function(method) {
    Query.prototype[method] = function(v) {
        this._validate(method);
        this.options[method] = v;
        return this;
    };
});
/**
 * Specifies the maxTimeMS option.
 *
 * ####Example
 *
 *     query.maxTime(100)
 *     query.maxTimeMS(100)
 *
 * @method maxTime
 * @memberOf Query
 * @param {Number} ms
 * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS
 * @api public
 */ Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
    this._validate("maxTime");
    this.options.maxTimeMS = ms;
    return this;
};
/**
 * Specifies this query as a `snapshot` query.
 *
 * ####Example
 *
 *     mquery().snapshot() // true
 *     mquery().snapshot(true)
 *     mquery().snapshot(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D
 * @return {Query} this
 * @api public
 */ Query.prototype.snapshot = function() {
    this._validate("snapshot");
    this.options.snapshot = arguments.length ? !!arguments[0] : true;
    return this;
};
/**
 * Sets query hints.
 *
 * ####Example
 *
 *     query.hint({ indexA: 1, indexB: -1});
 *     query.hint('indexA_1_indexB_1');
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Object|string} val a hint object or the index name
 * @return {Query} this
 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint
 * @api public
 */ Query.prototype.hint = function() {
    if (0 === arguments.length) return this;
    this._validate("hint");
    const arg = arguments[0];
    if (utils.isObject(arg)) {
        const hint = this.options.hint || (this.options.hint = {});
        // must keep object keys in order so don't use Object.keys()
        for(const k in arg){
            hint[k] = arg[k];
        }
        return this;
    }
    if (typeof arg === "string") {
        this.options.hint = arg;
        return this;
    }
    throw new TypeError("Invalid hint. " + arg);
};
/**
 * Requests acknowledgement that this operation has been persisted to MongoDB's
 * on-disk journal.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the `j` value if it is specified in writeConcern options
 *
 * ####Example:
 *
 *     mquery().w(2).j(true).wtimeout(2000);
 *
 * @method j
 * @memberOf Query
 * @instance
 * @param {boolean} val
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option
 * @return {Query} this
 * @api public
 */ Query.prototype.j = function j(val) {
    this.options.j = val;
    return this;
};
/**
 * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.
 *
 * ####Example:
 *
 *     query.slaveOk() // true
 *     query.slaveOk(true)
 *     query.slaveOk(false)
 *
 * @deprecated use read() preferences instead if on mongodb >= 2.2
 * @param {Boolean} v defaults to true
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see read()
 * @return {Query} this
 * @api public
 */ Query.prototype.slaveOk = function(v) {
    this.options.slaveOk = arguments.length ? !!v : true;
    return this;
};
/**
 * Sets the readPreference option for the query.
 *
 * ####Example:
 *
 *     new Query().read('primary')
 *     new Query().read('p')  // same as primary
 *
 *     new Query().read('primaryPreferred')
 *     new Query().read('pp') // same as primaryPreferred
 *
 *     new Query().read('secondary')
 *     new Query().read('s')  // same as secondary
 *
 *     new Query().read('secondaryPreferred')
 *     new Query().read('sp') // same as secondaryPreferred
 *
 *     new Query().read('nearest')
 *     new Query().read('n')  // same as nearest
 *
 *     // you can also use mongodb.ReadPreference class to also specify tags
 *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))
 *
 *     new Query().setReadPreference('primary') // alias of .read()
 *
 * ####Preferences:
 *
 *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
 *     secondary            Read from secondary if available, otherwise error.
 *     primaryPreferred     Read from primary if available, otherwise a secondary.
 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
 *
 * Aliases
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
 * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
 *
 * @param {String|ReadPreference} pref one of the listed preference options or their aliases
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
 * @return {Query} this
 * @api public
 */ Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
        console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
        Query.prototype.read.deprecationWarningIssued = true;
    }
    this.options.readPreference = utils.readPref(pref);
    return this;
};
/**
 * Sets the readConcern option for the query.
 *
 * ####Example:
 *
 *     new Query().readConcern('local')
 *     new Query().readConcern('l')  // same as local
 *
 *     new Query().readConcern('available')
 *     new Query().readConcern('a')  // same as available
 *
 *     new Query().readConcern('majority')
 *     new Query().readConcern('m')  // same as majority
 *
 *     new Query().readConcern('linearizable')
 *     new Query().readConcern('lz') // same as linearizable
 *
 *     new Query().readConcern('snapshot')
 *     new Query().readConcern('s')  // same as snapshot
 *
 *     new Query().r('s') // r is alias of readConcern
 *
 *
 * ####Read Concern Level:
 *
 *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
 *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.
 *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.
 *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern "majority", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.


 *
 *
 * Aliases
 *
 *     l   local
 *     a   available
 *     m   majority
 *     lz  linearizable
 *     s   snapshot
 *
 * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).
 *
 * @param {String} level one of the listed read concern level or their aliases
 * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/
 * @return {Query} this
 * @api public
 */ Query.prototype.readConcern = Query.prototype.r = function(level) {
    this.options.readConcern = utils.readConcern(level);
    return this;
};
/**
 * Sets tailable option.
 *
 * ####Example
 *
 *     query.tailable() <== true
 *     query.tailable(true)
 *     query.tailable(false)
 *
 * ####Note
 *
 * Cannot be used with `distinct()`
 *
 * @param {Boolean} v defaults to true
 * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors
 * @api public
 */ Query.prototype.tailable = function() {
    this._validate("tailable");
    this.options.tailable = arguments.length ? !!arguments[0] : true;
    return this;
};
/**
 * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,
 * that must acknowledge this write before this write is considered successful.
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to the `w` value if it is specified in writeConcern options
 *
 * ####Example:
 *
 * mquery().writeConcern(0)
 * mquery().writeConcern(1)
 * mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })
 * mquery().writeConcern('majority')
 * mquery().writeConcern('m') // same as majority
 * mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead
 * mquery().w(1) // w is alias of writeConcern
 *
 * @method writeConcern
 * @memberOf Query
 * @instance
 * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option
 * @return {Query} this
 * @api public
 */ Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
    if ("object" === typeof concern) {
        if ("undefined" !== typeof concern.j) this.options.j = concern.j;
        if ("undefined" !== typeof concern.w) this.options.w = concern.w;
        if ("undefined" !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;
    } else {
        this.options.w = "m" === concern ? "majority" : concern;
    }
    return this;
};
/**
 * Specifies a time limit, in milliseconds, for the write concern.
 * If `ms > 1`, it is maximum amount of time to wait for this write
 * to propagate through the replica set before this operation fails.
 * The default is `0`, which means no timeout.
 *
 * This option is only valid for operations that write to the database:
 *
 * - `deleteOne()`
 * - `deleteMany()`
 * - `findOneAndDelete()`
 * - `findOneAndUpdate()`
 * - `remove()`
 * - `update()`
 * - `updateOne()`
 * - `updateMany()`
 *
 * Defaults to `wtimeout` value if it is specified in writeConcern
 *
 * ####Example:
 *
 *     mquery().w(2).j(true).wtimeout(2000)
 *
 * @method wtimeout
 * @memberOf Query
 * @instance
 * @param {number} ms number of milliseconds to wait
 * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout
 * @return {Query} this
 * @api public
 */ Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
    this.options.wtimeout = ms;
    return this;
};
/**
 * Merges another Query or conditions object into this one.
 *
 * When a Query is passed, conditions, field selection and options are merged.
 *
 * @param {Query|Object} source
 * @return {Query} this
 */ Query.prototype.merge = function(source) {
    if (!source) return this;
    if (!Query.canMerge(source)) throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
    if (source instanceof Query) {
        // if source has a feature, apply it to ourselves
        if (source._conditions) {
            utils.merge(this._conditions, source._conditions);
        }
        if (source._fields) {
            this._fields || (this._fields = {});
            utils.merge(this._fields, source._fields);
        }
        if (source.options) {
            this.options || (this.options = {});
            utils.merge(this.options, source.options);
        }
        if (source._update) {
            this._update || (this._update = {});
            utils.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
            this._distinct = source._distinct;
        }
        return this;
    }
    // plain object
    utils.merge(this._conditions, source);
    return this;
};
/**
 * Finds documents.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.find()
 *     query.find(callback)
 *     query.find({ name: 'Burning Lights' }, callback)
 *
 * @param {Object} [criteria] mongodb selector
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.find = function(criteria, callback) {
    this.op = "find";
    if ("function" === typeof criteria) {
        callback = criteria;
        criteria = undefined;
    } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
    }
    if (!callback) return this;
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
        options.projection = this._fieldsForExec();
    } else {
        options.fields = this._fieldsForExec();
    }
    debug("find", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("find", callback, {
        conditions: conds,
        options: options
    });
    this._collection.find(conds, options, utils.tick(callback));
    return this;
};
/**
 * Returns the query cursor
 *
 * ####Examples
 *
 *     query.find().cursor();
 *     query.cursor({ name: 'Burning Lights' });
 *
 * @param {Object} [criteria] mongodb selector
 * @return {Object} cursor
 * @api public
 */ Query.prototype.cursor = function cursor(criteria) {
    if (this.op) {
        if (this.op !== "find") {
            throw new TypeError(".cursor only support .find method");
        }
    } else {
        this.find(criteria);
    }
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
        options.projection = this._fieldsForExec();
    } else {
        options.fields = this._fieldsForExec();
    }
    debug("findCursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
};
/**
 * Executes the query as a findOne() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.findOne().where('name', /^Burning/);
 *
 *     query.findOne({ name: /^Burning/ })
 *
 *     query.findOne({ name: /^Burning/ }, callback); // executes
 *
 *     query.findOne(function (err, doc) {
 *       if (err) return handleError(err);
 *       if (doc) {
 *         // doc may be null if no document matched
 *
 *       }
 *     });
 *
 * @param {Object|Query} [criteria] mongodb selector
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.findOne = function(criteria, callback) {
    this.op = "findOne";
    if ("function" === typeof criteria) {
        callback = criteria;
        criteria = undefined;
    } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
    }
    if (!callback) return this;
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
        options.projection = this._fieldsForExec();
    } else {
        options.fields = this._fieldsForExec();
    }
    debug("findOne", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("findOne", callback, {
        conditions: conds,
        options: options
    });
    this._collection.findOne(conds, options, utils.tick(callback));
    return this;
};
/**
 * Exectues the query as a count() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     query.count().where('color', 'black').exec(callback);
 *
 *     query.count({ color: 'black' }).count(callback)
 *
 *     query.count({ color: 'black' }, callback)
 *
 *     query.where('color', 'black').count(function (err, count) {
 *       if (err) return handleError(err);
 *       console.log('there are %d kittens', count);
 *     })
 *
 * @param {Object} [criteria] mongodb selector
 * @param {Function} [callback]
 * @return {Query} this
 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count
 * @api public
 */ Query.prototype.count = function(criteria, callback) {
    this.op = "count";
    this._validate();
    if ("function" === typeof criteria) {
        callback = criteria;
        criteria = undefined;
    } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
    }
    if (!callback) return this;
    const conds = this._conditions, options = this._optionsForExec();
    debug("count", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("count", callback, {
        conditions: conds,
        options: options
    });
    this._collection.count(conds, options, utils.tick(callback));
    return this;
};
/**
 * Declares or executes a distinct() operation.
 *
 * Passing a `callback` executes the query.
 *
 * ####Example
 *
 *     distinct(criteria, field, fn)
 *     distinct(criteria, field)
 *     distinct(field, fn)
 *     distinct(field)
 *     distinct(fn)
 *     distinct()
 *
 * @param {Object|Query} [criteria]
 * @param {String} [field]
 * @param {Function} [callback]
 * @return {Query} this
 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct
 * @api public
 */ Query.prototype.distinct = function(criteria, field, callback) {
    this.op = "distinct";
    this._validate();
    if (!callback) {
        switch(typeof field){
            case "function":
                callback = field;
                if ("string" == typeof criteria) {
                    field = criteria;
                    criteria = undefined;
                }
                break;
            case "undefined":
            case "string":
                break;
            default:
                throw new TypeError("Invalid `field` argument. Must be string or function");
        }
        switch(typeof criteria){
            case "function":
                callback = criteria;
                criteria = field = undefined;
                break;
            case "string":
                field = criteria;
                criteria = undefined;
                break;
        }
    }
    if ("string" == typeof field) {
        this._distinct = field;
    }
    if (Query.canMerge(criteria)) {
        this.merge(criteria);
    }
    if (!callback) {
        return this;
    }
    if (!this._distinct) {
        throw new Error("No value for `distinct` has been declared");
    }
    const conds = this._conditions, options = this._optionsForExec();
    debug("distinct", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("distinct", callback, {
        conditions: conds,
        options: options
    });
    this._collection.distinct(this._distinct, conds, options, utils.tick(callback));
    return this;
};
/**
 * Declare and/or execute this query as an update() operation. By default,
 * `update()` only modifies the _first_ document that matches `criteria`.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     mquery({ _id: id }).update({ title: 'words' }, ...)
 *
 * becomes
 *
 *     collection.update({ _id: id }, { $set: { title: 'words' }}, ...)
 *
 * ####Note
 *
 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
 *
 *     var q = mquery(collection).where({ _id: id });
 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
 *
 *     var q = mquery(collection).where({ _id: id });
 *     q.update({ $set: { name: 'bob' }}).exec(); // executed as unsafe
 *
 *     // keys that are not $atomic ops become $set.
 *     // this executes the same command as the previous example.
 *     q.update({ name: 'bob' }).where({ _id: id }).exec();
 *
 *     var q = mquery(collection).update(); // not executed
 *
 *     // overwriting with empty docs
 *     var q.where({ _id: id }).setOptions({ overwrite: true })
 *     q.update({ }, callback); // executes
 *
 *     // multi update with overwrite to empty doc
 *     var q = mquery(collection).where({ _id: id });
 *     q.setOptions({ multi: true, overwrite: true })
 *     q.update({ });
 *     q.update(callback); // executed
 *
 *     // multi updates
 *     mquery()
 *       .collection(coll)
 *       .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
 *     // more multi updates
 *     mquery({ })
 *       .collection(coll)
 *       .setOptions({ multi: true })
 *       .update({ $set: { arr: [] }}, callback)
 *
 *     // single update by default
 *     mquery({ email: 'address@example.com' })
 *      .collection(coll)
 *      .update({ $inc: { counter: 1 }}, callback)
 *
 *     // summary
 *     update(criteria, doc, opts, cb) // executes
 *     update(criteria, doc, opts)
 *     update(criteria, doc, cb) // executes
 *     update(criteria, doc)
 *     update(doc, cb) // executes
 *     update(doc)
 *     update(cb) // executes
 *     update(true) // executes (unsafe write)
 *     update()
 *
 * @param {Object} [criteria]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.update = function update(criteria, doc, options, callback) {
    let force;
    switch(arguments.length){
        case 3:
            if ("function" == typeof options) {
                callback = options;
                options = undefined;
            }
            break;
        case 2:
            if ("function" == typeof doc) {
                callback = doc;
                doc = criteria;
                criteria = undefined;
            }
            break;
        case 1:
            switch(typeof criteria){
                case "function":
                    callback = criteria;
                    criteria = options = doc = undefined;
                    break;
                case "boolean":
                    // execution with no callback (unsafe write)
                    force = criteria;
                    criteria = undefined;
                    break;
                default:
                    doc = criteria;
                    criteria = options = undefined;
                    break;
            }
    }
    return _update(this, "update", criteria, doc, options, force, callback);
};
/**
 * Declare and/or execute this query as an `updateMany()` operation. Identical
 * to `update()` except `updateMany()` will update _all_ documents that match
 * `criteria`, rather than just the first one.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     // Update every document whose `title` contains 'test'
 *     mquery().updateMany({ title: /test/ }, { year: 2017 })
 *
 * @param {Object} [criteria]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.updateMany = function updateMany(criteria, doc, options, callback) {
    let force;
    switch(arguments.length){
        case 3:
            if ("function" == typeof options) {
                callback = options;
                options = undefined;
            }
            break;
        case 2:
            if ("function" == typeof doc) {
                callback = doc;
                doc = criteria;
                criteria = undefined;
            }
            break;
        case 1:
            switch(typeof criteria){
                case "function":
                    callback = criteria;
                    criteria = options = doc = undefined;
                    break;
                case "boolean":
                    // execution with no callback (unsafe write)
                    force = criteria;
                    criteria = undefined;
                    break;
                default:
                    doc = criteria;
                    criteria = options = undefined;
                    break;
            }
    }
    return _update(this, "updateMany", criteria, doc, options, force, callback);
};
/**
 * Declare and/or execute this query as an `updateOne()` operation. Identical
 * to `update()` except `updateOne()` will _always_ update just one document,
 * regardless of the `multi` option.
 *
 * _All paths passed that are not $atomic operations will become $set ops._
 *
 * ####Example
 *
 *     // Update the first document whose `title` contains 'test'
 *     mquery().updateMany({ title: /test/ }, { year: 2017 })
 *
 * @param {Object} [criteria]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.updateOne = function updateOne(criteria, doc, options, callback) {
    let force;
    switch(arguments.length){
        case 3:
            if ("function" == typeof options) {
                callback = options;
                options = undefined;
            }
            break;
        case 2:
            if ("function" == typeof doc) {
                callback = doc;
                doc = criteria;
                criteria = undefined;
            }
            break;
        case 1:
            switch(typeof criteria){
                case "function":
                    callback = criteria;
                    criteria = options = doc = undefined;
                    break;
                case "boolean":
                    // execution with no callback (unsafe write)
                    force = criteria;
                    criteria = undefined;
                    break;
                default:
                    doc = criteria;
                    criteria = options = undefined;
                    break;
            }
    }
    return _update(this, "updateOne", criteria, doc, options, force, callback);
};
/**
 * Declare and/or execute this query as an `replaceOne()` operation. Similar
 * to `updateOne()`, except `replaceOne()` is not allowed to use atomic
 * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always
 * replace the existing doc.
 *
 * ####Example
 *
 *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`
 *     mquery().replaceOne({ _id: 1 }, { year: 2017 })
 *
 * @param {Object} [criteria]
 * @param {Object} [doc] the update command
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.replaceOne = function replaceOne(criteria, doc, options, callback) {
    let force;
    switch(arguments.length){
        case 3:
            if ("function" == typeof options) {
                callback = options;
                options = undefined;
            }
            break;
        case 2:
            if ("function" == typeof doc) {
                callback = doc;
                doc = criteria;
                criteria = undefined;
            }
            break;
        case 1:
            switch(typeof criteria){
                case "function":
                    callback = criteria;
                    criteria = options = doc = undefined;
                    break;
                case "boolean":
                    // execution with no callback (unsafe write)
                    force = criteria;
                    criteria = undefined;
                    break;
                default:
                    doc = criteria;
                    criteria = options = undefined;
                    break;
            }
    }
    this.setOptions({
        overwrite: true
    });
    return _update(this, "replaceOne", criteria, doc, options, force, callback);
};
/*!
 * Internal helper for update, updateMany, updateOne
 */ function _update(query, op, criteria, doc, options, force, callback) {
    query.op = op;
    if (Query.canMerge(criteria)) {
        query.merge(criteria);
    }
    if (doc) {
        query._mergeUpdate(doc);
    }
    if (utils.isObject(options)) {
        // { overwrite: true }
        query.setOptions(options);
    }
    // we are done if we don't have callback and they are
    // not forcing an unsafe write.
    if (!(force || callback)) {
        return query;
    }
    if (!query._update || !query.options.overwrite && 0 === utils.keys(query._update).length) {
        callback && utils.soon(callback.bind(null, null, 0));
        return query;
    }
    options = query._optionsForExec();
    if (!callback) options.safe = false;
    criteria = query._conditions;
    doc = query._updateForExec();
    debug("update", query._collection.collectionName, criteria, doc, options);
    callback = query._wrapCallback(op, callback, {
        conditions: criteria,
        doc: doc,
        options: options
    });
    query._collection[op](criteria, doc, options, utils.tick(callback));
    return query;
}
/**
 * Declare and/or execute this query as a remove() operation.
 *
 * ####Example
 *
 *     mquery(collection).remove({ artist: 'Anne Murray' }, callback)
 *
 * ####Note
 *
 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
 *
 *     // not executed
 *     var query = mquery(collection).remove({ name: 'Anne Murray' })
 *
 *     // executed
 *     mquery(collection).remove({ name: 'Anne Murray' }, callback)
 *     mquery(collection).remove({ name: 'Anne Murray' }).remove(callback)
 *
 *     // executed without a callback (unsafe write)
 *     query.exec()
 *
 *     // summary
 *     query.remove(conds, fn); // executes
 *     query.remove(conds)
 *     query.remove(fn) // executes
 *     query.remove()
 *
 * @param {Object|Query} [criteria] mongodb selector
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.remove = function(criteria, callback) {
    this.op = "remove";
    let force;
    if ("function" === typeof criteria) {
        callback = criteria;
        criteria = undefined;
    } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
    } else if (true === criteria) {
        force = criteria;
        criteria = undefined;
    }
    if (!(force || callback)) return this;
    const options = this._optionsForExec();
    if (!callback) options.safe = false;
    const conds = this._conditions;
    debug("remove", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("remove", callback, {
        conditions: conds,
        options: options
    });
    this._collection.remove(conds, options, utils.tick(callback));
    return this;
};
/**
 * Declare and/or execute this query as a `deleteOne()` operation. Behaves like
 * `remove()`, except for ignores the `justOne` option and always deletes at
 * most one document.
 *
 * ####Example
 *
 *     mquery(collection).deleteOne({ artist: 'Anne Murray' }, callback)
 *
 * @param {Object|Query} [criteria] mongodb selector
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.deleteOne = function(criteria, callback) {
    this.op = "deleteOne";
    let force;
    if ("function" === typeof criteria) {
        callback = criteria;
        criteria = undefined;
    } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
    } else if (true === criteria) {
        force = criteria;
        criteria = undefined;
    }
    if (!(force || callback)) return this;
    const options = this._optionsForExec();
    if (!callback) options.safe = false;
    delete options.justOne;
    const conds = this._conditions;
    debug("deleteOne", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options: options
    });
    this._collection.deleteOne(conds, options, utils.tick(callback));
    return this;
};
/**
 * Declare and/or execute this query as a `deleteMany()` operation. Behaves like
 * `remove()`, except for ignores the `justOne` option and always deletes
 * _every_ document that matches `criteria`.
 *
 * ####Example
 *
 *     mquery(collection).deleteMany({ artist: 'Anne Murray' }, callback)
 *
 * @param {Object|Query} [criteria] mongodb selector
 * @param {Function} [callback]
 * @return {Query} this
 * @api public
 */ Query.prototype.deleteMany = function(criteria, callback) {
    this.op = "deleteMany";
    let force;
    if ("function" === typeof criteria) {
        callback = criteria;
        criteria = undefined;
    } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
    } else if (true === criteria) {
        force = criteria;
        criteria = undefined;
    }
    if (!(force || callback)) return this;
    const options = this._optionsForExec();
    if (!callback) options.safe = false;
    delete options.justOne;
    const conds = this._conditions;
    debug("deleteOne", this._collection.collectionName, conds, options);
    callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options: options
    });
    this._collection.deleteMany(conds, options, utils.tick(callback));
    return this;
};
/**
 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
 *
 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
 *
 * ####Available options
 *
 * - `new`: bool - true to return the modified document rather than the original. defaults to true
 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 *
 * ####Examples
 *
 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
 *     query.findOneAndUpdate(conditions, update, callback) // executes
 *     query.findOneAndUpdate(conditions, update)           // returns Query
 *     query.findOneAndUpdate(update, callback)             // returns Query
 *     query.findOneAndUpdate(update)                       // returns Query
 *     query.findOneAndUpdate(callback)                     // executes
 *     query.findOneAndUpdate()                             // returns Query
 *
 * @param {Object|Query} [query]
 * @param {Object} [doc]
 * @param {Object} [options]
 * @param {Function} [callback]
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @return {Query} this
 * @api public
 */ Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
    this.op = "findOneAndUpdate";
    this._validate();
    switch(arguments.length){
        case 3:
            if ("function" == typeof options) {
                callback = options;
                options = {};
            }
            break;
        case 2:
            if ("function" == typeof doc) {
                callback = doc;
                doc = criteria;
                criteria = undefined;
            }
            options = undefined;
            break;
        case 1:
            if ("function" == typeof criteria) {
                callback = criteria;
                criteria = options = doc = undefined;
            } else {
                doc = criteria;
                criteria = options = undefined;
            }
    }
    if (Query.canMerge(criteria)) {
        this.merge(criteria);
    }
    // apply doc
    if (doc) {
        this._mergeUpdate(doc);
    }
    options && this.setOptions(options);
    if (!callback) return this;
    const conds = this._conditions;
    const update = this._updateForExec();
    options = this._optionsForExec();
    return this._collection.findOneAndUpdate(conds, update, options, utils.tick(callback));
};
/**
 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
 *
 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
 *
 * ####Available options
 *
 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
 *
 * ####Examples
 *
 *     A.where().findOneAndRemove(conditions, options, callback) // executes
 *     A.where().findOneAndRemove(conditions, options)  // return Query
 *     A.where().findOneAndRemove(conditions, callback) // executes
 *     A.where().findOneAndRemove(conditions) // returns Query
 *     A.where().findOneAndRemove(callback)   // executes
 *     A.where().findOneAndRemove()           // returns Query
 *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()
 *
 * @param {Object} [conditions]
 * @param {Object} [options]
 * @param {Function} [callback]
 * @return {Query} this
 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
 * @api public
 */ Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options, callback) {
    this.op = "findOneAndRemove";
    this._validate();
    if ("function" == typeof options) {
        callback = options;
        options = undefined;
    } else if ("function" == typeof conditions) {
        callback = conditions;
        conditions = undefined;
    }
    // apply conditions
    if (Query.canMerge(conditions)) {
        this.merge(conditions);
    }
    // apply options
    options && this.setOptions(options);
    if (!callback) return this;
    options = this._optionsForExec();
    const conds = this._conditions;
    return this._collection.findOneAndDelete(conds, options, utils.tick(callback));
};
/**
 * Wrap callback to add tracing
 *
 * @param {Function} callback
 * @param {Object} [queryInfo]
 * @api private
 */ Query.prototype._wrapCallback = function(method, callback, queryInfo) {
    const traceFunction = this._traceFunction || Query.traceFunction;
    if (traceFunction) {
        queryInfo.collectionName = this._collection.collectionName;
        const traceCallback = traceFunction && traceFunction.call(null, method, queryInfo, this);
        const startTime = new Date().getTime();
        return function wrapperCallback(err, result) {
            if (traceCallback) {
                const millis = new Date().getTime() - startTime;
                traceCallback.call(null, err, result, millis);
            }
            if (callback) {
                callback.apply(null, arguments);
            }
        };
    }
    return callback;
};
/**
 * Add trace function that gets called when the query is executed.
 * The function will be called with (method, queryInfo, query) and
 * should return a callback function which will be called
 * with (err, result, millis) when the query is complete.
 *
 * queryInfo is an object containing: {
 *   collectionName: <name of the collection>,
 *   conditions: <query criteria>,
 *   options: <comment, fields, readPreference, etc>,
 *   doc: [document to update, if applicable]
 * }
 *
 * NOTE: Does not trace stream queries.
 *
 * @param {Function} traceFunction
 * @return {Query} this
 * @api public
 */ Query.prototype.setTraceFunction = function(traceFunction) {
    this._traceFunction = traceFunction;
    return this;
};
/**
 * Executes the query
 *
 * ####Examples
 *
 *     query.exec();
 *     query.exec(callback);
 *     query.exec('update');
 *     query.exec('find', callback);
 *
 * @param {String|Function} [operation]
 * @param {Function} [callback]
 * @api public
 */ Query.prototype.exec = function exec(op, callback) {
    switch(typeof op){
        case "function":
            callback = op;
            op = null;
            break;
        case "string":
            this.op = op;
            break;
    }
    assert.ok(this.op, "Missing query type: (find, update, etc)");
    if ("update" == this.op || "remove" == this.op) {
        callback || (callback = true);
    }
    const _this = this;
    if ("function" == typeof callback) {
        this[this.op](callback);
    } else {
        return new Query.Promise(function(success, error) {
            _this[_this.op](function(err, val) {
                if (err) error(err);
                else success(val);
                success = error = null;
            });
        });
    }
};
/**
 * Returns a thunk which when called runs this.exec()
 *
 * The thunk receives a callback function which will be
 * passed to `this.exec()`
 *
 * @return {Function}
 * @api public
 */ Query.prototype.thunk = function() {
    const _this = this;
    return function(cb) {
        _this.exec(cb);
    };
};
/**
 * Executes the query returning a `Promise` which will be
 * resolved with either the doc(s) or rejected with the error.
 *
 * @param {Function} [resolve]
 * @param {Function} [reject]
 * @return {Promise}
 * @api public
 */ Query.prototype.then = function(resolve, reject) {
    const _this = this;
    const promise = new Query.Promise(function(success, error) {
        _this.exec(function(err, val) {
            if (err) error(err);
            else success(val);
            success = error = null;
        });
    });
    return promise.then(resolve, reject);
};
/**
 * Returns a cursor for the given `find` query.
 *
 * @throws Error if operation is not a find
 * @returns {Cursor} MongoDB driver cursor
 */ Query.prototype.cursor = function() {
    if ("find" != this.op) throw new Error("cursor() is only available for find");
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
        options.projection = this._fieldsForExec();
    } else {
        options.fields = this._fieldsForExec();
    }
    debug("cursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
};
/**
 * Determines if field selection has been made.
 *
 * @return {Boolean}
 * @api public
 */ Query.prototype.selected = function selected() {
    return !!(this._fields && Object.keys(this._fields).length > 0);
};
/**
 * Determines if inclusive field selection has been made.
 *
 *     query.selectedInclusively() // false
 *     query.select('name')
 *     query.selectedInclusively() // true
 *     query.selectedExlusively() // false
 *
 * @returns {Boolean}
 */ Query.prototype.selectedInclusively = function selectedInclusively() {
    if (!this._fields) return false;
    const keys = Object.keys(this._fields);
    if (0 === keys.length) return false;
    for(let i = 0; i < keys.length; ++i){
        const key = keys[i];
        if (0 === this._fields[key]) return false;
        if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
            return false;
        }
    }
    return true;
};
/**
 * Determines if exclusive field selection has been made.
 *
 *     query.selectedExlusively() // false
 *     query.select('-name')
 *     query.selectedExlusively() // true
 *     query.selectedInclusively() // false
 *
 * @returns {Boolean}
 */ Query.prototype.selectedExclusively = function selectedExclusively() {
    if (!this._fields) return false;
    const keys = Object.keys(this._fields);
    if (0 === keys.length) return false;
    for(let i = 0; i < keys.length; ++i){
        const key = keys[i];
        if (0 === this._fields[key]) return true;
    }
    return false;
};
/**
 * Merges `doc` with the current update object.
 *
 * @param {Object} doc
 */ Query.prototype._mergeUpdate = function(doc) {
    if (!this._update) this._update = {};
    if (doc instanceof Query) {
        if (doc._update) {
            utils.mergeClone(this._update, doc._update);
        }
    } else {
        utils.mergeClone(this._update, doc);
    }
};
/**
 * Returns default options.
 *
 * @return {Object}
 * @api private
 */ Query.prototype._optionsForExec = function() {
    const options = utils.clone(this.options);
    return options;
};
/**
 * Returns fields selection for this query.
 *
 * @return {Object}
 * @api private
 */ Query.prototype._fieldsForExec = function() {
    return utils.clone(this._fields);
};
/**
 * Return an update document with corrected $set operations.
 *
 * @api private
 */ Query.prototype._updateForExec = function() {
    const update = utils.clone(this._update);
    const ops = utils.keys(update);
    const ret = {};
    for (const op of ops){
        if (this.options.overwrite) {
            ret[op] = update[op];
            continue;
        }
        if ("$" !== op[0]) {
            // fix up $set sugar
            if (!ret.$set) {
                if (update.$set) {
                    ret.$set = update.$set;
                } else {
                    ret.$set = {};
                }
            }
            ret.$set[op] = update[op];
            if (!~ops.indexOf("$set")) ops.push("$set");
        } else if ("$set" === op) {
            if (!ret.$set) {
                ret[op] = update[op];
            }
        } else {
            ret[op] = update[op];
        }
    }
    this._compiledUpdate = ret;
    return ret;
};
/**
 * Make sure _path is set.
 *
 * @parmam {String} method
 */ Query.prototype._ensurePath = function(method) {
    if (!this._path) {
        const msg = method + "() must be used after where() " + "when called with these arguments";
        throw new Error(msg);
    }
};
/*!
 * Permissions
 */ Query.permissions = __webpack_require__(16032);
Query._isPermitted = function(a, b) {
    const denied = Query.permissions[b];
    if (!denied) return true;
    return true !== denied[a];
};
Query.prototype._validate = function(action) {
    let fail;
    let validator;
    if (undefined === action) {
        validator = Query.permissions[this.op];
        if ("function" != typeof validator) return true;
        fail = validator(this);
    } else if (!Query._isPermitted(action, this.op)) {
        fail = action;
    }
    if (fail) {
        throw new Error(fail + " cannot be used with " + this.op);
    }
};
/**
 * Determines if `conds` can be merged using `mquery().merge()`
 *
 * @param {Object} conds
 * @return {Boolean}
 */ Query.canMerge = function(conds) {
    return conds instanceof Query || utils.isObject(conds);
};
/**
 * Set a trace function that will get called whenever a
 * query is executed.
 *
 * See `setTraceFunction()` for details.
 *
 * @param {Object} conds
 * @return {Boolean}
 */ Query.setGlobalTraceFunction = function(traceFunction) {
    Query.traceFunction = traceFunction;
};
/*!
 * Exports.
 */ Query.utils = utils;
Query.env = __webpack_require__(91652);
Query.Collection = __webpack_require__(33716);
Query.BaseCollection = __webpack_require__(51037);
Query.Promise = Promise;
module.exports = exports = Query; // TODO
 // test utils


/***/ }),

/***/ 16032:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const denied = exports;
denied.distinct = function(self) {
    if (self._fields && Object.keys(self._fields).length > 0) {
        return "field selection and slice";
    }
    const keys = Object.keys(denied.distinct);
    let err;
    keys.every(function(option) {
        if (self.options[option]) {
            err = option;
            return false;
        }
        return true;
    });
    return err;
};
denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.maxScan = denied.distinct.snapshot = denied.distinct.hint = denied.distinct.tailable = true;
// aggregation integration
denied.findOneAndUpdate = denied.findOneAndRemove = function(self) {
    const keys = Object.keys(denied.findOneAndUpdate);
    let err;
    keys.every(function(option) {
        if (self.options[option]) {
            err = option;
            return false;
        }
        return true;
    });
    return err;
};
denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.maxScan = denied.findOneAndUpdate.snapshot = denied.findOneAndUpdate.tailable = true;
denied.count = function(self) {
    if (self._fields && Object.keys(self._fields).length > 0) {
        return "field selection and slice";
    }
    const keys = Object.keys(denied.count);
    let err;
    keys.every(function(option) {
        if (self.options[option]) {
            err = option;
            return false;
        }
        return true;
    });
    return err;
};
denied.count.slice = denied.count.batchSize = denied.count.maxScan = denied.count.snapshot = denied.count.tailable = true;


/***/ }),

/***/ 80154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*!
 * Module dependencies.
 */ const specialProperties = [
    "__proto__",
    "constructor",
    "prototype"
];
/**
 * Clones objects
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @return {Object} the cloned object
 * @api private
 */ const clone = exports.clone = function clone(obj, options) {
    if (obj === undefined || obj === null) return obj;
    if (Array.isArray(obj)) return exports.cloneArray(obj, options);
    if (obj.constructor) {
        if (/ObjectI[dD]$/.test(obj.constructor.name)) {
            return "function" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.id);
        }
        if (obj.constructor.name === "ReadPreference") {
            return new obj.constructor(obj.mode, clone(obj.tags, options));
        }
        if ("Binary" == obj._bsontype && obj.buffer && obj.value) {
            return "function" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
        }
        if ("Date" === obj.constructor.name || "Function" === obj.constructor.name) return new obj.constructor(+obj);
        if ("RegExp" === obj.constructor.name) return new RegExp(obj);
        if ("Buffer" === obj.constructor.name) return Buffer.from(obj);
    }
    if (isObject(obj)) return exports.cloneObject(obj, options);
    if (obj.valueOf) return obj.valueOf();
};
/*!
 * ignore
 */ exports.cloneObject = function cloneObject(obj, options) {
    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;
    let hasKeys = false, val, k = "", i = 0;
    for(i = 0; i < len; ++i){
        k = keys[i];
        // Not technically prototype pollution because this wouldn't merge properties
        // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.
        if (specialProperties.indexOf(k) !== -1) {
            continue;
        }
        val = clone(obj[k], options);
        if (!minimize || "undefined" !== typeof val) {
            hasKeys || (hasKeys = true);
            ret[k] = val;
        }
    }
    return minimize ? hasKeys && ret : ret;
};
exports.cloneArray = function cloneArray(arr, options) {
    const ret = [], l = arr.length;
    let i = 0;
    for(; i < l; i++)ret.push(clone(arr[i], options));
    return ret;
};
/**
 * process.nextTick helper.
 *
 * Wraps the given `callback` in a try/catch. If an error is
 * caught it will be thrown on nextTick.
 *
 * node-mongodb-native had a habit of state corruption when
 * an error was immediately thrown from within a collection
 * method (find, update, etc) callback.
 *
 * @param {Function} [callback]
 * @api private
 */ exports.tick = function tick(callback) {
    if ("function" !== typeof callback) return;
    return function() {
        // callbacks should always be fired on the next
        // turn of the event loop. A side benefit is
        // errors thrown from executing the callback
        // will not cause drivers state to be corrupted
        // which has historically been a problem.
        const args = arguments;
        soon(function() {
            callback.apply(this, args);
        });
    };
};
/**
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */ exports.merge = function merge(to, from) {
    const keys = Object.keys(from);
    for (const key of keys){
        if (specialProperties.indexOf(key) !== -1) {
            continue;
        }
        if ("undefined" === typeof to[key]) {
            to[key] = from[key];
        } else {
            if (exports.isObject(from[key])) {
                merge(to[key], from[key]);
            } else {
                to[key] = from[key];
            }
        }
    }
};
/**
 * Same as merge but clones the assigned values.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */ exports.mergeClone = function mergeClone(to, from) {
    const keys = Object.keys(from);
    for (const key of keys){
        if (specialProperties.indexOf(key) !== -1) {
            continue;
        }
        if ("undefined" === typeof to[key]) {
            to[key] = clone(from[key]);
        } else {
            if (exports.isObject(from[key])) {
                mergeClone(to[key], from[key]);
            } else {
                to[key] = clone(from[key]);
            }
        }
    }
};
/**
 * Read pref helper (mongo 2.2 drivers support this)
 *
 * Allows using aliases instead of full preference names:
 *
 *     p   primary
 *     pp  primaryPreferred
 *     s   secondary
 *     sp  secondaryPreferred
 *     n   nearest
 *
 * @param {String} pref
 */ exports.readPref = function readPref(pref) {
    switch(pref){
        case "p":
            pref = "primary";
            break;
        case "pp":
            pref = "primaryPreferred";
            break;
        case "s":
            pref = "secondary";
            break;
        case "sp":
            pref = "secondaryPreferred";
            break;
        case "n":
            pref = "nearest";
            break;
    }
    return pref;
};
/**
 * Read Concern helper (mongo 3.2 drivers support this)
 *
 * Allows using string to specify read concern level:
 *
 *     local          3.2+
 *     available      3.6+
 *     majority       3.2+
 *     linearizable   3.4+
 *     snapshot       4.0+
 *
 * @param {String|Object} concern
 */ exports.readConcern = function readConcern(concern) {
    if ("string" === typeof concern) {
        switch(concern){
            case "l":
                concern = "local";
                break;
            case "a":
                concern = "available";
                break;
            case "m":
                concern = "majority";
                break;
            case "lz":
                concern = "linearizable";
                break;
            case "s":
                concern = "snapshot";
                break;
        }
        concern = {
            level: concern
        };
    }
    return concern;
};
/**
 * Object.prototype.toString.call helper
 */ const _toString = Object.prototype.toString;
exports.toString = function(arg) {
    return _toString.call(arg);
};
/**
 * Determines if `arg` is an object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @return {Boolean}
 */ const isObject = exports.isObject = function(arg) {
    return "[object Object]" == exports.toString(arg);
};
/**
 * Object.keys helper
 */ exports.keys = Object.keys;
/**
 * Basic Object.create polyfill.
 * Only one argument is supported.
 *
 * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
 */ exports.create = "function" == typeof Object.create ? Object.create : create;
function create(proto) {
    if (arguments.length > 1) {
        throw new Error("Adding properties is not supported");
    }
    function F() {}
    F.prototype = proto;
    return new F;
}
/**
 * inheritance
 */ exports.inherits = function(ctor, superCtor) {
    ctor.prototype = exports.create(superCtor.prototype);
    ctor.prototype.constructor = ctor;
};
/**
 * nextTick helper
 * compat with node 0.10 which behaves differently than previous versions
 */ const soon = exports.soon = "function" == typeof setImmediate ? setImmediate : process.nextTick;
/**
 * Check if this object is an arguments object
 *
 * @param {Any} v
 * @return {Boolean}
 */ exports.isArgumentsObject = function(v) {
    return Object.prototype.toString.call(v) === "[object Arguments]";
};


/***/ }),

/***/ 57518:
/***/ ((module) => {

"use strict";
/**
 * Helpers.
 */ 
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
        return parse(val);
    } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch(type){
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
            return n * y;
        case "weeks":
        case "week":
        case "w":
            return n * w;
        case "days":
        case "day":
        case "d":
            return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
            return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
            return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
            return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + "s";
    }
    return ms + "ms";
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}


/***/ }),

/***/ 415:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.bailoutToClientRendering = bailoutToClientRendering;
var _dynamicNoSsr = __webpack_require__(97311);
var _staticGenerationAsyncStorage = __webpack_require__(90683);
function bailoutToClientRendering() {
    const staticGenerationStore = _staticGenerationAsyncStorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        (0, _dynamicNoSsr).suspense();
    }
    return false;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bailout-to-client-rendering.js.map


/***/ }),

/***/ 80383:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.clientHookInServerComponentError = clientHookInServerComponentError;
var _interop_require_default = (__webpack_require__(98144)/* ["default"] */ .Z);
var _react = _interop_require_default(__webpack_require__(85468));
function clientHookInServerComponentError(hookName) {
    if (false) {}
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-hook-in-server-component-error.js.map


/***/ }),

/***/ 79509:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useSearchParams = useSearchParams;
exports.usePathname = usePathname;
Object.defineProperty(exports, "ServerInsertedHTMLContext", ({
    enumerable: true,
    get: function() {
        return _serverInsertedHtml.ServerInsertedHTMLContext;
    }
}));
Object.defineProperty(exports, "useServerInsertedHTML", ({
    enumerable: true,
    get: function() {
        return _serverInsertedHtml.useServerInsertedHTML;
    }
}));
exports.useRouter = useRouter;
exports.useSelectedLayoutSegments = useSelectedLayoutSegments;
exports.useSelectedLayoutSegment = useSelectedLayoutSegment;
Object.defineProperty(exports, "redirect", ({
    enumerable: true,
    get: function() {
        return _redirect.redirect;
    }
}));
Object.defineProperty(exports, "notFound", ({
    enumerable: true,
    get: function() {
        return _notFound.notFound;
    }
}));
var _react = __webpack_require__(85468);
var _appRouterContext = __webpack_require__(24056);
var _hooksClientContext = __webpack_require__(698);
var _bailoutToClientRendering = __webpack_require__(415);
var _clientHookInServerComponentError = __webpack_require__(80383);
var _serverInsertedHtml = __webpack_require__(35350);
var _redirect = __webpack_require__(74615);
var _notFound = __webpack_require__(43164);
const INTERNAL_URLSEARCHPARAMS_INSTANCE = Symbol("internal for urlsearchparams readonly");
function readonlyURLSearchParamsError() {
    return new Error("ReadonlyURLSearchParams cannot be modified");
}
class ReadonlyURLSearchParams {
    [Symbol.iterator]() {
        return this[INTERNAL_URLSEARCHPARAMS_INSTANCE][Symbol.iterator]();
    }
    append() {
        throw readonlyURLSearchParamsError();
    }
    delete() {
        throw readonlyURLSearchParamsError();
    }
    set() {
        throw readonlyURLSearchParamsError();
    }
    sort() {
        throw readonlyURLSearchParamsError();
    }
    constructor(urlSearchParams){
        // Since `new Headers` uses `this.append()` to fill the headers object ReadonlyHeaders can't extend from Headers directly as it would throw.
        this[INTERNAL_URLSEARCHPARAMS_INSTANCE] = urlSearchParams;
        this.entries = urlSearchParams.entries.bind(urlSearchParams);
        this.forEach = urlSearchParams.forEach.bind(urlSearchParams);
        this.get = urlSearchParams.get.bind(urlSearchParams);
        this.getAll = urlSearchParams.getAll.bind(urlSearchParams);
        this.has = urlSearchParams.has.bind(urlSearchParams);
        this.keys = urlSearchParams.keys.bind(urlSearchParams);
        this.values = urlSearchParams.values.bind(urlSearchParams);
        this.toString = urlSearchParams.toString.bind(urlSearchParams);
    }
}
function useSearchParams() {
    (0, _clientHookInServerComponentError).clientHookInServerComponentError("useSearchParams");
    const searchParams = (0, _react).useContext(_hooksClientContext.SearchParamsContext);
    const readonlySearchParams = (0, _react).useMemo(()=>{
        return new ReadonlyURLSearchParams(searchParams || new URLSearchParams());
    }, [
        searchParams
    ]);
    if ((0, _bailoutToClientRendering).bailoutToClientRendering()) {
        // TODO-APP: handle dynamic = 'force-static' here and on the client
        return readonlySearchParams;
    }
    if (!searchParams) {
        throw new Error("invariant expected search params to be mounted");
    }
    return readonlySearchParams;
}
function usePathname() {
    (0, _clientHookInServerComponentError).clientHookInServerComponentError("usePathname");
    return (0, _react).useContext(_hooksClientContext.PathnameContext);
}
function useRouter() {
    (0, _clientHookInServerComponentError).clientHookInServerComponentError("useRouter");
    const router = (0, _react).useContext(_appRouterContext.AppRouterContext);
    if (router === null) {
        throw new Error("invariant expected app router to be mounted");
    }
    return router;
}
// TODO-APP: handle parallel routes
function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first = true, segmentPath = []) {
    let node;
    if (first) {
        // Use the provided parallel route key on the first parallel route
        node = tree[1][parallelRouteKey];
    } else {
        // After first parallel route prefer children, if there's no children pick the first parallel route.
        const parallelRoutes = tree[1];
        var _children;
        node = (_children = parallelRoutes.children) != null ? _children : Object.values(parallelRoutes)[0];
    }
    if (!node) return segmentPath;
    const segment = node[0];
    const segmentValue = Array.isArray(segment) ? segment[1] : segment;
    if (!segmentValue) return segmentPath;
    segmentPath.push(segmentValue);
    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
}
function useSelectedLayoutSegments(parallelRouteKey = "children") {
    (0, _clientHookInServerComponentError).clientHookInServerComponentError("useSelectedLayoutSegments");
    const { tree  } = (0, _react).useContext(_appRouterContext.LayoutRouterContext);
    return getSelectedLayoutSegmentPath(tree, parallelRouteKey);
}
function useSelectedLayoutSegment(parallelRouteKey = "children") {
    (0, _clientHookInServerComponentError).clientHookInServerComponentError("useSelectedLayoutSegment");
    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);
    if (selectedLayoutSegments.length === 0) {
        return null;
    }
    return selectedLayoutSegments[0];
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=navigation.js.map


/***/ }),

/***/ 43164:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.notFound = notFound;
exports.NOT_FOUND_ERROR_CODE = void 0;
const NOT_FOUND_ERROR_CODE = "NEXT_NOT_FOUND";
exports.NOT_FOUND_ERROR_CODE = NOT_FOUND_ERROR_CODE;
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = new Error(NOT_FOUND_ERROR_CODE);
    error.digest = NOT_FOUND_ERROR_CODE;
    throw error;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map


/***/ }),

/***/ 74615:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.redirect = redirect;
exports.REDIRECT_ERROR_CODE = void 0;
const REDIRECT_ERROR_CODE = "NEXT_REDIRECT";
exports.REDIRECT_ERROR_CODE = REDIRECT_ERROR_CODE;
function redirect(url) {
    // eslint-disable-next-line no-throw-literal
    const error = new Error(REDIRECT_ERROR_CODE);
    error.digest = REDIRECT_ERROR_CODE + ";" + url;
    throw error;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map


/***/ }),

/***/ 24056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__ */ 
const { createProxy  } = __webpack_require__(14353);
module.exports = createProxy("/Users/nikalachashvili/Desktop/WebProjects/buycom/node_modules/next/dist/shared/lib/app-router-context.js");
 //# sourceMappingURL=app-router-context.js.map


/***/ }),

/***/ 97311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__ */ 
const { createProxy  } = __webpack_require__(14353);
module.exports = createProxy("/Users/nikalachashvili/Desktop/WebProjects/buycom/node_modules/next/dist/shared/lib/dynamic-no-ssr.js");
 //# sourceMappingURL=dynamic-no-ssr.js.map


/***/ }),

/***/ 698:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__ */ 
const { createProxy  } = __webpack_require__(14353);
module.exports = createProxy("/Users/nikalachashvili/Desktop/WebProjects/buycom/node_modules/next/dist/shared/lib/hooks-client-context.js");
 //# sourceMappingURL=hooks-client-context.js.map


/***/ }),

/***/ 35350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* __next_internal_client_entry_do_not_use__ */ 
const { createProxy  } = __webpack_require__(14353);
module.exports = createProxy("/Users/nikalachashvili/Desktop/WebProjects/buycom/node_modules/next/dist/shared/lib/server-inserted-html.js");
 //# sourceMappingURL=server-inserted-html.js.map


/***/ }),

/***/ 5560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(79509);


/***/ }),

/***/ 53115:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const lib = __webpack_require__(51672);
module.exports = lib.default;
Object.assign(module.exports, lib);


/***/ }),

/***/ 51672:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

(function(global, factory) {
     true ? factory(exports) : 0;
})(void 0, function(exports1) {
    "use strict";
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var typeChecker = function(type) {
        var typeString = "[object " + type + "]";
        return function(value) {
            return getClassName(value) === typeString;
        };
    };
    var getClassName = function(value) {
        return Object.prototype.toString.call(value);
    };
    var comparable = function(value) {
        if (value instanceof Date) {
            return value.getTime();
        } else if (isArray(value)) {
            return value.map(comparable);
        } else if (value && typeof value.toJSON === "function") {
            return value.toJSON();
        }
        return value;
    };
    var isArray = typeChecker("Array");
    var isObject = typeChecker("Object");
    var isFunction = typeChecker("Function");
    var isVanillaObject = function(value) {
        return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
    };
    var equals = function(a, b) {
        if (a == null && a == b) {
            return true;
        }
        if (a === b) {
            return true;
        }
        if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
            return false;
        }
        if (isArray(a)) {
            if (a.length !== b.length) {
                return false;
            }
            for(var i = 0, length_1 = a.length; i < length_1; i++){
                if (!equals(a[i], b[i])) return false;
            }
            return true;
        } else if (isObject(a)) {
            if (Object.keys(a).length !== Object.keys(b).length) {
                return false;
            }
            for(var key in a){
                if (!equals(a[key], b[key])) return false;
            }
            return true;
        }
        return false;
    };
    /**
     * Walks through each value given the context - used for nested operations. E.g:
     * { "person.address": { $eq: "blarg" }}
     */ var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
        var currentKey = keyPath[depth];
        // if array, then try matching. Might fall through for cases like:
        // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].
        if (isArray(item) && isNaN(Number(currentKey))) {
            for(var i = 0, length_1 = item.length; i < length_1; i++){
                // if FALSE is returned, then terminate walker. For operations, this simply
                // means that the search critera was met.
                if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
                    return false;
                }
            }
        }
        if (depth === keyPath.length || item == null) {
            return next(item, key, owner, depth === 0);
        }
        return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
    };
    var BaseOperation = /** @class */ function() {
        function BaseOperation(params, owneryQuery, options, name) {
            this.params = params;
            this.owneryQuery = owneryQuery;
            this.options = options;
            this.name = name;
            this.init();
        }
        BaseOperation.prototype.init = function() {};
        BaseOperation.prototype.reset = function() {
            this.done = false;
            this.keep = false;
        };
        return BaseOperation;
    }();
    var GroupOperation = /** @class */ function(_super) {
        __extends(GroupOperation, _super);
        function GroupOperation(params, owneryQuery, options, children) {
            var _this = _super.call(this, params, owneryQuery, options) || this;
            _this.children = children;
            return _this;
        }
        /**
         */ GroupOperation.prototype.reset = function() {
            this.keep = false;
            this.done = false;
            for(var i = 0, length_2 = this.children.length; i < length_2; i++){
                this.children[i].reset();
            }
        };
        /**
         */ GroupOperation.prototype.childrenNext = function(item, key, owner, root) {
            var done = true;
            var keep = true;
            for(var i = 0, length_3 = this.children.length; i < length_3; i++){
                var childOperation = this.children[i];
                if (!childOperation.done) {
                    childOperation.next(item, key, owner, root);
                }
                if (!childOperation.keep) {
                    keep = false;
                }
                if (childOperation.done) {
                    if (!childOperation.keep) {
                        break;
                    }
                } else {
                    done = false;
                }
            }
            this.done = done;
            this.keep = keep;
        };
        return GroupOperation;
    }(BaseOperation);
    var NamedGroupOperation = /** @class */ function(_super) {
        __extends(NamedGroupOperation, _super);
        function NamedGroupOperation(params, owneryQuery, options, children, name) {
            var _this = _super.call(this, params, owneryQuery, options, children) || this;
            _this.name = name;
            return _this;
        }
        return NamedGroupOperation;
    }(GroupOperation);
    var QueryOperation = /** @class */ function(_super) {
        __extends(QueryOperation, _super);
        function QueryOperation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        /**
         */ QueryOperation.prototype.next = function(item, key, parent, root) {
            this.childrenNext(item, key, parent, root);
        };
        return QueryOperation;
    }(GroupOperation);
    var NestedOperation = /** @class */ function(_super) {
        __extends(NestedOperation, _super);
        function NestedOperation(keyPath, params, owneryQuery, options, children) {
            var _this = _super.call(this, params, owneryQuery, options, children) || this;
            _this.keyPath = keyPath;
            _this.propop = true;
            /**
             */ _this._nextNestedValue = function(value, key, owner, root) {
                _this.childrenNext(value, key, owner, root);
                return !_this.done;
            };
            return _this;
        }
        /**
         */ NestedOperation.prototype.next = function(item, key, parent) {
            walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
        };
        return NestedOperation;
    }(GroupOperation);
    var createTester = function(a, compare) {
        if (a instanceof Function) {
            return a;
        }
        if (a instanceof RegExp) {
            return function(b) {
                var result = typeof b === "string" && a.test(b);
                a.lastIndex = 0;
                return result;
            };
        }
        var comparableA = comparable(a);
        return function(b) {
            return compare(comparableA, comparable(b));
        };
    };
    var EqualsOperation = /** @class */ function(_super) {
        __extends(EqualsOperation, _super);
        function EqualsOperation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        EqualsOperation.prototype.init = function() {
            this._test = createTester(this.params, this.options.compare);
        };
        EqualsOperation.prototype.next = function(item, key, parent) {
            if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
                if (this._test(item, key, parent)) {
                    this.done = true;
                    this.keep = true;
                }
            }
        };
        return EqualsOperation;
    }(BaseOperation);
    var createEqualsOperation = function(params, owneryQuery, options) {
        return new EqualsOperation(params, owneryQuery, options);
    };
    var NopeOperation = /** @class */ function(_super) {
        __extends(NopeOperation, _super);
        function NopeOperation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        NopeOperation.prototype.next = function() {
            this.done = true;
            this.keep = false;
        };
        return NopeOperation;
    }(BaseOperation);
    var numericalOperationCreator = function(createNumericalOperation) {
        return function(params, owneryQuery, options, name) {
            if (params == null) {
                return new NopeOperation(params, owneryQuery, options, name);
            }
            return createNumericalOperation(params, owneryQuery, options, name);
        };
    };
    var numericalOperation = function(createTester) {
        return numericalOperationCreator(function(params, owneryQuery, options, name) {
            var typeofParams = typeof comparable(params);
            var test = createTester(params);
            return new EqualsOperation(function(b) {
                return typeof comparable(b) === typeofParams && test(b);
            }, owneryQuery, options, name);
        });
    };
    var createNamedOperation = function(name, params, parentQuery, options) {
        var operationCreator = options.operations[name];
        if (!operationCreator) {
            throwUnsupportedOperation(name);
        }
        return operationCreator(params, parentQuery, options, name);
    };
    var throwUnsupportedOperation = function(name) {
        throw new Error("Unsupported operation: " + name);
    };
    var containsOperation = function(query, options) {
        for(var key in query){
            if (options.operations.hasOwnProperty(key) || key.charAt(0) === "$") return true;
        }
        return false;
    };
    var createNestedOperation = function(keyPath, nestedQuery, parentKey, owneryQuery, options) {
        if (containsOperation(nestedQuery, options)) {
            var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];
            if (nestedOperations.length) {
                throw new Error("Property queries must contain only operations, or exact objects.");
            }
            return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
            new EqualsOperation(nestedQuery, owneryQuery, options)
        ]);
    };
    var createQueryOperation = function(query, owneryQuery, _a) {
        if (owneryQuery === void 0) {
            owneryQuery = null;
        }
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        var options = {
            compare: compare || equals,
            operations: Object.assign({}, operations || {})
        };
        var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];
        var ops = [];
        if (selfOperations.length) {
            ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
        }
        ops.push.apply(ops, nestedOperations);
        if (ops.length === 1) {
            return ops[0];
        }
        return new QueryOperation(query, owneryQuery, options, ops);
    };
    var createQueryOperations = function(query, parentKey, options) {
        var selfOperations = [];
        var nestedOperations = [];
        if (!isVanillaObject(query)) {
            selfOperations.push(new EqualsOperation(query, query, options));
            return [
                selfOperations,
                nestedOperations
            ];
        }
        for(var key in query){
            if (options.operations.hasOwnProperty(key)) {
                var op = createNamedOperation(key, query[key], query, options);
                if (op) {
                    if (!op.propop && parentKey && !options.operations[parentKey]) {
                        throw new Error("Malformed query. " + key + " cannot be matched against property.");
                    }
                }
                // probably just a flag for another operation (like $options)
                if (op != null) {
                    selfOperations.push(op);
                }
            } else if (key.charAt(0) === "$") {
                throwUnsupportedOperation(key);
            } else {
                nestedOperations.push(createNestedOperation(key.split("."), query[key], key, query, options));
            }
        }
        return [
            selfOperations,
            nestedOperations
        ];
    };
    var createOperationTester = function(operation) {
        return function(item, key, owner) {
            operation.reset();
            operation.next(item, key, owner);
            return operation.keep;
        };
    };
    var createQueryTester = function(query, options) {
        if (options === void 0) {
            options = {};
        }
        return createOperationTester(createQueryOperation(query, null, options));
    };
    var $Ne = /** @class */ function(_super) {
        __extends($Ne, _super);
        function $Ne() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        $Ne.prototype.init = function() {
            this._test = createTester(this.params, this.options.compare);
        };
        $Ne.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this.keep = true;
        };
        $Ne.prototype.next = function(item) {
            if (this._test(item)) {
                this.done = true;
                this.keep = false;
            }
        };
        return $Ne;
    }(BaseOperation);
    // https://docs.mongodb.com/manual/reference/operator/query/elemMatch/
    var $ElemMatch = /** @class */ function(_super) {
        __extends($ElemMatch, _super);
        function $ElemMatch() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        $ElemMatch.prototype.init = function() {
            if (!this.params || typeof this.params !== "object") {
                throw new Error("Malformed query. $elemMatch must by an object.");
            }
            this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
        };
        $ElemMatch.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this._queryOperation.reset();
        };
        $ElemMatch.prototype.next = function(item) {
            if (isArray(item)) {
                for(var i = 0, length_1 = item.length; i < length_1; i++){
                    // reset query operation since item being tested needs to pass _all_ query
                    // operations for it to be a success
                    this._queryOperation.reset();
                    var child = item[i];
                    this._queryOperation.next(child, i, item, false);
                    this.keep = this.keep || this._queryOperation.keep;
                }
                this.done = true;
            } else {
                this.done = false;
                this.keep = false;
            }
        };
        return $ElemMatch;
    }(BaseOperation);
    var $Not = /** @class */ function(_super) {
        __extends($Not, _super);
        function $Not() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        $Not.prototype.init = function() {
            this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
        };
        $Not.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this._queryOperation.reset();
        };
        $Not.prototype.next = function(item, key, owner, root) {
            this._queryOperation.next(item, key, owner, root);
            this.done = this._queryOperation.done;
            this.keep = !this._queryOperation.keep;
        };
        return $Not;
    }(BaseOperation);
    var $Size = /** @class */ function(_super) {
        __extends($Size, _super);
        function $Size() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        $Size.prototype.init = function() {};
        $Size.prototype.next = function(item) {
            if (isArray(item) && item.length === this.params) {
                this.done = true;
                this.keep = true;
            }
        // if (parent && parent.length === this.params) {
        //   this.done = true;
        //   this.keep = true;
        // }
        };
        return $Size;
    }(BaseOperation);
    var assertGroupNotEmpty = function(values) {
        if (values.length === 0) {
            throw new Error("$and/$or/$nor must be a nonempty array");
        }
    };
    var $Or = /** @class */ function(_super) {
        __extends($Or, _super);
        function $Or() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = false;
            return _this;
        }
        $Or.prototype.init = function() {
            var _this = this;
            assertGroupNotEmpty(this.params);
            this._ops = this.params.map(function(op) {
                return createQueryOperation(op, null, _this.options);
            });
        };
        $Or.prototype.reset = function() {
            this.done = false;
            this.keep = false;
            for(var i = 0, length_2 = this._ops.length; i < length_2; i++){
                this._ops[i].reset();
            }
        };
        $Or.prototype.next = function(item, key, owner) {
            var done = false;
            var success = false;
            for(var i = 0, length_3 = this._ops.length; i < length_3; i++){
                var op = this._ops[i];
                op.next(item, key, owner);
                if (op.keep) {
                    done = true;
                    success = op.keep;
                    break;
                }
            }
            this.keep = success;
            this.done = done;
        };
        return $Or;
    }(BaseOperation);
    var $Nor = /** @class */ function(_super) {
        __extends($Nor, _super);
        function $Nor() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = false;
            return _this;
        }
        $Nor.prototype.next = function(item, key, owner) {
            _super.prototype.next.call(this, item, key, owner);
            this.keep = !this.keep;
        };
        return $Nor;
    }($Or);
    var $In = /** @class */ function(_super) {
        __extends($In, _super);
        function $In() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        $In.prototype.init = function() {
            var _this = this;
            this._testers = this.params.map(function(value) {
                if (containsOperation(value, _this.options)) {
                    throw new Error("cannot nest $ under " + _this.name.toLowerCase());
                }
                return createTester(value, _this.options.compare);
            });
        };
        $In.prototype.next = function(item, key, owner) {
            var done = false;
            var success = false;
            for(var i = 0, length_4 = this._testers.length; i < length_4; i++){
                var test = this._testers[i];
                if (test(item)) {
                    done = true;
                    success = true;
                    break;
                }
            }
            this.keep = success;
            this.done = done;
        };
        return $In;
    }(BaseOperation);
    var $Nin = /** @class */ function(_super) {
        __extends($Nin, _super);
        function $Nin(params, ownerQuery, options, name) {
            var _this = _super.call(this, params, ownerQuery, options, name) || this;
            _this.propop = true;
            _this._in = new $In(params, ownerQuery, options, name);
            return _this;
        }
        $Nin.prototype.next = function(item, key, owner, root) {
            this._in.next(item, key, owner);
            if (isArray(owner) && !root) {
                if (this._in.keep) {
                    this.keep = false;
                    this.done = true;
                } else if (key == owner.length - 1) {
                    this.keep = true;
                    this.done = true;
                }
            } else {
                this.keep = !this._in.keep;
                this.done = true;
            }
        };
        $Nin.prototype.reset = function() {
            _super.prototype.reset.call(this);
            this._in.reset();
        };
        return $Nin;
    }(BaseOperation);
    var $Exists = /** @class */ function(_super) {
        __extends($Exists, _super);
        function $Exists() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.propop = true;
            return _this;
        }
        $Exists.prototype.next = function(item, key, owner) {
            if (owner.hasOwnProperty(key) === this.params) {
                this.done = true;
                this.keep = true;
            }
        };
        return $Exists;
    }(BaseOperation);
    var $And = /** @class */ function(_super) {
        __extends($And, _super);
        function $And(params, owneryQuery, options, name) {
            var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
                return createQueryOperation(query, owneryQuery, options);
            }), name) || this;
            _this.propop = false;
            assertGroupNotEmpty(params);
            return _this;
        }
        $And.prototype.next = function(item, key, owner, root) {
            this.childrenNext(item, key, owner, root);
        };
        return $And;
    }(NamedGroupOperation);
    var $All = /** @class */ function(_super) {
        __extends($All, _super);
        function $All(params, owneryQuery, options, name) {
            var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
                return createQueryOperation(query, owneryQuery, options);
            }), name) || this;
            _this.propop = true;
            return _this;
        }
        $All.prototype.next = function(item, key, owner, root) {
            this.childrenNext(item, key, owner, root);
        };
        return $All;
    }(NamedGroupOperation);
    var $eq = function(params, owneryQuery, options) {
        return new EqualsOperation(params, owneryQuery, options);
    };
    var $ne = function(params, owneryQuery, options, name) {
        return new $Ne(params, owneryQuery, options, name);
    };
    var $or = function(params, owneryQuery, options, name) {
        return new $Or(params, owneryQuery, options, name);
    };
    var $nor = function(params, owneryQuery, options, name) {
        return new $Nor(params, owneryQuery, options, name);
    };
    var $elemMatch = function(params, owneryQuery, options, name) {
        return new $ElemMatch(params, owneryQuery, options, name);
    };
    var $nin = function(params, owneryQuery, options, name) {
        return new $Nin(params, owneryQuery, options, name);
    };
    var $in = function(params, owneryQuery, options, name) {
        return new $In(params, owneryQuery, options, name);
    };
    var $lt = numericalOperation(function(params) {
        return function(b) {
            return b < params;
        };
    });
    var $lte = numericalOperation(function(params) {
        return function(b) {
            return b <= params;
        };
    });
    var $gt = numericalOperation(function(params) {
        return function(b) {
            return b > params;
        };
    });
    var $gte = numericalOperation(function(params) {
        return function(b) {
            return b >= params;
        };
    });
    var $mod = function(_a, owneryQuery, options) {
        var mod = _a[0], equalsValue = _a[1];
        return new EqualsOperation(function(b) {
            return comparable(b) % mod === equalsValue;
        }, owneryQuery, options);
    };
    var $exists = function(params, owneryQuery, options, name) {
        return new $Exists(params, owneryQuery, options, name);
    };
    var $regex = function(pattern, owneryQuery, options) {
        return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
    };
    var $not = function(params, owneryQuery, options, name) {
        return new $Not(params, owneryQuery, options, name);
    };
    var typeAliases = {
        number: function(v) {
            return typeof v === "number";
        },
        string: function(v) {
            return typeof v === "string";
        },
        bool: function(v) {
            return typeof v === "boolean";
        },
        array: function(v) {
            return Array.isArray(v);
        },
        null: function(v) {
            return v === null;
        },
        timestamp: function(v) {
            return v instanceof Date;
        }
    };
    var $type = function(clazz, owneryQuery, options) {
        return new EqualsOperation(function(b) {
            if (typeof clazz === "string") {
                if (!typeAliases[clazz]) {
                    throw new Error("Type alias does not exist");
                }
                return typeAliases[clazz](b);
            }
            return b != null ? b instanceof clazz || b.constructor === clazz : false;
        }, owneryQuery, options);
    };
    var $and = function(params, ownerQuery, options, name) {
        return new $And(params, ownerQuery, options, name);
    };
    var $all = function(params, ownerQuery, options, name) {
        return new $All(params, ownerQuery, options, name);
    };
    var $size = function(params, ownerQuery, options) {
        return new $Size(params, ownerQuery, options, "$size");
    };
    var $options = function() {
        return null;
    };
    var $where = function(params, ownerQuery, options) {
        var test;
        if (isFunction(params)) {
            test = params;
        } else if (!process.env.CSP_ENABLED) {
            test = new Function("obj", "return " + params);
        } else {
            throw new Error('In CSP mode, sift does not support strings in "$where" condition');
        }
        return new EqualsOperation(function(b) {
            return test.bind(b)(b);
        }, ownerQuery, options);
    };
    var defaultOperations = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        $Size: $Size,
        $eq: $eq,
        $ne: $ne,
        $or: $or,
        $nor: $nor,
        $elemMatch: $elemMatch,
        $nin: $nin,
        $in: $in,
        $lt: $lt,
        $lte: $lte,
        $gt: $gt,
        $gte: $gte,
        $mod: $mod,
        $exists: $exists,
        $regex: $regex,
        $not: $not,
        $type: $type,
        $and: $and,
        $all: $all,
        $size: $size,
        $options: $options,
        $where: $where
    });
    var createDefaultQueryOperation = function(query, ownerQuery, _a) {
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        return createQueryOperation(query, ownerQuery, {
            compare: compare,
            operations: Object.assign({}, defaultOperations, operations || {})
        });
    };
    var createDefaultQueryTester = function(query, options) {
        if (options === void 0) {
            options = {};
        }
        var op = createDefaultQueryOperation(query, null, options);
        return createOperationTester(op);
    };
    exports1.$Size = $Size;
    exports1.$all = $all;
    exports1.$and = $and;
    exports1.$elemMatch = $elemMatch;
    exports1.$eq = $eq;
    exports1.$exists = $exists;
    exports1.$gt = $gt;
    exports1.$gte = $gte;
    exports1.$in = $in;
    exports1.$lt = $lt;
    exports1.$lte = $lte;
    exports1.$mod = $mod;
    exports1.$ne = $ne;
    exports1.$nin = $nin;
    exports1.$nor = $nor;
    exports1.$not = $not;
    exports1.$options = $options;
    exports1.$or = $or;
    exports1.$regex = $regex;
    exports1.$size = $size;
    exports1.$type = $type;
    exports1.$where = $where;
    exports1.EqualsOperation = EqualsOperation;
    exports1.createDefaultQueryOperation = createDefaultQueryOperation;
    exports1.createEqualsOperation = createEqualsOperation;
    exports1.createOperationTester = createOperationTester;
    exports1.createQueryOperation = createQueryOperation;
    exports1.createQueryTester = createQueryTester;
    exports1.default = createDefaultQueryTester;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
}); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 29845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var unsupportedIterableToArray = __webpack_require__(97322);
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 1052:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getPrototypeOf = __webpack_require__(40373);
var isNativeReflectConstruct = __webpack_require__(49665);
var possibleConstructorReturn = __webpack_require__(67943);
function _createSuper(Derived) {
  var hasNativeReflectConstruct = isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return possibleConstructorReturn(this, result);
  };
}
module.exports = _createSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 13991:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"mongoose","description":"Mongoose MongoDB ODM","version":"6.9.1","author":"Guillermo Rauch <guillermo@learnboost.com>","keywords":["mongodb","document","model","schema","database","odm","data","datastore","query","nosql","orm","db"],"license":"MIT","dependencies":{"bson":"^4.7.0","kareem":"2.5.1","mongodb":"4.13.0","mpath":"0.9.0","mquery":"4.0.3","ms":"2.1.3","sift":"16.0.1"},"devDependencies":{"@babel/core":"7.20.12","@babel/preset-env":"7.20.2","@typescript-eslint/eslint-plugin":"5.50.0","@typescript-eslint/parser":"5.50.0","acquit":"1.2.1","acquit-ignore":"0.2.0","acquit-require":"0.1.1","assert-browserify":"2.0.0","axios":"1.1.3","babel-loader":"8.2.5","benchmark":"2.1.4","bluebird":"3.7.2","buffer":"^5.6.0","cheerio":"1.0.0-rc.12","crypto-browserify":"3.12.0","dox":"1.0.0","eslint":"8.33.0","eslint-plugin-mocha-no-only":"1.1.1","express":"^4.18.1","highlight.js":"11.7.0","lodash.isequal":"4.5.0","lodash.isequalwith":"4.4.0","marked":"4.2.12","mkdirp":"^2.1.3","mocha":"10.2.0","moment":"2.x","mongodb-memory-server":"8.11.4","ncp":"^2.0.0","nyc":"15.1.0","pug":"3.0.2","q":"1.5.1","sinon":"15.0.1","stream-browserify":"3.0.0","tsd":"0.25.0","typescript":"4.9.5","uuid":"9.0.0","webpack":"5.75.0"},"directories":{"lib":"./lib/mongoose"},"scripts":{"docs:clean":"npm run docs:clean:stable","docs:clean:stable":"rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:legacy":"rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:copy:tmp":"mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && cp index.html ./tmp","docs:copy:tmp:legacy":"rimraf ./docs/5.x && ncp ./tmp ./docs/5.x","docs:checkout:gh-pages":"git checkout gh-pages","docs:checkout:legacy":"git checkout 5.x","docs:generate":"node ./scripts/website.js","docs:generate:search":"node docs/search.js","docs:merge:stable":"git merge master","docs:merge:legacy":"git merge 5.x","docs:test":"npm run docs:generate && npm run docs:generate:search","docs:view":"node ./scripts/static.js","docs:prepare:publish:stable":"npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:clean:stable && npm run docs:generate && npm run docs:generate:search","docs:prepare:publish:legacy":"npm run docs:checkout:legacy && npm run docs:merge:legacy && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && docs:checkout:gh-pages && docs:copy:tmp:legacy","lint":"eslint .","lint-js":"eslint . --ext .js","lint-ts":"eslint . --ext .ts","build-browser":"(rm ./dist/* || true) && node ./scripts/build-browser.js","prepublishOnly":"npm run build-browser","release":"git pull && git push origin master --tags && npm publish","release-legacy":"git pull origin 5.x && git push origin 5.x --tags && npm publish --tag legacy","mongo":"node ./tools/repl.js","test":"mocha --exit ./test/*.test.js","test-deno":"deno run --allow-env --allow-read --allow-net --allow-run --allow-sys ./test/deno.js","test-rs":"START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js","test-tsd":"node ./test/types/check-types-filename && tsd","tdd":"mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}","test-coverage":"nyc --reporter=html --reporter=text npm test","ts-benchmark":"cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"},"main":"./index.js","types":"./types/index.d.ts","engines":{"node":">=12.0.0"},"bugs":{"url":"https://github.com/Automattic/mongoose/issues/new"},"repository":{"type":"git","url":"git://github.com/Automattic/mongoose.git"},"homepage":"https://mongoosejs.com","browser":"./dist/browser.umd.js","mocha":{"extension":["test.js"],"watch-files":["test/**/*.js"]},"config":{"mongodbMemoryServer":{"disablePostinstall":true}},"funding":{"type":"opencollective","url":"https://opencollective.com/mongoose"},"tsd":{"directory":"test/types","compilerOptions":{"esModuleInterop":false,"strict":true,"allowSyntheticDefaultImports":true,"strictPropertyInitialization":false,"noImplicitAny":false,"strictNullChecks":true,"module":"commonjs","target":"ES2017"}}}');

/***/ })

};
;